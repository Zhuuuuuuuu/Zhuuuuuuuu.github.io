<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>朱酱酱的学习博客</title>
  <icon>https://www.gravatar.com/avatar/336d255f627c733c7a50883547bcec06</icon>
  <subtitle>From Zero to Hero</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhuuu.work/"/>
  <updated>2020-07-03T09:12:32.889Z</updated>
  <id>http://zhuuu.work/</id>
  
  <author>
    <name>Zhuuu</name>
    <email>353446503@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode-046-全排列</title>
    <link href="http://zhuuu.work/2020/06/30/Leetcode/Leetcode-046-%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>http://zhuuu.work/2020/06/30/Leetcode/Leetcode-046-%E5%85%A8%E6%8E%92%E5%88%97/</id>
    <published>2020-06-30T08:44:53.000Z</published>
    <updated>2020-07-03T09:12:32.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-046-全排列"><a href="#Leetcode-046-全排列" class="headerlink" title="Leetcode-046-全排列"></a>Leetcode-046-<a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">全排列</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：回溯算法（DFS）"><a href="#方法：回溯算法（DFS）" class="headerlink" title="方法：回溯算法（DFS）"></a>方法：回溯算法（DFS）</h2><ul><li>“回溯”指的是“状态重置”，可以理解为“回到过去”、“恢复现场”，是在编码的过程中，是为了节约空间而使用的一种技巧</li><li>同时回溯其实就是“深度优先遍历”特有的一种现象</li><li>“全排列”就是一个非常经典的“回溯”算法的应用。我们知道，<code>N</code> 个数字的全排列一共有 N!这么多个。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以数组 [1, 2, 3] 的全排列为例。</span><br><span class="line"></span><br><span class="line">我们先写以 1 开头的全排列，它们是：[1, 2, 3], [1, 3, 2]；</span><br><span class="line">再写以 2 开头的全排列，它们是：[2, 1, 3], [2, 3, 1]；</span><br><span class="line">最后写以 3 开头的全排列，它们是：[3, 1, 2], [3, 2, 1]。</span><br></pre></td></tr></table></figure><ul><li>我们只需要按顺序枚举每一位可能出现的情况，已经选择的数字在接下来要确定的数字中不能出现。按照这种策略选取就能够做到不重不漏，把可能的全排列都枚举出来。<ul><li>在枚举第一位的时候，有三种情况。</li><li>在枚举第二位的时候，前面已经出现过的数字就不能再选择了。</li><li>在枚举第三位的时候，前面两个出现过的数字已经不能再选择了。</li></ul></li></ul><p>我们先写以 1 开头的全排列，它们是：[1, 2, 3], [1, 3, 2]；<br>再写以 2 开头的全排列，它们是：[2, 1, 3], [2, 3, 1]；<br>最后写以 3 开头的全排列，它们是：[3, 1, 2], [3, 2, 1]。</p><p>使用编程的方法得到全排列，就是在这样的一个树形结构中进行编程，具体来说，就是<strong>执行一次深度优先遍历，从树的根结点到叶子结点形成的路径就是一个全排列</strong>。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200703/165513074.png" alt="mark"></p><ol><li>每一个节点表示了全排列问题求解不同的阶段，这些<strong>阶段</strong>通过变量的不同值体现。</li><li>这些变量不同的值，也叫做<strong>状态</strong></li><li>使用深度优先遍历，可以借助系统的栈空间，为我们保存所需要的状态变量，具体做法是：<ul><li>往下走一层，将新的变量追加在尾部，</li><li>而往回走的时候，需要撤销上一次的选择，也就是在尾部删除之前的操作</li></ul></li><li>这里我们需要用到<strong>两个变量数组</strong><ul><li>已经选取了哪些数字，用path数组来记录</li><li>一个布尔数组used,初始化的时候都为false,表示这些数字没有被选择，如果被选择值为true</li></ul></li></ol><p><strong>废话不多说：show me the code(第一种：有错误的版本 )</strong></p><p>（注意：这个代码是错误的，希望读者能自己运行一下测试用例自己发现原因，然后再阅读后面的内容）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 首先是特判</span></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// 使用一个动态数组保存所有可能的全排列</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        dfs(nums, len, <span class="number">0</span>, path, used, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> len, <span class="keyword">int</span> depth,</span></span></span><br><span class="line"><span class="function"><span class="params">                     List&lt;Integer&gt; path, <span class="keyword">boolean</span>[] used,</span></span></span><br><span class="line"><span class="function"><span class="params">                     List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == len) &#123;</span><br><span class="line">            res.add(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                dfs(nums, len, depth + <span class="number">1</span>, path, used, res);</span><br><span class="line">                <span class="comment">// 注意：这里是状态重置，是从深层结点回到浅层结点的过程，代码在形式上和递归之前是对称的</span></span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = solution.permute(nums);</span><br><span class="line">        System.out.println(lists);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在运行的时候输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[], [], [], [], [], []]</span><br></pre></td></tr></table></figure><p>错误的原因出现在这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (depth == len) &#123;</span><br><span class="line">    res.add(path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>path</code> <strong>这个变量指向的变量在全局递归过程中只有一份存在，深度优先遍历完成之后，因为回到了根节点（撤销了之前的操作），因此path回到根节点以后就是空</strong>。</p><p><strong>在java中，传递的对象的内存地址，这些地址实际上是同一块内存区域，所以说我们要做一次深拷贝</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (depth == len) &#123;</span><br><span class="line">    res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正确的版本</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="comment">// 首先是特判</span></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// 使用一个动态数组来保存所有可能的全排列</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一个布尔数组 used，初始化的时候都为 false 表示这些数还没有被选择，</span></span><br><span class="line">        <span class="comment">// 当我们选定一个数的时候，就将这个数组的相应位置设置为 true ，</span></span><br><span class="line">        <span class="comment">// 这样在考虑下一个位置的时候，就能够以 O(1） 的时间复杂度判断这个数是否被选择过，</span></span><br><span class="line">        <span class="comment">// 这是一种“以空间换时间”的思想。</span></span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// path 这个变量所指向的对象在递归的过程中只有一份，</span></span><br><span class="line">        <span class="comment">// 深度优先遍历完成以后，因为回到了根结点（因为我们之前说了，从深层结点回到浅层结点的时候，需要撤销之前的选择），</span></span><br><span class="line">        <span class="comment">// 因此 path 这个变量回到根结点以后都为空。</span></span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        dfs(nums,len,<span class="number">0</span>,path,used,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> len, <span class="keyword">int</span> depth, List&lt;Integer&gt; path, <span class="keyword">boolean</span>[] used, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// depth 用来记录递归到了第几层</span></span><br><span class="line">        <span class="comment">// 用来结束递归，拿到当前的结果之后再撤销回上一层</span></span><br><span class="line">        <span class="keyword">if</span> (depth == len)&#123;</span><br><span class="line"><span class="comment">//            res.add(path);</span></span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// else进行递归</span></span><br><span class="line">        <span class="comment">// 遍历所有nums中的数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 是否这个数字之前已经用过</span></span><br><span class="line">            <span class="keyword">if</span> (!used[i])&#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 不断往下一层走</span></span><br><span class="line">                dfs(nums, len, depth + <span class="number">1</span>, path, used, res);</span><br><span class="line"></span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度：O(N * N!)   N个节点，每个都要计算N！次</li><li>空间复杂度：O(N * N!)  N个节点，每个都要存储N！次</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-046-全排列&quot;&gt;&lt;a href=&quot;#Leetcode-046-全排列&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-046-全排列&quot;&gt;&lt;/a&gt;Leetcode-046-&lt;a href=&quot;https://leetcode-cn.com/problems/permutations/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;全排列&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个 &lt;strong&gt;没有重复&lt;/strong&gt; 数字的序列，返回其所有可能的全排列。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,2,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [1,2,3],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [1,3,2],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [2,1,3],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [2,3,1],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [3,1,2],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [3,2,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="回溯算法" scheme="http://zhuuu.work/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>汇编-02-进制</title>
    <link href="http://zhuuu.work/2020/06/28/assembly/%E6%B1%87%E7%BC%96-02-%E8%BF%9B%E5%88%B6/"/>
    <id>http://zhuuu.work/2020/06/28/assembly/%E6%B1%87%E7%BC%96-02-%E8%BF%9B%E5%88%B6/</id>
    <published>2020-06-28T11:40:41.000Z</published>
    <updated>2020-06-30T02:05:45.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编-02-进制"><a href="#汇编-02-进制" class="headerlink" title="汇编-02-进制"></a>汇编-02-进制</h1><p>[参考博客链接:进制转换][<a href="https://blog.csdn.net/diyu122222/article/details/80692904?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase]" target="_blank" rel="noopener">https://blog.csdn.net/diyu122222/article/details/80692904?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase]</a></p><a id="more"></a><h2 id="1-为什么要使用进制数字？"><a href="#1-为什么要使用进制数字？" class="headerlink" title="1. 为什么要使用进制数字？"></a>1. 为什么要使用进制数字？</h2><p>如果我们直接操作二进制的话 , 面对这么长的数进行思考或操作，没有人会喜欢。</p><p>C，C++ 语言 没有提供在代码直接写二进制数的方法。<br>用16进制或8进制可以解决这个问题。<br><strong>因为，进制越大，数的表达长度也就越短。</strong></p><p><strong>之所以 使用 16或8进制，而不其它的，诸如9或20进制 .</strong></p><p><strong>是因为2、8、16，分别是2的1次方、3次方、4次方。这一点使得三种进制之间可以非常直接地互相转换 ;</strong></p><p>8进制或16进制 既 缩短了二进制数，还能 保持了二进制数的表达特点。转换还方便 .</p><h2 id="2-进制的介绍"><a href="#2-进制的介绍" class="headerlink" title="2. 进制的介绍"></a>2. 进制的介绍</h2><blockquote><p>进制 : 是计算机中数据的一种表示方法。 N进制的数可以用0~(N-1) 的数表示, 超过9的用字母A-F 表示 .</p></blockquote><ul><li>10进制</li></ul><blockquote><p>先说 我们最 熟悉的 10进制 , 就是 用 0~9 的数表示 , 逢 10 进 1 .</p></blockquote><ul><li>16进制</li></ul><blockquote><p>如果是 16 进制 , 它就是 由 0-9，A-F组成， 与10进制的对应关系是：0-9 对应 0-9；A-F对应10-15；<br>字母不区分大小写。</p></blockquote><ul><li>2进制 和 8进制</li></ul><blockquote><p>2进制 由 0-1组成</p><p>8进制 由 0-7组成</p></blockquote><p>再看几个特别的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写出各个进制1-20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一进制 </span></span><br><span class="line">1</span><br><span class="line">1 1</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1 1</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="comment"># 三进制</span></span><br><span class="line">0 1 2</span><br><span class="line">101112</span><br><span class="line">202122</span><br><span class="line">100101102</span><br><span class="line">110111112</span><br><span class="line">120121122</span><br><span class="line">1000 .....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 七进制</span></span><br><span class="line">0123456</span><br><span class="line">10111213141516</span><br><span class="line">20212223242526</span><br><span class="line">30313233343536</span><br></pre></td></tr></table></figure><p><strong>现在有个问题，用进制问题解释1 + 1 = 3？</strong></p><ul><li>如果你想清楚了，进制你就没问题了</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 十进制</span><br><span class="line">0 1 2 3 4 5 6 7 8 9        10  11 12</span><br><span class="line">0 2 4 6 8 9 a c d f    20  22 24</span><br></pre></td></tr></table></figure><h2 id="3-进制的计算"><a href="#3-进制的计算" class="headerlink" title="3. 进制的计算"></a>3. 进制的计算</h2><ul><li>八进制为例子</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 八进制计算下面结果</span></span><br><span class="line"></span><br><span class="line">2 + 3 = 5</span><br><span class="line">2 * 3 = 6</span><br><span class="line">4 + 5 = 11</span><br><span class="line">4 * 5 = 24</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运算的本质就是查数</span></span><br><span class="line">0 1 2 3 4 5 6 7 </span><br><span class="line">10 11 12 13 14 15 16 17</span><br><span class="line">20 21 22 23 24 25 26 27</span><br><span class="line"></span><br><span class="line">八进制计算  (进位和计算)</span><br><span class="line">277 + 333 = </span><br><span class="line">276 * 54 = </span><br><span class="line">237 - 54 = </span><br><span class="line">234 / 4 =</span><br></pre></td></tr></table></figure><p>各种进制的乘法表：<a href="https://wenku.baidu.com/view/ee774a731ed9ad51f01df252.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/ee774a731ed9ad51f01df252.html</a></p><ul><li>下面以八进制为例子</li></ul><p><strong>八进制乘法表</strong></p><table><thead><tr><th>1*1 = 1</th><th>1*2 = 2</th><th>1*3 = 3</th><th>1*4 =4</th><th>1*5 =5</th><th>1*6 = 6</th><th>1*7 = 7</th></tr></thead><tbody><tr><td>2*2 = 2</td><td>2*3 = 6</td><td>2*4 = 10</td><td>2*5 = 12</td><td>2*6 = 14</td><td>2*7 = 16</td><td></td></tr><tr><td>3*3 = 11</td><td>3*4 = 14</td><td>3*5 = 17</td><td>3* 6 = 22</td><td>3*7 = 25</td><td></td><td></td></tr><tr><td>4*4 = 20</td><td>4 * 5= 24</td><td>4*6 = 30</td><td>4*7 = 34</td><td></td><td></td><td></td></tr><tr><td>5*5 = 31</td><td>5*6 = 36</td><td>5*7 = 43</td><td></td><td></td><td></td><td></td></tr><tr><td>6*6 = 44</td><td>6*7 = 52</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>7*7 = 61</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>八进制加法表</strong></p><p><strong>结论：无论是什么进制，本身都有一套完美的体系</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编-02-进制&quot;&gt;&lt;a href=&quot;#汇编-02-进制&quot; class=&quot;headerlink&quot; title=&quot;汇编-02-进制&quot;&gt;&lt;/a&gt;汇编-02-进制&lt;/h1&gt;&lt;p&gt;[参考博客链接:进制转换][&lt;a href=&quot;https://blog.csdn.net/diyu122222/article/details/80692904?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/diyu122222/article/details/80692904?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase]&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="汇编" scheme="http://zhuuu.work/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="进制" scheme="http://zhuuu.work/tags/%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-139-单词拆分</title>
    <link href="http://zhuuu.work/2020/06/28/Leetcode/Leetcode-139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
    <id>http://zhuuu.work/2020/06/28/Leetcode/Leetcode-139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</id>
    <published>2020-06-28T09:44:53.000Z</published>
    <updated>2020-06-30T06:40:55.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-139-单词拆分"><a href="#Leecode-139-单词拆分" class="headerlink" title="Leecode-139-单词拆分"></a>Leecode-139-<a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">单词拆分</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-139-单词拆分&quot;&gt;&lt;a href=&quot;#Leecode-139-单词拆分&quot; class=&quot;headerlink&quot; title=&quot;Leecode-139-单词拆分&quot;&gt;&lt;/a&gt;Leecode-139-&lt;a href=&quot;https://leetcode-cn.com/problems/word-break/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;单词拆分&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-316-去除重复的字母</title>
    <link href="http://zhuuu.work/2020/06/28/Leetcode/Leetcode-316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E6%AF%8D/"/>
    <id>http://zhuuu.work/2020/06/28/Leetcode/Leetcode-316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E6%AF%8D/</id>
    <published>2020-06-28T07:44:53.000Z</published>
    <updated>2020-06-29T09:43:14.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-316-去除重复字母"><a href="#Leetcode-316-去除重复字母" class="headerlink" title="Leetcode-316-去除重复字母"></a>Leetcode-316-<a href="https://leetcode-cn.com/problems/remove-duplicate-letters/" target="_blank" rel="noopener">去除重复字母</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给你一个<strong>仅包含小写字母</strong>的字符串，请你去除字符串中重复的字母，使得每个字母只出现一次。</li><li><strong>保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: &quot;bcabc&quot;</span><br><span class="line">输出: &quot;abc&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: &quot;cbacdcbc&quot;</span><br><span class="line">输出: &quot;acdb&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：栈-哨兵"><a href="#方法：栈-哨兵" class="headerlink" title="方法：栈+哨兵"></a>方法：栈+哨兵</h2><p>思路分析：</p><ul><li><strong>首先解释一下什么是字典序。</strong><ul><li>字典序是指从前到后比较两个字符串的大小</li><li>首先比较第一个字符，如果不同则第一个字符较小的字符串更小</li><li>如果相同则继续比较第二个字符…. 如果比到最后都一样的话，那么两个字符串相等</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">观察示例 1：bcabc。</span><br><span class="line"></span><br><span class="line">字符 a 在字符串中只出现一次，根据题目要求，字符 a 必须被选取；</span><br><span class="line">字符 b 出现了两次，显然选择 a后面的那个，因为字典序 ab 在 ba 前面。同理，有两个相同的字符 c ，我们选择后一个。因此，输出就是 abc。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">再观察示例 2：cbacdcbc。</span><br><span class="line"></span><br><span class="line">有 4 个字符：</span><br><span class="line">a、b、c、d。其中 a 和 d 只出现一次，必须被选取；</span><br><span class="line">b 出现 2 次，一个在 a 前面，一个在 a 后面，显然保留在 a 后面的；</span><br><span class="line">c 出现 4 次，我们把几种可能都列出来观察一下：</span><br><span class="line">情况 1：cadb</span><br><span class="line">情况 2：acdb（字典序最小）</span><br><span class="line">情况 3：adcb</span><br><span class="line">情况 4：adbc</span><br></pre></td></tr></table></figure><ul><li>下面我们就要思考，当遍历到字符串<strong>ASCII 值减少的时候</strong>，应该如何处理。（一种最理想的情况是：<code>abcd</code>，在遍历的时候，遇到的字符串的 <strong>ASCII 值逐渐增大</strong>。）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">还看示例 1：</span><br><span class="line">已经读到了 bc，已经是字典序最小的排列。</span><br><span class="line">即将读到的 a 比 c 的 ASCII 值小。如果 a 能排在 c 之前，就能得到一个比 ca 更小的字典序 ac。</span><br><span class="line">那么 a 能不能排在 c 之前，就看 a 的后面还会不会出现字符 c，显然会。同理，由于字符 b 在将来还会出现，构成的字典序更小，因此舍弃之前的字符 b。</span><br><span class="line">到此为止，应该想到我们需要借助栈帮助我们完成这题。</span><br></pre></td></tr></table></figure><ul><li>然后根据这个思路，我们再看一下示例 2：<code>cbacdcbc</code>。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200629/143955298.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">第 1 步：读到 c，入栈，此时栈中元素 [c]；</span><br><span class="line"></span><br><span class="line">第 2 步：读到 b，b 比之前 a 小，c 在以后还会出现，因此 c 出栈，b 入栈，此时栈中元素 [b]；</span><br><span class="line"></span><br><span class="line">第 3 步：读到 a，a 比之前 b 小，b 在以后还会出现，因此 b 出栈，a 入栈，此时栈中元素 [a]；</span><br><span class="line"></span><br><span class="line">第 4 步：读到 c，c 比之前 a 大，直接让 c 入栈，此时栈中元素 [a, c]；</span><br><span class="line"></span><br><span class="line">第 5 步：读到 d，d 比之前 d 大，直接让 d 入栈，此时栈中元素 [a, c, d]；</span><br><span class="line"></span><br><span class="line">第 6 步：读到 c，这里要注意：此时栈中已经有 c 了，此时栈中元素构成的字符顺序就是最小的字典序，不可能舍弃之前的 c，而用现在的读到的 c，因此这个 c 不需要，直接跳过；</span><br><span class="line"></span><br><span class="line">第 7 步：读到 b，b 比之前的 d 小，但是，后面不会再出现 d 了，因此 b 就应该放在这个位置，因此让 b 入栈，此时栈中元素 [a, c, d, b]；</span><br><span class="line"></span><br><span class="line">第 8 步：读到 c，同第 6 步，这个 c 我们不需要。</span><br></pre></td></tr></table></figure><ul><li><p>于是：我们可以设计如下算法：</p><ul><li>遍历字符串里的字符，<strong>如果读到的字符的 ASCII 值是升序</strong>，依次存到一个栈中；</li><li>如果读到的栈中已经存在，那么这个字符我们不需要。</li><li>如果<strong>读到的ASCII 值比栈顶元素严格小，看看栈顶后面的是否还会再出现</strong>，如果还会出现，则舍弃栈顶元素，而选择后面出现的那个元素，这样得到的字典序更小。</li></ul></li><li><p>因为需要判断读到的字符在栈中是否已经存在，因此可以使用哈希表，又因为题目说，字符只会出现小写字母，<strong>用一个布尔数组也是可以的，注意在出栈入栈的时候，需要同步更新一下这个布尔数组。</strong></p></li><li><p>又因为要<strong>判断栈顶元素在后面是否会被遍历到，因此我们需要首先遍历一次字符，存一下这个字符最后出现的位置，就能判断栈顶元素在后面是否会被遍历到</strong></p></li></ul><p><strong>未使用哨兵的版本</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 借助栈来帮助我们完成这道题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="comment">// 不会有重复的情况</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于记录字符串中已经出现的字符</span></span><br><span class="line">        <span class="keyword">boolean</span>[] set = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录每个字符出现的最后一个位置</span></span><br><span class="line">        <span class="keyword">int</span>[] lastIndex = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            lastIndex[s.charAt(i) - <span class="string">'a'</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 栈：判断栈顶元素和入栈元素的ASCII大小</span></span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> curr = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (set[curr - <span class="string">'a'</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// lastIndex[stack.peek() -'a'] &gt;= i 说明后面还会出现</span></span><br><span class="line">            <span class="comment">// stack.peek() &gt; curr说明当前入栈元素比栈顶小</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.empty() &amp;&amp; stack.peek() &gt; curr &amp;&amp; lastIndex[stack.peek() -<span class="string">'a'</span>] &gt;= i)&#123;</span><br><span class="line">                <span class="keyword">char</span> top = stack.pop();</span><br><span class="line">                set[top - <span class="string">'a'</span>] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加入栈并记录</span></span><br><span class="line">            stack.push(curr);</span><br><span class="line">            set[curr - <span class="string">'a'</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 栈顶元素依次出栈并返回字符串形式</span></span><br><span class="line">        StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty())&#123;</span><br><span class="line">            buffer.insert(<span class="number">0</span>,stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用哨兵原因</strong>：里面判断语句太长，每一次都要判断栈是否为空。这里使用一个哨兵的技巧，一开始就在栈里面放一个最小字符’a’ 。因为后面判断语句<code>stack.peek() &gt; currentChar</code> 这里是严格符号，因此这个 <code>a</code> 一定不会被弹出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!stack.empty() &amp;&amp; stack.peek() &gt; currentChar &amp;&amp; lastAppearIndex[stack.peek() - <span class="string">'a'</span>] &gt;= i) &#123;</span><br><span class="line">    <span class="keyword">char</span> top = stack.pop();</span><br><span class="line">    set[top - <span class="string">'a'</span>] = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用哨兵：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哨兵+栈</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录每个字符出现的最后一个位置</span></span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] lastIndex = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            lastIndex[charArray[i] - <span class="string">'a'</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录字符是否已经出现在字符串中</span></span><br><span class="line">        <span class="keyword">boolean</span>[] set = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时 `a` 作为哨兵，这个 `a` 永远不会被弹出</span></span><br><span class="line">        <span class="comment">// 如此一来，在遍历的时候，就不用判断栈是否为空了</span></span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        stack.addLast(<span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前字符已经出现过了，跳出循环</span></span><br><span class="line">            <span class="keyword">char</span> currentChar = charArray[i];</span><br><span class="line">            <span class="keyword">if</span> (set[currentChar - <span class="string">'a'</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (stack.peekLast() &gt; currentChar &amp;&amp; lastIndex[stack.peekLast() - <span class="string">'a'</span>] &gt;= i)&#123;</span><br><span class="line">                <span class="comment">// 弹出并且将该字符改为未出现过</span></span><br><span class="line">                <span class="keyword">char</span> top = stack.removeLast();</span><br><span class="line">                set[top - <span class="string">'a'</span>] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 说明ASCII是升序的，直接加入</span></span><br><span class="line">            stack.addLast(currentChar);</span><br><span class="line">            set[currentChar - <span class="string">'a'</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转为字符串返回结果</span></span><br><span class="line">        <span class="keyword">int</span> size = stack.size();</span><br><span class="line">        StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            buffer.insert(<span class="number">0</span>,stack.removeLast());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-316-去除重复字母&quot;&gt;&lt;a href=&quot;#Leetcode-316-去除重复字母&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-316-去除重复字母&quot;&gt;&lt;/a&gt;Leetcode-316-&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicate-letters/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;去除重复字母&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给你一个&lt;strong&gt;仅包含小写字母&lt;/strong&gt;的字符串，请你去除字符串中重复的字母，使得每个字母只出现一次。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;bcabc&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;abc&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;cbacdcbc&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;acdb&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="栈" scheme="http://zhuuu.work/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>汇编-01-概述</title>
    <link href="http://zhuuu.work/2020/06/28/assembly/%E6%B1%87%E7%BC%96-01-%E6%A6%82%E8%BF%B0/"/>
    <id>http://zhuuu.work/2020/06/28/assembly/%E6%B1%87%E7%BC%96-01-%E6%A6%82%E8%BF%B0/</id>
    <published>2020-06-28T07:40:41.000Z</published>
    <updated>2020-06-28T14:17:27.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编-01-概述"><a href="#汇编-01-概述" class="headerlink" title="汇编-01-概述"></a>汇编-01-概述</h1><ul><li><p>CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。</p></li><li><p>这些指令都是二进制的，称为操作码（opcode），比如加法指令就是00000011。</p></li><li><p><strong>编译器的作用，就是将高级语言写好的程序，翻译成一条条操作码。</strong></p></li><li><p>对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。</p></li><li><p>为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。</p></li></ul><p>一张程序猿的鄙视链：（哈哈哈 看看就好！！）</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200628/220922706.png" alt="mark"></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编-01-概述&quot;&gt;&lt;a href=&quot;#汇编-01-概述&quot; class=&quot;headerlink&quot; title=&quot;汇编-01-概述&quot;&gt;&lt;/a&gt;汇编-01-概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这些指令都是二进制的，称为操作码（opcode），比如加法指令就是00000011。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;编译器的作用，就是将高级语言写好的程序，翻译成一条条操作码。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一张程序猿的鄙视链：（哈哈哈 看看就好！！）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200628/220922706.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="汇编" scheme="http://zhuuu.work/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.8源码-13-Scanner</title>
    <link href="http://zhuuu.work/2020/06/28/jdk_SourceCode/JDK1.8-13-Scanner/"/>
    <id>http://zhuuu.work/2020/06/28/jdk_SourceCode/JDK1.8-13-Scanner/</id>
    <published>2020-06-28T05:33:53.000Z</published>
    <updated>2020-06-28T13:00:01.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK1-8使用-13-Scanner"><a href="#JDK1-8使用-13-Scanner" class="headerlink" title="JDK1.8使用-13-Scanner"></a>JDK1.8使用-13-Scanner</h1><h2 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h2><p>在笔试编程过程中，关于数据的读取如果迷迷糊糊，那后来的编程即使想法很对，实现很好，也是徒劳，于是在这里认真总结了Java Scanner 类的使用</p><a id="more"></a><h2 id="常用方法：next-和nextline"><a href="#常用方法：next-和nextline" class="headerlink" title="常用方法：next()和nextline()"></a>常用方法：next()和nextline()</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200628/201806538.png" alt="mark"></p><ul><li>上图的方法：只读取对应数据类型的数据，如果输入了非对应数据类型的数据就是报错。</li><li>比如：<code>nextlnt():只读取int值</code>，就是只能读取整数类型的数据，如果输入了非整型的数据（浮点型字符串等）就会报错。<br><code>nextFloat（）、nextDouble（）</code>这些也是以此类推，只能读取符合该类型的数据。</li><li><strong>next() :  只读取输入直到空格，它不能读取两个由空格或者符号隔开的单词。此外next() 在读取输入后将光标放入到同一行中</strong></li><li><strong>nextLine():读取输入，包括单词之间的空格和除回车意外的所有符号（即它会读到行尾）。读取输入后，nextLine()会将光标定位在下一行。</strong></li></ul><p><strong>废话不多说：show me the code</strong></p><ul><li><strong>源码</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextInt(defaultRadix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scans the next token of the input as an &lt;tt&gt;int&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> * This method will throw &lt;code&gt;InputMismatchException&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> * if the next token cannot be translated into a valid int value as</span></span><br><span class="line"><span class="comment"> * described below. If the translation is successful, the scanner advances</span></span><br><span class="line"><span class="comment"> * past the input that matched.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; If the next token matches the &lt;a</span></span><br><span class="line"><span class="comment"> * href="#Integer-regex"&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined</span></span><br><span class="line"><span class="comment"> * above then the token is converted into an &lt;tt&gt;int&lt;/tt&gt; value as if by</span></span><br><span class="line"><span class="comment"> * removing all locale specific prefixes, group separators, and locale</span></span><br><span class="line"><span class="comment"> * specific suffixes, then mapping non-ASCII digits into ASCII</span></span><br><span class="line"><span class="comment"> * digits via &#123;<span class="doctag">@link</span> Character#digit Character.digit&#125;, prepending a</span></span><br><span class="line"><span class="comment"> * negative sign (-) if the locale specific negative prefixes and suffixes</span></span><br><span class="line"><span class="comment"> * were present, and passing the resulting string to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Integer#parseInt(String, int) Integer.parseInt&#125; with the</span></span><br><span class="line"><span class="comment"> * specified radix.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> radix the radix used to interpret the token as an int value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the &lt;tt&gt;int&lt;/tt&gt; scanned from the input</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InputMismatchException</span></span><br><span class="line"><span class="comment"> *         if the next token does not match the &lt;i&gt;Integer&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> *         regular expression, or is out of range</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if input is exhausted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if this scanner is closed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">(<span class="keyword">int</span> radix)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Check cached result</span></span><br><span class="line">    <span class="keyword">if</span> ((typeCache != <span class="keyword">null</span>) &amp;&amp; (typeCache <span class="keyword">instanceof</span> Integer)</span><br><span class="line">        &amp;&amp; <span class="keyword">this</span>.radix == radix) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = ((Integer)typeCache).intValue();</span><br><span class="line">        useTypeCache();</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    setRadix(radix);</span><br><span class="line">    clearCaches();</span><br><span class="line">    <span class="comment">// Search for next int</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String s = next(integerPattern());</span><br><span class="line">        <span class="keyword">if</span> (matcher.group(SIMPLE_GROUP_INDEX) == <span class="keyword">null</span>)</span><br><span class="line">            s = processIntegerToken(s);</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(s, radix);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException nfe) &#123;</span><br><span class="line">        position = matcher.start(); <span class="comment">// don't skip bad token</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InputMismatchException(nfe.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>测试</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">"请输入一个字符串(中间能加空格或符号)"</span>);</span><br><span class="line">    String a = input.nextLine();</span><br><span class="line">    System.out.println(<span class="string">"请输入一个字符串(中间不能加空格或符号)"</span>);</span><br><span class="line">    String b = input.next();</span><br><span class="line">    System.out.println(<span class="string">"请输入一个整数"</span>);</span><br><span class="line">    <span class="keyword">int</span> c = input.nextInt(); <span class="comment">// 只能读取Int</span></span><br><span class="line">    System.out.println(<span class="string">"请输入一个double类型的小数"</span>);</span><br><span class="line">    <span class="keyword">double</span> d= input.nextFloat();</span><br><span class="line">    System.out.println(<span class="string">"请输入一个float类型的小数"</span>);</span><br><span class="line">    <span class="keyword">float</span>  f = input.nextFloat();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"按顺序输出abcdf的值："</span>);</span><br><span class="line">    System.out.println(a);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">    System.out.println(c);</span><br><span class="line">    System.out.println(d);</span><br><span class="line">    System.out.println(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>运行输入：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">请输入一个字符串(中间能加空格或符号)</span><br><span class="line">我爱祖国！</span><br><span class="line">请输入一个字符串(中间不能加空格或符号)</span><br><span class="line">ILoveChina</span><br><span class="line">请输入一个整数</span><br><span class="line"><span class="number">520</span></span><br><span class="line">请输入一个<span class="keyword">double</span>类型的小数</span><br><span class="line"><span class="number">12.26e3</span></span><br><span class="line">请输入一个<span class="keyword">float</span>类型的小数</span><br><span class="line"><span class="number">3.1415926</span></span><br><span class="line">按顺序输出abcdf的值：</span><br><span class="line">我爱祖国！</span><br><span class="line">ILoveChina</span><br><span class="line"><span class="number">520</span></span><br><span class="line"><span class="number">12260.0</span></span><br><span class="line"><span class="number">3.1415925</span></span><br></pre></td></tr></table></figure><h2 id="常用用法：hasNext"><a href="#常用用法：hasNext" class="headerlink" title="常用用法：hasNext()"></a>常用用法：hasNext()</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200628/203935994.png" alt="mark"></p><ul><li><strong>源码：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNextInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasNextInt(defaultRadix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns true if the next token in this scanner's input can be</span></span><br><span class="line"><span class="comment"> * interpreted as an int value in the specified radix using the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #nextInt&#125; method. The scanner does not advance past any input.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> radix the radix used to interpret the token as an int value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if and only if this scanner's next token is a valid</span></span><br><span class="line"><span class="comment"> *         int value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if this scanner is closed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNextInt</span><span class="params">(<span class="keyword">int</span> radix)</span> </span>&#123;</span><br><span class="line">    setRadix(radix);</span><br><span class="line">    <span class="keyword">boolean</span> result = hasNext(integerPattern());</span><br><span class="line">    <span class="keyword">if</span> (result) &#123; <span class="comment">// Cache it</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String s = (matcher.group(SIMPLE_GROUP_INDEX) == <span class="keyword">null</span>) ?</span><br><span class="line">                processIntegerToken(hasNextResult) :</span><br><span class="line">                hasNextResult;</span><br><span class="line">            typeCache = Integer.parseInt(s, radix);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException nfe) &#123;</span><br><span class="line">            result = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个boolean的值</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>测试用例</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过Scanner构造函数接收控制台输入的信息</span></span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">"请输入你的姓名"</span>);</span><br><span class="line">    <span class="comment">// 接收一个字符串，可以加出回车键意外所有的信息，包括空格和Tab</span></span><br><span class="line">    String name = scanner.nextLine();</span><br><span class="line">    System.out.println(<span class="string">"请输入你的ID"</span>);</span><br><span class="line">    String ID;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环判断hasNextLine()方法是否有输入（返回true或false）</span></span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNextLine())&#123;</span><br><span class="line">        <span class="comment">// 如果输入的是整型类型，当为整型类型执行循环</span></span><br><span class="line">        <span class="keyword">if</span> (scanner.hasNextInt())&#123;</span><br><span class="line">            ID = scanner.nextLine();</span><br><span class="line">            System.out.println(<span class="string">"你输入的姓名为："</span>+name);</span><br><span class="line">            System.out.println(<span class="string">"你输入的ID为："</span>+ID);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"请输入数字哦！"</span>);</span><br><span class="line">            ID = scanner.nextLine();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">请输入你的姓名</span><br><span class="line">朱酱酱</span><br><span class="line">请输入你的ID</span><br><span class="line">qq353446503</span><br><span class="line">请输入数字哦！</span><br><span class="line"><span class="number">353446503</span></span><br><span class="line">你输入的姓名为：朱酱酱</span><br><span class="line">你输入的ID为：<span class="number">353446503</span></span><br></pre></td></tr></table></figure><h2 id="Demo-键盘输入求平均数"><a href="#Demo-键盘输入求平均数" class="headerlink" title="Demo:键盘输入求平均数"></a>Demo:键盘输入求平均数</h2><ul><li>注意：如果要输入int 或者 float … 之类的数据，在Scanner中输入之前最好先使用<code>hasNextXxx()</code> 方法进行验证，再使用<code>nextXxx()</code>进行读取接收</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNextDouble())&#123;</span><br><span class="line">        <span class="comment">// 接收dobule的值</span></span><br><span class="line">        <span class="keyword">double</span> x = scanner.nextDouble();</span><br><span class="line">        m = m + <span class="number">1</span>;</span><br><span class="line">        sum = sum + x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(m + <span class="string">"个数的和为"</span> + sum);</span><br><span class="line">    System.out.println(m + <span class="string">"个数的平均值是"</span> + (sum / m));</span><br><span class="line">    scanner.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试用例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">请输入数字：</span><br><span class="line"><span class="number">20.0</span></span><br><span class="line"><span class="number">30.0</span></span><br><span class="line"><span class="number">40.0</span></span><br><span class="line">end</span><br><span class="line"><span class="number">3</span>个数的和为<span class="number">90.0</span></span><br><span class="line"><span class="number">3</span>个数的平均值是<span class="number">30.0</span>s</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JDK1-8使用-13-Scanner&quot;&gt;&lt;a href=&quot;#JDK1-8使用-13-Scanner&quot; class=&quot;headerlink&quot; title=&quot;JDK1.8使用-13-Scanner&quot;&gt;&lt;/a&gt;JDK1.8使用-13-Scanner&lt;/h1&gt;&lt;h2 id=&quot;前序&quot;&gt;&lt;a href=&quot;#前序&quot; class=&quot;headerlink&quot; title=&quot;前序&quot;&gt;&lt;/a&gt;前序&lt;/h2&gt;&lt;p&gt;在笔试编程过程中，关于数据的读取如果迷迷糊糊，那后来的编程即使想法很对，实现很好，也是徒劳，于是在这里认真总结了Java Scanner 类的使用&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JDK源码分析" scheme="http://zhuuu.work/tags/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="面试必备" scheme="http://zhuuu.work/tags/%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87/"/>
    
  </entry>
  
  <entry>
    <title>排序-02-桶排序</title>
    <link href="http://zhuuu.work/2020/06/27/Sort/%E6%8E%92%E5%BA%8F-02-%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhuuu.work/2020/06/27/Sort/%E6%8E%92%E5%BA%8F-02-%E6%A1%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2020-06-27T10:32:24.000Z</published>
    <updated>2020-06-27T09:58:13.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序-02-桶排序"><a href="#排序-02-桶排序" class="headerlink" title="排序-02-桶排序"></a>排序-02-桶排序</h1><p>参考博客 ： <a href="https://www.cnblogs.com/skywang12345/p/3603935.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3603935.html</a></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200627/175321622.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200627/175306350.png" alt="mark"></p><h2 id="1-桶排序思想"><a href="#1-桶排序思想" class="headerlink" title="1. 桶排序思想"></a>1. 桶排序思想</h2><ul><li><strong>一句话总结：划分多个范围相同的区间，每个子区间进行自排序，最后合并</strong></li><li>桶排序是计数排序的扩展版本<ul><li>计数排序可以看成每个桶只存储相同的元素</li><li>而桶排序每个桶存储的是一定范围的元素，通过映射函数，将待排序数组中的元素映射到各个对应的桶中，对每个桶中的元素进行排序，最后将非空桶中的元素逐个放入原序列中。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200627/173153414.png" alt="mark"></p><a id="more"></a><h2 id="2-Java实现代码"><a href="#2-Java实现代码" class="headerlink" title="2. Java实现代码"></a>2. Java实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算最大值与最小值</span></span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            max = Math.max(max, arr[i]);</span><br><span class="line">            min = Math.min(min, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算桶的数量</span></span><br><span class="line">        <span class="keyword">int</span> bucketNum = (max - min) / arr.length + <span class="number">1</span>;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++)&#123;</span><br><span class="line">            bucketArr.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将每个元素放入桶</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = (arr[i] - min) / (arr.length);</span><br><span class="line">            bucketArr.get(num).add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对每个桶进行排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">            Collections.sort(bucketArr.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将桶中的元素赋值到原序列</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketArr.get(i).size(); j++)&#123;</span><br><span class="line">                arr[index++] = bucketArr.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BucketSort.bucketSort(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">18</span>,<span class="number">11</span>,<span class="number">28</span>,<span class="number">45</span>,<span class="number">23</span>,<span class="number">50</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><ul><li><strong>时间复杂度：O(N+K)</strong><ul><li>N 次循环，将每个元素装入对应的桶中</li><li>M 次循环，对每个桶中的数据进行排序（平均每个桶有 N/M 个元素）</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200627/175714244.png" alt="mark"></p><ul><li><strong>空间复杂度： O( N + M )</strong></li></ul><ul><li><strong>稳定性分析</strong><ul><li><strong>桶排序的稳定性取决于桶内排序使用的算法</strong></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;排序-02-桶排序&quot;&gt;&lt;a href=&quot;#排序-02-桶排序&quot; class=&quot;headerlink&quot; title=&quot;排序-02-桶排序&quot;&gt;&lt;/a&gt;排序-02-桶排序&lt;/h1&gt;&lt;p&gt;参考博客 ： &lt;a href=&quot;https://www.cnblogs.com/skywang12345/p/3603935.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/skywang12345/p/3603935.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200627/175321622.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200627/175306350.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-桶排序思想&quot;&gt;&lt;a href=&quot;#1-桶排序思想&quot; class=&quot;headerlink&quot; title=&quot;1. 桶排序思想&quot;&gt;&lt;/a&gt;1. 桶排序思想&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一句话总结：划分多个范围相同的区间，每个子区间进行自排序，最后合并&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;桶排序是计数排序的扩展版本&lt;ul&gt;
&lt;li&gt;计数排序可以看成每个桶只存储相同的元素&lt;/li&gt;
&lt;li&gt;而桶排序每个桶存储的是一定范围的元素，通过映射函数，将待排序数组中的元素映射到各个对应的桶中，对每个桶中的元素进行排序，最后将非空桶中的元素逐个放入原序列中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200627/173153414.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="排序算法" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-02-二叉查找树</title>
    <link href="http://zhuuu.work/2020/06/26/DataStructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-02-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    <id>http://zhuuu.work/2020/06/26/DataStructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-02-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</id>
    <published>2020-06-26T10:32:24.000Z</published>
    <updated>2020-06-28T08:21:57.302Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构-02-二叉查找树"><a href="#数据结构-02-二叉查找树" class="headerlink" title="数据结构-02-二叉查找树"></a>数据结构-02-二叉查找树</h1><p>参考博客 ： <a href="https://www.cnblogs.com/skywang12345/p/3603935.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3603935.html</a></p><p>数据结构在线生成工具 ： <a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p><a id="more"></a><h2 id="1-二叉查找树简介"><a href="#1-二叉查找树简介" class="headerlink" title="1. 二叉查找树简介"></a>1. 二叉查找树简介</h2><ul><li><p><strong>二叉查找树(Binary Search Tree)，又被称为二叉搜索树。</strong></p></li><li><p>它是<strong>特殊的二叉树</strong></p><ul><li>对于二叉树，假设x为二叉树中的任意一个节点，x节点中包含关键字key,节点x的key值记位key[x] 。</li><li>如果 y 是 x 的左子树中的一个节点，则key[y] &lt;= key[x] ; </li><li>如果 y 是  x的右子树中的一个节点，则key[y] &gt;= key[x];</li></ul></li></ul><p>那么，这棵树就是二叉查找树。如下图所示：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/151835002.png" alt="mark"></p><p><strong>性质：在二叉查找树中</strong></p><ul><li><strong>如果任意节点的左子树不为空，则左子树上所有节点的值均小于它的根节点的值</strong></li><li><strong>任意节点的右子树不为空，则右子树上所有节点的值均大于它的根节点的值</strong></li><li><strong>任意节点的左，右子树也分别为二叉查找树。（递归的思想）</strong></li><li>没有键值相等的节点（no duplicate nodes）。</li></ul><h2 id="2-二叉查找树的Java实现"><a href="#2-二叉查找树的Java实现" class="headerlink" title="2. 二叉查找树的Java实现"></a>2. 二叉查找树的Java实现</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T extends Comparable&lt;T&gt; 说明泛型T必须实现了Comparable接口</span></span><br><span class="line"><span class="comment">// &lt;T extends Comparable&lt;? super T&gt;&gt;　说明泛型T或者其父类必须实现了Comparable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTree</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BSTNode&lt;T&gt; mRoot;    <span class="comment">// 根结点</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTNode</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">        T key;                <span class="comment">// 关键字(键值)</span></span><br><span class="line">        BSTNode&lt;T&gt; left;      <span class="comment">// 左孩子</span></span><br><span class="line">        BSTNode&lt;T&gt; right;     <span class="comment">// 右孩子</span></span><br><span class="line">        BSTNode&lt;T&gt; parent;    <span class="comment">// 父结点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BSTNode</span><span class="params">(T key, BSTNode&lt;T&gt; parent, BSTNode&lt;T&gt; left, BSTNode&lt;T&gt; right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>BSTree是二叉树，它保护了二叉树的根节点mRoot;</li><li>mRoot是BSTNode类型，而BSTNode是而二叉查找树的节点，它是BSTree的内部类。</li><li>BSTNode 包含了以下几个基本信息：<ul><li>(01) key – 它是关键字，是用来对二叉查找树的节点进行排序的。<br>(02) left – 它指向当前节点的左孩子。<br>(03) right – 它指向当前节点的右孩子。<br>(04) parent – 它指向当前节点的父结点。</li></ul></li></ul><h3 id="2-2-遍历"><a href="#2-2-遍历" class="headerlink" title="2.2 遍历"></a>2.2 遍历</h3><ul><li>这里讲解前序遍历、中序遍历、后序遍历3种方式。</li></ul><p><strong>前序遍历</strong></p><p>若二叉树非空，则执行以下操作：<br>(01) 访问根结点；<br>(02) 先序遍历左子树；<br>(03) 先序遍历右子树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BSTNode&lt;T&gt; tree)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree != <span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(tree.key + <span class="string">" "</span>);</span><br><span class="line">        preOrder(tree.left);</span><br><span class="line">        preOrder(tree.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    preOrder(mRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>中序遍历</strong></p><p>若二叉树非空，则执行以下操作：<br>(01) 中序遍历左子树；<br>(02) 访问根结点；<br>(03) 中序遍历右子树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BSTNode&lt;T&gt; tree)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree != <span class="keyword">null</span>)&#123;</span><br><span class="line">        inOrder(tree.left);</span><br><span class="line">        System.out.println(tree.key + <span class="string">" "</span>);</span><br><span class="line">        inOrder(tree.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    inOrder(mRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>后序遍历</strong></p><p>若二叉树非空，则执行以下操作：<br>(01) 后序遍历左子树；<br>(02) 后序遍历右子树；<br>(03) 访问根结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BSTNode&lt;T&gt; tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        postOrder(tree.left);</span><br><span class="line">        postOrder(tree.right);</span><br><span class="line">        System.out.print(tree.key+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    postOrder(mRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看下面这颗树的各种遍历方式：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/155914685.png" alt="mark"></p><p>对于上面的二叉树而言，<br>(01) 前序遍历结果： 3 1 2 5 4 6<br>(02) 中序遍历结果： 1 2 3 4 5 6<br>(03) 后序遍历结果： 2 1 4 6 5 3</p><h3 id="2-3-查找"><a href="#2-3-查找" class="headerlink" title="2.3 查找"></a>2.3 查找</h3><ul><li>递归版本的查找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (递归实现)查找"二叉树x"中键值为key的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> BSTNode&lt;T&gt; <span class="title">search</span><span class="params">(BSTNode&lt;T&gt; x, T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> search(x.left, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> search(x.right, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BSTNode&lt;T&gt; <span class="title">search</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> search(mRoot, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>非递归实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (非递归实现)查找"二叉树x"中键值为key的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> BSTNode&lt;T&gt; <span class="title">iterativeSearch</span><span class="params">(BSTNode&lt;T&gt; x, T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            x = x.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            x = x.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BSTNode&lt;T&gt; <span class="title">iterativeSearch</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> iterativeSearch(mRoot, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构-02-二叉查找树&quot;&gt;&lt;a href=&quot;#数据结构-02-二叉查找树&quot; class=&quot;headerlink&quot; title=&quot;数据结构-02-二叉查找树&quot;&gt;&lt;/a&gt;数据结构-02-二叉查找树&lt;/h1&gt;&lt;p&gt;参考博客 ： &lt;a href=&quot;https://www.cnblogs.com/skywang12345/p/3603935.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/skywang12345/p/3603935.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数据结构在线生成工具 ： &lt;a href=&quot;https://www.cs.usfca.edu/~galles/visualization/Algorithms.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cs.usfca.edu/~galles/visualization/Algorithms.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://zhuuu.work/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>HTTP-HTTPS详解</title>
    <link href="http://zhuuu.work/2020/06/26/NetworkCoding/HTTP-HTTPS%E8%AF%A6%E8%A7%A3/"/>
    <id>http://zhuuu.work/2020/06/26/NetworkCoding/HTTP-HTTPS%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-06-26T03:32:24.000Z</published>
    <updated>2020-06-26T04:37:58.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-HTTPS详解"><a href="#HTTP-HTTPS详解" class="headerlink" title="HTTP-HTTPS详解"></a>HTTP-HTTPS详解</h1><h2 id="一：-基础概念"><a href="#一：-基础概念" class="headerlink" title="一： 基础概念"></a>一： 基础概念</h2><h3 id="1-1-URI"><a href="#1-1-URI" class="headerlink" title="1.1 URI"></a>1.1 URI</h3><ul><li>URI 包含 URL 和 URN。</li><li>我们通常所说的URL（统一资源定位符）是URI的子集</li><li>URI还有一个自己URN , URN只命名资源但是不指定如何定位资源.</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/120156077.png" alt="mark"></p><a id="more"></a><h3 id="1-2-请求报文"><a href="#1-2-请求报文" class="headerlink" title="1.2 请求报文"></a>1.2 请求报文</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/120719185.png" alt="mark"></p><h3 id="1-3-响应报文"><a href="#1-3-响应报文" class="headerlink" title="1.3 响应报文"></a>1.3 响应报文</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/120739566.png" alt="mark"></p><h2 id="二-HTTP-请求方法"><a href="#二-HTTP-请求方法" class="headerlink" title="二: HTTP 请求方法"></a>二: HTTP 请求方法</h2><p>客户端发送的   <strong>请求报文</strong>   第一行为请求行，包含了方法字段。</p><p><strong>举例:</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/120845030.png" alt="mark"></p><h3 id="1-1-GET"><a href="#1-1-GET" class="headerlink" title="1.1 GET"></a>1.1 GET</h3><ul><li><strong>获取资源的请求</strong>(绝大部分的请求都是GET方法)</li></ul><h3 id="1-2-HEAD"><a href="#1-2-HEAD" class="headerlink" title="1.2 HEAD"></a>1.2 HEAD</h3><ul><li><strong>获取报文的首部,但是不返回报文实体主体部分</strong></li><li>主要用于确认URL的有效性以及资源更新的日期时间等.</li></ul><h3 id="1-3-POST"><a href="#1-3-POST" class="headerlink" title="1.3 POST"></a>1.3 POST</h3><ul><li><strong>传输实体主体</strong></li><li>POST用于传输表单数据,具体和GET的区别会在下文进行阐述</li></ul><h3 id="1-4-PUT"><a href="#1-4-PUT" class="headerlink" title="1.4 PUT"></a>1.4 PUT</h3><ul><li><strong>上传文件</strong></li><li>由于自身不带验证机制,任何人都可以上传文件,因此存在安全性问题,一般不使用这个方法.</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /new.html HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-type: text/html</span><br><span class="line">Content-length: 16</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>New File<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-5-PATCH"><a href="#1-5-PATCH" class="headerlink" title="1.5 PATCH"></a>1.5 PATCH</h3><ul><li><strong>类似与PUT,但是PATCH用于资源的部分修改</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PATCH /file.txt HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">Content-Type: application/example</span><br><span class="line">If-Match: "e0023aa4e"</span><br><span class="line">Content-Length: 100</span><br><span class="line"></span><br><span class="line">[description of changes]</span><br></pre></td></tr></table></figure><h3 id="1-6-DELTETE"><a href="#1-6-DELTETE" class="headerlink" title="1.6 DELTETE"></a>1.6 DELTETE</h3><ul><li><p>删除文件</p></li><li><p>与PUT功能相反,并且同样不携带验证机制.</p></li></ul><h3 id="1-7-OPTIONS"><a href="#1-7-OPTIONS" class="headerlink" title="1.7 OPTIONS"></a>1.7 OPTIONS</h3><ul><li>支持查询的方法</li><li>作用:查询指定的URL能够支持的方法(会返回 <code>Allow GET POST HEAD OPTIONS</code>) 这样的内容</li></ul><h3 id="1-8-Connect"><a href="#1-8-Connect" class="headerlink" title="1.8 Connect"></a>1.8 Connect</h3><ul><li>要求在与代理服务器通信时建立隧道</li><li>使用SSL(Secure Sockets Layer，安全套接层) 和 TLS (Transport Layer Security,传输层安全)协议把通信内容加密后经网络隧道传输.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONNECT www.example.com:443 HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/122102520.png" alt="mark"></p><h3 id="1-9-TRACE"><a href="#1-9-TRACE" class="headerlink" title="1.9 TRACE"></a>1.9 TRACE</h3><ul><li>追踪路径</li><li>服务器会将通信路径返回给客户端(在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。)</li><li>通常不会使用TRACE,并且它容易受到XST攻击(Cross-Site Tracing ,跨站追踪)</li></ul><h2 id="三-HTTP-状态码"><a href="#三-HTTP-状态码" class="headerlink" title="三: HTTP 状态码"></a>三: HTTP 状态码</h2><ul><li>服务器返回的   <strong>响应报文</strong>   中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</li></ul><table><thead><tr><th>状态码</th><th>类别</th><th>含义</th></tr></thead><tbody><tr><td>1XX</td><td>Informational(信息状态码)</td><td>接收的请求正现在处理</td></tr><tr><td>2XX</td><td>Success(成功状态码)</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection(重定向状态码)</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error(客户端错误状态码)</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error(服务器错误状态码)</td><td>服务器处理请求发生错误</td></tr></tbody></table><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/122512956.png" alt="mark"></p><h3 id="1XX-信息"><a href="#1XX-信息" class="headerlink" title="1XX 信息"></a>1XX 信息</h3><ul><li><strong>100 Continue</strong> : 表示到目前为止数据都很正常,客户端可以继续发送请求或者忽略这个响应.</li></ul><h3 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h3><ul><li><strong>200  OK</strong></li><li><strong>204  No Content</strong>: 请求已经成功处理,但是返回的响应报文不包含实体的主体部分.一般在只需要从客户端向服务器发送信息,而不需要返回数据的时候使用.</li><li><strong>206  Partial Content</strong>: 表示客户端进行的范围请求,响应报文包含由Content-Range 指定范围的实体内容.</li></ul><h3 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h3><ul><li><p><strong>301 Moved Permanently</strong> : 永久性重定向</p></li><li><p><strong>302 Found</strong>: 临时性重定向</p></li><li><p><strong>303 See Other</strong> : 和302 有着相同的功能,但是303明确要求客户端应该采用GET方法请求资源</p><ul><li>注：虽然 <strong>HTTP 协议规定</strong> 301、302 状态下<strong>重定向时不允许把 POST 方法改成 GET 方法</strong>，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</li></ul></li><li><p><strong>304 Not Modified</strong> : 如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since,如果不满足以上条件,则服务器会返回304状态码.</p></li><li><p><strong>307 Temporary Redirect :</strong>  临时重定向,与302的含义类似,但是307要求浏览器不会把重定向请求的POST方法修改成GET 方法.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTTP-HTTPS详解&quot;&gt;&lt;a href=&quot;#HTTP-HTTPS详解&quot; class=&quot;headerlink&quot; title=&quot;HTTP-HTTPS详解&quot;&gt;&lt;/a&gt;HTTP-HTTPS详解&lt;/h1&gt;&lt;h2 id=&quot;一：-基础概念&quot;&gt;&lt;a href=&quot;#一：-基础概念&quot; class=&quot;headerlink&quot; title=&quot;一： 基础概念&quot;&gt;&lt;/a&gt;一： 基础概念&lt;/h2&gt;&lt;h3 id=&quot;1-1-URI&quot;&gt;&lt;a href=&quot;#1-1-URI&quot; class=&quot;headerlink&quot; title=&quot;1.1 URI&quot;&gt;&lt;/a&gt;1.1 URI&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;URI 包含 URL 和 URN。&lt;/li&gt;
&lt;li&gt;我们通常所说的URL（统一资源定位符）是URI的子集&lt;/li&gt;
&lt;li&gt;URI还有一个自己URN , URN只命名资源但是不指定如何定位资源.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/120156077.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="网络编程" scheme="http://zhuuu.work/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTP" scheme="http://zhuuu.work/tags/HTTP/"/>
    
      <category term="HTTPS" scheme="http://zhuuu.work/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-015-三数之和</title>
    <link href="http://zhuuu.work/2020/06/24/Leetcode/Leetcode-015-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://zhuuu.work/2020/06/24/Leetcode/Leetcode-015-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2020-06-24T11:52:53.000Z</published>
    <updated>2020-06-27T04:35:23.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-015-三数之和"><a href="#Leecode-015-三数之和" class="headerlink" title="Leecode-015-三数之和"></a>Leecode-015-<a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">三数之和</a></h1><h2 id="思路：排序-双指针"><a href="#思路：排序-双指针" class="headerlink" title="思路：排序+双指针"></a>思路：排序+双指针</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：排序-双指针"><a href="#方法：排序-双指针" class="headerlink" title="方法：排序+双指针"></a>方法：排序+双指针</h2><p><strong>算法思路</strong></p><ul><li>首先对排序后的数组进行遍历，固定一个nums[i] 。</li><li>其次使用一个指针L指向 <code>i + 1</code> 的位置，一个指针R指向 <code>nums.length - 1</code>的位置，同时计算<code>nums[i] + nums[L] + nums[R]</code>,计算这三个数的和是否等于0</li><li>细节条件一定要注意<ul><li>如果<code>nums[i] &gt; 0</code> ，那么这三个数的和比不可能等于0</li><li>如果<code>nums[i] == nums[i -1]</code> ,则说明该数字重复，会导致结果的重复，所以应该跳过</li><li>当sum == 0的时候，如果<code>nums[L] == nums[L+1]</code>,则会导致结果的重复，应该跳过，(L++)</li><li>当sum == 0的时候，如果<code>nums[R] == nums[R - 1]</code>,则会导致结果的重复，应该跳过，(R–)</li></ul></li></ul><p><strong>举个例子：</strong></p><ol><li><strong>首先进行排序</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100358932.png" alt="mark"></p><ol start="2"><li><strong>第一轮循环</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100418544.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100451353.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100458185.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100504327.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100511291.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100527129.png" alt="mark"></p><ol start="3"><li><strong>第二轮循环</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100538257.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100548763.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100554929.png" alt="mark"></p><ol start="4"><li><strong>第三轮循环</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100609939.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100615721.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化：ans记录结果</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特殊判断</span></span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 对数组进行排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 遍历数组中的每一个数字，固定nums[i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前数字大于0,，则三数之和一定大于0，所以结束循环</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意：对 i 进行去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化双指针</span></span><br><span class="line">            <span class="keyword">int</span> L = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> R = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 指针遍历</span></span><br><span class="line">            <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[L] + nums[R];</span><br><span class="line"></span><br><span class="line">                <span class="comment">//  如果三数之和等于0</span></span><br><span class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 记录结果</span></span><br><span class="line">                    ans.add(Arrays.asList(nums[i], nums[L], nums[R]));</span><br><span class="line">                    <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[L] == nums[L + <span class="number">1</span>]) L++; <span class="comment">// 注意：去重</span></span><br><span class="line">                    <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[R] == nums[R - <span class="number">1</span>]) R--; <span class="comment">// 注意：去重</span></span><br><span class="line">                    <span class="comment">// 指针移动来产生新的结果</span></span><br><span class="line">                    L++;</span><br><span class="line">                    R--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    L++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    R--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O（n^2） 排序O(nlogn) + 循环O（n^2） = O(n^2)</li><li>空间复杂度：O(1)  没有使用额外的空间</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-015-三数之和&quot;&gt;&lt;a href=&quot;#Leecode-015-三数之和&quot; class=&quot;headerlink&quot; title=&quot;Leecode-015-三数之和&quot;&gt;&lt;/a&gt;Leecode-015-&lt;a href=&quot;https://leetcode-cn.com/problems/3sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;三数之和&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：排序-双指针&quot;&gt;&lt;a href=&quot;#思路：排序-双指针&quot; class=&quot;headerlink&quot; title=&quot;思路：排序+双指针&quot;&gt;&lt;/a&gt;思路：排序+双指针&lt;/h2&gt;&lt;p&gt;给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;答案中不可以包含重复的三元组。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;给定数组 nums &amp;#x3D; [-1, 0, 1, 2, -1, -4]，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;满足要求的三元组集合为：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [-1, 0, 1],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [-1, -1, 2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="排序" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leecode-016-最接近的三数之和</title>
    <link href="http://zhuuu.work/2020/06/24/Leetcode/Leetcode-016-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://zhuuu.work/2020/06/24/Leetcode/Leetcode-016-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2020-06-24T07:52:53.000Z</published>
    <updated>2020-06-25T01:18:07.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-016-最接近的三数之和"><a href="#Leecode-016-最接近的三数之和" class="headerlink" title="Leecode-016-最接近的三数之和"></a>Leecode-016-<a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">最接近的三数之和</a></h1><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091530419.png" alt="mark"></p><h2 id="思路：排序-双指针"><a href="#思路：排序-双指针" class="headerlink" title="思路：排序+双指针"></a>思路：排序+双指针</h2><ul><li>本题目和Leetcode-015合在一起是三数之和的系列题目</li><li><a href="https://leetcode-cn.com/problems/3sum/（Leetcode-015）" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum/（Leetcode-015）</a></li></ul><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code>。</li><li>找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。</li><li>假定每组输入只存在唯一答案。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1</span><br><span class="line">输出：2</span><br><span class="line">解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">3 &lt;&#x3D; nums.length &lt;&#x3D; 10^3</span><br><span class="line">-10^3 &lt;&#x3D; nums[i] &lt;&#x3D; 10^3</span><br><span class="line">-10^4 &lt;&#x3D; target &lt;&#x3D; 10^4</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：排序-双指针"><a href="#方法：排序-双指针" class="headerlink" title="方法：排序+双指针"></a>方法：排序+双指针</h2><p><strong>算法思路：</strong></p><ul><li>本题目因为要计算三个数，如果暴力枚举的话时间复杂度会来到O（n^3） ，需要降低时间的复杂度才行</li><li>首先对数组进行排序，时间复杂度O(nlogn)</li><li>在数组 nums 中，进行遍历，每次遍历固定一个nums[i]</li><li>其次使用两个指针，一个L指针指向<code>i + 1</code> 处，一个R指针指向 <code>nums.length-1</code> 处，也就是结尾处。</li><li>计算sum的值 ，sum = nums[i] + nums[L] + nums[R]</li><li>最后判断sum 和 target的关系，因为数组有序，<ul><li>如果sum &gt; target, <code>R --</code></li><li>如果sum &lt; target , <code>L++</code></li><li>如果 sum == target ,距离为0直接返回结果</li></ul></li></ul><p><strong>举个例子：</strong></p><ol><li>排序</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091321683.png" alt="mark"></p><ol start="2"><li>初始化</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091334756.png" alt="mark"></p><ol start="3"><li>for循环</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091411150.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091423709.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091437310.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091444470.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091452814.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091505156.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091511678.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091521010.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 初始化</span></span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 循环固定nums[i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> L = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> R = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (L &lt; R)&#123;</span><br><span class="line">                <span class="comment">// 三数之和</span></span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[L] + nums[R];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 每次更新结果</span></span><br><span class="line">                <span class="keyword">if</span> (Math.abs(target - sum) &lt; Math.abs(target - ans))&#123;</span><br><span class="line">                    ans = sum;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断sum 和 target之间的关系</span></span><br><span class="line">                <span class="keyword">if</span> (sum &gt; target)&#123;</span><br><span class="line">                    R--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target)&#123;</span><br><span class="line">                    L++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 ：O（n^2）  排序O(nlogn) + 遍历O(n^2) = O(n^2)</li><li>空间复杂度： O(1) 没有使用额外的空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-016-最接近的三数之和&quot;&gt;&lt;a href=&quot;#Leecode-016-最接近的三数之和&quot; class=&quot;headerlink&quot; title=&quot;Leecode-016-最接近的三数之和&quot;&gt;&lt;/a&gt;Leecode-016-&lt;a href=&quot;https://leetcode-cn.com/problems/3sum-closest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;最接近的三数之和&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/091530419.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;思路：排序-双指针&quot;&gt;&lt;a href=&quot;#思路：排序-双指针&quot; class=&quot;headerlink&quot; title=&quot;思路：排序+双指针&quot;&gt;&lt;/a&gt;思路：排序+双指针&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本题目和Leetcode-015合在一起是三数之和的系列题目&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/3sum/（Leetcode-015）&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/3sum/（Leetcode-015）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给定一个包括 &lt;em&gt;n&lt;/em&gt; 个整数的数组 &lt;code&gt;nums&lt;/code&gt; 和 一个目标值 &lt;code&gt;target&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;找出 &lt;code&gt;nums&lt;/code&gt; 中的三个整数，使得它们的和与 &lt;code&gt;target&lt;/code&gt; 最接近。返回这三个数的和。&lt;/li&gt;
&lt;li&gt;假定每组输入只存在唯一答案。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [-1,2,1,-4], target &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：与 target 最接近的和是 2 (-1 + 2 + 1 &amp;#x3D; 2) 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3 &amp;lt;&amp;#x3D; nums.length &amp;lt;&amp;#x3D; 10^3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-10^3 &amp;lt;&amp;#x3D; nums[i] &amp;lt;&amp;#x3D; 10^3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-10^4 &amp;lt;&amp;#x3D; target &amp;lt;&amp;#x3D; 10^4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="排序" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-350-两个数组的交集II</title>
    <link href="http://zhuuu.work/2020/06/23/Leetcode/Leetcode-350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II/"/>
    <id>http://zhuuu.work/2020/06/23/Leetcode/Leetcode-350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II/</id>
    <published>2020-06-23T03:22:53.000Z</published>
    <updated>2020-06-25T07:30:37.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-350-两个数组的交集-II"><a href="#Leetcode-350-两个数组的交集-II" class="headerlink" title="Leetcode-350-两个数组的交集 II"></a>Leetcode-350-<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">两个数组的交集 II</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">输出: [2,2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]</span><br><span class="line">输出: [4,9]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。</li><li>我们可以不考虑输出结果的顺序。</li></ul><p><strong>进阶:</strong></p><ul><li>如果给定的数组已经排好序呢？你将如何优化你的算法？</li><li>如果 nums1 的大小比 nums2 小很多，哪种方法更优？</li><li>如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</li></ul><a id="more"></a><h2 id="方法一：排序-双指针"><a href="#方法一：排序-双指针" class="headerlink" title="方法一：排序+双指针"></a>方法一：排序+双指针</h2><p><strong>算法分析：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/143433760.jpg" alt="mark"></p><ul><li><p>首先对两个数组<code>nums1</code> 和 <code>nums2</code>进行排序</p></li><li><p>初始化指针<code>i,j</code> 用于指向两个数组</p><ul><li>指针<code>i</code> 指向 <code>nums1</code>,指针<code>j</code> 指向<code>nums2</code></li><li>如果<code>nums1[i] &lt; nums2[j]</code>  则 <code>i++</code></li><li>如果<code>nums1[i] &gt; nums2[j]</code>  则 <code>j++</code></li><li>如果<code>nums1[i] == nums2[j]</code>  则将元素拷贝到<code>nums1[k]</code>,且同时<code>i++ , j ++ , k++</code></li></ul></li><li><p><strong>初始化指针<code>k</code> 用于记录是否应该修改元素（作用是为了不使用额外的空间）</strong></p></li><li><p><strong>最后返回<code>nums1</code>的前k个元素就好</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 排序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对两个数组进行排序</span></span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">// 指向nums1</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;  <span class="comment">// 指向nums2</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;  <span class="comment">// 用于记录nums1 和 nums2 中重复元素的个数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums1.length &amp;&amp; j &lt; nums2.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[k] = nums1[i];</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将一个原始的数组original，从下标from开始复制，复制到上标to，生成一个新的数组。</span></span><br><span class="line">        <span class="comment">// 注意这里包括下标from，不包括上标to。</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(nums1,<span class="number">0</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度：</strong><code>O(nlogn+mlogm)</code>其中 n，m分别代表了数组的大小。我们对数组进行了排序然后进行了线性扫描。</li><li><strong>空间复杂度</strong>：O（1） 没有使用额外的空间。</li></ul><h2 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h2><ul><li>相对于上一题我们使用set去重，本题不要求去重，那么使用哈希表也很合适</li><li>如果 <code>nums1</code> 元素个数大于 <code>nums2</code>，则交换数组元素。</li><li>对于 <code>nums1</code> 的每个元素，添加到 <code>HashMap m</code> 中，如果元素已经存在则增加对应的计数。(这里用了一个getOrDefault方法，作用同map用if-else存放元素)</li><li>遍历数组<code>nums2</code><ul><li>检查元素在map中是否存在，如果存在且个数大于0<ul><li>将元素拷贝到<code>nums1[k]</code>, k++</li><li>减少map中对应元素的个数</li></ul></li></ul></li></ul><ul><li>最后返回<code>nums1</code>的前k个元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 哈希表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 首先决定用长度小的数组进行操作（检查数组的大小并对较小的数组进行哈希映射是一个小细节，当其中一个数组较大时，会减少内存的使用。）</span></span><br><span class="line">        <span class="keyword">if</span> (nums1.length &gt; nums2.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> intersect(nums2,nums1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 使用map存放元素</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums1) &#123;</span><br><span class="line">            map.put(n, map.getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 对应nums2去减少元素，（避免再开一个map浪费空间）</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums2.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果有这个Key存在的话</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(nums2[i]))&#123;</span><br><span class="line">                <span class="comment">// 获取这个key对应的value，</span></span><br><span class="line">                <span class="comment">// 如果对应的value &gt; 0,并将这个value值 - 1</span></span><br><span class="line">                <span class="keyword">int</span> count = map.get(nums2[i]);</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    map.put(nums2[i],count - <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 同时把当前元素的值赋值给nums1[k] ，这样减少了内存的浪费</span></span><br><span class="line">                    nums1[k] = nums2[i];</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(nums1,<span class="number">0</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>时间复杂度</strong>：<strong>O( n + m )</strong> 其中 n<em>，m</em> 分别代表了数组的大小。</p></li><li><p><strong>空间复杂度</strong>：<strong>O(min(m,n))</strong> 创建了两个数组中最小大小的map映射。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-350-两个数组的交集-II&quot;&gt;&lt;a href=&quot;#Leetcode-350-两个数组的交集-II&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-350-两个数组的交集 II&quot;&gt;&lt;/a&gt;Leetcode-350-&lt;a href=&quot;https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;两个数组的交集 II&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定两个数组，编写一个函数来计算它们的交集。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: nums1 &amp;#x3D; [1,2,2,1], nums2 &amp;#x3D; [2,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [2,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: nums1 &amp;#x3D; [4,9,5], nums2 &amp;#x3D; [9,4,9,8,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [4,9]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。&lt;/li&gt;
&lt;li&gt;我们可以不考虑输出结果的顺序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进阶:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果给定的数组已经排好序呢？你将如何优化你的算法？&lt;/li&gt;
&lt;li&gt;如果 nums1 的大小比 nums2 小很多，哪种方法更优？&lt;/li&gt;
&lt;li&gt;如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="哈希表" scheme="http://zhuuu.work/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="排序" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-242-有效的字母异位词</title>
    <link href="http://zhuuu.work/2020/06/15/Leetcode/Leetcode-242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
    <id>http://zhuuu.work/2020/06/15/Leetcode/Leetcode-242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</id>
    <published>2020-06-15T07:22:53.000Z</published>
    <updated>2020-06-17T09:21:59.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-242-有效的字母异位词"><a href="#Leecode-242-有效的字母异位词" class="headerlink" title="Leecode-242-有效的字母异位词"></a>Leecode-242-<a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">有效的字母异位词</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>说明:</strong><br>你可以假设字符串只包含小写字母。</p><p><strong>进阶:</strong><br>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p><a id="more"></a><h2 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h2><p>思路： </p><ul><li>通过将s字符串转换成char数组</li><li>对每个字符进行排序。</li><li>因此，如果T是S的异位词，对两个字符串进行排序将产生两个相同的字符串。</li><li>此外，如果s和t的长度不同，t不可能是s的异位词，这样我们可以提前返回。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] str1 = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] str2 = t.toCharArray();</span><br><span class="line">        Arrays.sort(str1);</span><br><span class="line">        Arrays.sort(str2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O（n）</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(str1,str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>复杂度分析<ul><li>时间复杂度：O(nlogn) ，排序的成本是O(nlogn) ，比较字符串的成本是O(n),所以总体的时间复杂度是O(nlogn)</li><li>空间复杂度：O(n) ,<code>toCharArray()</code> 制作了一个字符串的拷贝，所以它花费 O(n)额外的空间</li></ul></li></ul><h2 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h2><p>思路：</p><ul><li>为了检查t是否是s的重新排列，我们只需要计算两个字符串中对应字母出现的次数是否相同即可</li><li>因为S和T都只包含26个小写字母，所以哈希表大小26个字母就够了</li><li>这里需要两个计数器来进行比较吗？<ul><li>答：不需要，只需要一个计数器表即可。用一个计数器表计算s字母的频率，用t减少计数器表中每个字母的计数器，然后检查计数器是否回到了0。</li></ul></li></ul><ul><li>这里直接用数组代替hash，减少哈希碰撞带来的复杂度。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表</span></span><br><span class="line"><span class="comment">// 为了检查t是否是s的重新排列，我们可以计算连个字符串中每个字母的出现次数并比较</span></span><br><span class="line"><span class="comment">// 因为s和t都只包含A-Z的字母，所以一个简单的26位计数器就够了</span></span><br><span class="line"><span class="comment">// 我们需要连个计数器表进行比较吗？</span></span><br><span class="line"><span class="comment">// 答：是不需要的，因为我们可以用一个计数器表计算s字母的频率，用t减少计数器表中每个字母的计数器，最后检查计数器是否回到0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] counter = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            counter[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">            counter[t.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> count : counter) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)     遍历两个字符串的开销</li><li>空间复杂度： O(1)     26个字母对计算机来说不是什么事情。 </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-242-有效的字母异位词&quot;&gt;&lt;a href=&quot;#Leecode-242-有效的字母异位词&quot; class=&quot;headerlink&quot; title=&quot;Leecode-242-有效的字母异位词&quot;&gt;&lt;/a&gt;Leecode-242-&lt;a href=&quot;https://leetcode-cn.com/problems/valid-anagram/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;有效的字母异位词&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定两个字符串 &lt;em&gt;s&lt;/em&gt; 和 &lt;em&gt;t&lt;/em&gt; ，编写一个函数来判断 &lt;em&gt;t&lt;/em&gt; 是否是 &lt;em&gt;s&lt;/em&gt; 的字母异位词。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: s &amp;#x3D; &amp;quot;anagram&amp;quot;, t &amp;#x3D; &amp;quot;nagaram&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: s &amp;#x3D; &amp;quot;rat&amp;quot;, t &amp;#x3D; &amp;quot;car&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;br&gt;你可以假设字符串只包含小写字母。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进阶:&lt;/strong&gt;&lt;br&gt;如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="哈希表" scheme="http://zhuuu.work/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="排序" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础-原码,补码,反码</title>
    <link href="http://zhuuu.work/2020/06/13/JavaInterview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E5%8E%9F%E7%A0%81,%E8%A1%A5%E7%A0%81,%E5%8F%8D%E7%A0%81/"/>
    <id>http://zhuuu.work/2020/06/13/JavaInterview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E5%8E%9F%E7%A0%81,%E8%A1%A5%E7%A0%81,%E5%8F%8D%E7%A0%81/</id>
    <published>2020-06-13T07:38:38.000Z</published>
    <updated>2020-06-13T07:27:12.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机基础-原码-补码-反码"><a href="#计算机基础-原码-补码-反码" class="headerlink" title="计算机基础-原码,补码,反码"></a>计算机基础-原码,补码,反码</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机基础-原码-补码-反码&quot;&gt;&lt;a href=&quot;#计算机基础-原码-补码-反码&quot; class=&quot;headerlink&quot; title=&quot;计算机基础-原码,补码,反码&quot;&gt;&lt;/a&gt;计算机基础-原码,补码,反码&lt;/h1&gt;
      
    
    </summary>
    
    
    
      <category term="位运算" scheme="http://zhuuu.work/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="计算机基础" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-349-两个数组的交集</title>
    <link href="http://zhuuu.work/2020/06/13/Leetcode/Leetcode-349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
    <id>http://zhuuu.work/2020/06/13/Leetcode/Leetcode-349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</id>
    <published>2020-06-13T06:22:53.000Z</published>
    <updated>2020-06-22T06:49:00.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-349-两个数组的交集"><a href="#Leecode-349-两个数组的交集" class="headerlink" title="Leecode-349-两个数组的交集"></a>Leecode-349-<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">两个数组的交集</a></h1><h2 id="思路：哈希表"><a href="#思路：哈希表" class="headerlink" title="思路：哈希表"></a>思路：哈希表</h2><h2 id="题目表述"><a href="#题目表述" class="headerlink" title="题目表述"></a>题目表述</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">输出：[2]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]</span><br><span class="line">输出：[9,4]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：两个set"><a href="#方法：两个set" class="headerlink" title="方法：两个set"></a>方法：两个set</h2><ul><li>将两个数组都转换成集合</li><li>然后迭代较小的集合，检查其中每个元素是否在较大的集合中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将两个数组都转化为集合</span></span><br><span class="line"><span class="comment">// 然后迭代较小的集合</span></span><br><span class="line"><span class="comment">// 检查其中每个元素是否同样存在较大的集合中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; set2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把nums1数组存到对应的set1中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums1) &#123;</span><br><span class="line">            set1.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把nums2数组存到对应的set2中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums2) &#123;</span><br><span class="line">            set2.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从较小的set检查和较大数组的交集</span></span><br><span class="line">        <span class="keyword">if</span> (set1.size() &lt; set2.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> helper(set1,set2);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> helper(set2,set1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] helper(HashSet&lt;Integer&gt; set1, HashSet&lt;Integer&gt; set2) &#123;</span><br><span class="line">        <span class="comment">// 创建一个和较小set一样的数组记为result</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[set1.size()];</span><br><span class="line">        <span class="comment">// 交集含有的个数</span></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历较小Set</span></span><br><span class="line">        <span class="comment">// 查找较大set中是否存在较小set的元素</span></span><br><span class="line">        <span class="keyword">for</span> (Integer num : set1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set2.contains(num))&#123;</span><br><span class="line">                result[idx] = num;</span><br><span class="line">                idx++; <span class="comment">// 这里idx++完之后会比原数组长度多1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回一个idx长度的交集</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(result,idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度： O（m + n） 其中 <code>n</code> 和 <code>m</code> 是数组的长度。<ul><li>将<code>num1</code> 转换成集合要 O(n )的时间</li><li>类似地，将 <code>nums2</code> 转换为集合需要 <em>O</em>(<em>m</em>) 的时间</li><li>而在平均情况下，集合的 <code>in/contains</code> 操作只需要 O(1) 的时间。</li></ul></li></ul><ul><li>空间复杂度：O<em>(</em>m<em>+</em>n)，最坏的情况是数组中的所有元素都不同。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-349-两个数组的交集&quot;&gt;&lt;a href=&quot;#Leecode-349-两个数组的交集&quot; class=&quot;headerlink&quot; title=&quot;Leecode-349-两个数组的交集&quot;&gt;&lt;/a&gt;Leecode-349-&lt;a href=&quot;https://leetcode-cn.com/problems/intersection-of-two-arrays/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;两个数组的交集&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：哈希表&quot;&gt;&lt;a href=&quot;#思路：哈希表&quot; class=&quot;headerlink&quot; title=&quot;思路：哈希表&quot;&gt;&lt;/a&gt;思路：哈希表&lt;/h2&gt;&lt;h2 id=&quot;题目表述&quot;&gt;&lt;a href=&quot;#题目表述&quot; class=&quot;headerlink&quot; title=&quot;题目表述&quot;&gt;&lt;/a&gt;题目表述&lt;/h2&gt;&lt;p&gt;给定两个数组，编写一个函数来计算它们的交集。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums1 &amp;#x3D; [1,2,2,1], nums2 &amp;#x3D; [2,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums1 &amp;#x3D; [4,9,5], nums2 &amp;#x3D; [9,4,9,8,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[9,4]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="哈希表" scheme="http://zhuuu.work/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>��Դ��Ŀ-02-SSM����</title>
    <link href="http://zhuuu.work/2020/06/13/Project/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-02-SSM%E6%95%B4%E5%90%88/"/>
    <id>http://zhuuu.work/2020/06/13/Project/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-02-SSM%E6%95%B4%E5%90%88/</id>
    <published>2020-06-13T03:02:24.000Z</published>
    <updated>2020-06-13T12:14:02.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="��Դ��L-02-SSM����"><a href="#��Դ��L-02-SSM����" class="headerlink" title="��Դ��Ŀ-02-SSM����"></a>��Դ��Ŀ-02-SSM����</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;��Դ��L-02-SSM����&quot;&gt;&lt;a href=&quot;#��Դ��L-02-SSM����&quot; class=&quot;headerlink&quot; title=&quot;��Դ��Ŀ-02-SSM����&quot;&gt;&lt;/a&gt;��Դ��Ŀ-02-SSM����&lt;/h1&gt;
      
    
    </summary>
    
    
    
      <category term="��Դ��Ŀ" scheme="http://zhuuu.work/tags/%EF%BF%BD%EF%BF%BD%D4%B4%EF%BF%BD%EF%BF%BDL/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-448-找到所有数组中消失的数字</title>
    <link href="http://zhuuu.work/2020/06/12/Leetcode/Leetcode-448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://zhuuu.work/2020/06/12/Leetcode/Leetcode-448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2020-06-12T08:44:53.000Z</published>
    <updated>2020-06-27T09:19:20.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-448-找到所有数组中消失的数字"><a href="#Leecode-448-找到所有数组中消失的数字" class="headerlink" title="Leecode-448-找到所有数组中消失的数字"></a>Leecode-448-<a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">找到所有数组中消失的数字</a></h1><h2 id="思路：自哈希"><a href="#思路：自哈希" class="headerlink" title="思路：自哈希"></a>思路：自哈希</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p><p><strong>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</strong></p><p>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：自哈希"><a href="#方法：自哈希" class="headerlink" title="方法：自哈希"></a>方法：自哈希</h2><ul><li><p>这里由于数组元素限定在数组长度的范围内，因此，我们可以通过一次遍历：</p><p>让数值 1 就放在索引位置 0 处；<br>让数值 2 就放在索引位置 1 处；<br>让数值 3 就放在索引位置 2 处；</p></li><li><p>再次遍历一遍数组，如果当前 <code>索引+1 != 当前值</code></p><ul><li>说明这个数不匹配，是消失的数，所以加入到结果集中</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录结果</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[nums[i] - <span class="number">1</span>] != nums[i])&#123;</span><br><span class="line">                swap(nums,i,nums[i] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历交换后的数组，查看消失的数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>)&#123;</span><br><span class="line">                res.add(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基与异或的交换方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index1,<span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index1 == index2)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左边a b a</span></span><br><span class="line">        <span class="comment">// 右边相同 ：两个数字的异或</span></span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index2] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)，这里 N 是数组的长度。<strong>(均摊复杂度)</strong></li><li>空间复杂度：O(1)，这里因为使用异或运算交换数组的元素，故没有使用额外的数组空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-448-找到所有数组中消失的数字&quot;&gt;&lt;a href=&quot;#Leecode-448-找到所有数组中消失的数字&quot; class=&quot;headerlink&quot; title=&quot;Leecode-448-找到所有数组中消失的数字&quot;&gt;&lt;/a&gt;Leecode-448-&lt;a href=&quot;https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;找到所有数组中消失的数字&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：自哈希&quot;&gt;&lt;a href=&quot;#思路：自哈希&quot; class=&quot;headerlink&quot; title=&quot;思路：自哈希&quot;&gt;&lt;/a&gt;思路：自哈希&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;找到所有在 [1, n] 范围之间没有出现在数组中的数字。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[4,3,2,7,8,2,3,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[5,6]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="自哈希" scheme="http://zhuuu.work/tags/%E8%87%AA%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-442-数组中重复的数据</title>
    <link href="http://zhuuu.work/2020/06/12/Leetcode/Leetcode-442-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E6%8D%AE/"/>
    <id>http://zhuuu.work/2020/06/12/Leetcode/Leetcode-442-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E6%8D%AE/</id>
    <published>2020-06-12T07:46:53.000Z</published>
    <updated>2020-06-27T09:01:29.295Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-442-数组中重复的数据"><a href="#Leetcode-442-数组中重复的数据" class="headerlink" title="Leetcode-442-数组中重复的数据"></a>Leetcode-442-<a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/" target="_blank" rel="noopener">数组中重复的数据</a></h1><h2 id="思路：自哈希-抽屉原理"><a href="#思路：自哈希-抽屉原理" class="headerlink" title="思路：自哈希/抽屉原理"></a>思路：自哈希/抽屉原理</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。</p><p>找到所有出现两次的元素。</p><p>你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[2,3]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：抽屉原理"><a href="#方法：抽屉原理" class="headerlink" title="方法：抽屉原理"></a>方法：抽屉原理</h2><ul><li><p><strong>思路分析：“桶排序”的思想是“抽屉原理”，</strong>即“一个萝卜一个坑”，8 个萝卜要放在 7 个坑里，则至少有 1 个坑里至少有 2 个萝卜。</p></li><li><p>这里由于数组元素限定在数组长度的范围内，因此，我们可以通过一次遍历：</p><p>让数值 1 就放在索引位置 0 处；<br>让数值 2 就放在索引位置 1 处；<br>让数值 3 就放在索引位置 2 处；</p></li><li><p>一次遍历以后，那些“无处安放”的元素就是我们要查找的“出现两次的元素”</p></li><li><p>为了不使用额外的空间，这里使用到的一个技巧是“基于异或运算交换两个变量的值”：交换两个整数，除了引入一个新的变量，写出一个“轮换”的赋值表达式以外，还有两种比较 tricky 的做法，下面给出结论。</p><ul><li>如果 <code>a ^ b = c</code> 那么 <code>a ^ c = b</code> 与 <code>b ^ c = a</code>同时成立</li></ul></li></ul><table><thead><tr><th>基于异或运算</th><th>基于加减法</th></tr></thead><tbody><tr><td><code>a = a ^ b</code> <code>b = a ^ b</code> <code>a = a ^ b</code></td><td><code>a = a + b</code> <code>b = a - b</code> <code>a = a - b</code></td></tr></tbody></table><ul><li>对于异或运算实现的交换方法，如果调用 <code>swap(nums, i, i)</code>，那么最终的结果会变为 <code>0</code>。</li><li>对于加减法实现的交换方法，有可能发生溢出。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基与异或的交换方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index1,<span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index1 == index2)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左边a b a</span></span><br><span class="line">    <span class="comment">// 右边相同 ：两个数字的异或</span></span><br><span class="line">    nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">    nums[index2] = nums[index1] ^ nums[index2];</span><br><span class="line">    nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录结果</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对数组自己做哈希：数值为i的数字映射到下标 i - 1的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 在指定范围内，如果数字并且没有放在正确的位置上，才交换</span></span><br><span class="line">            <span class="comment">// 例如：数值3应该放在索引2的位置上</span></span><br><span class="line">            <span class="keyword">while</span> (nums[nums[i] - <span class="number">1</span>] != nums[i])&#123;</span><br><span class="line">                swap(nums,i,nums[i] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历交换后的数组，如果当前下标和数字不对应</span></span><br><span class="line">        <span class="comment">// 说明出现了重复的数字，加入到res中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] - <span class="number">1</span> != i)&#123;</span><br><span class="line">                res.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基与异或的交换方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index1,<span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index1 == index2)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左边a b a</span></span><br><span class="line">        <span class="comment">// 右边相同 ：两个数字的异或</span></span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index2] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//    // 普通交换函数</span></span><br><span class="line"><span class="comment">//    private void swap(int[] nums, int i, int j) &#123;</span></span><br><span class="line"><span class="comment">//        int temp = nums[i];</span></span><br><span class="line"><span class="comment">//        nums[i] = nums[j];</span></span><br><span class="line"><span class="comment">//        nums[j] = temp;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)，这里 N 是数组的长度。<strong>(均摊复杂度)</strong></li><li>空间复杂度：O(1)，这里因为使用异或运算交换数组的元素，故没有使用额外的数组空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-442-数组中重复的数据&quot;&gt;&lt;a href=&quot;#Leetcode-442-数组中重复的数据&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-442-数组中重复的数据&quot;&gt;&lt;/a&gt;Leetcode-442-&lt;a href=&quot;https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数组中重复的数据&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：自哈希-抽屉原理&quot;&gt;&lt;a href=&quot;#思路：自哈希-抽屉原理&quot; class=&quot;headerlink&quot; title=&quot;思路：自哈希/抽屉原理&quot;&gt;&lt;/a&gt;思路：自哈希/抽屉原理&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。&lt;/p&gt;
&lt;p&gt;找到所有出现两次的元素。&lt;/p&gt;
&lt;p&gt;你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[4,3,2,7,8,2,3,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[2,3]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="自哈希" scheme="http://zhuuu.work/tags/%E8%87%AA%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-0XX</title>
    <link href="http://zhuuu.work/2020/06/12/Leetcode/Leetcode-264-%E4%B8%91%E6%95%B0/"/>
    <id>http://zhuuu.work/2020/06/12/Leetcode/Leetcode-264-%E4%B8%91%E6%95%B0/</id>
    <published>2020-06-12T07:33:53.000Z</published>
    <updated>2020-06-17T10:20:52.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-264-丑数"><a href="#Leecode-264-丑数" class="headerlink" title="Leecode-264-丑数"></a>Leecode-264-<a href="https://leetcode-cn.com/problems/ugly-number/" target="_blank" rel="noopener">丑数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个程序判断给定的数是否为丑数。</p><p>丑数就是只包含质因数 <code>2, 3, 5</code> 的<strong>正整数</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 6</span><br><span class="line">输出: true</span><br><span class="line">解释: 6 &#x3D; 2 × 3</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 8</span><br><span class="line">输出: true</span><br><span class="line">解释: 8 &#x3D; 2 × 2 × 2</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: 14</span><br><span class="line">输出: false </span><br><span class="line">解释: 14 不是丑数，因为它包含了另外一个质因数 7。</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol><li><code>1</code> 是丑数。</li><li>输入不会超过 32 位有符号整数的范围: [−231, 231 − 1]。</li></ol><a id="more"></a><h3 id="方法一：除法"><a href="#方法一：除法" class="headerlink" title="方法一：除法"></a>方法一：除法</h3><ul><li>思路：不断除以2，3，5 ，最后结果是1，那么一定是丑数<ul><li>换句话来说：除尽所有的因子，那么最后一定等于1</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (num % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            num /= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (num % <span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            num /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (num % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            num /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度： O(1)</li><li>空间复杂度： O(1)</li></ul><h2 id="题目描述（丑数进阶）："><a href="#题目描述（丑数进阶）：" class="headerlink" title="题目描述（丑数进阶）："></a>题目描述（丑数进阶）：</h2><p>我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br></pre></td></tr></table></figure><h3 id="方法一：三指针"><a href="#方法一：三指针" class="headerlink" title="方法一：三指针"></a>方法一：三指针</h3><p>思路：</p><ul><li><p>创建一个大小是 n+1 的数组，来存放n个丑数（第一个丑数是<code>numList[0] = 1</code>）</p></li><li><p>存入的每个丑数是2，3，5对应指针最小的那个丑数</p></li><li><p>三个指针分别指向2,3,5的因子</p><ul><li>如果含有2的因子，2的指针加1</li><li>如果含有3的因子，3的指针加1</li><li>如果含有5的因子，5的指针加1</li></ul></li><li><p>最后返回数组下标 <code>n - 1</code>对应的元素即可</p></li></ul><h3 id="方法二：最小堆"><a href="#方法二：最小堆" class="headerlink" title="方法二：最小堆"></a>方法二：最小堆</h3><p>思路：</p><ul><li><p>从堆中包含一个数字开始：1</p></li><li><p>去计算下一个丑数。将 1 从堆中弹出然后将三个数字添加到堆中：2，3，5</p></li><li><p>现在堆中最小的数字是 2。为了计算下一个丑数，要将 2 从堆中弹出然后添加三个数字：4，6，10</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200617/181811361.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200617/181826820.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200617/181836970.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆：队列实现</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存放丑数</span></span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 用来对堆去重</span></span><br><span class="line">        HashSet&lt;Long&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// 在每个步骤中，弹出堆中最小的丑数 k，并</span></span><br><span class="line">        <span class="comment">// 在堆中添加三个丑数：k×2, k×3，和 k×5</span></span><br><span class="line">        PriorityQueue&lt;Long&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同时加入第一个丑数</span></span><br><span class="line">        pq.add(<span class="number">1L</span>);</span><br><span class="line">        set.add(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化丑数和因子</span></span><br><span class="line">        <span class="keyword">long</span> currUgly = <span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">long</span> newUgly  = <span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">int</span>[] primes = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从堆中包含第一个数字开始</span></span><br><span class="line">        <span class="comment">// 重复该步骤计算所有丑数。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 弹出堆中最小的丑数 k</span></span><br><span class="line">            currUgly = pq.poll();</span><br><span class="line">            <span class="comment">// 将这个丑数加入到数组存放</span></span><br><span class="line">            nums[i] = (<span class="keyword">int</span>)currUgly;</span><br><span class="line">            <span class="comment">// 添加三个新丑数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> prime : primes) &#123;</span><br><span class="line">                newUgly = currUgly * prime;</span><br><span class="line">                <span class="keyword">if</span> (!set.contains(newUgly))&#123;</span><br><span class="line">                    set.add(newUgly);</span><br><span class="line">                    pq.add(newUgly);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n) 对每个丑数乘以因子的for循环操作。</li><li>空间复杂度：O(n) 数组的长度，Set的长度</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-264-丑数&quot;&gt;&lt;a href=&quot;#Leecode-264-丑数&quot; class=&quot;headerlink&quot; title=&quot;Leecode-264-丑数&quot;&gt;&lt;/a&gt;Leecode-264-&lt;a href=&quot;https://leetcode-cn.com/problems/ugly-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;丑数&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;编写一个程序判断给定的数是否为丑数。&lt;/p&gt;
&lt;p&gt;丑数就是只包含质因数 &lt;code&gt;2, 3, 5&lt;/code&gt; 的&lt;strong&gt;正整数&lt;/strong&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 6 &amp;#x3D; 2 × 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: 8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 8 &amp;#x3D; 2 × 2 × 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: 14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 14 不是丑数，因为它包含了另外一个质因数 7。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt; 是丑数。&lt;/li&gt;
&lt;li&gt;输入不会超过 32 位有符号整数的范围: [−231, 231 − 1]。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="最小堆" scheme="http://zhuuu.work/tags/%E6%9C%80%E5%B0%8F%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-283-移动0</title>
    <link href="http://zhuuu.work/2020/06/12/Leetcode/Leetcode-283-%E7%A7%BB%E5%8A%A80/"/>
    <id>http://zhuuu.work/2020/06/12/Leetcode/Leetcode-283-%E7%A7%BB%E5%8A%A80/</id>
    <published>2020-06-12T07:32:53.000Z</published>
    <updated>2020-06-14T09:37:27.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-283-移动零"><a href="#Leecode-283-移动零" class="headerlink" title="Leecode-283-移动零"></a>Leecode-283-<a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">移动零</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p><strong>说明</strong>:</p><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ol><a id="more"></a><h2 id="方法一：两次遍历"><a href="#方法一：两次遍历" class="headerlink" title="方法一：两次遍历"></a>方法一：两次遍历</h2><ul><li>创建两个指针 i 和 j </li><li>第一次遍历指针 j 记录 当前有多少非0的元素，即遍历的时候每遇到一个非0的元素就将它向左边挪</li><li>第一次遍历完之后，j 指针就记录了最后一个非0元素的下标。</li><li>第二次遍历的时候，起始位置从 j 开始到结束，把所有剩下的元素都修改为0。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200614/172243741.gif" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两次遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一次遍历，j指针记录非0的个数</span></span><br><span class="line">        <span class="comment">// 只要是非0的统统都赋给nums[j]</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                nums[j] = nums[i];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二次遍历把末尾的元素全部赋值为0</span></span><br><span class="line">        <span class="comment">// 非0元素统计完了，剩下的都是0了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = j;i &lt; nums.length; i++)&#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//时间复杂度:O(n)</span></span><br><span class="line"><span class="comment">//空间复杂度:O(1)</span></span><br></pre></td></tr></table></figure><ul><li>时间复杂度:O(n)</li><li>空间复杂度:O(1)</li></ul><h2 id="方法二：一次遍历"><a href="#方法二：一次遍历" class="headerlink" title="方法二：一次遍历"></a>方法二：一次遍历</h2><ul><li><strong>参考快速排序的思想</strong><ul><li>首先确定一个带分割的点 x ，</li><li>然后把所有小于等于x 的都放到 x的左边，把所有大于 x 的都放到 x的右边</li><li>这里的 x 根据题目 取 0 . (把所有小于等于0的都放在0的左边，所有大于0的都放在0的右边)</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200614/173058469.gif" alt="mark"></p><ul><li>这的中间点就是<code>0</code>本身，所以实现起来比快速排序简单很多，我们使用两个指针<code>i</code>和<code>j</code>，只要<code>nums[i]!=0</code>，我们就交换<code>nums[i]</code>和<code>nums[j]</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双指针交换</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 当前元素不等于0.就把它交换到左边</span></span><br><span class="line">            <span class="comment">// 等于0就交换到右边</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = temp;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度:O(n)</li><li>空间复杂度:O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-283-移动零&quot;&gt;&lt;a href=&quot;#Leecode-283-移动零&quot; class=&quot;headerlink&quot; title=&quot;Leecode-283-移动零&quot;&gt;&lt;/a&gt;Leecode-283-&lt;a href=&quot;https://leetcode-cn.com/problems/move-zeroes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;移动零&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [0,1,0,3,12]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [1,3,12,0,0]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;必须在原数组上操作，不能拷贝额外的数组。&lt;/li&gt;
&lt;li&gt;尽量减少操作次数。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="快速排序" scheme="http://zhuuu.work/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-387-字符串中的第一个唯一字符</title>
    <link href="http://zhuuu.work/2020/06/12/Leetcode/Leetcode-387-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/"/>
    <id>http://zhuuu.work/2020/06/12/Leetcode/Leetcode-387-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/</id>
    <published>2020-06-12T06:13:53.000Z</published>
    <updated>2020-06-14T09:16:53.295Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-387-字符串中的第一个唯一字符"><a href="#Leecode-387-字符串中的第一个唯一字符" class="headerlink" title="Leecode-387-字符串中的第一个唯一字符"></a>Leecode-387-<a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">字符串中的第一个唯一字符</a></h1><h2 id="思路：哈希表"><a href="#思路：哈希表" class="headerlink" title="思路：哈希表"></a>思路：哈希表</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s &#x3D; &quot;leetcode&quot;</span><br><span class="line">返回 0</span><br><span class="line"></span><br><span class="line">s &#x3D; &quot;loveleetcode&quot;</span><br><span class="line">返回 2</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路：哈希表-1"><a href="#思路：哈希表-1" class="headerlink" title="思路：哈希表"></a>思路：哈希表</h2><ul><li>第一次遍历：遍历一遍字符串，把所有的字符串及对应的出现次数存入哈希表中。</li><li>第二次遍历：遍历一遍字符串，去哈希表中检查出现次数为1的字符在不在哈希表中，并且返回它的索引。</li></ul><p><strong>举例</strong></p><ol><li><strong>存入哈希表</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200614/171457153.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200614/171519200.png" alt="mark"></p><ol start="2"><li>返回对应第一次出现次数为1的索引</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200614/171557448.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将对应的字符存入hash表中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">                map.put(s.charAt(i),map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(s.charAt(i),<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字符串 去哈希表中查找对应元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(s.charAt(i)) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找不到返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度：O(n)  遍历两次的时间复杂度 </li><li>空间复杂度：O(n)  哈希表的额外空间</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-387-字符串中的第一个唯一字符&quot;&gt;&lt;a href=&quot;#Leecode-387-字符串中的第一个唯一字符&quot; class=&quot;headerlink&quot; title=&quot;Leecode-387-字符串中的第一个唯一字符&quot;&gt;&lt;/a&gt;Leecode-387-&lt;a href=&quot;https://leetcode-cn.com/problems/first-unique-character-in-a-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;字符串中的第一个唯一字符&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：哈希表&quot;&gt;&lt;a href=&quot;#思路：哈希表&quot; class=&quot;headerlink&quot; title=&quot;思路：哈希表&quot;&gt;&lt;/a&gt;思路：哈希表&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;s &amp;#x3D; &amp;quot;leetcode&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;返回 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s &amp;#x3D; &amp;quot;loveleetcode&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;返回 2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="哈希表" scheme="http://zhuuu.work/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-面试题09-用两个栈实现队列</title>
    <link href="http://zhuuu.work/2020/06/11/Leetcode/Leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9809-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://zhuuu.work/2020/06/11/Leetcode/Leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9809-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</id>
    <published>2020-06-11T09:52:53.000Z</published>
    <updated>2020-06-30T06:37:45.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-面试题09-用两个栈实现队列"><a href="#Leetcode-面试题09-用两个栈实现队列" class="headerlink" title="Leetcode-面试题09-用两个栈实现队列"></a>Leetcode-面试题09-用两个栈实现队列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>用两个栈实现一个队列。</p></li><li><p>队列的声明如下，请实现它的两个函数<code>appendTail</code>和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p></li></ul><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：两个栈实现队列"><a href="#方法：两个栈实现队列" class="headerlink" title="方法：两个栈实现队列"></a>方法：两个栈实现队列</h2><p><strong>遇到的问题</strong></p><ul><li><strong>栈无法实现队列的功能：</strong>栈底元素（对应队首元素）无法直接删除，需要将上方所有元素出栈</li><li><strong>双栈可以实现列表的倒序</strong>：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">设有含三个元素的栈 </span><br><span class="line">A &#x3D; [1,2,3] 和空栈 B &#x3D; []。</span><br><span class="line">若循环执行 A 元素出栈并添加入栈 B ，直到栈 A 为空，则 A &#x3D; [] , B &#x3D; [3,2,1]，即 栈 B 元素实现栈 A 元素倒序 。</span><br></pre></td></tr></table></figure><ul><li><strong>利用栈B删除队首元素：倒序后，B执行出栈就相当于删除了A的栈底元素，即对应队首元素</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200630/141348516.png" alt="mark"></p><p><strong>算法：</strong></p><ul><li>题目只要求实现 <strong>加入队尾</strong><code>appendTail()</code> 和 <strong>删除队首</strong><code>deleteHead()</code> 两个函数的正常工作<ul><li><strong>因此我们可以设计栈A用于加入队尾的操作，栈B用于将元素倒序，从而实现删除队首的元素。</strong></li><li><strong>加入队尾<code>appendTail()</code> 将数字val加入到栈<code>A</code>即可</strong></li><li><strong>删除队首<code>deleteHead()</code> 有以下三种情况</strong><ul><li>栈B不为空：说明B中有已完成倒序的元素，因此直接返回B的栈顶元素</li><li>栈B为空，A也为空：说明两个栈都为空，没有元素存在，返回-1</li><li>栈B为空，A不为空：将栈A元素全部转移至栈B。实现元素的倒序，并返回栈B的栈顶元素</li></ul></li></ul></li></ul><p>举个例子:</p><ol><li><code>appendTail()</code></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200630/142609731.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200630/142654422.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200630/142707058.png" alt="mark"></p><ol start="2"><li><code>deleteHead()</code></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200630/142731670.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200630/142740386.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200630/142749930.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200630/142758957.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200630/142807413.png" alt="mark"></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span></span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; A,B;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        A = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队操作，只需要在A栈最后添加元素即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        A.addLast(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1. 如果B不是空的，删除B的最后一个元素并返回</span></span><br><span class="line">        <span class="keyword">if</span> (!B.isEmpty()) <span class="keyword">return</span> B.removeLast();</span><br><span class="line">        <span class="comment">// 2. 如果A空了，说明还没有入队，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (A.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 3. 如果A不是空的，B不断添加A的栈顶（相当于B是A的倒序）</span></span><br><span class="line">        <span class="keyword">while</span> (!A.isEmpty())&#123;</span><br><span class="line">            B.addLast(A.removeLast());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除B的最后一个元素返回即可</span></span><br><span class="line">        <span class="keyword">return</span> B.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)  <code>appendTail()</code> 函数为O(1) ,<code>deleteHead</code> 要完成N个元素的倒序</li><li>空间复杂度 : O(n) 。 最差情况下 栈A 栈B共要保存n个元素</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-面试题09-用两个栈实现队列&quot;&gt;&lt;a href=&quot;#Leetcode-面试题09-用两个栈实现队列&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-面试题09-用两个栈实现队列&quot;&gt;&lt;/a&gt;Leetcode-面试题09-用两个栈实现队列&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;用两个栈实现一个队列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;队列的声明如下，请实现它的两个函数&lt;code&gt;appendTail&lt;/code&gt;和 &lt;code&gt;deleteHead&lt;/code&gt; ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&amp;quot;CQueue&amp;quot;,&amp;quot;appendTail&amp;quot;,&amp;quot;deleteHead&amp;quot;,&amp;quot;deleteHead&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[],[3],[],[]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[null,null,3,-1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&amp;quot;CQueue&amp;quot;,&amp;quot;deleteHead&amp;quot;,&amp;quot;appendTail&amp;quot;,&amp;quot;appendTail&amp;quot;,&amp;quot;deleteHead&amp;quot;,&amp;quot;deleteHead&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[],[],[5],[2],[],[]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[null,-1,null,null,5,2]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="栈" scheme="http://zhuuu.work/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-190-颠倒的二进制位</title>
    <link href="http://zhuuu.work/2020/06/11/Leetcode/Leetcode-190-%E9%A2%A0%E5%80%92%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/"/>
    <id>http://zhuuu.work/2020/06/11/Leetcode/Leetcode-190-%E9%A2%A0%E5%80%92%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/</id>
    <published>2020-06-11T07:32:53.000Z</published>
    <updated>2020-06-13T07:33:52.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-190-颠倒二进制位"><a href="#Leetcode-190-颠倒二进制位" class="headerlink" title="Leetcode-190-颠倒二进制位"></a>Leetcode-190-<a href="https://leetcode-cn.com/problems/reverse-bits/" target="_blank" rel="noopener">颠倒二进制位</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>颠倒给定的 32 位无符号整数的二进制位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 00000010100101000001111010011100</span><br><span class="line">输出: 00111001011110000010100101000000</span><br><span class="line">解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，</span><br><span class="line">     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：10111111111111111111111111111111</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，</span><br><span class="line">     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。</span><br></pre></td></tr></table></figure><h2 id="思路：逐位颠倒"><a href="#思路：逐位颠倒" class="headerlink" title="思路：逐位颠倒"></a>思路：逐位颠倒</h2><ul><li>在面试的时候逐位颠倒作为最直接的解决方案。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200611/153644249.png" alt="mark"></p><ul><li>对于十进制而言(反转)<ul><li>十进制：<code>ans = ans * 10 + n % 10; n = n / 10;</code></li><li>二进制：<code>ans = ans * 2 + n % 2; n = n / 2;</code></li></ul></li></ul><p><strong>但是：</strong></p><ul><li>这种写法会有整型溢出，Java的整数溢出后的二进制数会变成负数（补码的形式），Java中负数除以2会向0取整，参考：<a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html</a></li><li>所以综上所述，要使用位运算来避免溢出问题，同时循环32次。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对于十进制而言</span></span><br><span class="line"><span class="comment"> *  ans = ans * 10 + n % 10 ; n = n /10;</span></span><br><span class="line"><span class="comment"> * 对于二进制而言</span></span><br><span class="line"><span class="comment"> *  ans = ans * 2 + n % 2 ; n = n /2;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  * 对于二进制而言</span></span><br><span class="line">        <span class="comment">// *  ans = ans * 2 + n % 2 ; n = n /2;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            ans = (ans &lt;&lt; <span class="number">1</span>) + (n &amp; <span class="number">1</span>);</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200611/155935426.png" alt="mark"></p><p><strong>时间复杂度</strong>：O(logn)   这里32位所以是O(1) </p><p><strong>空间复杂度</strong>： O(1)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Leetcode-190-颠倒二进制位&quot;&gt;&lt;a href=&quot;#Leetcode-190-颠倒二进制位&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-190-颠倒二进制位&quot;&gt;&lt;/a&gt;Leetcode-190-&lt;a href=&quot;https:/
      
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="位运算" scheme="http://zhuuu.work/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="进制转换" scheme="http://zhuuu.work/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-168 &amp;&amp; 171-Excel表</title>
    <link href="http://zhuuu.work/2020/06/10/Leetcode/Leetcode-168&amp;&amp;171-Excel%E8%A1%A8/"/>
    <id>http://zhuuu.work/2020/06/10/Leetcode/Leetcode-168&amp;&amp;171-Excel%E8%A1%A8/</id>
    <published>2020-06-10T07:52:53.000Z</published>
    <updated>2020-06-11T07:29:03.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-168-amp-amp-171-Excel表"><a href="#Leetcode-168-amp-amp-171-Excel表" class="headerlink" title="Leetcode-168 &amp;&amp; 171-Excel表"></a>Leetcode-168 &amp;&amp; 171-Excel表</h1><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p>这两道题本质上就是进制转换，把10进制转换成26禁止表示。</p><p>关于进制转换：<a href="https://zhuanlan.zhihu.com/p/75006709" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/75006709</a></p><h2 id="Leetcode-168-Excel表列名称"><a href="#Leetcode-168-Excel表列名称" class="headerlink" title="Leetcode 168 Excel表列名称"></a>Leetcode 168 <a href="https://leetcode-cn.com/problems/excel-sheet-column-title/" target="_blank" rel="noopener">Excel表列名称</a></h2><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h3><p>给定一个正整数，返回它在 Excel 表中相对应的列名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; A</span><br><span class="line">2 -&gt; B</span><br><span class="line">3 -&gt; C</span><br><span class="line">...</span><br><span class="line">26 -&gt; Z</span><br><span class="line">27 -&gt; AA</span><br><span class="line">28 -&gt; AB </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: &quot;A&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 28</span><br><span class="line">输出: &quot;AB&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 701</span><br><span class="line">输出: &quot;ZY&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-进制转换"><a href="#2-进制转换" class="headerlink" title="2. 进制转换"></a>2. 进制转换</h3><p><strong>首先讨论一下10进制和16进制的转换</strong></p><ul><li>16 进制中，0 到 9 还是正常的数字，然后增加字母 A 表示 10，字母 B 表示 11… 以此类推，直到 F 表示 15，所以我们各个位的取值范围是 0 - 15 。</li><li>假如16进制的<code>A1F</code> 转换成16进制就是下边的式子</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200611/151121423.png" alt="mark"></p><ul><li>那么假如我们知道的是 <code>10</code> 进制的 <code>2591</code>，怎么转为 <code>16</code> 进制呢？<ul><li>我们把上边的等式一般化，设我们要求的每一位分别是 <code>x1,x2,x3...</code>，事先我们并不知道有多少位。</li><li><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200611/151303783.png" alt="mark"></li><li>我们可以同时在等式的两边模上<code>16</code>,等式就变成了</li><li><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200611/151458546.png" alt="mark"></li><li>这样我们就求出了<code>x1</code> ,接下来我们在等式的两边同时除以<code>16</code>。等式左边由于 <code>x1</code> 的范围是 <code>0 - 15</code>，所以在整数间运算不管 <code>x1</code> 是多少，<code>x1/16</code> 都等于 <code>0</code>，所以等式就变成了下边的样子</li><li><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200611/151621890.png" alt="mark"></li><li>接下来哦我们就可以重复上边的两个步骤，模16和除16，就可以依次算出<code>x2 , x3</code>了,直到除以16以后变成 0 就可以结束了。</li></ul></li><li>对于10 进制 转26 进制也是一样的道理，只不过我们每次都是模26和除26。 </li></ul><h3 id="3-题解"><a href="#3-题解" class="headerlink" title="3. 题解"></a>3. 题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出对应数字的序列号</span></span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 这里参考leetcode171 ，因为正着计算加一 所以这里反着需要减一</span></span><br><span class="line">            n -= <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 获得当前数字对应的字符 并加入到 StringBuffer中</span></span><br><span class="line">            sb.append((<span class="keyword">char</span>)(<span class="string">'A'</span> + (n % <span class="number">26</span>)));</span><br><span class="line">            <span class="comment">// 向下退一位</span></span><br><span class="line">            n /= <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 倒序输出字符串</span></span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上述唯一不一样的地方是：</strong></p><ul><li><strong>对于Excel来说 ， x1,x2,x3的取值范围都是0-25。 所以在除以26之前，我们需要将对应的数减去1在进行模运算。</strong></li></ul><h2 id="Leetcode-171-Excel表列序号"><a href="#Leetcode-171-Excel表列序号" class="headerlink" title="Leetcode 171 Excel表列序号"></a>Leetcode 171 <a href="https://leetcode-cn.com/problems/excel-sheet-column-number/" target="_blank" rel="noopener">Excel表列序号</a></h2><h3 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h3><p>给定一个Excel表格中的列名称，返回其相应的列序号。</p><p>例如，</p><pre><code>A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 ...</code></pre><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;A&quot;</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;AB&quot;</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;ZY&quot;</span><br><span class="line">输出: 701</span><br></pre></td></tr></table></figure><h3 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h3><ul><li><p>这里是26进制转换成10进制 （也就是需要乘上26）</p></li><li><p>以ZY为例，Z的值为26，Y的值为25，则结果为<code>26 * 26 + 25=701</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 算出当前i索引对应的字母值</span></span><br><span class="line">            <span class="keyword">int</span> num = s.charAt(i) - <span class="string">'A'</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 向前进一位</span></span><br><span class="line">            sum = sum * <span class="number">26</span> + num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>： O（n） 遍历一边字符串</li><li><strong>空间复杂度</strong>: O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-168-amp-amp-171-Excel表&quot;&gt;&lt;a href=&quot;#Leetcode-168-amp-amp-171-Excel表&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-168 &amp;amp;&amp;amp; 171-Excel表&quot;&gt;&lt;/a&gt;Leetcode-168 &amp;amp;&amp;amp; 171-Excel表&lt;/h1&gt;&lt;h2 id=&quot;进制转换&quot;&gt;&lt;a href=&quot;#进制转换&quot; class=&quot;headerlink&quot; title=&quot;进制转换&quot;&gt;&lt;/a&gt;进制转换&lt;/h2&gt;&lt;p&gt;这两道题本质上就是进制转换，把10进制转换成26禁止表示。&lt;/p&gt;
&lt;p&gt;关于进制转换：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/75006709&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/75006709&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-168-Excel表列名称&quot;&gt;&lt;a href=&quot;#Leetcode-168-Excel表列名称&quot; class=&quot;headerlink&quot; title=&quot;Leetcode 168 Excel表列名称&quot;&gt;&lt;/a&gt;Leetcode 168 &lt;a href=&quot;https://leetcode-cn.com/problems/excel-sheet-column-title/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Excel表列名称&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1. 题目描述&quot;&gt;&lt;/a&gt;1. 题目描述&lt;/h3&gt;&lt;p&gt;给定一个正整数，返回它在 Excel 表中相对应的列名称。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1 -&amp;gt; A&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2 -&amp;gt; B&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3 -&amp;gt; C&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26 -&amp;gt; Z&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27 -&amp;gt; AA&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28 -&amp;gt; AB &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;A&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;AB&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 701&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;ZY&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="进制转换" scheme="http://zhuuu.work/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-191-位1的个数</title>
    <link href="http://zhuuu.work/2020/06/10/Leetcode/Leetcode-191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://zhuuu.work/2020/06/10/Leetcode/Leetcode-191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</id>
    <published>2020-06-10T03:00:53.000Z</published>
    <updated>2020-06-10T03:06:33.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-191-Number-of-1-Bits"><a href="#Leetcode-191-Number-of-1-Bits" class="headerlink" title="Leetcode-191-Number of 1 Bits"></a>Leetcode-191-<a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">Number of 1 Bits</a></h1><h2 id="思路：位运算"><a href="#思路：位运算" class="headerlink" title="思路：位运算"></a>思路：位运算</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a href="https://baike.baidu.com/item/汉明重量" target="_blank" rel="noopener">汉明重量</a>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br><span class="line"></span><br><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span><br><span class="line"></span><br><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：-按位与1"><a href="#方法：-按位与1" class="headerlink" title="方法： 按位与1"></a>方法： 按位与1</h2><ul><li>这个方法比较直接。我们遍历数字的 32 位。如果某一位是 1 ，将计数器加一。</li><li><strong>重点：任何数字跟掩码1进行逻辑与运算，都可以让我们获得这个数字的最低位。当检查下一位时候，我们将掩码左移一位</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line"><span class="comment"># 左移一位</span></span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0010</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查二进制每一位1的个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化掩码是1</span></span><br><span class="line">        <span class="keyword">int</span> bitmask = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; bitmask) != <span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每次掩码向左移动一位</span></span><br><span class="line">            bitmask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(1) 。 因为本题最大数字长度是32位，所以运行时间是O(1)的。</li><li>空间复杂度：O(1)  没有使用额外的空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-191-Number-of-1-Bits&quot;&gt;&lt;a href=&quot;#Leetcode-191-Number-of-1-Bits&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-191-Number of 1 Bits&quot;&gt;&lt;/a&gt;Leetcode-191-&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-1-bits/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Number of 1 Bits&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：位运算&quot;&gt;&lt;a href=&quot;#思路：位运算&quot; class=&quot;headerlink&quot; title=&quot;思路：位运算&quot;&gt;&lt;/a&gt;思路：位运算&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为&lt;a href=&quot;https://baike.baidu.com/item/汉明重量&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;汉明重量&lt;/a&gt;）。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：00000000000000000000000000001011&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &amp;#39;1&amp;#39;。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：00000000000000000000000010000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &amp;#39;1&amp;#39;。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：11111111111111111111111111111101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &amp;#39;1&amp;#39;。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="位运算" scheme="http://zhuuu.work/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://zhuuu.work/2020/06/09/GoF23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zhuuu.work/2020/06/09/GoF23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-09T11:02:24.000Z</published>
    <updated>2020-07-03T01:26:23.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200610/221023280.png" alt="mark"></p><ul><li>设计模式是解决问题的方案，学习现有的设计模式可以做到经验的复用</li><li>拥有设计模式的词汇，在沟通是就能用到更少的词汇来讨论，并且不需要知道底层的细节</li></ul><p><strong>话在前头：</strong></p><ol><li>什么是好的设计模式？</li></ol><ul><li>提高复用</li><li>应对变化</li></ul><ol start="2"><li>在什么时候，什么地方使用设计模式？</li></ol><ul><li><p><strong>在需求频繁变化的变化点使用设计模式</strong></p></li><li><p><strong>Refactoring to Patterns(重构的方式一步一步到模式)</strong></p></li></ul><p>重构的关键方法：</p><ol><li>静态 -&gt; 动态</li><li>早绑定 -&gt; 晚绑定</li><li>继承 -&gt; 组合</li><li>编译时依赖 -&gt; 运行时依赖</li><li>紧耦合 -&gt; 松耦合</li></ol><a id="more"></a><h3 id="1-设计原则"><a href="#1-设计原则" class="headerlink" title="1. 设计原则"></a>1. 设计原则</h3><h4 id="1-1-依赖倒置原则-DIP"><a href="#1-1-依赖倒置原则-DIP" class="headerlink" title="1.1 依赖倒置原则(DIP)"></a>1.1 依赖倒置原则(DIP)</h4><ul><li><p>Dependence Inversion Principle，缩写DIP</p></li><li><p>高层次的模块不依赖于低层次模块的实现细节</p><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象</li><li>细节应该依赖抽象</li><li>抽象不应该依赖细节</li></ul></li></ul><p>是不是觉得和没说一个样，至少我是这么觉得的；继续往后看才明白，</p><ul><li>所谓高层模块就是调用端</li><li>低层模块就是具体的实现类</li><li><strong>依赖倒置原则在java中的表现就是：模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系</strong><ul><li><strong>也就是通过接口或者抽象类产生依赖关系（调用关系）</strong></li><li><strong>也就是面向接口编程或者说面向抽象编程</strong></li></ul></li></ul><p>其实依赖倒置原则主要目的就是解耦</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200614/211520692.png" alt="mark"></p><p>可以使用这张图来表示，表达出来就是<code>ImageLoader</code>和<code>MemonyCache</code>等并没有直接关系，甚至<code>ImageLoader</code>只需要实现<code>ImageCache</code>类或继承其他已有的<code>ImageCache</code>子类完成相应的缓存功能，然后将具体的实现注入到<code>ImageLoader</code>即可实现缓存功能的替换。这也是依赖倒置原则的体现。</p><h4 id="1-2-开闭原则（OCP）"><a href="#1-2-开闭原则（OCP）" class="headerlink" title="1.2 开闭原则（OCP）"></a>1.2 开闭原则（OCP）</h4><ul><li><p>Open Close Principle，缩写OCP</p></li><li><p>定义：软件中得对象应该对于扩展是开放的，但是对于修改是封闭的。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200614/211520692.png" alt="mark"></p><p><strong>简单地说，当软件需要变化时，应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。</strong></p><p>“应该尽量”4个字说明OCP原则并不是说绝对不可以修改原始类的，当代码需要需要重构的时候要及时重构，使代码恢复正常，而不是通过继承等方式添加新的实现，这会导致类型的膨胀以及历史遗留代码的冗余。</p><h4 id="1-3-单一职责原则（SRP）"><a href="#1-3-单一职责原则（SRP）" class="headerlink" title="1.3 单一职责原则（SRP）"></a>1.3 单一职责原则（SRP）</h4><ul><li>单一职责原则，就一个类而言，应该只有一个引起它变化的原因。</li><li>简单说，<strong>一个类</strong>应该是一组<strong>高度相关的函数</strong>、数据的封装；也就是高内聚。</li><li>Single Responsibility Principle，缩写SRP</li></ul><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span></span>&#123;</span><br><span class="line">    <span class="comment">//图片缓存</span></span><br><span class="line">    LruCache&lt;String,Bitmap&gt; mImageCache;</span><br><span class="line">    <span class="comment">//线程池，线程数量为CPU的数量</span></span><br><span class="line">    ExecutorService mExecutorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProessors());</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageLoader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        initImageCache();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initImageCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略...         </span></span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//显示图片</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(<span class="keyword">final</span> String url, <span class="keyword">final</span> ImageView imageView)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略... </span></span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//下载图片</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  Bitmap <span class="title">downloadImage</span><span class="params">(String imageUrl)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略... </span></span><br><span class="line">        <span class="keyword">return</span> bitmap;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看出来 <code>ImageLoader</code> 类作用有初始化图片缓存、显示图片、下载图片，显然显示图片和下载图片两个方法与初始化图片缓存方法相比作用就显得有些不相关。(也就是不符合单一职责原则)。</p><p>按照逻辑进行拆分后得到<code>ImageLoader</code>和<code>ImageCache</code>两个类。</p><ul><li><code>ImageLoader</code>负责图片加载逻辑</li><li><code>ImageCache</code>负责处理图片缓存逻辑</li><li>这样职责就很清楚了，当与缓存相关的逻辑需要改变时，不需要修改<code>ImageLoader</code>类，而图片加载的逻辑需要修改时也不会影响到缓存处理逻辑。</li></ul><p>修改后代码如下所示：</p><ul><li>添加的<code>ImageCache</code>类用于处理图片缓存，具体代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 图片LRU缓存</span></span><br><span class="line">    LruCache&lt;String, Bitmap&gt; mImageCache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initImageCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initImageCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略... </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">        mImageCache.put(url, bitmap) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mImageCache.get(url) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>ImageLoader</code>代码修改如下所示：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 图片加载类 */</span></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">//图片缓存</span></span><br><span class="line">    ImageCache mImageCache = <span class="keyword">new</span> ImageCache() ;</span><br><span class="line">    <span class="comment">//线程池,线程数量为CPU的数量</span></span><br><span class="line">    ExecutorService mExecutorService = Executors.newFixedThreadPool (Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载图片</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(<span class="keyword">final</span> String url, <span class="keyword">final</span> ImageView imageView)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略... </span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Bitmap <span class="title">downloadImage</span><span class="params">(String imageUrl)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略... </span></span><br><span class="line">        <span class="keyword">return</span> bitmap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-里氏替换原则-LSP"><a href="#1-4-里氏替换原则-LSP" class="headerlink" title="1.4 里氏替换原则 (LSP)"></a>1.4 里氏替换原则 (LSP)</h4><ul><li>Liskov Substitution Principle</li><li>里氏替换原则，书上原话的定义简直看不得（解释的辣眼睛，完全看不懂），简单的来说就是所有引用基类的地方必须能透明的时候其子类的对现象。只要父类能出现的地方子类就能出现，而且替换成子类也不会产生任何的错误和异常。使用者可能根本就不需要知道是父类还是子类。</li><li>但是，反过来就不行了，有子类出现的地方，父类未必就能适应。其实就是：抽象。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200615/145239391.png" alt="mark"></p><ul><li>上图可以看出，<code>Window</code>依赖于<code>View</code>，而<code>Button</code>和<code>TextView</code>继承<code>View</code>。这里任何继承自<code>View</code>类的子类都可以设置给<code>show()</code>方法，也就是<strong>里氏替换原则</strong>。</li><li>通过里氏替换，就可以自定义各式各样的View，然后传递给Window，并且将View显示到屏幕上。</li></ul><p><strong>里氏替换原则的核心原理是抽象，抽象又依赖于继承这个特性，继承的优缺点都相当明显</strong></p><p>优点：</p><ul><li>代码重用，减少创建类的成本，每个子类都拥有父类的方法和属性</li><li>子类与父类基本相似，但又与父类有所区别</li><li>提高代码的可扩展性</li></ul><p>缺点：</p><ul><li>继承是侵入性的，只要继承就必须拥有父类的所有属性和方法</li><li>可能造成子类代码冗余、灵活性降低，因为子类必须拥有父类的属性和方法</li></ul><p>事物总是具有两面性，如何权衡利与弊都是需要根据具体场景来做出选择并加以处理。</p><h4 id="1-5-接口隔离原则（ISP）"><a href="#1-5-接口隔离原则（ISP）" class="headerlink" title="1.5 接口隔离原则（ISP）"></a>1.5 接口隔离原则（ISP）</h4><ul><li><p>Interface Segregation Principle</p></li><li><p>接口隔离原则将非常庞大、臃肿的接口拆分成为更小的和更具体的接口；目的就是解耦。</p></li><li><p>这个原则的做法和单一职责有点相似，就是说接口中的方法保持更高的相关性，尽量少，避免调不需要的方法。</p></li><li><p><strong>java中类尽量不使用public</strong></p></li></ul><h4 id="1-6-迪米特法则（LOP）"><a href="#1-6-迪米特法则（LOP）" class="headerlink" title="1.6 迪米特法则（LOP）"></a>1.6 迪米特法则（LOP）</h4><ul><li><p>Law of Principle</p></li><li><p>迪米特法则还有一个英文解释是：Only talk to your immedate friends，翻译过来就是：只与直接的朋友通信。（什么叫做直接的朋友，每个对象都必然会与其他对象有耦合关系，两个对象之间的耦合就成为朋友关系，这种关系类型有很多，例如：组合，聚合，依赖等）</p></li><li><p>迪米特原则也称为最少知识原则（Least Knowledge Principle），定义：一个对象应该对其他对象有最少的了解。通俗地讲，一个类要对自己需要调用的类知道得最少，类的内部如何实现、如何复杂都与调用者（或依赖者）没关系，调用者（或依赖者）只需要知道他需要的方法即可，其他的不需要关心。</p></li><li><p>类与类之间的关系越密切，耦合度越大；当一个类发生改变时，对另一个类的影响也越大。</p></li></ul><h2 id="一-创建型"><a href="#一-创建型" class="headerlink" title="一 . 创建型"></a>一 . 创建型</h2><h3 id="1-原型模式（Prototype）"><a href="#1-原型模式（Prototype）" class="headerlink" title="1. 原型模式（Prototype）"></a>1. 原型模式（Prototype）</h3><ul><li><p>使用原型实例指定要创建对象的类型，通过<strong>复制这个原型来创建新对象。</strong></p></li><li><p>简单来说，其实就是当需要创建一个指定对象的时候，我们刚好有这样一个对象，但是又不能直接使用这个对象，那么我就会<strong>clone</strong> 一个一模一样的对象，基本上这就是原型模型</p></li><li><p><strong>关键字： clone</strong></p></li></ul><p>这些场景可能派的上用场</p><ul><li>当new一个对象时，非常繁琐复杂时，可以使用原型模式来进行复制一个对象。即使需求的变更，这些对象需要作出调整，我们依然拥有比较稳定一致的接口创建对象。</li><li>需要提供数据对象，同时有需要避免外部对数据对象进行修改。</li></ul><p><strong>简单的UML类图</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200610/221312940.webp" alt="mark"></p><p><strong>角色：</strong></p><ul><li><code>client</code> ： 使用者</li><li><code>Prototype</code> : 接口（抽象类），声明具备clone 能力，例如Java中的<code>Cloneable</code> 接口</li><li><code>ConcretePrototype</code>： 具体的原型类</li></ul><p><strong>关于浅拷贝和深拷贝：</strong></p><ul><li><strong>浅拷贝</strong>：一个对象通过赋值的形式直接传递的其实是对象在内存中的内存地址</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; a = <span class="keyword">new</span> ArrayList();</span><br><span class="line">ArrayList&lt;String&gt; b = a;</span><br><span class="line"><span class="comment">//当修改a时，b的值同样会被修改</span></span><br></pre></td></tr></table></figure><p>以上的代码就是浅拷贝，从某种角度来说，<strong>这种浅拷贝的方式并不合适在原型模式中使用，更多情况下我们需要一个不会影响原始对象的一个新对象，也就需要使用到深拷贝</strong></p><ul><li><strong>深拷贝</strong>：一个不会影响原始对象的一个新对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; a = <span class="keyword">new</span> ArrayList();</span><br><span class="line">ArrayList&lt;String&gt; b = a.clone();</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">ArrayList&lt;String&gt; c = <span class="keyword">new</span> ArrayList(a);</span><br></pre></td></tr></table></figure><p>上面代码的</p><p><strong>第一种方式</strong>，是使用<code>Object</code> 类的<code>super.clone()</code>方法来使用实现拷贝的过程。</p><p><strong>第二种方式</strong>：使用a在创建了一个新的对象并且赋值给c ， 这样a和 c是两个值相同的两个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ArrayList的clone()方法代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：通过实现<code>Cloneable</code>接口的原型模式在调用<code>clone()</code> 方法构造实例并不一定比new操作速度快，只有new 对象操作复杂且耗时成本较高的时候，clone方法才有效率上的提升。</p><p><strong>简单实现</strong></p><ol><li>Prototype</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Prototype <span class="title">myclone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>ConcretePrototype</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype</span> <span class="keyword">extends</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String filed;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcretePrototype</span><span class="params">(String filed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filed = filed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">Prototype <span class="title">myclone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcretePrototype(filed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ConcretePrototype&#123;"</span> +</span><br><span class="line">                <span class="string">"filed='"</span> + filed + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Client</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Prototype prototype = <span class="keyword">new</span> ConcretePrototype(<span class="string">"abc"</span>);</span><br><span class="line">        Prototype clone = prototype.myclone();</span><br><span class="line">        System.out.println(clone.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK</strong></p><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone%28%29" target="_blank" rel="noopener">java.lang.Object#clone()</a></li></ul><h3 id="2-生成器（Builder）"><a href="#2-生成器（Builder）" class="headerlink" title="2. 生成器（Builder）"></a>2. 生成器（Builder）</h3><ul><li>封装一个对象的构造过程，并允许按照步骤构造。</li><li>Builder 模式也就是<strong>建造者模式</strong>，先说定义，<strong>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</strong><ul><li>首先，将复杂对象的创建过程和部件分离出来，其实就是把创建过程和自身的部件解耦，使得构建过程和部件都可以自由扩展，两者之间的耦合度降到最低。</li><li>然后，再是相同的构建过程可以创建不同的表示，相同的组合也可以通过不同的部件创建出不同的对象。</li></ul></li></ul><p><strong>可能使用的场景</strong></p><ul><li>相同的方法，不同的执行顺序，产生不同的结果</li><li>多个部件（代码中就对应类的属性），都可以装配到同一个对象中，但是产生的结果又不相同的时候</li><li>初始化一个对象特别复杂，参数多且很多参数都有默认值的时候。</li></ul><p><strong>实现</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200611/114543747.webp" alt="mark"></p><ul><li>Product  : 抽象的产品类。</li><li>Builder : 抽象的Builder 类，规范产品的组件。</li><li>ConcreteBuilder  :  具体的Builder类，实现具体的组件过程。</li><li>Director : 统一组装的过程。</li></ul><ol><li>手机配置简化的抽象类，设置CPU、OS以、内存大小以及运存大小</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 这是一个手机配置简化的抽象类，</span></span><br><span class="line"><span class="comment">// 设置CPU、OS以、内存大小以及运存大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String mCPU;</span><br><span class="line">    <span class="keyword">protected</span> String mOS;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> mMemorySize;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> mStorageSize;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setmCPU</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setmOS</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmMemorySize</span><span class="params">(<span class="keyword">int</span> mMemorySize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mMemorySize = mMemorySize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmStorageSize</span><span class="params">(<span class="keyword">int</span> mStorageSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mStorageSize = mStorageSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Phone&#123;"</span> +</span><br><span class="line">                <span class="string">"mCPU='"</span> + mCPU + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", mOS='"</span> + mOS + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", mMemorySize="</span> + mMemorySize +</span><br><span class="line">                <span class="string">", mStorageSize="</span> + mStorageSize +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>具体的IPhoneX的类，由于CPU和系统是固定，而内存和运存运存可选。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体的IPhoneX的类，</span></span><br><span class="line"><span class="comment">// 由于CPU和系统是固定，而内存和运存运存可选。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPhoneX</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IPhoneX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmCPU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mCPU = <span class="string">"A11"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmOS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mOS = <span class="string">"iOS 11"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>抽象的Builder类，作为主要隔离作用的类，<strong>Phone的API每一个方法都有对应的builder方法，并且都返回自身来实现链式API</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象的Builder类，作为主要隔离作用的类，</span></span><br><span class="line"><span class="comment">// Phone的API的每一个方法都有对应的build方法，并都返回自身来实现链式API。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置CPU</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Builder <span class="title">buildCPU</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//设置系统</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Builder <span class="title">buildOS</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//设置运存大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Builder <span class="title">buildMemorySize</span><span class="params">(<span class="keyword">int</span> memorySize)</span></span>;</span><br><span class="line">    <span class="comment">//设置储存大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Builder <span class="title">buildStorageSize</span><span class="params">(<span class="keyword">int</span> storageSize)</span></span>;</span><br><span class="line">    <span class="comment">//创建一个Phone对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Phone <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><code>IPhoneXBuilder</code>，具体的<code>Builder</code>类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IPhoneXBuilder，具体的Builder类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPhoneXBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IPhoneX mIPhoneX = <span class="keyword">new</span> IPhoneX();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">buildCPU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mIPhoneX.setmCPU();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">buildOS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mIPhoneX.setmOS();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">buildMemorySize</span><span class="params">(<span class="keyword">int</span> memorySize)</span> </span>&#123;</span><br><span class="line">        mIPhoneX.setmMemorySize(memorySize);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">buildStorageSize</span><span class="params">(<span class="keyword">int</span> storageSize)</span> </span>&#123;</span><br><span class="line">        mIPhoneX.setmStorageSize(storageSize);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意一定要返回一个具体的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mIPhoneX;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>Director：负责指挥phone的建造顺序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Director类，负责构造Phone</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Builder mBuilder = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder Builder)</span> </span>&#123;</span><br><span class="line">        mBuilder = Builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(<span class="keyword">int</span> memorySize,<span class="keyword">int</span> StorageSize)</span></span>&#123;</span><br><span class="line">        mBuilder.buildCPU().</span><br><span class="line">                buildOS().</span><br><span class="line">                buildMemorySize(memorySize).</span><br><span class="line">                buildStorageSize(StorageSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>客户端测试：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Builder builder = <span class="keyword">new</span> IPhoneXBuilder();</span><br><span class="line"></span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line"></span><br><span class="line">        director.construct(<span class="number">6</span>,<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(builder.create().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>再来一个JDK中简易的实现 (StringBuilder)</strong></p><ol><li><code>AbstractStringBuilder</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractStringBuilder</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(count + <span class="number">1</span>);</span><br><span class="line">        value[count++] = c;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>)</span><br><span class="line">            expandCapacity(minimumCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">expandCapacity</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = value.length * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minimumCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minimumCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minimumCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">            newCapacity = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        value = Arrays.copyOf(value, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>StringBuilder</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilder</span> <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create a copy, don't share the array</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Client:测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            sb.append((<span class="keyword">char</span>) (<span class="string">'a'</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb.toString());  <span class="comment">// abcdefghijklmnopqrstuvwxyz</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK中Builder模式的具体实现</strong></p><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" target="_blank" rel="noopener">java.lang.StringBuilder</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html#put-byte-" target="_blank" rel="noopener">java.nio.ByteBuffer</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#append-boolean-" target="_blank" rel="noopener">java.lang.StringBuffer</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Appendable.html" target="_blank" rel="noopener">java.lang.Appendable</a></li><li><a href="https://github.com/apache/camel/tree/0e195428ee04531be27a0b659005e3aa8d159d23/camel-core/src/main/java/org/apache/camel/builder" target="_blank" rel="noopener">Apache Camel builders</a></li></ul><h3 id="3-工厂模式（Factory）"><a href="#3-工厂模式（Factory）" class="headerlink" title="3. 工厂模式（Factory）"></a>3. 工厂模式（Factory）</h3><ul><li>顾名思义，工厂模式就是生产产品的！</li><li>工厂模式(Factory Pattern) 提供了一种<strong>创建对象的最佳方式，属于创建型模式。</strong></li><li>在工厂模式中，创建对象时不会对客户端暴露创建逻辑，并且是通过一个共同的接口来指定新创建的对象。<strong>（绕开了new）</strong></li></ul><p><strong>大致描述：</strong></p><ul><li>将上述思想对应到code中，工厂模式需要做的就是帮助我们构建对象，因为构建对象的过程可能比较复杂，我们无法掌握（例如：无法直接new 出来）。这是对工厂模式的一个大致描述，接下来可以从实现方式来说明。</li></ul><h4 id="3-1-简单工厂模式（Simple-Factory）"><a href="#3-1-简单工厂模式（Simple-Factory）" class="headerlink" title="3.1 简单工厂模式（Simple Factory）"></a>3.1 简单工厂模式（Simple Factory）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单工厂模式的大致模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 商品A</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductA</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 商品B</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductB</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 商品C</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductC</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先，简单工厂模式并没有被归纳到23中GOF设计模式中，其实可以理解为工厂模式的简单使用。</li><li><strong>一个工厂对象决定创建出哪一种类产品</strong>，而产品有不同的系列相互之间有些许差异。举个生产鞋的例子，先看UML图</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200613/092602806.webp" alt="mark"></p><p>大致可以分为三部分：工厂类，抽象产品类，具体的产品类</p><ul><li>Factory : 工厂类，生产shoe</li><li>Shoe : 抽象的产品类</li><li>SportShoe : 具体的产品，运动鞋</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 鞋的抽象类 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shoe</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 运动鞋 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SportShoe</span> <span class="keyword">extends</span> <span class="title">Shoe</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 工厂类 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoeFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shoe <span class="title">produceShoe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SportShoe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是最简单的工厂，但是一个只生产运动鞋的工厂，老板想去赚更多的钱，要求添加生成<code>HighHeeledShoe</code>(高跟鞋)。我们需要对<code>ShoeFactory</code>的设计进行修改，如图：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200613/092542993.webp" alt="mark"></p><p>改造后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在produceShoe()的函数中添加了type参数，</span></span><br><span class="line"><span class="comment">// 表示Shoe的不同类型，以此来生产不同的鞋子。我们开始改造ShoeFactory类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 高跟鞋 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighHeeledShoe</span> <span class="keyword">extends</span> <span class="title">Shoe</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 修改后的工厂类 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoeFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shoe <span class="title">produceShoe</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"sport"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SportShoe();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"highHeeled"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> HighHeeledShoe();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Shoe();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们可以根据给定的不同类型生产对应鞋子了。这里看到代码可能会有两个问题</p><ul><li>第一：每次添加一个品牌需要加一个case(虽然现实中是很正常的逻辑。但是在代码层面并不优雅)。同时，<strong>简单工厂模式违反了开闭原则，即对扩展开放，对修改关闭；因为增加了具体产品，就需要修改对应工厂类代码；</strong></li><li>第二：调用<code>produceShoe（）</code>的时候，我们还需要去创建一个Factory对象并进行控制管理<ul><li><strong>直接new出<code>Factory</code>的对象</strong>（如<code>return new SportShoe();</code>），我们就必须自己控制工厂类的构造和生成，同时我们也需要非常清楚工厂的构造函数（比如构造函数有多少个参数，输入参数时有什么条件等等），还需要知道工厂的内部细节，一旦工厂扩展或者改变了，就很可能不知道怎么调用了，对于调用者来说无疑会是噩梦。</li></ul></li></ul><p><strong>优化问题：</strong></p><ul><li>先优化第一个问题：从技术的层面我们不使用<code>swith case</code> 这种形式来实现不同类型的对象创建，我们<strong>使用反射就可以实现优化（编译期到运行期）</strong></li><li>对于第二个问题：最直接的解决方案就是我们直接调用生产鞋子的方法，直接告诉工厂再由工厂生产，这样我们就不需要创建工厂。（那就是给<code>produceShoe()</code>函数添加<code>static</code>关键字就可以解决问题了）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 优化后的工厂类 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoeFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据类型生产鞋子</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cls</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Shoe <span class="title">produceShoe</span><span class="params">(Class&lt;? extends Shoe&gt; cls)</span></span>&#123;</span><br><span class="line">        Shoe shoe = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            shoe = (Shoe) Class.forName(cls.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shoe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这样一来问题就解决了</strong></p><ul><li>用静态方法则完全不用关心如何构造对象，我们需要关心工厂的构造细节，即使工厂内部发生变化也不需要关心</li><li>简单工厂模式主要适用于创建抽象子类的业务相同但具体实现不同的对象的情况。</li></ul><h4 id="3-2-工厂方法模式"><a href="#3-2-工厂方法模式" class="headerlink" title="3.2 工厂方法模式"></a>3.2 工厂方法模式</h4><ul><li>实际上，制造鞋子的厂商一定不会只有一家，肯定存在多家竞争的关系，所以有更多的制造不同鞋子的工厂，<code>produceShoe</code>函数就可以抽象出来，不同的<code>Factory</code>子类根据自己的需求去实现。</li><li>例如下图的<code>NikeFactory</code>和<code>DaphneFactory</code>类</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200613/112053054.webp" alt="mark"></p><ul><li>相对于简单工厂，<strong>工厂方法的区别就在于工厂类分类抽象工厂和具体的实现工厂类。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 抽象工厂类 */</span></span><br><span class="line">pulibc <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Shoe <span class="title">produceShoe</span><span class="params">(String type)</span>；</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/** Nike工厂类 */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class NikeFactory extends Factory </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shoe <span class="title">produceShoe</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"sport"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SportShoe();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"highHeeled"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> HighHeeledShoe();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Shoe();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Daphne工厂类 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaphneFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shoe <span class="title">produceShoe</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"sport"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SportShoe();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"highHeeled"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> HighHeeledShoe();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Shoe();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候就很简单了，只需要调用对应的工厂，选择客户需要的类型就可以获得相应的产品了，这样不同的制造商就能分别生产不同的鞋子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Factory daphneFactory = <span class="keyword">new</span> DaphneFactory();</span><br><span class="line">daphneFactory.produceShoe(<span class="string">"highHeeled"</span>);</span><br><span class="line"></span><br><span class="line">Factory nikeFactory = <span class="keyword">new</span> NikeFactory();</span><br><span class="line">nikeFactory.produceShoe(<span class="string">"sport"</span>);</span><br></pre></td></tr></table></figure><p>在工厂的环节采用抽象类的形式实现，其实也可以将<code>produceShoe</code>抽象成<code>IProduceShoe</code>接口，当然，这也是我的个人理解。其实觉得抽象类或者接口使用其中一个就可以了，不必要同时使用；但也不是绝对的，这个需要根据具体的情况而定。</p><p><strong>对应JDK中：</strong></p><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html#getInstance--" target="_blank" rel="noopener">java.util.Calendar</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html#getBundle-java.lang.String-" target="_blank" rel="noopener">java.util.ResourceBundle</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/text/NumberFormat.html#getInstance--" target="_blank" rel="noopener">java.text.NumberFormat</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html#forName-java.lang.String-" target="_blank" rel="noopener">java.nio.charset.Charset</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/net/URLStreamHandlerFactory.html#createURLStreamHandler-java.lang.String-" target="_blank" rel="noopener">java.net.URLStreamHandlerFactory</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/EnumSet.html#of-E-" target="_blank" rel="noopener">java.util.EnumSet</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/JAXBContext.html#createMarshaller--" target="_blank" rel="noopener">javax.xml.bind.JAXBContext</a></li></ul><p><strong>通用形式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product product = factoryMethod();</span><br><span class="line">        <span class="comment">// do something with the product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-抽象工厂模式（Abstract-Factory）"><a href="#3-3-抽象工厂模式（Abstract-Factory）" class="headerlink" title="3.3 抽象工厂模式（Abstract Factory）"></a>3.3 抽象工厂模式（Abstract Factory）</h4><ul><li>生产鞋子的厂商不一定只会生产衣服<code>cloth</code>,我们需要为了工厂添加制造衣服的这条生产线。为了工厂添加生产衣服后的UML图如下：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200613/113418278.webp" alt="mark"></p><ul><li><p><strong>将<code>ShoeFactory</code>和<code>ClothFactory</code>抽象成接口（原因：Java无法多继承，所以使用Interface）</strong></p></li><li><p>需要对应的产品就要实现工厂对应的接口。</p></li><li><p>添加<code>NikeFactory</code>中的生产衣服的功能<code>produceCloth</code>,这样也就是实现<code>NikeFactory</code>可以生产多种产品。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NikeFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shoe <span class="title">produceShoe</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"sport"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SportShoe();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"highHeeled"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> HighHeeledShoe();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Shoe();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//新增方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cloth <span class="title">produceCloth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"sport"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SportCloth();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"skirt"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Skirt();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Shoe();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>当你需要创建一些对象家族时候，抽象工厂也是不错的选择，因为它可以一次性创建多个对象。</strong></p></li><li><p>抽象工厂十分强大灵活（至少比前两种都要好），可以用<strong>多个抽象子类完成复杂的需求</strong>，同时保证了外界接触不到任何类型的具体产品类型，某种意思上很符合开闭原则 。</p></li><li><p>当然，缺点也显而易见，模式比较庞大，从UML图就能看出来。</p></li></ul><h4 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4 小结"></a>3.4 小结</h4><ul><li>简单工厂<strong>只能有一个工厂生产相同类型的产品</strong></li><li>工厂方法模式<strong>只能生产一系列的产品，可以同时有不同的工厂去实现。</strong></li><li>抽象工厂模式通过<strong>实现不同的抽象方法可以生产出多个系列的产品。</strong></li></ul><h3 id="4-单例模式"><a href="#4-单例模式" class="headerlink" title="4. 单例模式"></a>4. 单例模式</h3><ul><li>单例模式是应用最广泛的模式之一，定义就是<strong>单例对象的类必须保证只有一个实例存在</strong></li><li>单例模式适用于创建一个对象需要消耗过多资源的情况，例如数据库等资源是需要考虑使用的。</li></ul><p>实现单例模式关键点如下：</p><ul><li><strong>构造函数私有化（不会让你有机会再创建一个对象）</strong></li><li><strong>通过一个静态方法或枚举（后面会有举例）返回单例类对象</strong></li><li>确保单例类的对象有且只有一个,尤其是多线程的环境下(难点)</li><li>确保单例类的对象在反序列化的时候不会重新构建对象</li></ul><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200313101430.png" alt=""></p><h4 id="4-1-饿汉式-线程安全"><a href="#4-1-饿汉式-线程安全" class="headerlink" title="4.1 饿汉式-线程安全"></a>4.1 饿汉式-线程安全</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明对象的时候就 已经初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 共有静态方法，对外暴露获取的途径(Getter方法)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-懒汉式-线程不安全"><a href="#4-2-懒汉式-线程不安全" class="headerlink" title="4.2 懒汉式-线程不安全"></a>4.2 懒汉式-线程不安全</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 懒汉式实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明对象的时候不进行初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter方法加锁保证线程安全</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 进入是检查有没有被创建</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>懒汉式与饿汉式不同的地方是单例对象初始化的时机,实现了懒加载</li><li>同时<code>getInstance()</code>方法前添加了<code>synchronized</code>关键字,以此来确保多线程环境下单例模式的唯一性.(相对的,每次调用<code>getInstance()</code>方法都是会进行同步的,也是懒汉式最大的问题)</li></ul><h4 id="4-3-懒汉式-DCL-线程不安全"><a href="#4-3-懒汉式-DCL-线程不安全" class="headerlink" title="4.3 懒汉式(DCL)-线程不安全"></a>4.3 懒汉式(DCL)-线程不安全</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. DCL</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明对象的时候不进行初始化</span></span><br><span class="line">    <span class="comment">// volatile作用：避免指令的重排，保证原子性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双重检测锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance)&#123;</span><br><span class="line">                     instance = <span class="keyword">new</span> Singleton();  <span class="comment">// 造成问题的关键</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回对象实例</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以看到<code>getInstance()</code>方法对instance进行了两次判空,</p><ul><li>第一次判断是为了判断不必要的同步</li><li>第二次是为了判断null的情况下创建实例</li></ul></li><li><p>同时<code>instance</code>对象前面还添加了 <code>volatile</code>关键字,如果不使用<code>volatile</code>是无法保证<code>instance</code>的原子性的</p><ul><li><code>instance = new Singleton();</code>这句代码不是一个原子性操作</li><li><strong>这句代码最终会被编译成多条汇编指令，大致做了3件事：</strong></li><li><ol><li><strong>给Singleton的实例分配内存空间</strong></li><li><strong>调用<code>Singleton()</code>的构造函数,初始化成员字段</strong></li><li><strong>指向分配的内存空间(此时<code>instance</code>不为null)**</strong></li></ol></li></ul></li><li><p>由于JMM允许指令重排来保证代码效率,所以上述第二点和第三点的顺序无法保证,也就是说执行顺序可能是1-2-3或者是1-3-2。</p><ul><li>如果是1-3-2, instance 在 3 步骤的时候就已经是非空了,所以2步骤没有执行,那么另外一个线程会取走一个还没初始化完毕的实例,导致DCL失效</li><li>在JDK1.5之后，调整了JVM，具体化了<code>volatile</code>关键字。然，<code>volatile</code>或多或少会影响到性能，考虑到正确性这点性能的牺牲还是值得的。</li></ul></li><li><p><strong>DCL模式能够在绝大多数场景下保证单例对象的唯一性，资源利用率高，只有第一次加载时反应稍慢，一般能够满足需求</strong></p></li></ul><h4 id="4-4-静态内部类"><a href="#4-4-静态内部类" class="headerlink" title="4.4 静态内部类"></a>4.4 静态内部类</h4><ul><li>懒汉式的改进</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4 . 静态内部类实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">   <span class="comment">// 1. 私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="comment">// final：保证线程中只有一个存在</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 只有调用的时候才会加载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>当第一次加载<code>Singleton</code>类时并不会初始化<code>instance</code>，只有在第一次调用<code>getInstance()</code>方法是回初始化。</p></li><li><p>第一次调用<code>getInstance()</code>方法导致虚拟机加载<code>SingletonHolder</code>类，这种方式嫩确保线程安全，也能确保单例对象的唯一性，</p></li><li><p>同时也延迟了单例对象的实例化，所以推荐使用这种实现方式。</p></li></ul><h4 id="4-5-枚举单例-线程安全"><a href="#4-5-枚举单例-线程安全" class="headerlink" title="4.5 枚举单例-线程安全"></a>4.5 枚举单例-线程安全</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  5.枚举单例模式</span></span><br><span class="line"><span class="keyword">public</span> enmu SingletonEnum &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5. 枚举单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">    INSTANCE; <span class="comment">//纯天然单例模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance1 = Singleton.INSTANCE;</span><br><span class="line">        Singleton instance2 = Singleton.INSTANCE;</span><br><span class="line">        System.out.println(instance1 == instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>就是这么简单粗暴，其实最大优点在于关键点的第4点，即是反序列化也不会重新生成新的实例。</li></ul><h4 id="4-6-总结"><a href="#4-6-总结" class="headerlink" title="4.6 总结"></a>4.6 总结</h4><p>不管哪种形式实现单例模式，核心原理都是那四个关键点，具体选择哪种实现方式取决于项目本身以及具体的开发环境等等。</p><p>而对于客户端来说通常没有高并发的情况，推荐使用DCL模式或者是静态内部类的方式实现。</p><p>优点</p><ul><li>只存在一个实例，减少了内存开支，减少了系统的性能开销</li><li>避免对资源的多重占用</li><li>全局的访问点，优化和共享资源访问</li></ul><p>缺点</p><ul><li>没有接口，难扩展，只能修改代码</li><li>如果持有Context容易导致内存泄露（需要传递Context的话最好是Application Context）</li></ul><p><strong>JDK实现:</strong></p><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#getRuntime%28%29" target="_blank" rel="noopener">java.lang.Runtime#getRuntime()</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/awt/Desktop.html#getDesktop--" target="_blank" rel="noopener">java.awt.Desktop#getDesktop()</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getSecurityManager--" target="_blank" rel="noopener">java.lang.System#getSecurityManager()</a></li></ul><h2 id="二-行为型"><a href="#二-行为型" class="headerlink" title="二. 行为型"></a>二. 行为型</h2><h4 id="1-模板方法模式（Template-Method）"><a href="#1-模板方法模式（Template-Method）" class="headerlink" title="1. 模板方法模式（Template Method）"></a>1. 模板方法模式（Template Method）</h4><ul><li>动机：对于一项任务，常常有<strong>稳定的整体操作结构</strong>，但各个子步骤却又很多改变的需求，或者需要子步骤的晚期实现（<strong>延迟到子类去实现</strong>）。</li><li>Template Method 使得子类可以复用一个算法的结构（Override 重写）该算法的某些特定步骤。</li><li>不要调用我，让我来调用你，实现晚绑定机制，这也就是控制反转的思想。</li><li>声明成 <code>protected</code> ,因为具体步骤在流程中才有意义。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200615/161657528.png" alt="mark"></p><ul><li><strong>AbstractClass : 稳定的骨架（里面有具体的方法和需要被重写的方法）</strong></li><li><strong>ContreteClass : 具体的重写方法</strong></li></ul><ul><li>具体实现（举例）</li></ul><p>冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200615/162632540.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 骨架流程</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepareRecipe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        boilWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourIncoup();</span><br><span class="line">        addCondiments();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待重写的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待重写的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pourIncoup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"倒进杯子"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">boilWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"倒水"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"倒咖啡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"加入咖啡粉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tea</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"倒茶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"加入茶叶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractClass coffee = <span class="keyword">new</span> Coffee();</span><br><span class="line">        coffee.prepareRecipe();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"========"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        AbstractClass tea = <span class="keyword">new</span> Tea();</span><br><span class="line">        tea.prepareRecipe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果显示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">倒水</span><br><span class="line">倒咖啡</span><br><span class="line">倒进杯子</span><br><span class="line">加入咖啡粉</span><br><span class="line">========</span><br><span class="line">倒水</span><br><span class="line">倒茶</span><br><span class="line">倒进杯子</span><br><span class="line">加入茶叶</span><br></pre></td></tr></table></figure><p><strong>JDK中实现：</strong></p><ul><li>java.util.Collections#sort()</li><li>java.io.InputStream#skip()</li><li>java.io.InputStream#read()</li><li>java.util.AbstractList#indexOf()</li></ul><h4 id="2-策略模式（Strategy）"><a href="#2-策略模式（Strategy）" class="headerlink" title="2. 策略模式（Strategy）"></a>2. 策略模式（Strategy）</h4><ul><li><p>定义：针对同一个算法的问题多种处理方式，仅仅是具体的行为有差别的时候</p></li><li><p>在工厂模式中，为了创建不同的产品使用了<code>switch case</code>（或<code>if else</code>）的形式的代码，这样违背了<strong>开闭原则：对扩展开放，对修改封闭</strong> 。</p></li><li><p>服务端的性能负担会随着条件判断的增加而增加，而本文的<strong>策略模式</strong>可以较好的解决这个问题</p></li></ul><p><strong>定义：定义了一系列的算法，把它们一个个封装起来，并且是他们可以相互替换。策略模式让算法独立于它的使用者之外，可以自由修改。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200623/091054383.webp" alt="mark"></p><p>来看看UML类图，图中主要有三个部分组成</p><ul><li>Context: 上下文环境，持有<code>Strategy</code> 引用</li><li>Strategy: 抽象的策略（接口或者抽象类）</li><li>ConcreteStrategy: 具体的实现策略，实现了具体的算法（<strong>一般是工厂模式的具体实现</strong>）</li></ul><p><strong>注意：</strong></p><p><strong><code>Strategy</code>是使用接口还是抽象类</strong></p><ul><li>取决于一系列的策略中是否有共同的属性或者方法，如果没有，使用接口更加灵活方便</li><li>反之，使用抽象类，抽象类中便可存放公共的属性以及方法。</li></ul><p><strong>原始待修改代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 待修改的代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LetGo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MODE_AIRPLAN = <span class="string">"airPlan"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MODE_TRAVEL = <span class="string">"travel"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MODE_CAR = <span class="string">"car"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printSpend</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"出行花费："</span> + needSpend(MODE_AIRPLAN));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">needSpend</span><span class="params">(String model)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (model)&#123;</span><br><span class="line">            <span class="keyword">case</span> MODE_AIRPLAN:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1400</span>;</span><br><span class="line">            <span class="keyword">case</span> MODE_TRAVEL:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">            <span class="keyword">case</span> MODE_CAR:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2400</span>;</span><br><span class="line">                <span class="comment">// 异常值</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LetGo letGo = <span class="keyword">new</span> LetGo();</span><br><span class="line">        letGo.printSpend();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如同前文所说的，当需要添加可选的出行方案时，我们不得不去修改<code>needSpend()</code>函数中的<code>switch case</code>来达到目的；然而这样并不利于后期的维护。接下来，试着使用策略模式来使实现这个简单的出行案例。</p><p><strong>策略模式实现：</strong></p><ul><li>既然，出现是可选的策略，我们可以先抽象除一个出行策略的的接口，包含<code>needSpend()</code>方法，返回出行花费的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITravelStrategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">needSpend</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接着，实现各种出行方案的实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 飞机出行 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirPlanStrategy</span> <span class="keyword">implements</span> <span class="title">ITravelStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">needSpend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1400</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 火车出行 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrainStrategy</span>  <span class="keyword">implements</span> <span class="title">ITravelStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">needSpend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 自驾出行 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarStrategy</span>  <span class="keyword">implements</span> <span class="title">ITravelStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">needSpend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2400</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们需要的策略就都已经完成了，就等着我们选一种方案，看看所需要的花费。</p><ul><li>我们创建一个类，和<strong><code>Strategy</code>组合</strong>使用来获取各种出行方的花费，并在<code>printSpend()</code>方法中打印出所需要的花费。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LetGoII</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 组合的思想</span></span><br><span class="line">    ITravelStrategy iTravelStrategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LetGoII</span><span class="params">(ITravelStrategy iTravelStrategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iTravelStrategy = iTravelStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printSpend</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"出行花费："</span> + iTravelStrategy.needSpend());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LetGoII letGoII = <span class="keyword">new</span> LetGoII(<span class="keyword">new</span> AirPlanStrategy());</span><br><span class="line">    letGoII.printSpend();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码就可以完成自驾游花费的输出，使用了策略模式。</p><p>现在代码是不是比之前使用<code>switch case</code>实现的代码结构更加清晰、简洁</p><p>如果要实现更多的出行方式，只需要再实现<code>ITravelStrategy</code>接口,替换掉传入的<code>LetGo</code> 构造器的参数即可。</p><p><strong>总结：</strong></p><ul><li><strong>策略模式，其实可以简单地理解成，将过多的<code>switch case</code>中<code>case</code>的代码封装成一个个具有共性的对象，需要什么我们就直接使用什么；</strong></li><li><strong>对于这种共性的实现就利用<code>interface</code>或者是抽象类来实现。这从对代码的封装以及解耦的角度来理解，可能会更加容易理解。</strong></li></ul><p><strong>使用场景：</strong></p><ul><li>针对同一个算法的问题多种处理方式，仅仅是具体的行为有差别的时候</li><li>出现同一抽象类的多个子类，而有需要使用<code>switch case</code>或<code>if else</code>来选择具体子类时</li></ul><h4 id="3-观察者模式（Obersver）"><a href="#3-观察者模式（Obersver）" class="headerlink" title="3. 观察者模式（Obersver）"></a>3. 观察者模式（Obersver）</h4><ul><li>观察者模式是使用频率非常高的模式了，它定义了对象间一种一对多的关系，使得每当一个对象改变状态，则所有依赖它的对象都会收到通知，并且自动更新。</li><li>例如：Java中的监听器Listener用的就是观察者模式。</li></ul><p><strong>UML类图：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200624/094333516.png" alt="mark"></p><ul><li>Subject: 具有注册和移除观察者，并且通知观察者的功能，主体是通过某种数据结构（可能是列表）来维护一张观察者列表实现这些操作的。</li><li>观察者（Observer）的注册功能需要调用主体的registerObserver() 方法。</li></ul><p><strong>实现：</strong></p><ul><li>开发技术周报，每周会更新一些内容，但是不知道具体的更新时间，又想第一时间阅读更新内容。</li><li>难道要一直按住F5等它更新么？那估计F5烂了可能都没有更新。其实我们只需要简单的订阅一下就好，当有新的内容更新的时候，会发邮件到你订阅的邮箱中。</li></ul><p>上述例子中：</p><ul><li>订阅者就是观察者，技术周报就是被观察者</li></ul><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"><span class="keyword">import</span> java.util.Observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者：程序员</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coder</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Coder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"收到的更新内容为"</span> + o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 被观察者：主体（开发周报）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weekly</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一对多的通知</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加一个观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除一个观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        observers.forEach(observer -&gt; observer.update(<span class="string">"数据更新了"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK中自带的观察者模式的类</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200624/103921192.png" alt="mark"></p><ul><li>在<code>java.util</code> 包中内置了<code>Observer</code> 和 <code>observable</code>类,同时<code>Observable</code>类实现了注册和反注册等方法，使用起来方便很多。可见观察者模式是非常重要的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Vector&lt;java.util.Observer&gt; obs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Observable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obs = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (!obs.contains(o)) &#123;</span><br><span class="line">            obs.addElement(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反注册</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        obs.removeElement(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反注册所有观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obs.removeAllElements();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知更新</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        notifyObservers(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知更新</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        Object[] arrLocal;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!changed)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            arrLocal = obs.toArray();</span><br><span class="line">            clearChanged();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arrLocal.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">            ((Observer)arrLocal[i]).update(<span class="keyword">this</span>, arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        changed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clearChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        changed = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">hasChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> changed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">countObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obs.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Observer</code>接口则是比较简单的代码，<code>update()</code>的参数中除了可以传递数据意外，还提供了被观察者的引用对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is called whenever the observed object is changed. An</span></span><br><span class="line"><span class="comment">     * application calls an &lt;tt&gt;Observable&lt;/tt&gt; object's</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;notifyObservers&lt;/code&gt; method to have all the object's</span></span><br><span class="line"><span class="comment">     * observers notified of the change.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   o     the observable object.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   arg   an argument passed to the &lt;code&gt;notifyObservers&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     *                 method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK中的实现：</strong></p><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Observer.html" target="_blank" rel="noopener">java.util.Observer</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/EventListener.html" target="_blank" rel="noopener">java.util.EventListener</a></li><li><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionBindingListener.html" target="_blank" rel="noopener">javax.servlet.http.HttpSessionBindingListener</a></li><li><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a></li></ul><h4 id="4-中介者模式（Mediator）"><a href="#4-中介者模式（Mediator）" class="headerlink" title="4 . 中介者模式（Mediator）"></a>4 . 中介者模式（Mediator）</h4><ul><li>中介者模式（Mediator Pattern） , 使用一个中介对象封装一系列对象交互，使得个对象之间没有明显的交互，并且能够独立的改变对象之间的交互（可能说的有点绕<strong>T_T</strong>）</li><li>看看下面这张<strong>UML类图</strong>，就能理解了。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200701/091636157.webp" alt="mark"></p><ul><li>其实和门面模式（Facade）有异曲同工之处，Facade解决的是系统内外的耦合性问题，而Mediator解决的是系统内的对象间的耦合问题。</li></ul><p><strong>举个例子：</strong></p><ul><li>简单的说就是，中介者对象聚合了对象的交互，其他的对象都是通过中介者对象进行交互，没有直接的交互。</li><li>这个可以想象一下租房，中介手里有房东的房子，你找中介租房，中介就是你和房东之间的那个中介对象。（代理模式也是如此）</li></ul><blockquote><p>虽然跳过中介直接找房东更加便宜，但是相对的，中介起的作用也简化和房东扯皮的一些过程</p></blockquote><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200701/092158293.webp" alt="mark"></p><ul><li>Meadiator:  抽象中介者，定义了同事对象到中介者对象的接口。</li><li>ConcreteMediator： 具体的中介者角色，继承抽象中介者，实现了父类定义的方法，负责具体的同事对象之间的交互</li><li>Colleague : 抽象同事类,定义了中介者对象接口,只于中介者交互.不与其他同事对象交互.</li><li>ConcreteColleagueA/B:具体的同事类,继承抽象的同事类,每个具体的同事类都知道本身小范围内的行为,不知道自己大范围内的目的.</li></ul><p>其实这样描述,有没有觉得想MVC模式里面的Controller(当然在Controller里面的代码可能不会像中介者这样降低View 之间的耦合),也是起到Model 和 View 聚合的一个作用,使得Model 和 View的耦合性降低.</p><p><strong>代码实现:</strong></p><h4 id="5-状态模式（State）"><a href="#5-状态模式（State）" class="headerlink" title="5. 状态模式（State）"></a>5. 状态模式（State）</h4><ul><li>定义：类的内部状态改变的时候，可以改变它的行为<ul><li>可能描述的有点模糊，举个栗子（真就是举个栗子）</li></ul></li></ul><p>（Android系统在未root时，是无法卸载系统预装应用的；root成功，开启root权限之后，不仅可以卸载系统预装应用，还可以使用xposed，简直就是可以为所欲为啊！这就可以看出，Android系统在root的状态变更时，影响到了自身的某些行为，进而某些行为也相对应的发生了改变。）</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200703/083558850.webp" alt="mark"></p><ul><li><p>从UML类图上来看，结构似乎和策略模式是一模一样的。</p></li><li><p>状态模式的关键点在于不同的状态下，对于同一行为有不同的响应，避免使用<code>if-else</code>或<code>switch-case</code>区分状态所带来的代码臃肿；在保持代码结构的清晰的同时还保证了扩展和维护性。</p></li></ul><p><strong>代码实现</strong></p><ul><li>平常使用的登陆或者注销状态，经常使用的收藏和关注的功能，然而没有登录会提示去登陆，功能是无法使用的。</li><li>实现收藏功能很容易出现以下代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isLogin())&#123;</span><br><span class="line">        <span class="comment">//收藏</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//去登陆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果还需要添加关注功能的话，又需要再次判断是否登录，一旦需要判断登录的功能一多，这种coding方式就会成为噩梦。</strong></p><ul><li>接下来使用状态模式可以很好的避免这种情况，首先我们需要抽象出一个公共行为接口<code>UserState</code> ，其中包含<code>collect()</code>以及<code>follow()</code>方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserState</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 收藏行为 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="comment">/** 关注行为 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对应<strong>登录</strong>和<strong>未登录</strong>两种状态会有两种不同的实现方式，如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginState</span> <span class="keyword">implements</span> <span class="title">UserState</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"收藏成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"关注成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogoutState</span> <span class="keyword">implements</span> <span class="title">UserState</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"请登录"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"请登录"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接下来，我们需要一个类来关联登录状态与外界，并为外界提供<code>collect()</code>函数和<code>follow()</code>函数对应的调用；并将<code>LoginState</code>和<code>LogoutState</code>结合起来。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里主要是实现状态模式，</span></span><br><span class="line"><span class="comment">// 对于用户这个案例来说，结合单例模式可能会更好。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserState LOGIN = <span class="keyword">new</span> LoginState();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserState LOGOUT = <span class="keyword">new</span> LogoutState();</span><br><span class="line">    <span class="keyword">private</span> UserState mState = LOGOUT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 登录，供外部调用 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mState = LOGIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 退出登录，供外部调用 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mState = LOGOUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 调用mState的coolect() */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mState.collect(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 调用mState的follow() */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mState.follow(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 此方法判断不太严谨，请忽略 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLogin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mState <span class="keyword">instanceof</span> LoginState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>这里的<code>UserContext</code> 提供给外部的<code>collect()</code> 和 <code>follow()</code> 方法的同时，还要提供<code>login()</code> 和 <code>logout（）</code>两个方法给外部调用来更改<code>UserContext</code> 的内部状态。</p></li><li><p>这里主要是实现状态模式，<strong>对于用户这个案例来说，通常会结合单例模式使用的更好</strong></p></li></ul><blockquote><p>从某种程度上来说，提供login()和logout()两个方法是为了防止外界篡改内部的行为，因为外部无法传入自己实现的UserState对象，也就无法修改UserContext对应状态的行为。</p><p>确实也看到有些文章，在设置状态时，状态是由外部传入的，这种写法觉得不太合适，所以这里单独说明。</p></blockquote><p><strong>扩展思考</strong></p><p>其实对于实际情况来说，用户的操作行为可能远远不止这两个方法，若还有需要状态判断登录状态的行为，我们可以继续在<code>UserState</code>接口中为新增的行为添加相应的方法；但是，我们也可以预见，<code>UserState</code>接口将会越来越庞大。</p><p>这种问题的话，也可以将每个行为独立成一个接口，进而让<code>UserState</code>继承各个行为接口，或者将<code>UserState</code>改成抽象类实现各个行为接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//独立的收藏的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICollect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//独立的关注的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFollow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有行为接口的集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserState</span> <span class="keyword">extends</span> <span class="title">ICollect</span>,<span class="title">IFollow</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>总结：</strong><ul><li>状态模式的关键点在于不同的状态下，对于同一行为有不同的响应，避免使用<code>if-else</code>或<code>switch-case</code>区分状态所带来的代码臃肿；在保持代码结构的清晰的同时还保证了扩展和维护性。</li><li>随着状态的增加，系统类和对象的个数也会增加，使用不当会导致程序结构变得越来越庞大。</li></ul></li></ul><h4 id="6-备忘录模式（Memento）"><a href="#6-备忘录模式（Memento）" class="headerlink" title="6. 备忘录模式（Memento）"></a>6. 备忘录模式（Memento）</h4><ul><li>定义：在不破坏封闭的前提下，将对象的当前内部状态保存到对象之外，之后可以再次恢复到此对象。（典型的例子就是游戏存档和读档的这个行为）</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200703/090135433.webp" alt="mark"></p><ul><li><strong>Originator:</strong> 发起者，负责创建一个备忘录，并且可以记录，恢复自身的内部状态。可以根据需要决定<code>Memeto</code>保存自身的那些内部状态。</li><li><strong>Memento:</strong>备忘录，用于存储<code>Originator</code>的状态，防止<code>Originator</code>以外的对象访问<code>Memento</code></li><li><strong>Caretaker</strong> : 备忘录管理者，负责存储备忘录，不能对备忘录的内容进行操作和访问，只能将备忘录传递给其他对象。</li></ul><p><strong>代码实现：</strong></p><ul><li>发起者通过创建一个新的备忘录对象来保存自己的内部状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//看出其模式的封闭性，对于状态得存储只有Originator知道</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的备忘录对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">createMemento</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将发起者的状态恢复到备忘录的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restore</span><span class="params">(Memento memento)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = memento.getState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>备忘录，将发起人对象传入的状态存储起来。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>备忘录管理者，负责保存备忘录对象，但是从不修改（甚至不查看）备忘录对象的内容。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Memento mMemento;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">restoreMemento</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMemento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">storeMemengto</span><span class="params">(Memento memento)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mMemento = memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上这就是备忘录模式的结构了，可以看出其模式的封闭性，对于状态的存储只有<code>Originator</code> 知道。</p><p><strong>总结：</strong></p><ul><li>备忘录模式在不破坏封装性的条件下，通过备忘录对象存储另外一个对象的内部状态的快照，在将来合适的时候把这个对象还原到存储的状态。</li></ul><p><strong>优点：</strong></p><ul><li>给用户提供了一种可以恢复状态的机制，可以是用户能够方便的回到某个历史的状态</li><li>实现了信息的封装，是的用户不需要关心状态的保存细节</li></ul><p><strong>缺点</strong></p><ul><li><strong>现在很多序列化的技术已经比备忘录模式优秀很多</strong></li></ul><p><strong>JDK：</strong></p><ul><li>java.io.Serializable</li></ul><h2 id="三：结构型"><a href="#三：结构型" class="headerlink" title="三：结构型"></a>三：结构型</h2><h4 id="1-装饰者模式（Decorator）"><a href="#1-装饰者模式（Decorator）" class="headerlink" title="1. 装饰者模式（Decorator）"></a>1. 装饰者模式（Decorator）</h4><ul><li>装饰者模式（Decorator Pattern）也称为包装模式（Wrapper Pattern），以透明动态的方式来动态扩展对象的功能，也是<strong>继承关系中一种代替方案</strong>。</li><li><strong>装饰者模式与继承关系的目的都是要扩展对象的功能，但是装饰者模式可以提供比继承更多的灵活性。(减少代码的冗余)</strong></li><li><strong>通过不同具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200624/104532725.webp" alt="mark"></p><ul><li>Component: 抽象组件（可以是抽象类或者接口），被装饰的原始对象</li><li>ConcreteComponent：具体的实现类，被装饰的具体对象</li><li>Decorator ： 抽象的装饰者，职责就是为了装饰我们的组件对象，内部一定要有一个指向组件的对象引用。</li><li>ConcreteDecoratorA：装饰者具体实现类，只对抽象装饰者做出具体实现</li><li>ConcreteDecoratorB：同上</li></ul><p><strong>举个例子：</strong></p><ol><li>人定义为抽象类，有一个抽象方法<code>eat()</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建一个<code>NormalPerson</code>类继承<code>Person</code>，对<code>eat()</code>方法有了具体实现；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalPerson</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>定义一个<code>PersonFood</code>类来表示装饰者的抽象类，保持了一个对<code>Person</code>的引用，可以方便调用具体被装饰的对象方法，这样就可以方便的对其进行扩展功能，并且不改变原类的层次结构。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonFood</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonFood</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>接着就是具体的装饰类了，这两个类没有本质上的区别，都是为了扩展<code>PersonFood</code>类，不修改原有类的方法和结构</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpensiveFood</span> <span class="keyword">extends</span> <span class="title">PersonFood</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExpensiveFood</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.eat();</span><br><span class="line">        eatSteak();</span><br><span class="line">        drinkRedWine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatSteak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃牛排"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drinkRedWine</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"喝拉菲"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheapFood</span> <span class="keyword">extends</span> <span class="title">PersonFood</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheapFood</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.eat();</span><br><span class="line">        eatNoodles();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatNoodles</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃面条"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Client:测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> NormalPerson();</span><br><span class="line"></span><br><span class="line">        PersonFood cheapFood = <span class="keyword">new</span> CheapFood(person);</span><br><span class="line">        cheapFood.eat();</span><br><span class="line"></span><br><span class="line">        PersonFood expensiveFood = <span class="keyword">new</span> ExpensiveFood(person);</span><br><span class="line">        expensiveFood.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>装饰者模式与<strong>继承关系</strong>的目的都是要<strong>扩展对象的功能</strong>，但是装饰者模式可以提供比继承更多的灵活性。</li><li>通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的<strong>组合</strong>。</li></ul></li></ul><p><strong>与代理模式的区别：</strong></p><ul><li>其实装饰着模式和代理模式很想，但两个目的不尽相同</li><li>装饰者模式是以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，目的是为了减少类的冗余</li><li>代理模式是提供一个代理对象，并有代理对象来控制原来对象的引用。</li><li>总而言之：代理模式是为了对代理对象进行控制，但不做功能的扩展；装饰者模式为本装饰的对象进行功能的扩展。</li></ul><h4 id="2-桥模式（Bridge）"><a href="#2-桥模式（Bridge）" class="headerlink" title="2. 桥模式（Bridge）"></a>2. 桥模式（Bridge）</h4><ul><li><p>定义：将<strong>抽象部分（业务功能</strong>）与<strong>实现部分（平台实现）</strong>分离，使他们可以独立的变化。<strong>（主要是违背了单一职责原则）</strong></p></li><li><p>动机：由于某些类型的固有的实现逻辑，使得他们具有两个变化的维度，乃至多个变化的维度</p><ul><li>使用在对象间的<strong>组合关系</strong>，使得抽象和实现之间沿着各自的维度来变化。</li></ul></li></ul><p><strong>类图：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200626/091251315.png" alt="mark"></p><ul><li>Abstraction：定义抽象类的接口</li><li>Implementor：定义实现类接口</li></ul><p><strong>代码实现：</strong></p><ul><li>RemoteControl 表示遥控器，指代 Abstraction。</li><li>TV 表示电视，指代 Implementor。</li><li>桥接模式将遥控器和电视分离开来，从而可以独立改变遥控器或者电视的实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TV</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">tuneChannel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TV具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sony</span> <span class="keyword">extends</span> <span class="title">TV</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sony On"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sony Off"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tuneChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sony ChannelChange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">extends</span> <span class="title">TV</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ChangHong On"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ChangHong Off"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tuneChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ChangHong ChannelChange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遥控器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组合tv</span></span><br><span class="line">    <span class="keyword">protected</span> TV tv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向tv的指针</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RemoteController</span><span class="params">(TV tv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">tuneChannel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体遥控器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteRemote1</span> <span class="keyword">extends</span> <span class="title">RemoteController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向tv的指针</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteRemote1</span><span class="params">(TV tv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(tv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConcreteRemoteControl1 on"</span>);</span><br><span class="line">        tv.on();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConcreteRemoteControl1 off"</span>);</span><br><span class="line">        tv.off();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tuneChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConcreteRemoteControl1 tuneChannel"</span>);</span><br><span class="line">        tv.tuneChannel();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteRemote2</span> <span class="keyword">extends</span> <span class="title">RemoteController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向TV的指针</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteRemote2</span><span class="params">(TV tv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(tv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConcreteRemoteControl2 on"</span>);</span><br><span class="line">        tv.on();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConcreteRemoteControl2 off"</span>);</span><br><span class="line">        tv.off();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tuneChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConcreteRemoteControl2 tuneChannel"</span>);</span><br><span class="line">        tv.tuneChannel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 组合的方式</span></span><br><span class="line">        ConcreteRemote1 remote1 = <span class="keyword">new</span> ConcreteRemote1(<span class="keyword">new</span> ChangHong());</span><br><span class="line">        remote1.on();</span><br><span class="line">        remote1.off();</span><br><span class="line">        remote1.tuneChannel();</span><br><span class="line">        System.out.println(remote1.tv);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"====================="</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 组合的方式</span></span><br><span class="line">        ConcreteRemote2 remote2 = <span class="keyword">new</span> ConcreteRemote2(<span class="keyword">new</span> Sony());</span><br><span class="line">        remote2.on();</span><br><span class="line">        remote2.off();</span><br><span class="line">        remote2.tuneChannel();</span><br><span class="line">        System.out.println(remote2.tv);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line">ConcreteRemoteControl1 on</span><br><span class="line">ChangHong On</span><br><span class="line">ConcreteRemoteControl1 off</span><br><span class="line">ChangHong Off</span><br><span class="line">ConcreteRemoteControl1 tuneChannel</span><br><span class="line">ChangHong ChannelChange</span><br><span class="line">ChangHong@<span class="number">4554617</span>c</span><br><span class="line">=====================</span><br><span class="line">ConcreteRemoteControl2 on</span><br><span class="line">Sony On</span><br><span class="line">ConcreteRemoteControl2 off</span><br><span class="line">Sony Off</span><br><span class="line">ConcreteRemoteControl2 tuneChannel</span><br><span class="line">Sony ChannelChange</span><br><span class="line">Sony@<span class="number">74</span>a14482</span><br></pre></td></tr></table></figure><p><strong>JDK中实现</strong></p><ul><li>AWT (It provides an abstraction layer which maps onto the native OS the windowing support.)</li><li>JDBC</li></ul><h4 id="3-享元模式（Flyweight）"><a href="#3-享元模式（Flyweight）" class="headerlink" title="3. 享元模式（Flyweight）"></a>3. 享元模式（Flyweight）</h4><ul><li><p><strong>享元模式</strong> ： 是对象池的一种实现，主要用于减少创建对象的数量，<strong>以减少内存占用和提供性能。</strong></p></li><li><p>定义：运用共享技术有效的支持大量细粒度的对象<strong>（要求对象是只读的）</strong></p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200628/111500446.webp" alt="mark"></p><ul><li>Flyweight:  享元模式的抽象类或者接口。</li><li>ConcreateFlyweight: 具体的享元对象。</li><li>FlyweightFactory：享元工厂，负责管理享元对象池和创建享元对象。</li></ul><p><strong>代码实现</strong></p><ul><li>场景：过年抢票，大家肯定都不陌生，各种刷票插件、软件什么的。在用户设置好出发和到达之后，每次查询请求都返回一系列的车票结果。<ul><li>当数千万的用户在不断请求查询结果时，如果每次查询结果都是重新创建返回的，可想而知，肯定会有大量的重复对象的创建、销毁，内存占用和GC的压力都会随之增大。</li><li>而享元模式就能很好的应对这种情况，车次是固定的，根据出发地和到达地查询出来的车次基本都是相同的</li></ul></li></ul><ol><li>创建一个Ticket接口，定义输出车票信息的方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Ticket接口，定义输出车票信息的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showTicket</span><span class="params">(String info)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>具体的实现类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrainTicket</span> <span class="keyword">implements</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出发地</span></span><br><span class="line">    <span class="keyword">private</span>  String from;</span><br><span class="line">    <span class="comment">//到达地</span></span><br><span class="line">    <span class="keyword">private</span>  String to;</span><br><span class="line">    <span class="comment">//铺位</span></span><br><span class="line">    <span class="keyword">private</span> String bunk;</span><br><span class="line">    <span class="comment">//价格</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrainTicket</span><span class="params">(String from, String to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showTicket</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        price = <span class="keyword">new</span> Random().nextInt(<span class="number">200</span>);</span><br><span class="line">        System.out.println(<span class="string">"查询 从 "</span>+from+<span class="string">" 到 "</span> + to + <span class="string">" 的 "</span> + bunk + <span class="string">" 车票，价格："</span> + price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>享元工厂</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JUC MAP</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Ticket&gt; ticketMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次获取车票对象时的创建，享元模式有效的减少了重复对象的创建。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Ticket <span class="title">getTicket</span><span class="params">(String from,String to)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String key = from + <span class="string">"-"</span> + to;</span><br><span class="line">        <span class="comment">// 享元模式的精髓，有就直接返回这个对象</span></span><br><span class="line">        <span class="keyword">if</span> (ticketMap.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> ticketMap.get(key);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有就加入到对象池中，并且返回这个对象</span></span><br><span class="line">            TrainTicket ticket = <span class="keyword">new</span> TrainTicket(from, to);</span><br><span class="line">            ticketMap.put(key,ticket);</span><br><span class="line">            <span class="keyword">return</span> ticket;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK:</strong></p><p>Java 利用缓存来加速大量小对象的访问时间。</p><ul><li>java.lang.Integer#valueOf(int)</li><li>java.lang.Boolean#valueOf(boolean)</li><li>java.lang.Byte#valueOf(byte)</li><li>java.lang.Character#valueOf(char)</li></ul><h4 id="4-外观模式（Facade）"><a href="#4-外观模式（Facade）" class="headerlink" title="4. 外观模式（Facade）"></a>4. 外观模式（Facade）</h4><ul><li>外观模式：封装系统的复杂结构，向外提供一个可以访问系统的接口，这个接口就是系统内外通信的统一的出入口。这样使得系统更加易于维护和使用<ul><li>在我们集成很多第三方SDK的时候就会发现，我们集成一次之后，想要升级SDK的版本的话，我们只需要替换jar或者修改依赖库的版本，当然你也可以一直使用最新的版本。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200628/113712188.webp" alt="mark"></p><ul><li>Client：客户端，直接使用<code>Facade</code>接口提供的方法</li><li>Facade：就是系统对外的同一对象，封装了各个子系统的交互简化了<code>Client</code>调用</li><li>SystemA、SystemB、SystemC：子系统接口</li><li>ConcreteSystemA、ConcreteSystemB、ConcreteSystemC：子系统的实现</li></ul><p>这里就可以看出，对Client来说只需要知道一个Facade一个就行，不需要知道Facade内部的具体复杂逻辑，降低用户的使用成本。<strong>（思想：高内聚，松耦合）</strong></p><p><strong>优点</strong></p><ul><li>对使用者隐藏内部的具体细节，降低使用者和子系统的耦合。</li><li>外观类对子系统的接口封装，使得系统更加容易使用</li></ul><p><strong>缺点</strong></p><ul><li>外观类接口会过于庞大</li><li>没有遵循开闭原则，业务变化时需要修改外观类</li></ul><p><strong>代码实现：没有特定代码结构</strong></p><ul><li>场景：生活中有很多这样的例子，我们经常使用的智能手机就是一个外观模式的例子，能够打电话、拍照等功能，而打电话和拍照又是独立的功能系统。</li></ul><ol><li>手机功能</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hangUp</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhomeImpl</span> <span class="keyword">implements</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hangUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"挂电话"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>拍照功能</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Camera</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePhoto</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnoyCamera</span> <span class="keyword">implements</span> <span class="title">Camera</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开启相机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePhoto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"拍照"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"关闭相机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>组装手机</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmartPhone</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PhomeImpl phome = <span class="keyword">new</span> PhomeImpl();</span><br><span class="line">    <span class="keyword">private</span> SnoyCamera camera = <span class="keyword">new</span> SnoyCamera();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        phome.call();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePhoto</span><span class="params">()</span></span>&#123;</span><br><span class="line">        camera.open();</span><br><span class="line">        camera.takePhoto();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-代理模式（Proxy）"><a href="#5-代理模式（Proxy）" class="headerlink" title="5. 代理模式（Proxy）"></a>5. 代理模式（Proxy）</h4><ul><li><strong>代理模式</strong>： 为其他对象提供一个代理，并由代理对象控制原有对象的引用。也称作委托模式</li><li>其实代理模式无论是在日常开发中还是设计模式汇总都随处可见，中介者模式的中介者对象也是<strong>代理模式</strong>的应用，其他的对象的交互都是交给终结者对象处理的。而在生活中就更多的类似代理模式的例子。例如：抢票插件，科学上网等等。</li></ul><p><strong>UML类图：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200629/091646377.webp" alt="mark"></p><ul><li>subject: 抽象主体类（也可以是接口），声明共同的功能</li><li>RealSubject: 真实的主体类，也就是<strong>被代理的类</strong>，负责执行具体的业务逻辑方法；客户类调用代理类间接调用其定义的方法。</li><li>ProxySubject:代理主体类，也就是<strong>代理类</strong>，持有一个被代理类的真实对象，在实现抽象主体类共同方法中调用<strong>被代理类</strong>的相对应的方法，起到代理的作用。</li><li>Client: 客户类，直接去访问代理</li></ul><h5 id="5-1-静态代理"><a href="#5-1-静态代理" class="headerlink" title="5.1 静态代理"></a>5.1 静态代理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**抽象主体*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**被代理主体*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"this is real subject"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**代理主题*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="comment">// 真实主体</span></span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxySubject</span><span class="params">(RealSubject realSubject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.realSubject = realSubject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"proxy start"</span>);</span><br><span class="line">        realSubject.visit();</span><br><span class="line">        System.out.print(<span class="string">"proxy end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**客户类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建被代理对象</span></span><br><span class="line">        RealSubject realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        ProxySubject proxySubject = <span class="keyword">new</span> ProxySubject(realSubject);</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        proxySubject.visit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>静态代理的好处:</strong></p><ul><li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li><li>公共的业务由代理来完成 . 实现了业务的分工 ,</li><li>公共业务发生扩展时变得更加集中和方便 .</li></ul><p><strong>缺点：</strong></p><ul><li>类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 .</li></ul><h5 id="5-2-动态代理"><a href="#5-2-动态代理" class="headerlink" title="5.2 动态代理"></a>5.2 动态代理</h5><ul><li>上一部分介绍的，其实就是<strong>静态代理，也就是在代码的编译阶段生成代理类来完成代理对象的一系列操作。</strong></li><li>而<strong>动态代理</strong>则是在运行时动态生成代理类对象。</li><li>代理对象的生成则是利用<code>JDK</code>中的<code>java.lang.reflect.Proxy</code> 类 ，使用<code>newProxyInstance</code> 方法则可以创建一个我们所需要代理的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要是newProxyInstance方法，动态生成代理类</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">        <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            Throwable t = e.getCause();</span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>newProxyInstance</code> 是一个<code>Proxy</code>的静态方法，并且接收三个参数</p><ul><li><code>ClassLoader loader</code> <strong>类加载器</strong></li><li><code>Class&lt;?&gt;[] interfaces</code> <strong>目标对象实现的接口类型</strong></li><li><code>InvocationHandler h</code> 处理事件的对象，<code>InvocationHandler</code> 是一个接口，执行目标对象的方法，会触发<code>InvocationHandler</code> 的<code>invoke</code></li></ul><p><strong>另外一个重要的类当然就是<code>InvocationHandler</code> 了，其中最重要的方法就是<code>invoke</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Object proxy</code>: 执行方法的代理对象</li><li><code>Method method</code> ：被执行的方法的对象</li><li><code>bject[] args</code> : 被执行方法的参数</li><li>返回值：代理对象调用方法所返回的值</li></ul><p>依然使用<code>Subject</code>作为例子，看看简单的代码实现（代码没有封装）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建被代理对象</span></span><br><span class="line">        <span class="keyword">final</span> RealSubject realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建被代理对象</span></span><br><span class="line">        Subject subject = (Subject) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;Subject<span class="class">.<span class="keyword">class</span>&#125;,</span></span><br><span class="line"><span class="class">                <span class="title">new</span> <span class="title">InvocationHandler</span>() </span>&#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        <span class="comment">// 第一个参数是要代理的对象</span></span><br><span class="line">                        <span class="comment">// 第二个参数是需要传入的参数</span></span><br><span class="line">                        <span class="keyword">return</span> method.invoke(realSubject,args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        subject.visit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从代码上来看，比之前静态代理要简单很多，没有那么多类和对象，但是<strong>相对的代码在性能上有牺牲</strong>，而且对于不太熟悉反射相关的知识的开发者并不是太友好。</li><li>通过反射类<code>Proxy</code> 和 <code>InvocationHandler</code> 回调接口实现JDK动态代理，要求被代理类必须实现一个接口，但事实上并不是所有的类都有接口，对于没有实现接口的类，便无法使用该方法实现动态代理。</li></ul><h5 id="5-3-其他代理分类"><a href="#5-3-其他代理分类" class="headerlink" title="5.3 其他代理分类"></a>5.3 其他代理分类</h5><p>静态代理和动态代理是代码方法来区分代理模式，也可以从使用范围来区分不同的代理实现</p><ul><li>远程代理（Remote Proxy）: 为某个对象在不同的内存地址空间提供局部代理。使得系统可以将<code>Server</code> 部分的实现隐藏，以便<code>Client</code>不必考虑<code>Server</code>的存在</li><li>虚拟代理（Virtual Proxy） : 使用一个代理对象表示一个十分耗资源的对象并在真正需要时候才创建</li><li>保护代理(Protection Proxy): 使用代理控制对原始对象的访问.该类型的代理常被用于原始对象有不同访问权限的情况.</li><li>智能引用(Smart Reference) : 在访问原始对象时执行一些自己的附加操作并对指向原始对象的引用计数.</li></ul><p>这里要注意的是，静态和动态代理都可以应用于上述4种情形，两者是各自独立的变化。</p><p><strong>总结:</strong></p><p>代理模式使用非常广泛，基本在其他的设计模式中也能看到代理模式的影子，但是使用时针对性较强，而且模式本身并没有什么突出的优缺点，基本上可以放心使用</p><p><strong>通用的动态代理实现类:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成代理类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                <span class="keyword">this</span>.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// proxy ： 代理类</span></span><br><span class="line">    <span class="comment">// method : 代理类中要代理的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">        <span class="comment">// 业务逻辑代码</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(target,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK:</strong></p><ul><li>java.lang.reflect.proxy</li><li>java.lang.reflect.InvocationHandler</li><li>Spring的 Aop</li></ul><h4 id="6-适配器模式（Adapter）"><a href="#6-适配器模式（Adapter）" class="headerlink" title="6. 适配器模式（Adapter）"></a>6. 适配器模式（Adapter）</h4><p>定义：此模式的作用就是兼容原本接口不匹配的两个类，起到桥梁的作用。</p><h5 id="6-1-类的适配器模式"><a href="#6-1-类的适配器模式" class="headerlink" title="6.1 类的适配器模式"></a>6.1 类的适配器模式</h5><ul><li>类的适配器模式：采用继承实现</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200701/085746124.webp" alt="mark"></p><ul><li>Target：目标接口，也就是期望得到的接口</li><li>Adaptee：需要适配的接口</li><li>Adapter：适配器，负责把<code>Adaptee</code>转换成<code>Target</code>的类</li></ul><p>不说远了，就说<strong>手机充电头</strong>，其实就是一个电源适配器，生活用电的电压是220v，而手机充电的电压是5v，所以这时候就需要使用到电源适配器将220v的电压转换为5v（如果你是直接插在插板的USB接口上的话，当我没说）。</p><p>对应上面的UML图， 生活电压就是<code>Adaptee</code>，手机充电电压就是<code>Target</code>，不用多说，电源适配器自然就是<code>Adapter</code>了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Target接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Volt5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVolt5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adaptee类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Volt220</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVlot220</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">220</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Adapter类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VoltAdapter</span> <span class="keyword">extends</span> <span class="title">Volt220</span> <span class="keyword">implements</span> <span class="title">Volt5</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVolt5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VoltAdapter adapter = <span class="keyword">new</span> VoltAdapter();</span><br><span class="line">        System.out.println(<span class="string">"输出电压"</span> + adapter.getVolt5());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-2-对象适配器模式"><a href="#6-2-对象适配器模式" class="headerlink" title="6.2 对象适配器模式"></a>6.2 对象适配器模式</h5><ul><li>与类适配器不同的是，<strong>对象适配器模式不使用继承关联链接<code>Adaptee</code> 类，而是使用代理关系连接到<code>Adaptee</code>类</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200701/090602860.webp" alt="mark"></p><ul><li>这种实现方式直接将要被适配的对象传递到<code>Adapter</code> 中，使用组合的形式实现接口的兼容效果。</li><li>一般常用的适配器模式都是对象适配器模式</li><li>还有就是<code>Adaptee</code> 对象不会被暴露出来，因为没有继承被适配的对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Target接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Volt5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVolt5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Adaptee类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Volt220</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVlot220</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">220</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Adapter类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VoltAdapter</span> <span class="keyword">implements</span> <span class="title">Volt5</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组合的形式</span></span><br><span class="line">    Volt220 volt220;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VoltAdapter</span><span class="params">(Volt220 volt220)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.volt220 = volt220;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVolt5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVolt220</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> volt220.getVlot220();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VoltAdapter adapter = <span class="keyword">new</span> VoltAdapter(<span class="keyword">new</span> Volt220());</span><br><span class="line">        System.out.println(<span class="string">"输出电压"</span> + adapter.getVolt5());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK:</strong></p><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList%28T...%29" target="_blank" rel="noopener">java.util.Arrays#asList()</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#list-java.util.Enumeration-" target="_blank" rel="noopener">java.util.Collections#list()</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#enumeration-java.util.Collection-" target="_blank" rel="noopener">java.util.Collections#enumeration()</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/adapters/XmlAdapter.html#marshal-BoundType-" target="_blank" rel="noopener">javax.xml.bind.annotation.adapters.XMLAdapter</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200610/221023280.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设计模式是解决问题的方案，学习现有的设计模式可以做到经验的复用&lt;/li&gt;
&lt;li&gt;拥有设计模式的词汇，在沟通是就能用到更少的词汇来讨论，并且不需要知道底层的细节&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;话在前头：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么是好的设计模式？&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;提高复用&lt;/li&gt;
&lt;li&gt;应对变化&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;在什么时候，什么地方使用设计模式？&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;在需求频繁变化的变化点使用设计模式&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Refactoring to Patterns(重构的方式一步一步到模式)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重构的关键方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;静态 -&amp;gt; 动态&lt;/li&gt;
&lt;li&gt;早绑定 -&amp;gt; 晚绑定&lt;/li&gt;
&lt;li&gt;继承 -&amp;gt; 组合&lt;/li&gt;
&lt;li&gt;编译时依赖 -&amp;gt; 运行时依赖&lt;/li&gt;
&lt;li&gt;紧耦合 -&amp;gt; 松耦合&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="设计模式" scheme="http://zhuuu.work/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-189-旋转数组</title>
    <link href="http://zhuuu.work/2020/06/09/Leetcode/Leetcode-189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <id>http://zhuuu.work/2020/06/09/Leetcode/Leetcode-189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</id>
    <published>2020-06-09T08:53:53.000Z</published>
    <updated>2020-06-09T09:21:02.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-189-Rotate-Array"><a href="#Leetcode-189-Rotate-Array" class="headerlink" title="Leetcode-189-Rotate Array"></a>Leetcode-189-<a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">Rotate Array</a></h1><h2 id="思路：遍历替换"><a href="#思路：遍历替换" class="headerlink" title="思路：遍历替换"></a>思路：遍历替换</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组，将数组中的元素向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k &#x3D; 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [-1,-100,3,99] 和 k &#x3D; 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法一：暴力替换"><a href="#方法一：暴力替换" class="headerlink" title="方法一：暴力替换"></a>方法一：暴力替换</h2><p>最简单的方法是旋转 k 次，每次将数组旋转 1 个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> previous = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 外层循环：旋转k次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            previous = nums[nums.length - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 内层循环：每次和数组中最后一个元素交换</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                temp = nums[j];</span><br><span class="line">                nums[j] = previous;</span><br><span class="line">                previous = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(n*k)   内层循环n个元素，外层循环遍历k次</li><li><strong>空间复杂度</strong>：O(1)</li></ul><h2 id="方法二：使用额外的数组"><a href="#方法二：使用额外的数组" class="headerlink" title="方法二：使用额外的数组"></a>方法二：使用额外的数组</h2><ul><li>思路：使用一个额外的数组把每个元素放到正确的位置上，也就是把i放到了 <code>i + k%数组长度</code>的位置。然后将数组重新拷贝到原数组中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 新建一个数组，把对应位置存到新数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            a[(i+k) % nums.length] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 拷回到原数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(n) 。将数字放到新的数组中需要一遍遍历，另一边来把新数组的元素拷贝回原数组。</li><li><strong>空间复杂度</strong>：O(n)。另一个数组需要原数组长度的空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-189-Rotate-Array&quot;&gt;&lt;a href=&quot;#Leetcode-189-Rotate-Array&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-189-Rotate Array&quot;&gt;&lt;/a&gt;Leetcode-189-&lt;a href=&quot;https://leetcode-cn.com/problems/rotate-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Rotate Array&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：遍历替换&quot;&gt;&lt;a href=&quot;#思路：遍历替换&quot; class=&quot;headerlink&quot; title=&quot;思路：遍历替换&quot;&gt;&lt;/a&gt;思路：遍历替换&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个数组，将数组中的元素向右移动 &lt;em&gt;k&lt;/em&gt; 个位置，其中 &lt;em&gt;k&lt;/em&gt; 是非负数。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,2,3,4,5,6,7] 和 k &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [5,6,7,1,2,3,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;向右旋转 1 步: [7,1,2,3,4,5,6]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;向右旋转 2 步: [6,7,1,2,3,4,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;向右旋转 3 步: [5,6,7,1,2,3,4]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [-1,-100,3,99] 和 k &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [3,99,-1,-100]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;向右旋转 1 步: [99,-1,-100,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;向右旋转 2 步: [3,99,-1,-100]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-009-回文数反转</title>
    <link href="http://zhuuu.work/2020/06/09/Leetcode/Leetcode-009-%E5%9B%9E%E6%96%87%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>http://zhuuu.work/2020/06/09/Leetcode/Leetcode-009-%E5%9B%9E%E6%96%87%E6%95%B0%E5%8F%8D%E8%BD%AC/</id>
    <published>2020-06-09T07:42:53.000Z</published>
    <updated>2020-06-13T08:25:23.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-009-回文数"><a href="#Leecode-009-回文数" class="headerlink" title="Leecode-009- 回文数"></a>Leecode-009- <a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">回文数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 121</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法一：字符串双指针"><a href="#方法一：字符串双指针" class="headerlink" title="方法一：字符串双指针"></a>方法一：字符串双指针</h2><p><strong>思路：由于特点很合适，所以转换成字符串去判断</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// int转换成string</span></span><br><span class="line">        String s = String.valueOf(x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双指针判断</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = s.length() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="comment">// 判断首尾是否相等</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">                <span class="comment">// 相等的话判断下一位</span></span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不相等直接退出</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度： O(n) </li><li>空间复杂度：O(n) 使用了一个字符串数组实现</li></ul><h2 id="方法二-十进制反转"><a href="#方法二-十进制反转" class="headerlink" title="方法二: 十进制反转"></a>方法二: 十进制反转</h2><p><strong>思路: 把数字进行十进制倒转,再判断和原先是否相同</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200613/161720769.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 保存反转前的结果</span></span><br><span class="line">        <span class="keyword">int</span> temp = x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对每一位进行反转</span></span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans == temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(1)  因为数字长度有限,int最大是32位,所以遍历32位就行.</li><li>空间复杂度：O(1)  使用常数的额外空间</li></ul><p>注意:这里有一个隐藏的问题细节</p><ul><li><p>如果我们输入的是最大32位整数2147483647，这个数字本身是没有问题，是一个合法的32位最大整数，用int存储也没问题，但是如果将这个数字反转的话，其大小超过了32位最大整数，也就是会溢出</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200613/161836795.png" alt="mark"></p></li><li><p>那么是否要改变类型位Long类型存储呢?</p><ul><li><strong>其实是不用的,因为32位整数中最大的回文数字是2147447421,这个数字是比最大32位整数要小的</strong></li><li>也就是说超过<code>2147447412</code>大小的数字也就不是回文数字了，虽然最后结果溢出了,但是返回的结果仍然是对的.</li></ul></li></ul><h2 id="方法三-反转一半的数字"><a href="#方法三-反转一半的数字" class="headerlink" title="方法三: 反转一半的数字"></a>方法三: 反转一半的数字</h2><p><strong>思路:我们不用反转整数的所有数字，只需要反转一半数字就可以了，这是利用了【回文】的对称性。。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200613/162055172.png" alt="mark"></p><ul><li>反转操作和方法二相同</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    ans = ans * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">    x /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>不同的地方在于 while 的判断条件</strong><ul><li>我们可以注意到的是(如果反转后的数字 大于 反转后得到的数字,那么说明已经过半了)</li><li>上面的那个很好理解,你随便写一个数字看看就知道了</li></ul></li></ul><ul><li>最后要判断奇偶数的情况<ul><li>如果是偶数的话, 两者应该相等</li><li>如果是奇数的话,新得到的数字正好是原数字x的10倍.</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200613/162144789.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x&#x3D;&#x3D;ans || x&#x3D;&#x3D;(ans&#x2F;10)</span><br></pre></td></tr></table></figure><ul><li><p>还有要考虑的一点:</p><ul><li>对于<code>10</code>，<code>20</code>，<code>100</code>这样的数字，用上面的判断方式就有问题了</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200613/162255628.png" alt="mark"></p><ul><li>所以我们要对这些数字进行特殊处理(如果某个数字 % 10 等于 0 , 并且它不是0开头,那么直接返回false就可以了.)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这些数字特殊处理一下，</span></span><br><span class="line">        <span class="comment">// 如果某个数字%10等于0，并且它不是0开头，那么直接返回false就可以了</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x%<span class="number">10</span>==<span class="number">0</span> &amp;&amp; x!=<span class="number">0</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果原数字大于新数字，不断求解得到新数字</span></span><br><span class="line">        <span class="keyword">while</span> (x &gt; ans)&#123;</span><br><span class="line">            ans = ans*<span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断奇数偶数的情况</span></span><br><span class="line">        <span class="keyword">return</span> x == ans || x==(ans/<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-009-回文数&quot;&gt;&lt;a href=&quot;#Leecode-009-回文数&quot; class=&quot;headerlink&quot; title=&quot;Leecode-009- 回文数&quot;&gt;&lt;/a&gt;Leecode-009- &lt;a href=&quot;https://leetcode-cn.com/problems/palindrome-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;回文数&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: 121&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: -121&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: 10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 从右向左读, 为 01 。因此它不是一个回文数。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-202-快乐数</title>
    <link href="http://zhuuu.work/2020/06/08/Leetcode/Leetcode-202-%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
    <id>http://zhuuu.work/2020/06/08/Leetcode/Leetcode-202-%E5%BF%AB%E4%B9%90%E6%95%B0/</id>
    <published>2020-06-08T01:12:53.000Z</published>
    <updated>2020-06-09T03:14:59.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-202-Happy-Number"><a href="#Leetcode-202-Happy-Number" class="headerlink" title="Leetcode-202-Happy Number"></a>Leetcode-202-<a href="https://leetcode-cn.com/problems/happy-number/" target="_blank" rel="noopener">Happy Number</a></h1><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</p><p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：19</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">12 + 92 &#x3D; 82</span><br><span class="line">82 + 22 &#x3D; 68</span><br><span class="line">62 + 82 &#x3D; 100</span><br><span class="line">12 + 02 + 02 &#x3D; 1</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>参考题解</strong>：<a href="https://leetcode-cn.com/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/</a></p><h2 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我们可以先举几个例子。我们从 7 开始。则下一个数字是 49（因为 7^2&#x3D;49 </span><br><span class="line">然后下一个数字是 97（因为 4^2+9^2&#x3D;97) </span><br><span class="line">）。</span><br><span class="line">我们可以不断重复该的过程，直到我们得到 1。因为我们得到了 1，我们知道 7 是一个快乐数，函数应该返回 true。</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200609/100208586.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">再举一个例子，从116开始。</span><br><span class="line">通过反复平方和计算下一个数字，我们最终得到了58，</span><br><span class="line">在继续计算之后，我们又回到了58.由于我们回到了一个已经计算过的数字，可以知道有一个环，因此不可能达到1。</span><br><span class="line">所以对于116，函数应该返回false</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200609/100356018.png" alt="mark"></p><ul><li><strong>思考</strong></li></ul><p>根据我们的探索，我们猜测会有以下三种可能。</p><ol><li>最终会得到 1。</li><li>最终会进入循环。</li><li>值会越来越大，最后接近无穷大。</li></ol><p>第三个情况比较难以检测和处理。我们怎么知道它会继续变大，而不是最终得到 1 呢？我们可以仔细想一想，每一位数的最大数字的下一位数是多少。</p><table><thead><tr><th>Digits</th><th align="center">Largest</th><th align="right">Next</th></tr></thead><tbody><tr><td>1</td><td align="center">9</td><td align="right">81</td></tr><tr><td>2</td><td align="center">99</td><td align="right">162</td></tr><tr><td>3</td><td align="center">999</td><td align="right">243</td></tr><tr><td>4</td><td align="center">9999</td><td align="right">324</td></tr><tr><td>13</td><td align="center">9999999999999</td><td align="right">1053</td></tr></tbody></table><ol><li>对于三位数的数字，他不可能大于243。</li></ol><p>（这意味着它要么被困在243以下的循环内，要么跌倒1。）</p><ol start="2"><li>对于4位或者以上的是数字，在每一步都会丢失一位，直到降到3位位置。所以我们知道，最坏的情况下，算法可能会在243以下的循环内或者回到1。但它不会无限期的进行下去，所以我们排除第三种选择。</li></ol><ul><li><strong>算法</strong><ul><li>给定一个数字n，判断他的下一个平方后数字是什么</li><li>按照一系列数字来判断我们是否进入了一个循环</li></ul></li></ul><p>第 1 部分我们按照题目的要求做数位分离，求平方和。</p><p>第 2 部分可以使用 HashSet 完成。每次生成链中的下一个数字时，我们都会检查它是否已经在 HashSet 中。</p><ul><li>如果不在hashset中，把它加入到hashset中</li><li>如果在hashset中，说明我们进入了一个循环，返回false。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环条件： 回到了1表示快乐数字 并且 这个数字之前没有出现过</span></span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !set.contains(n))&#123;</span><br><span class="line">            <span class="comment">// 加入到set中</span></span><br><span class="line">            set.add(n);</span><br><span class="line">            <span class="comment">// n的下一个平方数</span></span><br><span class="line">            n = getNext(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断结果</span></span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算n 的平方数函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            total += d*d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：（这里参考官网）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">确定这个问题的时间复杂度对于一个 “简单” 级别的问题来说是一个挑战。如果您对这些问题还不熟悉，可以尝试只计算 getNext(n) 函数的时间复杂度。</span><br><span class="line"></span><br><span class="line">时间复杂度：O(243 \cdot 3 + \log n + \log\log n + \log\log\log n)...O(243⋅3+logn+loglogn+logloglogn)... &#x3D; O(logn)。</span><br><span class="line">查找给定数字的下一个值的成本为 O(logn)，因为我们正在处理数字中的每位数字，而数字中的位数由 \log nlogn 给定。</span><br><span class="line">要计算出总的时间复杂度，我们需要仔细考虑循环中有多少个数字，它们有多大。</span><br><span class="line">我们在上面确定，一旦一个数字低于 243243，它就不可能回到 243243 以上。因此，我们就可以用 243243 以下最长循环的长度来代替 243243，不过，因为常数无论如何都无关紧要，所以我们不会担心它。</span><br><span class="line">对于高于 243243 的 nn，我们需要考虑循环中每个数高于 243243 的成本。通过数学运算，我们可以证明在最坏的情况下，这些成本将是 O(\log n) + O(\log \log n) + O(\log \log \log n)...O(logn)+O(loglogn)+O(logloglogn)...。幸运的是，O(\log n)O(logn) 是占主导地位的部分，而其他部分相比之下都很小（总的来说，它们的总和小于\log nlogn），所以我们可以忽略它们。</span><br><span class="line">空间复杂度：O(\log n)O(logn)。与时间复杂度密切相关的是衡量我们放入 HashSet 中的数字以及它们有多大的指标。对于足够大的 nn，大部分空间将由 nn 本身占用。我们可以很容易地优化到 O(243 \cdot 3) &#x3D; O(1)O(243⋅3)&#x3D;O(1)，方法是只保存集合中小于 243243 的数字，因为对于较高的数字，无论如何都不可能返回到它们。</span><br></pre></td></tr></table></figure><h2 id="方法二：快慢指针"><a href="#方法二：快慢指针" class="headerlink" title="方法二：快慢指针"></a>方法二：快慢指针</h2><ul><li><p>通过反复调用<code>getNext(n)</code> 得到的是一个<strong>隐式的链表</strong>。</p></li><li><p>隐式意味着我们没有实际的链表节点和指针，但数据仍然形成链表结构。</p></li></ul><p><strong>如果这里意识到实际上有个链表，那么可以转换成链表是否有环的问题</strong></p><ul><li><p>因此我们在这里可以使用弗洛伊德循环查找算法。这个算法是两个奔跑选手，一个跑的快，一个跑得慢。在龟兔赛跑的寓言中，跑的快的称为 “乌龟”，跑得快的称为 “兔子”。</p></li><li><p>不管乌龟和兔子在循环中从哪里开始，它们最终都会相遇。这是因为兔子每走一步就向乌龟靠近一个节点（在它们的移动方向上）。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200609/111050456.png" alt="mark"></p><p><strong>算法：</strong></p><ul><li>我们不是每次链表中的一个值，而是跟踪两个值，称为快跑者和慢跑者。</li><li>在每一步的算法中，慢速在链表中前进一个节点，快跑这前进两个节点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-202-Happy-Number&quot;&gt;&lt;a href=&quot;#Leetcode-202-Happy-Number&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-202-Happy Number&quot;&gt;&lt;/a&gt;Leetcode-202-&lt;a href=&quot;https://leetcode-cn.com/problems/happy-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Happy Number&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：&quot;&gt;&lt;a href=&quot;#思路：&quot; class=&quot;headerlink&quot; title=&quot;思路：&quot;&gt;&lt;/a&gt;思路：&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;编写一个算法来判断一个数 n 是不是快乐数。&lt;/p&gt;
&lt;p&gt;「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。&lt;/p&gt;
&lt;p&gt;如果 n 是快乐数就返回 True ；不是，则返回 False 。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12 + 92 &amp;#x3D; 82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82 + 22 &amp;#x3D; 68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62 + 82 &amp;#x3D; 100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12 + 02 + 02 &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="哈希表" scheme="http://zhuuu.work/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-108-将有序数组转换为二叉搜索树</title>
    <link href="http://zhuuu.work/2020/06/07/Leetcode/Leetcode-108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://zhuuu.work/2020/06/07/Leetcode/Leetcode-108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2020-06-07T09:52:53.000Z</published>
    <updated>2020-07-03T00:06:54.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#Leecode-108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="Leecode-108-Convert Sorted Array to Binary Search Tree"></a>Leecode-108-<a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">Convert Sorted Array to Binary Search Tree</a></h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定有序数组: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Solution：DFS</strong></p><ul><li>深度优先遍历（DFS）<ul><li>这种方法以深度<code>depth</code> 为优先策略，从根节点开始一直遍历到某个叶子节点，回到根节点，再遍历另外一个分支。</li><li>根据根节点，左孩子和右孩子的访问顺序又可以把DFS细分为 前序遍历，中序遍历，后序遍历。</li></ul></li><li><strong>这里有很重要的一点：有序数组转换成二叉搜索树的结果不唯一</strong><ul><li><strong>众所周知，二叉搜索树的中序遍历是一个升序序列。</strong></li><li><strong>将有序数组作为输入，可以把该问题看作根据中序遍历创建二叉搜索树</strong></li><li>中序遍历不能唯一确定一棵二叉搜索树。</li><li>先序和后序遍历不能确定一颗唯一的二叉搜索树</li><li>中序+后序，后序+先序可以唯一确定一颗二叉搜索树</li><li>因此，“有序数组 -&gt; BST”有多种答案。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200608/172631566.png" alt="mark"></p><h2 id="方法一：中序遍历（始终选择中间左边元素作为根节点）"><a href="#方法一：中序遍历（始终选择中间左边元素作为根节点）" class="headerlink" title="方法一：中序遍历（始终选择中间左边元素作为根节点）"></a>方法一：中序遍历（始终选择中间左边元素作为根节点）</h2><ul><li>方法<code>helper(left,right,nums)</code> 使用数组nums 中索引从left到right创建BST<ul><li>如果 left &gt; right ，子树中不存在元素，返回空</li><li>找出中间元素 <code>p = (left + right) &gt;&gt;&gt;1;</code></li><li>创建根节点 <code>root = TreeNode(nums[p])</code></li><li>递归创建左子树 <code>root.left = helper(left,p-1,nums)</code></li><li>递归创建右子树 <code>root.right = helper(p + 1,right)</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,nums.length - <span class="number">1</span>,nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper</span> <span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right , <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 退出递归的条件</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿到中间节点作为根节点 （左侧）</span></span><br><span class="line">        <span class="keyword">int</span> p = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// inorder traversal: left -&gt; node -&gt; right</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[p]);</span><br><span class="line">        root.left  = helper(left, p -<span class="number">1</span>,nums);</span><br><span class="line">        root.right = helper(p + <span class="number">1</span>,right,nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(N) 每个元素只访问一次</li><li>空间复杂度：O(N) 二叉搜索树空间O(<em>N</em>)，递归栈深度 O(log<em>N</em>)。</li></ul><h2 id="方法二：中序遍历：始终选择中间位置右边元素作为根节点"><a href="#方法二：中序遍历：始终选择中间位置右边元素作为根节点" class="headerlink" title="方法二：中序遍历：始终选择中间位置右边元素作为根节点"></a>方法二：中序遍历：始终选择中间位置右边元素作为根节点</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200608/173643871.png" alt="mark"></p><ul><li>道理同上一个解法，这里不再重述</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] nums;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// always choose right middle node as a root</span></span><br><span class="line">    <span class="keyword">int</span> p = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ((left + right) % <span class="number">2</span> == <span class="number">1</span>) ++p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inorder traversal: left -&gt; node -&gt; right</span></span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(nums[p]);</span><br><span class="line">    root.left = helper(left, p - <span class="number">1</span>);</span><br><span class="line">    root.right = helper(p + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.nums = nums;</span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><ul><li><p>时间复杂度：O(N)，每个元素只访问一次。</p></li><li><p>空间复杂度：O(N)，二叉搜索树空间O(N)，递归栈深度 O(logN)。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-108-Convert-Sorted-Array-to-Binary-Search-Tree&quot;&gt;&lt;a href=&quot;#Leecode-108-Convert-Sorted-Array-to-Binary-Search-Tree&quot; class=&quot;headerlink&quot; title=&quot;Leecode-108-Convert Sorted Array to Binary Search Tree&quot;&gt;&lt;/a&gt;Leecode-108-&lt;a href=&quot;https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Convert Sorted Array to Binary Search Tree&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。&lt;/p&gt;
&lt;p&gt;本题中，一个高度平衡二叉树是指一个二叉树&lt;em&gt;每个节点&lt;/em&gt; 的左右两个子树的高度差的绝对值不超过 1。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定有序数组: [-10,-3,0,5,9],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#x2F; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   -3   9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F;   &amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; -10  5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="深度优先搜索" scheme="http://zhuuu.work/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>数据库-面经</title>
    <link href="http://zhuuu.work/2020/06/05/JavaInterview/%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%9D%A2%E7%BB%8F/"/>
    <id>http://zhuuu.work/2020/06/05/JavaInterview/%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%9D%A2%E7%BB%8F/</id>
    <published>2020-06-05T02:38:38.000Z</published>
    <updated>2020-06-06T02:48:37.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库-面经"><a href="#数据库-面经" class="headerlink" title="数据库-面经"></a>数据库-面经</h1><h2 id="1-索引的本质"><a href="#1-索引的本质" class="headerlink" title="1. 索引的本质"></a>1. 索引的本质</h2><ul><li>官方的话：索引是帮助MySQL高效获取数据的排好序的数据结构</li></ul><ul><li><p>索引的数据结构</p><ul><li>二叉查找树<strong>(不使用，缺点是因为会变成一颗斜树)</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200605/110901758.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200605/110930860.png" alt="mark"></p></li></ul><ul><li>红黑树（特化二叉平衡树AVL）<ul><li>缺点：维护平衡二叉树的代价非常大，<strong>树的高度会很大</strong></li></ul></li><li>Hash表</li><li>B-Tree（）</li></ul><a id="more"></a><h2 id="2-B-树-和-B-树"><a href="#2-B-树-和-B-树" class="headerlink" title="2. B 树 和 B+树"></a>2. B 树 和 B+树</h2><h3 id="2-1-B-Tree"><a href="#2-1-B-Tree" class="headerlink" title="2.1 B-Tree"></a>2.1 B-Tree</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200605/114028488.png" alt="mark"></p><ul><li>所有的叶子节点在同一层</li><li>根节点至少有两个子女</li></ul><h3 id="2-2-B-Tree"><a href="#2-2-B-Tree" class="headerlink" title="2.2 B+Tree"></a>2.2 B+Tree</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200605/114050759.png" alt="mark"></p><ul><li><p>它是B树的变种</p></li><li><p><strong>非叶子节点没有指针，叶子节点由指针顺序相连</strong></p></li><li><p><strong>data元素放到了叶子节点去</strong></p></li><li><p>高度为3的B+ 树 根节点可以存放 16KB /( 8B + 6B) = 1170个索引</p><ul><li>对于叶子节点来说可以存放 1170 * 1170 * 16 = 2000万左右的数据</li></ul></li></ul><h2 id="3-B-树索引"><a href="#3-B-树索引" class="headerlink" title="3. B + 树索引"></a>3. B + 树索引</h2><ul><li><p>B+ 树索引的本质就是B+树在数据库中的实现</p></li><li><p>B + 索引的特点就是高扇出性，<strong>树一般高度在 2 到 4层 ，这也就是说明了查找某一个键值记录最多需要2到4次的 IO</strong></p></li><li><p><strong>B + 索引 分为 聚集索引和非聚集索引</strong></p></li><li><p>因为有<strong>双向指针</strong>的原因，所以可以<strong>快速的进行范围查找</strong></p></li></ul><p><strong>对于MyISAM来说（frm,MYD,MYI）：</strong></p><ul><li>frm 表结构</li><li>MYD 存数据</li><li>MYI  存索引</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200605/120500810.png" alt="mark"></p><p><strong>对于Innodb来说(frm ibd)：</strong></p><ul><li>frm 表结构</li><li>ibd : 数据 + 索引</li><li>innodb 表必须有逐渐，并且推荐使用整型的自增主键</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200605/120742564.png" alt="mark"></p><h3 id="3-1-聚集索引"><a href="#3-1-聚集索引" class="headerlink" title="3.1 聚集索引"></a>3.1 聚集索引</h3><ul><li><strong>聚集索引就是按照每张表的主键构造一棵B + 树，同时叶子节点存放的就是整张表的行记录（也就是说聚集索引的叶子节点称为数据页）</strong></li></ul><h3 id="3-2-非聚集索引"><a href="#3-2-非聚集索引" class="headerlink" title="3.2 非聚集索引"></a>3.2 非聚集索引</h3><h2 id="4-哈希-索引"><a href="#4-哈希-索引" class="headerlink" title="4. 哈希 索引"></a>4. 哈希 索引</h2><ul><li>对于哈希索引，数据库一般采用<strong>除法散列</strong>的方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h(k) &#x3D; k mod m</span><br><span class="line"></span><br><span class="line">解释： k个关键字映射到m个槽中</span><br></pre></td></tr></table></figure><ul><li>只对等值查找(where)有效果，对范围查找没效果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select XXX where id &#x3D; 1</span><br></pre></td></tr></table></figure><h2 id="5-联合索引"><a href="#5-联合索引" class="headerlink" title="5. 联合索引"></a>5. 联合索引</h2><h3 id="5-1-最左前缀原则"><a href="#5-1-最左前缀原则" class="headerlink" title="5.1 最左前缀原则"></a>5.1 最左前缀原则</h3><ol><li>创建表</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test(</span><br><span class="line">a INT,</span><br><span class="line">b INT,</span><br><span class="line">c INT,</span><br><span class="line">d INT,</span><br><span class="line">KEY index_abc(a,b,c)</span><br><span class="line">)ENGINE&#x3D;INNODB DEFAULT CHARSET &#x3D; utf8;</span><br></pre></td></tr></table></figure><ol start="2"><li>插入 10000 条数据</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DROP PROCEDURE IF EXISTS proc_initData;</span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE proc_initData()</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 1;</span><br><span class="line">WHILE i&lt;&#x3D;10000 DO</span><br><span class="line">    INSERT INTO test(a,b,c,d) VALUES(i,i,i,i);</span><br><span class="line">    SET i &#x3D; i+1;</span><br><span class="line">END WHILE;</span><br><span class="line">END $</span><br><span class="line">CALL proc_initData();</span><br></pre></td></tr></table></figure><p>这样就建立好了联合索引（a，b，c）</p><ol start="3"><li><strong>接下来我们来验证最左前缀原则</strong></li></ol><ul><li><p>关于explain 指令详解可以查看：[Explain指令][<a href="https://www.cnblogs.com/gomysql/p/3720123.html]" target="_blank" rel="noopener">https://www.cnblogs.com/gomysql/p/3720123.html]</a></p></li><li><p>接下来几个查询都是满足最左前缀原则的</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># a为主键，</span><br><span class="line">explain select * from test where a&lt;10 ;</span><br><span class="line"></span><br><span class="line">explain select * from test where a&lt;10 and b &lt;10;</span><br><span class="line"></span><br><span class="line">explain select * from test where a&lt;10 and b &lt;10 and c&lt;10;</span><br></pre></td></tr></table></figure><ul><li>能不能将 a，b出现顺序换一下，a，b，c出现顺序换一下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 这样也是满足最左前缀原则的</span><br><span class="line"># 原因是：即使a不是在where的最左方，但mysql优化器会判断纠正这条sql以设么样执行效率最高，最后才生成最后的计划</span><br><span class="line">explain select * from test where b&lt;10 and a &lt;10;</span><br><span class="line"></span><br><span class="line">explain select * from test where b&lt;10 and a &lt;10 and c&lt;10;</span><br></pre></td></tr></table></figure><p><strong>以上都是用到了联合索引的。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200606/104420926.png" alt="mark"></p><ul><li><strong>重点</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 不会用到索引</span><br><span class="line">explain select * from test where b&lt;10 and c &lt;10;</span><br><span class="line"># 会用到索引</span><br><span class="line">explain select * from test where a&lt;10 and c &lt;10;</span><br><span class="line"></span><br><span class="line"># 为什么 b&lt;10 and c &lt;10,没有用到索引？而 a&lt;10 and c &lt;10用到了？</span><br><span class="line"></span><br><span class="line"># 原因：当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+树会按照从左到右的原则来建立搜索树，</span><br><span class="line"># 比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name 相同再比较sex和age,最后得到检索的数据</span><br><span class="line"># 但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。</span><br><span class="line"># 比如当(张三,F)这样的数据来检索时，B+树可以用动啊name来制定搜索方向，即使下一个字段age缺失，也可以把名字等于张三的数据都找到了，然后在匹配到F的数据，这就是复杂索引的最左匹配原则</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200606/104828872.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据库-面经&quot;&gt;&lt;a href=&quot;#数据库-面经&quot; class=&quot;headerlink&quot; title=&quot;数据库-面经&quot;&gt;&lt;/a&gt;数据库-面经&lt;/h1&gt;&lt;h2 id=&quot;1-索引的本质&quot;&gt;&lt;a href=&quot;#1-索引的本质&quot; class=&quot;headerlink&quot; title=&quot;1. 索引的本质&quot;&gt;&lt;/a&gt;1. 索引的本质&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;官方的话：索引是帮助MySQL高效获取数据的排好序的数据结构&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;索引的数据结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二叉查找树&lt;strong&gt;(不使用，缺点是因为会变成一颗斜树)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200605/110901758.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200605/110930860.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;红黑树（特化二叉平衡树AVL）&lt;ul&gt;
&lt;li&gt;缺点：维护平衡二叉树的代价非常大，&lt;strong&gt;树的高度会很大&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Hash表&lt;/li&gt;
&lt;li&gt;B-Tree（）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="面经总结" scheme="http://zhuuu.work/tags/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/"/>
    
      <category term="索引优化" scheme="http://zhuuu.work/tags/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-238-除自身以外数组的乘积</title>
    <link href="http://zhuuu.work/2020/06/04/Leetcode/Leetcode-238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/"/>
    <id>http://zhuuu.work/2020/06/04/Leetcode/Leetcode-238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/</id>
    <published>2020-06-04T07:33:53.000Z</published>
    <updated>2020-06-05T01:05:23.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-238-Product-of-Array-Except-Self"><a href="#Leecode-238-Product-of-Array-Except-Self" class="headerlink" title="Leecode-238-Product of Array Except Self"></a>Leecode-238-<a href="https://leetcode-cn.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">Product of Array Except Self</a></h1><h2 id="思路：左右乘积列表"><a href="#思路：左右乘积列表" class="headerlink" title="思路：左右乘积列表"></a>思路：左右乘积列表</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个长度为 n 的整数数组 nums，</span><br><span class="line">其中 n &gt; 1，返回输出数组 output ，</span><br><span class="line">其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</span><br></pre></td></tr></table></figure><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong>题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。</p><p><strong>说明:</strong> 请<strong>不要使用除法，</strong>且在 O(<em>n</em>) 时间复杂度内完成此题。</p><p><strong>进阶：</strong><br>你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组<strong>不被视为</strong>额外空间。）</p><a id="more"></a><h2 id="方法一：左右两个列表保存前缀和后缀乘积"><a href="#方法一：左右两个列表保存前缀和后缀乘积" class="headerlink" title="方法一：左右两个列表保存前缀和后缀乘积"></a>方法一：左右两个列表保存前缀和后缀乘积</h2><p>思路： 不必将所有数字的乘积除以给定索引处的数字得到相应的答案，而是利用索引左侧所有数字的乘积和右侧所有数字的乘积（即前缀与后缀）相乘得到答案。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200605/085330808.png" alt="mark"></p><ul><li><p>对于给定索引 i，我们将使用它左边所有数字的乘积乘以右边所有数字的乘积。下面让我们更加具体的描述这个算法。</p></li><li><p>初始化两个空数组L 和 R ,对于给定的索引i ,L[i] 代表i 左侧所有数字的乘积，<code>R[i]</code> 代表的是 <code>i</code> 右侧所有数字的乘积。</p></li><li><p>我们需要用两个循环来填充 L 和 R 数组的值。对于数组 L，L[0] 应该是 1，因为第一个元素的左边没有元素。对于其他元素：<code>L[i] = L[i-1] * nums[i-1]</code>。</p></li></ul><ul><li>当 <code>R</code> 和 <code>L</code> 数组填充完成，我们只需要在输入数组上迭代，且索引 <code>i</code> 处的值为：<code>L[i] * R[i]</code>。</li></ul><p>举个例子：</p><ul><li>数组L 的形成</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200605/085545678.png" alt="mark"></p><ul><li>数组R的形成</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200605/085622095.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200605/085637517.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// L 和 R 分别表示左右两侧的乘积列表</span></span><br><span class="line">        <span class="keyword">int</span>[] L = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] R = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于索引是0的元素，因为左边没有元素，所以L[0] = 1</span></span><br><span class="line">        <span class="comment">// L[i]是索引i左侧所有元素的乘积</span></span><br><span class="line">        L[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            L[i] = nums[i - <span class="number">1</span>] * L[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于索引是 len - 1 的元素，因为右侧没有元素，所以R[len - 1] = 1</span></span><br><span class="line">        <span class="comment">// R[i] 是索引i右侧所有元素的乘积</span></span><br><span class="line">        R[len - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            R[i] = nums[i + <span class="number">1</span>] * R[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后算是前缀和后缀的乘积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            answer[i] = L[i] * R[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：O(n)。</strong>其中 N指的是数组 <code>nums</code> 的大小。预处理 <code>L</code> 和 <code>R</code> 数组以及最后的遍历计算都是 O(N)的时间复杂度。</li><li><strong>空间复杂度：O(n)。</strong> 其中 N指的是数组 <code>nums</code> 的大小。使用了 <code>L</code> 和 <code>R</code> 数组去构造答案，<code>L</code> 和 <code>R</code> 数组的长度为数组 <code>nums</code> 的大小。</li></ul><h2 id="方法二：-O-1-的空间复杂度"><a href="#方法二：-O-1-的空间复杂度" class="headerlink" title="方法二： O(1)的空间复杂度"></a>方法二： O(1)的空间复杂度</h2><p><strong>思路</strong></p><p>尽管上面的方法已经能够很好的解决这个问题，但是空间复杂度并不为常数。</p><p>由于输出数组不算 空间复杂度 ，所以我们可以想到</p><ul><li>让输出数组代替原来的L 数组</li><li>同时让R 变成一个不断更新的整型变量</li></ul><p><strong>算法思想：</strong></p><ul><li>初始化 <code>answer</code> 数组，对于给定索引 <code>i</code>，<code>answer[i]</code> 代表的是 <code>i</code> 左侧所有数字的乘积。</li><li>构造方式与之前相同，只是我们试图节省空间，先把 <code>answer</code> 作为方法一的 <code>L</code> 数组。</li><li>这种方法的唯一区别是我们没有构造R数组。而是用一个遍历来跟踪右边元素的乘积。并更新数组<code>answer[i] = answer[i] * R</code>, 同时<code>R = R*nums[i]</code>,这里的R表示的就是索引右侧数字的乘积。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200605/090333694.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 只需使用一个数组保存答案</span></span><br><span class="line">        <span class="comment">// 空间复杂度降到O(1)</span></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// answer[i]表示索引i左侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// answer[0] = 1。因为索引为 '0' 的元素左侧没有元素</span></span><br><span class="line">        answer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            answer[i] = nums[i - <span class="number">1</span>] * answer[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// R是一个整型变量，代表右侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 刚开始最后一个元素右边没有元素，R = 1</span></span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            <span class="comment">// 对于索引i ,左边的成绩是answer[i] , 右边的乘积是R</span></span><br><span class="line">            answer[i] = answer[i] * R;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// R需要包括右边所有元素的成绩，所以计算结果更新到R上</span></span><br><span class="line">            R *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-238-Product-of-Array-Except-Self&quot;&gt;&lt;a href=&quot;#Leecode-238-Product-of-Array-Except-Self&quot; class=&quot;headerlink&quot; title=&quot;Leecode-238-Product of Array Except Self&quot;&gt;&lt;/a&gt;Leecode-238-&lt;a href=&quot;https://leetcode-cn.com/problems/product-of-array-except-self/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Product of Array Except Self&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：左右乘积列表&quot;&gt;&lt;a href=&quot;#思路：左右乘积列表&quot; class=&quot;headerlink&quot; title=&quot;思路：左右乘积列表&quot;&gt;&lt;/a&gt;思路：左右乘积列表&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给你一个长度为 n 的整数数组 nums，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;其中 n &amp;gt; 1，返回输出数组 output ，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,2,3,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [24,12,8,6]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt; 请&lt;strong&gt;不要使用除法，&lt;/strong&gt;且在 O(&lt;em&gt;n&lt;/em&gt;) 时间复杂度内完成此题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进阶：&lt;/strong&gt;&lt;br&gt;你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组&lt;strong&gt;不被视为&lt;/strong&gt;额外空间。）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Docker-09-网络原理</title>
    <link href="http://zhuuu.work/2020/06/03/Docker/Docker-09-%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://zhuuu.work/2020/06/03/Docker/Docker-09-%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/</id>
    <published>2020-06-03T06:44:24.000Z</published>
    <updated>2020-06-04T09:14:54.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-09-网络原理"><a href="#Docker-09-网络原理" class="headerlink" title="Docker-09-网络原理"></a>Docker-09-网络原理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当你开始大规模使用Docker时，你会发现需要了解很多关于网络的知识。Docker作为目前最火的轻量级容器技术，有很多令人称道的功能，如Docker的镜像管理。然而，Docker同样有着很多不完善的地方，网络方面就是Docker比较薄弱的部分。因此，我们有必要深入了解Docker的网络知识，以满足更高的网络需求。本文首先介绍了Docker自身的4种网络工作方式，然后介绍一些自定义网络模式。</p><a id="more"></a><h2 id="1-理解-Docker-0"><a href="#1-理解-Docker-0" class="headerlink" title="1. 理解 Docker 0"></a>1. 理解 Docker 0</h2><ul><li>首先通过<code>ip addr</code> 查看ip环境</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200603/221802079.png" alt="mark"></p><p>可以明显的看到网络有三个地址。</p><p><strong>我们每启动一个docker 容器，docker就会给docker容器分配一个ip ，我们只要安装了docker ，就会有一个docker网卡<code>docker0</code></strong></p><ul><li><p><strong>使用的技术是evth-pair技术！（桥接模式）</strong></p><ul><li>在主机上创建一对虚拟网卡veth pair设备。veth设备总是成对出现的，它们组成了一个数据的通道，数据从一个设备进入，就会从另一个设备出来。因此，veth设备常用来连接两个网络设备</li></ul></li><li><p>Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0。另一端放在主机中，以veth65f9这样类似的名字命名，并将这个网络设备加入到docker0网桥中，可以通过brctl show命令查看。</p><ul><li>从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。</li></ul></li><li><p><strong>每启动一个容器，就会多一对网络地址</strong></p></li><li><p><strong>所以docker容器之间都是可以互相ping通的！！！</strong></p></li></ul><p><strong>示意图：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200603/224057604.png" alt="mark"></p><p><strong>结论：</strong></p><ul><li>所有的容器不指定网络的情况下，都是由docker0路由的，docker会给每一个容器分配一个可用的Ip</li><li>Docker中的所有网络都是虚拟的，这样转发的效率高。</li><li>只要容器删除，对应的网桥就没了。</li></ul><h2 id="2-使用–-link"><a href="#2-使用–-link" class="headerlink" title="2. 使用– link"></a>2. 使用– link</h2><p>接下来有个思考问题？</p><ul><li>如果宕机（或者重启），容器ip发生了变化，那么可以使用名字来访问容器吗？</li></ul><p><code># 如: 通过--link就可以解决</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P --name 服务名1 --link 服务名2 要启动的服务</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如: 通过--link就可以解决</span></span><br><span class="line">docker run -d -P --name tomcat01 --link tomcat02 tomcat</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">这样只能实现单向的联通</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>-- link</code> : 本质上就是在etc/hosts 中增加了另一个服务的映射</strong> </p></li><li><p>但是<code>-- link</code> 已经不推荐使用(Docker0 不支持容器名访问)</p></li></ul><h2 id="3-自定义网络"><a href="#3-自定义网络" class="headerlink" title="3. 自定义网络"></a>3. 自定义网络</h2><h3 id="3-1-网络模式"><a href="#3-1-网络模式" class="headerlink" title="3.1 网络模式"></a>3.1 网络模式</h3><p><strong>安装Docker时，它会自动创建三个网络，bridge（创建容器默认连接到此网络）、 none 、host</strong></p><table><thead><tr><th>网络模式</th><th>简介</th></tr></thead><tbody><tr><td>Host</td><td>容器不会虚拟自己的网卡，配置自己的Ip地址，而是使用宿主机的ip和端口</td></tr><tr><td>Bridge</td><td>此模式会为了每一个容器分配，设置IP，并将容器连接到一个docker0的虚拟网桥，通过docker0网桥连接以及iptables nat表配置与宿主机的通信</td></tr><tr><td>none</td><td>该模式关闭了容器的网络功能</td></tr><tr><td>Container</td><td>创建的容器不会创建自己的网卡，配置自己的ip，而是和一个指定的容器共享ip，端口范围</td></tr><tr><td>自定义网络</td><td>略</td></tr></tbody></table><h3 id="3-2-默认网络"><a href="#3-2-默认网络" class="headerlink" title="3.2 默认网络"></a>3.2 默认网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@server1 ~]<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">0147b8d16c64        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">2da931af3f0b        host                host                <span class="built_in">local</span></span><br><span class="line">63d31338bcd9        none                null                <span class="built_in">local</span></span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200604/144135446.png" alt="mark"></p><ul><li><p>Docker内置这三个网络，运行容器时，你可以使用该–network标志来指定容器应连接到哪些网络。</p></li><li><p>该bridge网络代表docker0 所有Docker安装中存在的网络。除非你使用该docker run –network=选项指定，否则Docker守护程序默认使用Bridge模式</p></li></ul><h3 id="3-3-自定义网络"><a href="#3-3-自定义网络" class="headerlink" title="3.3 自定义网络"></a>3.3 自定义网络</h3><ul><li><strong>建议使用自定义网桥来控制哪些容器之间可以相互通信，还可以自动DNS解析容器名称到ip地址</strong></li><li><strong>Docker提供了创建这些网络的默认网络驱动程序，你可以创建一个新的Bridge网络，Overlay或Macvlan网络</strong></li></ul><p>接下来介绍Dokcer的内置网络驱动程序。</p><ol><li><strong>Bridge</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br></pre></td></tr></table></figure><ul><li>一个bridge网络是Docker中最常用的网络类型。</li><li>桥接网络类似于默认bridge网络，但添加一些新功能并删除一些旧的能力。</li></ul><p>创建成功后结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@Zhuuu:~<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">38cf4307d18e        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">227d5be3657a        host                host                <span class="built_in">local</span></span><br><span class="line">b1ae1f4f0884        mynet               bridge              <span class="built_in">local</span></span><br><span class="line">84aeff069277        none                null                <span class="built_in">local</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">root@Zhuuu:~<span class="comment"># docker network inspect mynet</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"mynet"</span>,</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"b1ae1f4f088456d79d05194b76b69a2ecc543249bc061f5dca8cccf88cf0dd18"</span>,</span><br><span class="line">        <span class="string">"Created"</span>: <span class="string">"2020-06-04T14:50:29.74809742+08:00"</span>,</span><br><span class="line">        <span class="string">"Scope"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"bridge"</span>,</span><br><span class="line">        <span class="string">"EnableIPv6"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"IPAM"</span>: &#123;</span><br><span class="line">            <span class="string">"Driver"</span>: <span class="string">"default"</span>,</span><br><span class="line">            <span class="string">"Options"</span>: &#123;&#125;,</span><br><span class="line">            <span class="string">"Config"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"Subnet"</span>: <span class="string">"192.168.0.0/16"</span>,</span><br><span class="line">                    <span class="string">"Gateway"</span>: <span class="string">"192.168.0.1"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Internal"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Attachable"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Ingress"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"ConfigFrom"</span>: &#123;</span><br><span class="line">            <span class="string">"Network"</span>: <span class="string">""</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"ConfigOnly"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Containers"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Options"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Labels"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>测试：创建两个tomcat容器并丢入我们自己创建的网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Zhuuu:~<span class="comment"># docker run -d -P --name tomcat-net-01 --net mynet tomcat</span></span><br><span class="line">9e43abf5054091f38d76ccd85c1b7324f266920ef31576d33293faf3281c2b34</span><br><span class="line">root@Zhuuu:~<span class="comment"># docker run -d -P --name tomcat-net-02 --net mynet tomcat</span></span><br><span class="line">1ce722ed205dc443ec308665e0bffd5d9e2c148d65728c278b2f5e5aa13ac9b0</span><br></pre></td></tr></table></figure><p>再次查看：发现多出了两个容器在这个网络中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">root@Zhuuu:~<span class="comment"># docker network inspect mynet</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"mynet"</span>,</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"b1ae1f4f088456d79d05194b76b69a2ecc543249bc061f5dca8cccf88cf0dd18"</span>,</span><br><span class="line">        <span class="string">"Created"</span>: <span class="string">"2020-06-04T14:50:29.74809742+08:00"</span>,</span><br><span class="line">        <span class="string">"Scope"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"bridge"</span>,</span><br><span class="line">        <span class="string">"EnableIPv6"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"IPAM"</span>: &#123;</span><br><span class="line">            <span class="string">"Driver"</span>: <span class="string">"default"</span>,</span><br><span class="line">            <span class="string">"Options"</span>: &#123;&#125;,</span><br><span class="line">            <span class="string">"Config"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"Subnet"</span>: <span class="string">"192.168.0.0/16"</span>,</span><br><span class="line">                    <span class="string">"Gateway"</span>: <span class="string">"192.168.0.1"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Internal"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Attachable"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Ingress"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"ConfigFrom"</span>: &#123;</span><br><span class="line">            <span class="string">"Network"</span>: <span class="string">""</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"ConfigOnly"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Containers"</span>: &#123;</span><br><span class="line">            <span class="string">"1ce722ed205dc443ec308665e0bffd5d9e2c148d65728c278b2f5e5aa13ac9b0"</span>: &#123;</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"tomcat-net-02"</span>,</span><br><span class="line">                <span class="string">"EndpointID"</span>: <span class="string">"dc2f31d7e5955a2d43945b30b16f70bc017a7eb60fc5556c27ca76b579c96d6e"</span>,</span><br><span class="line">                <span class="string">"MacAddress"</span>: <span class="string">"02:42:c0:a8:00:03"</span>,</span><br><span class="line">                <span class="string">"IPv4Address"</span>: <span class="string">"192.168.0.3/16"</span>,</span><br><span class="line">                <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"9e43abf5054091f38d76ccd85c1b7324f266920ef31576d33293faf3281c2b34"</span>: &#123;</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"tomcat-net-01"</span>,</span><br><span class="line">                <span class="string">"EndpointID"</span>: <span class="string">"b18174355605a296f99d10182219e41d746da84cab390d5682f3c870e598bc4d"</span>,</span><br><span class="line">                <span class="string">"MacAddress"</span>: <span class="string">"02:42:c0:a8:00:02"</span>,</span><br><span class="line">                <span class="string">"IPv4Address"</span>: <span class="string">"192.168.0.2/16"</span>,</span><br><span class="line">                <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Options"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Labels"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>优点：<ul><li>不使用 – link 也可以让容器通过网桥互通</li><li>自定义的网络已经维护好了对应的关系</li><li>推荐使用自定义网络</li><li>不同集群之间网络是可以互相隔离的</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@Zhuuu:~<span class="comment"># docker exec -it tomcat-net-01 ping tomcat-net-02</span></span><br><span class="line">PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.125 ms</span><br><span class="line">64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.093 ms</span><br><span class="line">^Z64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.106 ms</span><br></pre></td></tr></table></figure><h3 id="3-4-自定义网络连通"><a href="#3-4-自定义网络连通" class="headerlink" title="3.4 自定义网络连通"></a>3.4 自定义网络连通</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200604/145925139.png" alt="mark"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令使用</span></span><br><span class="line">docker network connect  网卡 容器名</span><br></pre></td></tr></table></figure><p>测试</p><ol><li>在docker0上新建两个tomcat容器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Zhuuu:~<span class="comment"># docker run -d -P --name tomcat01 tomcat</span></span><br><span class="line">root@Zhuuu:~<span class="comment"># docker run -d -P --name tomcat02 tomcat</span></span><br></pre></td></tr></table></figure><ol start="2"><li>目前网络图</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200604/150159939.png" alt="mark"></p><ol start="3"><li>打通网络(tomcat02 加入到 mynet中)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect  mynet tomcat02</span><br></pre></td></tr></table></figure><p><strong>结果：将tomcat02加入到了mynet网络中（一个容器，两个ip）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@Zhuuu:~<span class="comment"># docker network connect mynet tomcat02</span></span><br><span class="line">root@Zhuuu:~<span class="comment"># docker exec -it tomcat02 ping tomcat-net-01</span></span><br><span class="line">PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.092 ms</span><br><span class="line">64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.079 ms</span><br><span class="line">64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=3 ttl=64 time=0.094 ms</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200604/150723389.png" alt="mark"></p><h2 id="4-网络实战"><a href="#4-网络实战" class="headerlink" title="4. 网络实战"></a>4. 网络实战</h2><h3 id="4-1-部署redis集群"><a href="#4-1-部署redis集群" class="headerlink" title="4.1 部署redis集群"></a>4.1 部署redis集群</h3><ul><li>分片 + 高可用 + 负载均衡</li></ul><ol><li>创建集群网络环境</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create redis --subnet 172.38.0.0/16</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200604/154127625.png" alt="mark"></p><ol start="2"><li>创建6个redis服务并修改配置文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> port <span class="keyword">in</span> $(seq 1 6);\</span><br><span class="line"><span class="keyword">do</span> \</span><br><span class="line">mkdir -p /mydata/redis/node-<span class="variable">$&#123;port&#125;</span>/conf</span><br><span class="line">touch /mydata/redis/node-<span class="variable">$&#123;port&#125;</span>/conf/redis.conf</span><br><span class="line">cat &lt;&lt; EOF &gt;/mydata/redis/node-<span class="variable">$&#123;port&#125;</span>/conf/redis.conf</span><br><span class="line">port 6379</span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">cluster-announce-ip 172.38.0.1<span class="variable">$&#123;port&#125;</span></span><br><span class="line">cluster-announce-port 6379</span><br><span class="line">cluster-announce-bus-port 16379</span><br><span class="line">appendonly yes</span><br><span class="line">EOF</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ol start="3"><li>启动6个服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 637<span class="variable">$&#123;port&#125;</span>:6379 -p 1637<span class="variable">$&#123;port&#125;</span>:16379 --name redis-<span class="variable">$&#123;port&#125;</span> \</span><br><span class="line">-v /mydata/redis/node-<span class="variable">$&#123;port&#125;</span>/data:/data \</span><br><span class="line">-v /mydata/redis/node-<span class="variable">$&#123;port&#125;</span>/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d --net redis --ip 172.38.0.0<span class="variable">$&#123;port&#125;</span> redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf; \</span><br><span class="line"></span><br><span class="line"><span class="comment"># $&#123;port&#125;就代表自身的端口号</span></span><br></pre></td></tr></table></figure><ol start="4"><li>进入redis配置集群</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入redis配置集群</span></span><br><span class="line">docker <span class="built_in">exec</span> -it redis-1 /bin/sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置集群</span></span><br><span class="line">redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1</span><br></pre></td></tr></table></figure><h3 id="4-2-SpringBoot-微服务打包Docker镜像"><a href="#4-2-SpringBoot-微服务打包Docker镜像" class="headerlink" title="4.2 SpringBoot 微服务打包Docker镜像"></a>4.2 SpringBoot 微服务打包Docker镜像</h3><ol><li>构建SpringBoot 项目</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello,朱酱酱"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>打包应用</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200604/164856776.png" alt="mark"></p><ol start="3"><li>编写dockerfile</li></ol><ul><li>在idea中装一个插件</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200604/165026808.png" alt="mark"></p><p>安装成功之后：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200604/165114532.png" alt="mark"></p><ul><li>编写dockerfile</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> *.jar /app.jar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"--server.port=8080"</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"/app.jar"</span>]</span></span><br></pre></td></tr></table></figure><ol start="4"><li>发布运行</li></ol><ul><li>只需要把生成的jar包和dockerfile放到服务器上即可</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200604/165658531.png" alt="mark"></p><ul><li>服务端构建镜像</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t zhuuu666 .</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200604/170105165.png" alt="mark"></p><ul><li>最后启动测试</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P --name testproject-web zhuuu666</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200604/171154131.png" alt="mark"></p><p><strong>搞定收工！！！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-09-网络原理&quot;&gt;&lt;a href=&quot;#Docker-09-网络原理&quot; class=&quot;headerlink&quot; title=&quot;Docker-09-网络原理&quot;&gt;&lt;/a&gt;Docker-09-网络原理&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;当你开始大规模使用Docker时，你会发现需要了解很多关于网络的知识。Docker作为目前最火的轻量级容器技术，有很多令人称道的功能，如Docker的镜像管理。然而，Docker同样有着很多不完善的地方，网络方面就是Docker比较薄弱的部分。因此，我们有必要深入了解Docker的网络知识，以满足更高的网络需求。本文首先介绍了Docker自身的4种网络工作方式，然后介绍一些自定义网络模式。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Docker" scheme="http://zhuuu.work/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.8源码-12-PriorityQueue</title>
    <link href="http://zhuuu.work/2020/06/03/jdk_SourceCode/JDK1.8-12-PriorityQueue/"/>
    <id>http://zhuuu.work/2020/06/03/jdk_SourceCode/JDK1.8-12-PriorityQueue/</id>
    <published>2020-06-03T05:33:53.000Z</published>
    <updated>2020-06-04T01:53:50.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK1-8源码-12-PriorityQueue"><a href="#JDK1-8源码-12-PriorityQueue" class="headerlink" title="JDK1.8源码-12-PriorityQueue"></a>JDK1.8源码-12-PriorityQueue</h1><h2 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h2><p><strong>写在前面：请把我的博客中关于 二叉堆的数据结构看了再来看此篇，效果会增倍！！！</strong></p><p>之前的文章中，我们有介绍过动态数组ArrayList，双向队列LinkedList，键值对集合HashMap，树集TreeMap。</p><p>他们各自有各自的优点，</p><ul><li><strong>ArrayList动态扩容</strong>，数组实现查询非常快但要求连续内存空间</li><li><strong>双向队列LinkedList</strong>  不需要像ArrayList一样连续的内存空间，他们以链表的形式连接各个节点的，但是查询的效率特别低。</li><li><strong>HashMap存放的是键值对</strong>，内部使用数组加链表的形式实现，检索快但是由于是按照Hash值进行存储，所以无序，在有些情况下不合适。</li><li><strong>TreeMap</strong> 使用了优化的排序二叉树（红黑树）进行逻辑实现，物理实现使用一个静态内部类Entry 代表一个树节点，这是一个完全有序的结构，但是每个树节点都需要保存一个父节点的引用，左右孩子节点引用，还有一个value值，虽然效率高但是开销很大。</li></ul><p>今天我们将要介绍的PriorityQueue优先队列，更多的可以理解为是上述所有集合实现的一种折中的结构，它逻辑上使用堆结构（完全二叉树实现），物理上使用动态数组实现，并非像TreeMap一样完全有序，但是如果按照指定方式出队，结果依然是有序的。本篇就将详细谈谈该结构的内部实现。</p><a id="more"></a><h2 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1. 构造函数"></a>1. 构造函数</h2><p> 在实际介绍PriorityQueue原理之前，再次啰嗦PriorityQueue的内部结构。</p><ul><li>PriorityQueue中的元素在逻辑上构成了<strong>一棵完全二叉树</strong></li><li>PriorityQueue实际存储时是一个<strong>数组类型</strong></li><li>PriorityQueue <strong>继承了接口Queue ，表明这是一个队列</strong>，只是它并不像普通队列（如LinkedList）在遍历输出时候简单的按照顺序从头到尾输出</li><li>PriorityQueue 总是先输出根节点的值，然后调整树使它继续成为一棵完全二叉树，每次输出根节点总是整个树优先级最高的，要么数值最小要么数值最大。</li></ul><p>在PriorityQueue的内部，主要有以下<strong>结构属性</strong>构成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认用于存储节点信息的数组大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于存储节点信息的数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组中实际存放元素的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部比较器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于记录修改次数的变量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>堆这种数据结构主要分为两种，大根堆和小根堆</strong>，而我们每次调整结构都是按照某种规则比较两个元素值的大小，然后调整堆的结构。，这里我们就需要用到比较器。（所以构建一个PriorityQueue 实例主要还是<strong>初始化数组容量和Comparator 比较器</strong>，而在PriorityQueue 中主要有以下几种构造器）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>主要构造器有上述四种，前三种在内部会调用最后一个构造器</strong></li><li><strong>两个参数：</strong><ul><li>一个指定要初始化数组的容量，</li><li>一个则用于初始化一个比较器</li><li>（如果没有显示的指定他们的值，默认初始化容量<code>DEFAULT_INITIAL_CAPACITY（11)</code>, 比较器传入的是<code>null</code>）</li></ul></li></ol><p>下面我们看获取到PriorityQueue实例之后，如何向其中添加和删除节点却一样保持原堆结构不变。</p><h2 id="2-优先队列的增删改查"><a href="#2-优先队列的增删改查" class="headerlink" title="2. 优先队列的增删改查"></a>2. 优先队列的增删改查</h2><h3 id="2-1-增加"><a href="#2-1-增加" class="headerlink" title="2.1 增加"></a>2.1 增加</h3><p><strong>add(E e) 和 offer(E e) 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际上add方法的内部调用的还是offer方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> offer(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要看看offer是如何实现添加一个元素到堆结构中并维持这种结构不被破坏的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">// 首先收取queue中实际存放元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> i = size;</span><br><span class="line">        <span class="comment">// 如果数组已经被完全使用了（没有空间了）</span></span><br><span class="line">        <span class="comment">// 调用grow方法进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">            grow(i + <span class="number">1</span>);</span><br><span class="line">        size = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 接着判断该完全二叉树是否为空，</span></span><br><span class="line">        <span class="comment">// 如果没有任何节点，那么直接将新增节点作为根节点即可</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            queue[<span class="number">0</span>] = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 否则会调用siftUp添加新元素并调整结构，这个是整个插入最重点的地方</span></span><br><span class="line">            siftUp(i, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果原数组较小则会扩大两倍</span></span><br><span class="line"><span class="comment">// 否则增加百分之50</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = queue.length;</span><br><span class="line">        <span class="comment">// Double size if small; else grow by 50%</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">                                         (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">                                         (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><code>siftUp(int k, E x)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此处会根据调用者是否传入比较器而分为两种情况，代码类似，我们只看一种即可。</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        siftUpUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUpComparable(k, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 首先获取父节点的索引</span></span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 拿到父节点对应索引的值</span></span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        <span class="comment">// 如果新增的节点值和父节点的值比较之后满足堆结构,就break直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 否则循环向上交换，最终完成堆结构的调整</span></span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后再换，优化了复杂度</span></span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体我们通过一个实例演示整个过程：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200603/170555189.png" alt="mark"></p><ul><li>首先初始化一个小根堆，加入我们现在要添加一个新元素的值是5，根据<code>siftUpUsingComparator</code>方法的代码，此时参数 k 是 6， 对应最后一个节点父元素的索引是 2 （即索引是2的节点），然后 e 的值就是11</li><li>通过比较器判断5是否小于e , 如果小于则说明需要调整结构，那么将最后一个节点值用父节点e的值进行取代，也就是以下的流程。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200603/171109204.png" alt="mark"></p><ul><li>再次进入循环，发现<code>parent</code>的值是 <code>（2-1）/2=0</code> ,比较器比较索引是0的节点和我们需要的新插入的节点（值是5），发现3小于5，则break跳出循环</li><li>最后将<code>queue[k] = x</code></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200603/171113531.png" alt="mark"></p><h3 id="2-2-删除"><a href="#2-2-删除" class="headerlink" title="2.2 删除"></a>2.2 删除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = indexOf(o);</span><br><span class="line">        <span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            removeAt(i);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用的是以下removeAt(i) 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert i &gt;= 0 &amp;&amp; i &lt; size;</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">// 拿到最后一个元素的索引</span></span><br><span class="line">        <span class="keyword">int</span> s = --size;</span><br><span class="line">        <span class="comment">// 首先该方法会获取到最后一个节点的索引并判断删除元素是否为最后一个节点，</span></span><br><span class="line">        <span class="comment">// 如果是则直接删除即可。</span></span><br><span class="line">        <span class="keyword">if</span> (s == i) <span class="comment">// removed last element</span></span><br><span class="line">            queue[i] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果删除索引不是最后一个位置</span></span><br><span class="line">            <span class="comment">// 先拿到最后一个节点的值并把它删除</span></span><br><span class="line">            E moved = (E) queue[s];</span><br><span class="line">            queue[s] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 调整堆的结构</span></span><br><span class="line">            siftDown(i, moved);</span><br><span class="line">            <span class="comment">// 调整完成之后，会判断queue[i] == moved</span></span><br><span class="line">            <span class="keyword">if</span> (queue[i] == moved) &#123;</span><br><span class="line">                siftUp(i, moved);</span><br><span class="line">                <span class="keyword">if</span> (queue[i] != moved)</span><br><span class="line">                    <span class="keyword">return</span> moved;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>（如果向下调整过结构自然是不需要再向上调整了），如果<code>queue[i] != moved</code>值为true表示向上调整过结构，那么将会返回moved。（至于为什么要在向上调整结构之后返回moved，主要是用于迭代器使用，此处暂时不会介绍）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        siftDownUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftDownComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;)x;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;        <span class="comment">// loop while a non-leaf</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            ((Comparable&lt;? <span class="keyword">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-有序出队"><a href="#2-3-有序出队" class="headerlink" title="2.3 有序出队"></a>2.3 有序出队</h3><p><strong>peek()  poll()</strong></p><ul><li>PriorityQueue这种结构使用的是堆结构，所以它是一种不完全有序的结构，但是我们也提过，可以逐个出队来实现有序输出。下面我们看看它是如何实现的</li></ul><ul><li><strong>peek( ) 获取队列的头元素</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (size == <span class="number">0</span>) ? <span class="keyword">null</span> : (E) queue[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>poll() 获取队列的头元素并出队</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 首先判断该队中是否有元素</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 如果没有则直接返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 分别获取头元素和末节点的元素</span></span><br><span class="line">    E result = (E) queue[<span class="number">0</span>];</span><br><span class="line">    E x = (E) queue[s];</span><br><span class="line">    <span class="comment">// 删除末节点的元素</span></span><br><span class="line">    queue[s] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 从0到x 向下调整堆结构</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        siftDown(<span class="number">0</span>, x);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们看一个实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Object&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    pq.offer(<span class="number">1</span>);</span><br><span class="line">    pq.offer(<span class="number">21</span>);</span><br><span class="line">    pq.offer(<span class="number">345</span>);</span><br><span class="line">    pq.offer(<span class="number">23</span>);</span><br><span class="line">    pq.offer(<span class="number">22</span>);</span><br><span class="line">    pq.offer(<span class="number">44</span>);</span><br><span class="line">    pq.offer(<span class="number">0</span>);</span><br><span class="line">    pq.offer(<span class="number">34</span>);</span><br><span class="line">    pq.offer(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pq.peek()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(pq.poll() + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0 </span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">21 </span><br><span class="line">22 </span><br><span class="line">23 </span><br><span class="line">34 </span><br><span class="line">44 </span><br><span class="line">345</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>这里我们没有显示的传入比较器，此处会默认使用Integer的Comparator（也就是从小到大：小根堆）</li><li>如果我们需要实现大根堆，需要传递一个自定义比较器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span> <span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    pq.offer(<span class="number">1</span>);</span><br><span class="line">    pq.offer(<span class="number">21</span>);</span><br><span class="line">    pq.offer(<span class="number">345</span>);</span><br><span class="line">    pq.offer(<span class="number">23</span>);</span><br><span class="line">    pq.offer(<span class="number">22</span>);</span><br><span class="line">    pq.offer(<span class="number">44</span>);</span><br><span class="line">    pq.offer(<span class="number">0</span>);</span><br><span class="line">    pq.offer(<span class="number">34</span>);</span><br><span class="line">    pq.offer(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pq.peek()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(pq.poll() + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">345</span> </span><br><span class="line"><span class="number">44</span> </span><br><span class="line"><span class="number">34</span> </span><br><span class="line"><span class="number">23</span> </span><br><span class="line"><span class="number">22</span> </span><br><span class="line"><span class="number">21</span> </span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JDK1-8源码-12-PriorityQueue&quot;&gt;&lt;a href=&quot;#JDK1-8源码-12-PriorityQueue&quot; class=&quot;headerlink&quot; title=&quot;JDK1.8源码-12-PriorityQueue&quot;&gt;&lt;/a&gt;JDK1.8源码-12-PriorityQueue&lt;/h1&gt;&lt;h2 id=&quot;前序&quot;&gt;&lt;a href=&quot;#前序&quot; class=&quot;headerlink&quot; title=&quot;前序&quot;&gt;&lt;/a&gt;前序&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;写在前面：请把我的博客中关于 二叉堆的数据结构看了再来看此篇，效果会增倍！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前的文章中，我们有介绍过动态数组ArrayList，双向队列LinkedList，键值对集合HashMap，树集TreeMap。&lt;/p&gt;
&lt;p&gt;他们各自有各自的优点，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ArrayList动态扩容&lt;/strong&gt;，数组实现查询非常快但要求连续内存空间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;双向队列LinkedList&lt;/strong&gt;  不需要像ArrayList一样连续的内存空间，他们以链表的形式连接各个节点的，但是查询的效率特别低。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HashMap存放的是键值对&lt;/strong&gt;，内部使用数组加链表的形式实现，检索快但是由于是按照Hash值进行存储，所以无序，在有些情况下不合适。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TreeMap&lt;/strong&gt; 使用了优化的排序二叉树（红黑树）进行逻辑实现，物理实现使用一个静态内部类Entry 代表一个树节点，这是一个完全有序的结构，但是每个树节点都需要保存一个父节点的引用，左右孩子节点引用，还有一个value值，虽然效率高但是开销很大。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今天我们将要介绍的PriorityQueue优先队列，更多的可以理解为是上述所有集合实现的一种折中的结构，它逻辑上使用堆结构（完全二叉树实现），物理上使用动态数组实现，并非像TreeMap一样完全有序，但是如果按照指定方式出队，结果依然是有序的。本篇就将详细谈谈该结构的内部实现。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JDK源码分析" scheme="http://zhuuu.work/tags/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="优先队列" scheme="http://zhuuu.work/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-01-堆和二叉堆</title>
    <link href="http://zhuuu.work/2020/05/30/DataStructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-01-%E5%A0%86%E5%92%8C%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
    <id>http://zhuuu.work/2020/05/30/DataStructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-01-%E5%A0%86%E5%92%8C%E4%BA%8C%E5%8F%89%E5%A0%86/</id>
    <published>2020-05-30T10:32:24.000Z</published>
    <updated>2020-06-04T01:33:02.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构-01-堆和二叉堆"><a href="#数据结构-01-堆和二叉堆" class="headerlink" title="数据结构-01-堆和二叉堆"></a>数据结构-01-堆和二叉堆</h1><p>参考博客 ： <a href="https://www.cnblogs.com/skywang12345/p/3603935.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3603935.html</a></p><p>本章介绍二叉堆，二叉堆就是通常我们所说的数据结构中”堆”中的一种。</p><a id="more"></a><h2 id="1-堆的定义"><a href="#1-堆的定义" class="headerlink" title="1. 堆的定义"></a>1. 堆的定义</h2><ul><li><p>堆（heap） ，这里所说的堆是数据结构中的堆，而不是内存模型中的堆。</p></li><li><p><strong>堆通常可以被看做一棵树，它满足以下性质</strong></p><ul><li><strong>堆中任意节点的值总是不大于（不小于）其子节点的值</strong></li><li><strong>堆总是一个完全树</strong></li></ul></li><li><p>将任意节点不大于其子节点的堆叫做最小堆或小根堆</p></li><li><p>将任意节点不小于其子节点的堆叫做最大堆或大根堆</p></li></ul><p>常见的堆有二叉堆、左倾堆、斜堆、二项堆、斐波那契堆等等。</p><h2 id="2-二叉堆的定义"><a href="#2-二叉堆的定义" class="headerlink" title="2. 二叉堆的定义"></a>2. 二叉堆的定义</h2><p>二叉堆是完全二元树或者是近似完全二元树，它分为两种：最大堆和最小堆。</p><ul><li>最大堆：父节点的键值总是大于或者等于任何一个子节点的键值。</li><li>最小堆：父结点的键值总是小于或等于任何一个子节点的键值。</li></ul><p>示意图如下：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200603/110858045.png" alt="mark"></p><p>二叉堆一般都是通过<strong>数组</strong>来实现。数组实现的二叉堆，父节点和子节点的位置存在一定的关系。</p><ul><li>有时候，我们将”二叉堆的第一个元素”放在数组索引 0 的位置，有时候放在1的位置。当然，他们的本质一样（都是二叉堆），只是实现上稍微有一丁点区别</li><li><strong>假设”第一个元素”在数组中的索引为 0 的话</strong>，则父节点和子节点的位置关系如下：<ul><li>索引为i的左孩子的索引是 <code>（2i+1);</code></li><li>索引为i的左孩子的索引是  <code>(2i+2);</code></li><li>索引为i的父节点索引是<code>floor((i-1)/2);</code></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200603/113301481.png" alt="mark"></p><ul><li>假设”第一个元素”在数组中的索引为 1 的话，则父节点和子节点的位置关系如下：<ul><li>索引为i的左孩子的索引是 <code>(2i);</code></li><li>索引为i的左孩子的索引是 <code>(2i+1);</code></li><li>索引为i的父结点的索引是<code>floor(i/2);</code></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200603/115323001.png" alt="mark"></p><p><strong>注意：本文二叉堆的实现统统都是采用”二叉堆第一个元素在数组索引为0”的方式！</strong></p><h2 id="3-二叉堆的图文解析"><a href="#3-二叉堆的图文解析" class="headerlink" title="3. 二叉堆的图文解析"></a>3. 二叉堆的图文解析</h2><p>在前面，我们已经了解到：”最大堆”和”最小堆”是对称关系。这也意味着，了解其中之一即可。本节的图文解析是以”最大堆”来进行介绍的。</p><p>二叉堆的核心是“添加节点”和“删除节点”，理解这两个算法，二叉堆也就基本掌握了。下面对它们进行介绍。</p><h3 id="3-1-添加"><a href="#3-1-添加" class="headerlink" title="3.1 添加"></a>3.1 添加</h3><p>假设在<strong>最大堆</strong><code>[90,80,70,60,40,30,20,10,50]</code>种添加85，需要执行的步骤如下：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200603/120036286.png" alt="mark"></p><p>如上图所示，当向最大堆中添加数据时候；先将数据加入到最大堆的最后，然后尽可能把这个元素向上挪，直到挪不动位置。</p><p>将85添加到[90,80,70,60,40,30,20,10,50]中后，最大堆变成了[90,85,70,60,80,30,20,10,50,40]。</p><p><strong>最大堆的插入代码(Java语言)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 最大堆的向上调整算法(从start开始向上直到0，调整堆)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     start -- 被上调节点的起始位置(一般为数组中最后一个元素的索引)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">filterup</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = start;            <span class="comment">// 当前节点(current)的位置</span></span><br><span class="line">    <span class="keyword">int</span> p = (c-<span class="number">1</span>)/<span class="number">2</span>;          <span class="comment">// 父(parent)结点的位置 </span></span><br><span class="line">    T tmp = mHeap.get(c);     <span class="comment">// 当前节点(current)的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = mHeap.get(p).compareTo(tmp);</span><br><span class="line">        <span class="keyword">if</span>(cmp &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            mHeap.set(c, mHeap.get(p));</span><br><span class="line">            c = p;</span><br><span class="line">            p = (p-<span class="number">1</span>)/<span class="number">2</span>;   </span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后再把值换上去</span></span><br><span class="line">    mHeap.set(c, tmp);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 将data插入到二叉堆中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = mHeap.size();</span><br><span class="line"></span><br><span class="line">    mHeap.add(data);     <span class="comment">// 将"数组"插在表尾</span></span><br><span class="line">    filterup(size);        <span class="comment">// 向上调整堆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-删除"><a href="#3-2-删除" class="headerlink" title="3.2 删除"></a>3.2 删除</h3><p><code>假设从最大堆[90,85,70,60,80,30,20,10,50,40]中删除90，需要执行的步骤如下：</code></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200603/120626872.png" alt="mark"></p><p><code>从[90,85,70,60,80,30,20,10,50,40]删除90之后，最大堆变成了[85,80,70,60,40,30,20,10,50]。</code></p><p>如上图所示，当从最大堆中删除数据时候；</p><ul><li>先删除该数据，然后用最大堆中的最后一个元素插入这个空位。</li><li>接着，把这个空位尽量向下挪，直到剩余数据变成一个最大堆。</li></ul><p><strong>注意：考虑从最大堆[90,85,70,60,80,30,20,10,50,40]中删除60，执行的步骤不能单纯的用它的子节点来替换；而必须考虑到”替换后的树仍然要是最大堆”！</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200603/120823590.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 最大堆的向下调整算法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     start -- 被下调节点的起始位置(一般为0，表示从第1个开始)</span></span><br><span class="line"><span class="comment"> *     end   -- 截至范围(一般为数组中最后一个元素的索引)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">filterdown</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = start;          <span class="comment">// 当前(current)节点的位置</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">2</span>*c + <span class="number">1</span>;     <span class="comment">// 左(left)孩子的位置</span></span><br><span class="line">    T tmp = mHeap.get(c);    <span class="comment">// 当前(current)节点的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = mHeap.get(l).compareTo(mHeap.get(l+<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// "l"是左孩子，"l+1"是右孩子</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt; end &amp;&amp; cmp&lt;<span class="number">0</span>)</span><br><span class="line">            l++;        <span class="comment">// 左右两孩子中选择较大者，即mHeap[l+1]</span></span><br><span class="line">        cmp = tmp.compareTo(mHeap.get(l));</span><br><span class="line">        <span class="keyword">if</span>(cmp &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;        <span class="comment">//调整结束</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            mHeap.set(c, mHeap.get(l));</span><br><span class="line">            c = l;</span><br><span class="line">            l = <span class="number">2</span>*l + <span class="number">1</span>;   </span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;   </span><br><span class="line">    mHeap.set(c, tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 删除最大堆中的data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *      0，成功</span></span><br><span class="line"><span class="comment"> *     -1，失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remove</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果"堆"已空，则返回-1</span></span><br><span class="line">    <span class="keyword">if</span>(mHeap.isEmpty() == <span class="keyword">true</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取data在数组中的索引</span></span><br><span class="line">    <span class="keyword">int</span> index = mHeap.indexOf(data);</span><br><span class="line">    <span class="keyword">if</span> (index==-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = mHeap.size();</span><br><span class="line">    mHeap.set(index, mHeap.get(size - <span class="number">1</span>));   <span class="comment">// 用最后元素填补</span></span><br><span class="line">    mHeap.remove(size - <span class="number">1</span>);                <span class="comment">// 删除最后的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mHeap.size() &gt; <span class="number">1</span>)</span><br><span class="line">        filterdown(index, mHeap.size()-<span class="number">1</span>);    <span class="comment">// 从index号位置开始自上向下调整为最大堆</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-完整源码"><a href="#4-完整源码" class="headerlink" title="4. 完整源码"></a>4. 完整源码</h2><ul><li>最大堆的实现（MaxHeap.java）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Heap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉堆(最大堆) 实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; mHeap;    <span class="comment">// 队列(实际上是动态数组ArrayList的实例)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mHeap = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 最大堆的向下调整算法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 参数说明：</span></span><br><span class="line"><span class="comment">     *     start -- 被下调节点的起始位置(一般为0，表示从第1个开始)</span></span><br><span class="line"><span class="comment">     *     end   -- 截至范围(一般为数组中最后一个元素的索引)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">filterdown</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = start;       <span class="comment">// 当前节点的位置</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">2</span>*c + <span class="number">1</span>;     <span class="comment">// 左孩子的位置</span></span><br><span class="line">        T tmp = mHeap.get(c);<span class="comment">// 当前节点的大小</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = mHeap.get(l).compareTo(mHeap.get(l + <span class="number">1</span>));</span><br><span class="line">            <span class="comment">// "l"是左孩子，"l+1"是右孩子</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (l &lt; end &amp;&amp; cmp &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                l ++;   <span class="comment">// 左右两孩子中选择较大者，即mHeap[l+1]</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cmp = tmp.compareTo(mHeap.get(l));</span><br><span class="line">            <span class="keyword">if</span> (cmp &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                mHeap.set(c,mHeap.get(l));  <span class="comment">// 用数组最后一个元素放到该位置</span></span><br><span class="line">                c = l;              <span class="comment">// 索引变为其父节点</span></span><br><span class="line">                l = <span class="number">2</span>*l + <span class="number">1</span>;        <span class="comment">// 父节点变为原子节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mHeap.set(c,tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 删除最大堆中的data</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 返回值：</span></span><br><span class="line"><span class="comment">    *      0，成功</span></span><br><span class="line"><span class="comment">    *     -1，失败</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remove</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果"堆"已空，则返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(mHeap.isEmpty() == <span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取data在数组中的索引</span></span><br><span class="line">        <span class="keyword">int</span> index = mHeap.indexOf(data);</span><br><span class="line">        <span class="keyword">if</span> (index==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size = mHeap.size();</span><br><span class="line">        mHeap.set(index, mHeap.get(size-<span class="number">1</span>));    <span class="comment">// 用最后元素填补</span></span><br><span class="line">        mHeap.remove(size - <span class="number">1</span>);           <span class="comment">// 删除最后的元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mHeap.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            filterdown(index, mHeap.size()-<span class="number">1</span>);    <span class="comment">// 从index号位置开始自上向下调整为最小堆</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 最大堆的向上调整算法(从start开始向上直到0，调整堆)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     start -- 被上调节点的起始位置(一般为数组中最后一个元素的索引)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">filterup</span><span class="params">(<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = start;          <span class="comment">// 当前节点的位置</span></span><br><span class="line">        <span class="keyword">int</span> p = (c - <span class="number">1</span>)/<span class="number">2</span>;      <span class="comment">// 父节点的位置</span></span><br><span class="line">        T tmp = mHeap.get(c);   <span class="comment">// 当前索引对应的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (c &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = mHeap.get(p).compareTo(tmp);</span><br><span class="line">            <span class="keyword">if</span> (cmp &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                mHeap.set(c,mHeap.get(p));</span><br><span class="line">                c = p;</span><br><span class="line">                p = (p - <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mHeap.set(c,tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将data插入到二叉堆中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = mHeap.size();</span><br><span class="line"></span><br><span class="line">        mHeap.add(data);  <span class="comment">// 首先将元素插到数组末尾</span></span><br><span class="line">        filterup(size);    <span class="comment">// 向上调整堆</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mHeap.size(); i++) &#123;</span><br><span class="line">            sb.append(mHeap.get(i) + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试用例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> a[] = &#123;<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">60</span>, <span class="number">90</span>, <span class="number">70</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">80</span>&#125;;</span><br><span class="line">        MaxHeap&lt;Integer&gt; tree = <span class="keyword">new</span> MaxHeap&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"== 依次添加: "</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">            tree.insert(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"\n== 最 大 堆: %s"</span>, tree);</span><br><span class="line"></span><br><span class="line">        i=<span class="number">85</span>;</span><br><span class="line">        tree.insert(i);</span><br><span class="line">        System.out.printf(<span class="string">"\n== 添加元素: %d"</span>, i);</span><br><span class="line">        System.out.printf(<span class="string">"\n== 最 大 堆: %s"</span>, tree);</span><br><span class="line"></span><br><span class="line">        i=<span class="number">90</span>;</span><br><span class="line">        tree.remove(i);</span><br><span class="line">        System.out.printf(<span class="string">"\n== 删除元素: %d"</span>, i);</span><br><span class="line">        System.out.printf(<span class="string">"\n== 最 大 堆: %s"</span>, tree);</span><br><span class="line">        System.out.printf(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最小堆的实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Heap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉堆(最小堆)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; mHeap;        <span class="comment">// 存放堆的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mHeap = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 最小堆的向下调整算法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 参数说明：</span></span><br><span class="line"><span class="comment">     *     start -- 被下调节点的起始位置(一般为0，表示从第1个开始)</span></span><br><span class="line"><span class="comment">     *     end   -- 截至范围(一般为数组中最后一个元素的索引)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">filterdown</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = start;          <span class="comment">// 当前(current)节点的位置</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">2</span>*c + <span class="number">1</span>;     <span class="comment">// 左(left)孩子的位置</span></span><br><span class="line">        T tmp = mHeap.get(c);    <span class="comment">// 当前(current)节点的大小</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = mHeap.get(l).compareTo(mHeap.get(l+<span class="number">1</span>));</span><br><span class="line">            <span class="comment">// "l"是左孩子，"l+1"是右孩子</span></span><br><span class="line">            <span class="keyword">if</span>(l &lt; end &amp;&amp; cmp&gt;<span class="number">0</span>)</span><br><span class="line">                l++;        <span class="comment">// 左右两孩子中选择较小者，即mHeap[l+1]</span></span><br><span class="line"></span><br><span class="line">            cmp = tmp.compareTo(mHeap.get(l));</span><br><span class="line">            <span class="keyword">if</span>(cmp &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;        <span class="comment">//调整结束</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                mHeap.set(c, mHeap.get(l));</span><br><span class="line">                c = l;</span><br><span class="line">                l = <span class="number">2</span>*l + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mHeap.set(c, tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 最小堆的删除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 返回值：</span></span><br><span class="line"><span class="comment">     *     成功，返回被删除的值</span></span><br><span class="line"><span class="comment">     *     失败，返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remove</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果"堆"已空，则返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(mHeap.isEmpty() == <span class="keyword">true</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取data在数组中的索引</span></span><br><span class="line">        <span class="keyword">int</span> index = mHeap.indexOf(data);</span><br><span class="line">        <span class="keyword">if</span> (index==-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size = mHeap.size();</span><br><span class="line">        mHeap.set(index, mHeap.get(size-<span class="number">1</span>));   <span class="comment">// 用最后元素填补</span></span><br><span class="line">        mHeap.remove(size - <span class="number">1</span>);                <span class="comment">// 删除最后的元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mHeap.size() &gt; <span class="number">1</span>)</span><br><span class="line">            filterdown(index, mHeap.size() - <span class="number">1</span>);    <span class="comment">// 从index号位置开始自上向下调整为最小堆</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 最小堆的向上调整算法(从start开始向上直到0，调整堆)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 参数说明：</span></span><br><span class="line"><span class="comment">     *     start -- 被上调节点的起始位置(一般为数组中最后一个元素的索引)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">filterup</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = start;            <span class="comment">// 当前节点(current)的位置</span></span><br><span class="line">        <span class="keyword">int</span> p = (c-<span class="number">1</span>)/<span class="number">2</span>;          <span class="comment">// 父(parent)结点的位置</span></span><br><span class="line">        T tmp = mHeap.get(c);     <span class="comment">// 当前节点(current)的大小</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = mHeap.get(p).compareTo(tmp);</span><br><span class="line">            <span class="keyword">if</span>(cmp &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                mHeap.set(c, mHeap.get(p));</span><br><span class="line">                c = p;</span><br><span class="line">                p = (p-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后再把值换上去</span></span><br><span class="line">        mHeap.set(c, tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 将data插入到二叉堆中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = mHeap.size();</span><br><span class="line"></span><br><span class="line">        mHeap.add(data);       <span class="comment">// 将"数组"插在表尾</span></span><br><span class="line">        filterup(size);        <span class="comment">// 向上调整堆</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mHeap.size(); i++)</span><br><span class="line">            sb.append(mHeap.get(i) +<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> a[] = &#123;<span class="number">80</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">60</span>, <span class="number">90</span>, <span class="number">70</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">20</span>&#125;;</span><br><span class="line">        MinHeap&lt;Integer&gt; tree=<span class="keyword">new</span> MinHeap&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"== 依次添加: "</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;a.length; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">            tree.insert(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"\n== 最 小 堆: %s"</span>, tree);</span><br><span class="line"></span><br><span class="line">        i=<span class="number">15</span>;</span><br><span class="line">        tree.insert(i);</span><br><span class="line">        System.out.printf(<span class="string">"\n== 添加元素: %d"</span>, i);</span><br><span class="line">        System.out.printf(<span class="string">"\n== 最 小 堆: %s"</span>, tree);</span><br><span class="line"></span><br><span class="line">        i=<span class="number">10</span>;</span><br><span class="line">        tree.remove(i);</span><br><span class="line">        System.out.printf(<span class="string">"\n== 删除元素: %d"</span>, i);</span><br><span class="line">        System.out.printf(<span class="string">"\n== 最 小 堆: %s"</span>, tree);</span><br><span class="line">        System.out.printf(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><ul><li>最大堆(MaxHeap.java)的运行结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">== 依次添加: <span class="number">10</span> <span class="number">40</span> <span class="number">30</span> <span class="number">60</span> <span class="number">90</span> <span class="number">70</span> <span class="number">20</span> <span class="number">50</span> <span class="number">80</span> </span><br><span class="line">== 最 大 堆: <span class="number">90</span> <span class="number">80</span> <span class="number">70</span> <span class="number">60</span> <span class="number">40</span> <span class="number">30</span> <span class="number">20</span> <span class="number">10</span> <span class="number">50</span> </span><br><span class="line">== 添加元素: <span class="number">85</span></span><br><span class="line">== 最 大 堆: <span class="number">90</span> <span class="number">85</span> <span class="number">70</span> <span class="number">60</span> <span class="number">80</span> <span class="number">30</span> <span class="number">20</span> <span class="number">10</span> <span class="number">50</span> <span class="number">40</span> </span><br><span class="line">== 删除元素: <span class="number">90</span></span><br><span class="line">== 最 大 堆: <span class="number">85</span> <span class="number">80</span> <span class="number">70</span> <span class="number">60</span> <span class="number">40</span> <span class="number">30</span> <span class="number">20</span> <span class="number">10</span> <span class="number">50</span></span><br></pre></td></tr></table></figure><ul><li>最小堆(MinHeap.java)的运行结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">== 最 小 堆: <span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">50</span> <span class="number">90</span> <span class="number">70</span> <span class="number">40</span> <span class="number">80</span> <span class="number">60</span> </span><br><span class="line">== 添加元素: <span class="number">15</span></span><br><span class="line">== 最 小 堆: <span class="number">10</span> <span class="number">15</span> <span class="number">30</span> <span class="number">50</span> <span class="number">20</span> <span class="number">70</span> <span class="number">40</span> <span class="number">80</span> <span class="number">60</span> <span class="number">90</span> </span><br><span class="line">== 删除元素: <span class="number">10</span></span><br><span class="line">== 最 小 堆: <span class="number">15</span> <span class="number">20</span> <span class="number">30</span> <span class="number">50</span> <span class="number">90</span> <span class="number">70</span> <span class="number">40</span> <span class="number">80</span> <span class="number">60</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构-01-堆和二叉堆&quot;&gt;&lt;a href=&quot;#数据结构-01-堆和二叉堆&quot; class=&quot;headerlink&quot; title=&quot;数据结构-01-堆和二叉堆&quot;&gt;&lt;/a&gt;数据结构-01-堆和二叉堆&lt;/h1&gt;&lt;p&gt;参考博客 ： &lt;a href=&quot;https://www.cnblogs.com/skywang12345/p/3603935.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/skywang12345/p/3603935.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本章介绍二叉堆，二叉堆就是通常我们所说的数据结构中”堆”中的一种。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="堆" scheme="http://zhuuu.work/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.8源码-11-Comparable和Comparator</title>
    <link href="http://zhuuu.work/2020/05/30/jdk_SourceCode/JDK1.8-11-Comparable%E5%92%8CComparator%20-%20%E5%89%AF%E6%9C%AC/"/>
    <id>http://zhuuu.work/2020/05/30/jdk_SourceCode/JDK1.8-11-Comparable%E5%92%8CComparator%20-%20%E5%89%AF%E6%9C%AC/</id>
    <published>2020-05-30T05:33:53.000Z</published>
    <updated>2020-06-03T01:21:54.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK1-8源码-11-Comparable和Comparator"><a href="#JDK1-8源码-11-Comparable和Comparator" class="headerlink" title="JDK1.8源码-11-Comparable和Comparator"></a>JDK1.8源码-11-Comparable和Comparator</h1><h2 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h2><p>本文，先<strong>介绍Comparable 和 Comparator两个接口</strong>，以及他们的差异；接着，通过示例，对它们的使用方法进行说明。</p><p>他们也是所属java.lang.util包下的接口。</p><a id="more"></a><h2 id="1-Comparable"><a href="#1-Comparable" class="headerlink" title="1. Comparable"></a>1. Comparable</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><ul><li>Comparable 是排序接口。</li><li>若一个类实现了Comparable 接口，就意味着“该类支持排序”。既然实现Comparable 接口的类支持排序，假设现在存在“实现Comparable 接口类的对象List列表【或者数组】”，则该列表（或数组）可以通过<code>Collections.sort(或者Arrays.sort)</code> 进行排序</li><li>此外，“实现Comparable 接口的类的对象”可以用作有序映射（如TreeMap）中的键或有序集合（TreeSet） 中的元素，而不需要指定比较器。</li></ul><h3 id="1-2-定义"><a href="#1-2-定义" class="headerlink" title="1.2 定义"></a>1.2 定义</h3><p>Comparable 接口仅仅只包括一个函数，它的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：假设我们通过 <code>x.compareTo(y)</code> 来“比较x和y的大小”。</p><ul><li>若返回负数，说明 x &lt; y</li><li>若返回 0 ，说明 x = y</li><li>若返回正数， 说明 x &gt;y</li></ul><h2 id="2-Comparator"><a href="#2-Comparator" class="headerlink" title="2. Comparator"></a>2. Comparator</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><ul><li>Comparator 是 比较器接口</li><li>若需要控制某个类的次序，而该类本身不支持排序（即没有实现Comparable接口）；那么，我们可以建立一个“该类的比较器”来进行排序。</li><li>这个比较器只需要实现Comparator 接口即可。</li><li><strong>也就是说，我们通过实现Comparator 类来新建了一个比较器，然后通过这个比较器对类进行排序</strong></li></ul><h3 id="2-2-定义"><a href="#2-2-定义" class="headerlink" title="2.2 定义"></a>2.2 定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><p>若一个类要实现Comparator 接口，它一定要实现<code>compareTo(T o1, T o2)</code> 函数，但是可以不实现<code>equals(Object obj)</code>函数。</p><ul><li>为什么可以不用实现<code>equals(Object obj)</code> 函数呢？因为任何类，默认都是已经实现了<code>equals(Object obj)</code>的。Java中所有的类都是继承于<code>java.lang.Object</code>,在Object.java中实现了<code>equals(Object obj)</code> 函数；所以，其他所有的类也相当于实现了这个函数。</li></ul></li><li><p><code>int compare(T o1, T o2)</code> 是比较o1 和 o2 的大小</p><ul><li>若返回负数，说明o1 &lt; o2</li><li>若返回0，说明 o1 = o2</li><li>若返回正数，说明 o1 &gt; o2</li></ul></li></ul><h2 id="3-Comparator-和-Comparable-比较"><a href="#3-Comparator-和-Comparable-比较" class="headerlink" title="3. Comparator 和 Comparable 比较"></a>3. Comparator 和 Comparable 比较</h2><ul><li><strong>Comparable 是排序接口；若一个类实现了Comparable接口，就意味着“该类支持排序”。</strong></li><li><strong>Comparator 是比较器，若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。</strong></li><li>不难发现，Comparable  相当于内部比较器，Comparator 相当于外部比较器</li></ul><p>我们通过一个测试程序来对这两个接口进行说明。源码如下：</p><h3 id="3-1-Comparable-使用"><a href="#3-1-Comparable-使用" class="headerlink" title="3.1 Comparable 使用"></a>3.1 Comparable 使用</h3><ol><li><strong>Person类定义</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Person实现了Comparable接口，这意味着Person本身支持排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  实现 “Comparable&lt;String&gt;” 的接口，即重写compareTo&lt;T t&gt;函数。</span></span><br><span class="line">    <span class="comment">//  这里是通过“person的名字”进行比较的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name.compareTo(person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较两个Person是否相等：若它们的name和age都相等，则认为它们相等</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.age == person.age &amp;&amp; <span class="keyword">this</span>.name == person.name)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>Person 类代表一个人，Person类中有两个属性：age(年纪) 和 name“人名”。</li><li><strong>Person 类实现了Comparable接口，因此它能被排序。</strong></li></ul><ol start="2"><li><strong>在main()函数中，我们创建Person的数组（list）</strong> </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建ArrayList(动态数组)</span></span><br><span class="line">List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加对象到ArrayList中</span></span><br><span class="line">list.add(<span class="keyword">new</span> Person(<span class="string">"ccc"</span>, <span class="number">20</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Person(<span class="string">"AAA"</span>, <span class="number">30</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Person(<span class="string">"bbb"</span>, <span class="number">10</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Person(<span class="string">"ddd"</span>, <span class="number">40</span>));</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>接着我们打印list全部元素</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印list的原始序列</span></span><br><span class="line">System.out.printf(<span class="string">"Original sort, list:%s\n"</span>, list);</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>然后，我们通过Collections的sort()函数，对list进行排序</strong></li></ol><ul><li>由于Person类实现了<code>Comparable</code>接口，因此通过sort()排序的时候，会根据Person 支持的排序方式，即<code>compareTo(Person peron)</code> 所定义的规则进行排序，如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对list进行排序</span></span><br><span class="line"><span class="comment">// 这里会根据“Person实现的Comparable&lt;String&gt;接口”进行排序，</span></span><br><span class="line"><span class="comment">// 即会根据“name”进行排序</span></span><br><span class="line">Collections.sort(list);</span><br><span class="line">System.out.printf(<span class="string">"Name sort, list:%s\n"</span>, list);</span><br></pre></td></tr></table></figure><h3 id="3-2-Comparator-使用"><a href="#3-2-Comparator-使用" class="headerlink" title="3.2 Comparator 使用"></a>3.2 Comparator 使用</h3><ol><li>我们定义了两个比较器 <strong><em>AscAgeComparator</em></strong> 和 <strong><em>DescAgeComparator</em></strong>，来分别对Person进行 <strong>升序</strong> 和 <strong>降低</strong> 排序。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> AscAgeComparator比较器</span></span><br><span class="line"><span class="comment"> *       它是“Person的age的升序比较器”</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AscAgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.getAge() - p2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> DescAgeComparator比较器</span></span><br><span class="line"><span class="comment"> *       它是“Person的age的升序比较器”</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DescAgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p2.getAge() - p1.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>通过自定义比较器AscAgeComparator 对list按照年龄升序排序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过“比较器(AscAgeComparator)”，对list进行排序</span></span><br><span class="line">Collections.sort(list,<span class="keyword">new</span> AscAgeComparator());</span><br><span class="line">System.out.printf(<span class="string">"Asc(age)  sort, list:%s\n"</span>, list);</span><br></pre></td></tr></table></figure><ol start="3"><li>通过自定义比较器DescAgeComparator 对list按照年龄降序排序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过“比较器(DescAgeComparator)”，对list进行排序</span></span><br><span class="line">Collections.sort(list,<span class="keyword">new</span> DescAgeComparator());</span><br><span class="line">System.out.printf(<span class="string">"Desc(age) sort, list:%s\n"</span>, list);</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Original  sort, list:[ccc - <span class="number">20</span>, AAA - <span class="number">30</span>, bbb - <span class="number">10</span>, ddd - <span class="number">40</span>]</span><br><span class="line">Name      sort, list:[AAA - <span class="number">30</span>, bbb - <span class="number">10</span>, ccc - <span class="number">20</span>, ddd - <span class="number">40</span>]</span><br><span class="line">Asc(age)  sort, list:[bbb - <span class="number">10</span>, ccc - <span class="number">20</span>, AAA - <span class="number">30</span>, ddd - <span class="number">40</span>]</span><br><span class="line">Desc(age) sort, list:[ddd - <span class="number">40</span>, AAA - <span class="number">30</span>, ccc - <span class="number">20</span>, bbb - <span class="number">10</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JDK1-8源码-11-Comparable和Comparator&quot;&gt;&lt;a href=&quot;#JDK1-8源码-11-Comparable和Comparator&quot; class=&quot;headerlink&quot; title=&quot;JDK1.8源码-11-Comparable和Comparator&quot;&gt;&lt;/a&gt;JDK1.8源码-11-Comparable和Comparator&lt;/h1&gt;&lt;h2 id=&quot;前序&quot;&gt;&lt;a href=&quot;#前序&quot; class=&quot;headerlink&quot; title=&quot;前序&quot;&gt;&lt;/a&gt;前序&lt;/h2&gt;&lt;p&gt;本文，先&lt;strong&gt;介绍Comparable 和 Comparator两个接口&lt;/strong&gt;，以及他们的差异；接着，通过示例，对它们的使用方法进行说明。&lt;/p&gt;
&lt;p&gt;他们也是所属java.lang.util包下的接口。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JDK源码分析" scheme="http://zhuuu.work/tags/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="比较器" scheme="http://zhuuu.work/tags/%E6%AF%94%E8%BE%83%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-347-前K个高频元素</title>
    <link href="http://zhuuu.work/2020/05/29/Leetcode/Leetcode-347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"/>
    <id>http://zhuuu.work/2020/05/29/Leetcode/Leetcode-347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</id>
    <published>2020-05-29T07:52:53.000Z</published>
    <updated>2020-05-30T07:37:58.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-347-Top-K-Frequent-Elements"><a href="#Leecode-347-Top-K-Frequent-Elements" class="headerlink" title="Leecode-347-Top K Frequent Elements"></a>Leecode-347-<a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">Top K Frequent Elements</a></h1><h2 id="思路：堆"><a href="#思路：堆" class="headerlink" title="思路：堆"></a>思路：堆</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非空的整数数组，返回其中出现频率前 <strong>k</strong>高的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</span><br><span class="line">输出: [1,2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [1], k &#x3D; 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure><ul><li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li><li>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</li><li>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</li><li>你可以按任意顺序返回答案。</li></ul><a id="more"></a><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>这里题目描述中对时间复杂度做出了要求 ，需要在 O(n log n)的限制。</li></ul><p><strong>Solution : 粗暴排序法</strong></p><ul><li>最简单粗暴的思路就是 <strong>使用排序算法对元素按照频率由高到低进行排序</strong>，然后再取前 k 个元素。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200530/150737778.png" alt="mark"></p><ul><li>可以发现，使用常规的诸如冒泡，选择，甚至快速排序都不满足要求，它们的时间复杂度要求必须优于O(nlogn)</li></ul><ul><li><p><strong>时间复杂度：O(nlogn)</strong>，n 表示数组长度。首先，遍历一遍数组统计元素的频率，这一系列操作的时间复杂度是 O(n)；接着，排序算法时间复杂度为 O(nlogn)；因此整体时间复杂度为 O(nlogn)。</p></li><li><p><strong>空间复杂度：O（n）</strong> ，需要Map来存储n个键值对</p></li></ul><p><strong>接下来我们介绍遇到TopK问题最常用的方法：最大堆或者最小堆</strong></p><p><strong>本题使用的是最小堆</strong></p><p><strong>Solution : 最小堆</strong></p><ul><li>题目最终需要返回的是前k个频率最大的元素。可以想到借助堆这种数据结构，对于k频率之后的元素不用再去处理，进一步优化时间复杂度</li><li>举个例子：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200530/151221418.png" alt="mark"></p><p>具体的操作流程为：</p><ul><li><p>借助<strong>哈希表</strong>来建立数字和其出现次数之间的映射，遍历一遍数组统计元素的频率</p></li><li><p>维护一个元素数目是 k 的最小堆</p></li><li><p>每次都将新的元素和堆顶元素（堆中频率最小的元素）进行比较</p></li><li><p>如果新的元素频率比堆顶的元素大，则淡出堆顶的元素，将新的元素添加进堆中</p></li><li><p>最终，堆中的K个元素就是前 k 个高频元素。</p></li></ul><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><strong>Solution :</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 统计每个元素出现的次数，元素为键，元素出现的次数为值</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计每个元素出现的次数，元素为键，元素出现的次数为值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(num))&#123;</span><br><span class="line">                map.put(num,map.get(num) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(num,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造最小堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a, Integer b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> map.get(a) - map.get(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次将新的元素和堆顶元素（堆中频率最小的元素）进行比较</span></span><br><span class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &lt; k)&#123;</span><br><span class="line">                pq.add(key);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (map.get(key) &gt; map.get(pq.peek()))&#123;</span><br><span class="line">                pq.remove();</span><br><span class="line">                pq.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出最小堆中的元素</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty())&#123;</span><br><span class="line">            res.add(pq.remove());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-347-Top-K-Frequent-Elements&quot;&gt;&lt;a href=&quot;#Leecode-347-Top-K-Frequent-Elements&quot; class=&quot;headerlink&quot; title=&quot;Leecode-347-Top K Frequent Elements&quot;&gt;&lt;/a&gt;Leecode-347-&lt;a href=&quot;https://leetcode-cn.com/problems/top-k-frequent-elements/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Top K Frequent Elements&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：堆&quot;&gt;&lt;a href=&quot;#思路：堆&quot; class=&quot;headerlink&quot; title=&quot;思路：堆&quot;&gt;&lt;/a&gt;思路：堆&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个非空的整数数组，返回其中出现频率前 &lt;strong&gt;k&lt;/strong&gt;高的元素。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: nums &amp;#x3D; [1,1,1,2,2,3], k &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: nums &amp;#x3D; [1], k &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [1]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ul&gt;
&lt;li&gt;你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。&lt;/li&gt;
&lt;li&gt;你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。&lt;/li&gt;
&lt;li&gt;题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。&lt;/li&gt;
&lt;li&gt;你可以按任意顺序返回答案。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="TopK算法题" scheme="http://zhuuu.work/tags/TopK%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Docker-08-DockerFile-实战测试</title>
    <link href="http://zhuuu.work/2020/05/29/Docker/Docker-08-DockerFile-%E5%AE%9E%E6%88%98%E6%B5%8B%E8%AF%95/"/>
    <id>http://zhuuu.work/2020/05/29/Docker/Docker-08-DockerFile-%E5%AE%9E%E6%88%98%E6%B5%8B%E8%AF%95/</id>
    <published>2020-05-29T06:44:24.000Z</published>
    <updated>2020-05-30T05:04:03.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-08-DockerFile-实战测试"><a href="#Docker-08-DockerFile-实战测试" class="headerlink" title="Docker-08-DockerFile-实战测试"></a>Docker-08-DockerFile-实战测试</h1><h2 id="1-构建自己的centos"><a href="#1-构建自己的centos" class="headerlink" title="1. 构建自己的centos"></a>1. 构建自己的centos</h2><p>docker hub centos: <a href="https://hub.docker.com/_/centos" target="_blank" rel="noopener">https://hub.docker.com/_/centos</a></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200529/145634229.png" alt="mark"></p><a id="more"></a><ol><li>我们可以看到的是：官方的镜像很多命令都是没有的（压缩版本）</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200529/150243099.png" alt="mark"></p><ol start="2"><li>于是我们构建自己的centos (编写dockerfile文件)：</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200529/150648287.png" alt="mark"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MAINTAINER zhuuu&lt;353446503@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line"></span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line"></span><br><span class="line">CMD echo "----end----"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><ol start="3"><li>通过文件构建镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker bulild -f dockerfile文件路径 -t 镜像名:[tag] .</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200529/151230887.png" alt="mark"></p><ol start="4"><li>进入查看是否构建成功</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker  run -it mycentos:0.2</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200529/151459510.png" alt="mark"></p><ul><li>工作目录设置成功</li><li>ifconfig 安装成功</li></ul><ol start="5"><li>查看构建历史</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker history ID</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200529/151812072.png" alt="mark"></p><h2 id="2-构建自己的Tomcat"><a href="#2-构建自己的Tomcat" class="headerlink" title="2. 构建自己的Tomcat"></a>2. 构建自己的Tomcat</h2><ol><li>准备镜像文件 <ul><li>tomcat 压缩包  </li><li>jdk 压缩包</li></ul></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200530/093714924.png" alt="mark"></p><ol start="2"><li>编写Dockerfile ,官方命令<code>Dockerfile</code> ，build会自动寻找这个文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">MAINTAINER zhuuu&lt;353446503@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ADD jdk-8u11-linux-x64.tar.gz /usr/<span class="built_in">local</span>/</span><br><span class="line">ADD apache-tomcat-8.5.51.tar.gz /usr/<span class="built_in">local</span>/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/<span class="built_in">local</span></span><br><span class="line"></span><br><span class="line">WORKDIR <span class="variable">$MYPATH</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ENV JAVA_HOME /usr/<span class="built_in">local</span>/jdk1.8.0_11</span><br><span class="line"></span><br><span class="line">ENV CLASSPATH <span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ENV CATALINA_HOME /usr/<span class="built_in">local</span>/apache-tomcat-8.5.51</span><br><span class="line">ENV CATALINA_BASH /usr/<span class="built_in">local</span>/apache-tomcat-8.5.51</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$CATALINA_HOME</span>/lib:<span class="variable">$CATALINA_HOME</span>/bin</span><br><span class="line"></span><br><span class="line">EXPOSE  8080</span><br><span class="line"> </span><br><span class="line">CMD /usr/<span class="built_in">local</span>/apache-tomcat-8.5.51/bin/startup.sh &amp;&amp; tail -F /usr/<span class="built_in">local</span>/apache-tomcat-8.5.51/bin/logs/catalina.out</span><br></pre></td></tr></table></figure><ol start="3"><li>构建镜像</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t mytomcat .</span><br><span class="line">## 因为取名字为dockerfile ,所有不需要指定文件</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200530/094950118.png" alt="mark"></p><ol start="4"><li>启动镜像</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9090:8080 --name ZhuuuTomcat03 -v /home/Zhuuu/build/tomcat/<span class="built_in">test</span>:/usr/<span class="built_in">local</span>/apache-tomcat-8.5.51/webapps/<span class="built_in">test</span> -v/home/Zhuuu/build/tomcat/tomcatlogs/:/usr/<span class="built_in">local</span>/apache-tomcat-8.5.51/logs diytomcat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">8e0776e9f68fda3a6cf909193d990f6f4f0bcc84153af41e6db819f890f9fd11</span><br></pre></td></tr></table></figure><p>并且测试tomcat是否启动：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200530/121133726.png" alt="mark"></p><ol start="5"><li>发布项目（在本地发布就可以）</li></ol><ul><li>这里配置了卷，所以本地和镜像内是同步的。</li></ul><ul><li>web.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"3.1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-发布自己的镜像"><a href="#3-发布自己的镜像" class="headerlink" title="3. 发布自己的镜像"></a>3. 发布自己的镜像</h2><h3 id="3-1-Dockerhub"><a href="#3-1-Dockerhub" class="headerlink" title="3.1 Dockerhub"></a>3.1 Dockerhub</h3><ul><li>官网： <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a> </li><li>国内的Docker hub : <a href="https://www.daocloud.io/mirror" target="_blank" rel="noopener">https://www.daocloud.io/mirror</a></li><li>注册自己的账号</li></ul><ol><li>登录自己的docker hub</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@Zhuuu:/home/Zhuuu/build/tomcat/<span class="built_in">test</span>/WEB-INF<span class="comment"># docker login --help</span></span><br><span class="line"></span><br><span class="line">Usage:docker login [OPTIONS] [SERVER]</span><br><span class="line"></span><br><span class="line">Log <span class="keyword">in</span> to a Docker registry.</span><br><span class="line">If no server is specified, the default is defined by the daemon.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -p, --password string   Password</span><br><span class="line">      --password-stdin    Take the password from stdin</span><br><span class="line">  -u, --username string   Username</span><br><span class="line">root@Zhuuu:/home/Zhuuu/build/tomcat/<span class="built_in">test</span>/WEB-INF<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200530/123252478.png" alt="mark"></p><ol start="2"><li>提交镜像</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker push zhuuu/diytomcat:1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker push 名字/容器名:版本号</span></span><br></pre></td></tr></table></figure><p>可以发现出现了问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Zhuuu:/home/Zhuuu/build/tomcat/<span class="built_in">test</span>/WEB-INF<span class="comment"># docker push zhuuu/diytomcat:1.0</span></span><br><span class="line">The push refers to repository [docker.io/zhuuu/diytomcat]</span><br><span class="line">An image does not exist locally with the tag: zhuuu/diytomcat</span><br></pre></td></tr></table></figure><p>解决方法：docker tag 打上标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Zhuuu:/home/Zhuuu/build/tomcat/<span class="built_in">test</span>/WEB-INF<span class="comment"># docker tag ac9db0881fda zhuuu/tomcat:1.0</span></span><br><span class="line">root@Zhuuu:/home/Zhuuu/build/tomcat/<span class="built_in">test</span>/WEB-INF<span class="comment"># docker push zhuuu/tomcat:1.0</span></span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200530/123910348.png" alt="mark"></p><h3 id="3-2-阿里云镜像"><a href="#3-2-阿里云镜像" class="headerlink" title="3.2 阿里云镜像"></a>3.2 阿里云镜像</h3><ul><li>登录阿里云，找到容器镜像服务</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200530/124208361.png" alt="mark"></p><ul><li>创建命名空间</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200530/124413608.png" alt="mark"></p><ul><li>创建镜像仓库</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200530/124522866.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200530/124556500.png" alt="mark"></p><p><strong>好了 ，这就创建成功了</strong></p><ul><li>操作指南</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200530/124712412.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-08-DockerFile-实战测试&quot;&gt;&lt;a href=&quot;#Docker-08-DockerFile-实战测试&quot; class=&quot;headerlink&quot; title=&quot;Docker-08-DockerFile-实战测试&quot;&gt;&lt;/a&gt;Docker-08-DockerFile-实战测试&lt;/h1&gt;&lt;h2 id=&quot;1-构建自己的centos&quot;&gt;&lt;a href=&quot;#1-构建自己的centos&quot; class=&quot;headerlink&quot; title=&quot;1. 构建自己的centos&quot;&gt;&lt;/a&gt;1. 构建自己的centos&lt;/h2&gt;&lt;p&gt;docker hub centos: &lt;a href=&quot;https://hub.docker.com/_/centos&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://hub.docker.com/_/centos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200529/145634229.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Docker" scheme="http://zhuuu.work/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker-07-DockerFile</title>
    <link href="http://zhuuu.work/2020/05/27/Docker/Docker-07-DockerFile/"/>
    <id>http://zhuuu.work/2020/05/27/Docker/Docker-07-DockerFile/</id>
    <published>2020-05-27T04:44:24.000Z</published>
    <updated>2020-06-03T09:57:40.210Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-07-DockerFile"><a href="#Docker-07-DockerFile" class="headerlink" title="Docker-07-DockerFile"></a>Docker-07-DockerFile</h1><p>官网文档：<a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/</a></p><p>参考博客：<a href="https://www.cnblogs.com/edisonchou/p/dockerfile_inside_introduction.html" target="_blank" rel="noopener">https://www.cnblogs.com/edisonchou/p/dockerfile_inside_introduction.html</a></p><p>​                    <a href="https://www.cnblogs.com/panwenbin-logs/p/8007348.html" target="_blank" rel="noopener">https://www.cnblogs.com/panwenbin-logs/p/8007348.html</a></p><a id="more"></a><h2 id="1-什么是DockerFile"><a href="#1-什么是DockerFile" class="headerlink" title="1. 什么是DockerFile?"></a>1. 什么是DockerFile?</h2><ul><li><p>在Docker中创建镜像最常用的方式就是使用DockerFile。</p></li><li><p>DockerFile 是一个Docker 镜像的描述文件，可以理解成火箭发射的A、B、C、D…的步骤。</p></li><li><p><strong>Dockerfile是一个包含用于组合映像的命令的文本文档。可以使用在命令行中调用任何命令。 Docker通过读取<code>Dockerfile</code>中的指令自动生成映像。</strong></p></li><li><p>利用 <code>docker build</code>命令用于从Dockerfile 中构建镜像。可以在  <code>docker build</code> 命令中使用 -f 标志指向文件系统中任何位置的Dockerfile。</p></li></ul><p>一个Dockerfile的示例如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基于centos镜像</span></span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line"><span class="comment">#维护人的信息</span></span><br><span class="line">MAINTAINER The CentOS Project &lt;303323496@qq.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装httpd软件包</span></span><br><span class="line">RUN yum -y update</span><br><span class="line">RUN yum -y install httpd</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启80端口</span></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"><span class="comment">#复制网站首页文件至镜像中web站点下</span></span><br><span class="line">ADD index.html /var/www/html/index.html</span><br><span class="line"></span><br><span class="line"><span class="comment">#复制该脚本至镜像中，并修改其权限</span></span><br><span class="line">ADD run.sh /run.sh</span><br><span class="line">RUN chmod 775 /run.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#当启动容器时执行的脚本文件</span></span><br><span class="line">CMD [<span class="string">"/run.sh"</span>]</span><br></pre></td></tr></table></figure><p>由上可知：DockerFile 结构大致分为以下四个部分：</p><ul><li>基础镜像信息</li><li>维护者信息</li><li>镜像操作指令</li><li>容器启动时执行指令</li></ul><p>Dockerfile每行支持一条指令，每条指令可带多个参数，支持使用以#号开头的注释。下面会对上面使用到的一些常用指令做一些介绍。</p><h2 id="2-DockerFile-常用指令"><a href="#2-DockerFile-常用指令" class="headerlink" title="2. DockerFile 常用指令"></a>2. DockerFile 常用指令</h2><p>首先，来一张通俗易懂的<strong>全景图</strong>：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200528/223153968.png" alt="mark"></p><p>Docker以<strong>从上到下的顺序运行Dockerfile的指令</strong>。为了指定基本映像，第一条指令必须是<em>FROM</em>。一个声明以<code>＃</code>字符开头则被视为注释。可以在Docker文件中使用<code>RUN</code>，<code>CMD</code>，<code>FROM</code>，<code>EXPOSE</code>，<code>ENV</code>等指令。</p><ol><li><strong>FROM ： 指定基础镜像，必须是第一个指令</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">　　FROM &lt;image&gt;</span><br><span class="line">　　FROM &lt;image&gt;:&lt;tag&gt;</span><br><span class="line">　　FROM &lt;image&gt;@&lt;digest&gt;</span><br><span class="line">　　示例：　　FROM mysql:5.6</span><br><span class="line">　　</span><br><span class="line">　　注：　　tag或digest是可选的，如果不使用这两个值时，会使用latest版本的基础镜像</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>MAINTAINER:维护者信息</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    MAINTAINER &lt;name&gt;</span><br><span class="line">示例：</span><br><span class="line">    MAINTAINER Zhuuu</span><br><span class="line">    MAINTAINER zhuuu@163.com</span><br><span class="line">    MAINTAINER Zhuuu &lt;zhuuu@163.com&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>RUN: 构建镜像时执行的命令</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RUN用于在镜像容器中执行命令，其有以下两种命令执行方式：</span><br><span class="line">shell执行</span><br><span class="line">格式：</span><br><span class="line">    RUN &lt;command&gt;</span><br><span class="line">    </span><br><span class="line">exec执行</span><br><span class="line">格式：</span><br><span class="line">    RUN ["executable", "param1", "param2"]</span><br><span class="line">示例：</span><br><span class="line">    RUN ["executable", "param1", "param2"]</span><br><span class="line">    RUN apk update</span><br><span class="line">    RUN ["/etc/execfile", "arg1", "arg1"]</span><br><span class="line">注：　　RUN指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定--no-cache参数，如：docker build --no-cache</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>ADD:将本地文件添加到容器中，tar类型文件会自动解压（网络压缩资源不会被解压），可以访问网络资源，类似于wget</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    ADD &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">    ADD ["&lt;src&gt;",... "&lt;dest&gt;"] 用于支持包含空格的路径</span><br><span class="line">示例：</span><br><span class="line">    ADD hom* /mydir/          # 添加所有以"hom"开头的文件</span><br><span class="line">    ADD hom?.txt /mydir/      # ? 替代一个单字符,例如："home.txt"</span><br><span class="line">    ADD test relativeDir/     # 添加 "test" 到 `WORKDIR`/relativeDir/</span><br><span class="line">    ADD test /absoluteDir/    # 添加 "test" 到 /absoluteDir/</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>COPY：功能类似ADD，但是是不会自动解压文件，也不能访问网络资源</strong></li></ol><ol start="6"><li><strong>CMD:构建容器后调用，也就是在容器启动时候才进行调用</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    CMD ["executable","param1","param2"] (执行可执行文件，优先)</span><br><span class="line">    CMD ["param1","param2"] (设置了ENTRYPOINT，则直接调用ENTRYPOINT添加参数)</span><br><span class="line">    CMD command param1 param2 (执行shell内部命令)</span><br><span class="line">示例：</span><br><span class="line">    CMD echo "This is a test." | wc -</span><br><span class="line">    CMD ["/usr/bin/wc","--help"]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    注： 　　CMD不同于RUN，CMD用于指定在容器启动时所要执行的命令，而RUN用于指定镜像构建时所要执行的命令。</span><br></pre></td></tr></table></figure><ol start="7"><li><strong>ENTRYPOINT:配置容器，使其可执行化。配合CMD可省去“application”,只使用参数</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    ENTRYPOINT ["executable", "param1", "param2"] (可执行文件, 优先)</span><br><span class="line">    ENTRYPOINT command param1 param2 (shell内部命令)</span><br><span class="line">示例：</span><br><span class="line">    FROM ubuntu</span><br><span class="line">    ENTRYPOINT ["top", "-b"]</span><br><span class="line">    CMD ["-c"]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    注：</span><br><span class="line">    ENTRYPOINT与CMD非常类似，不同的是通过docker run执行的命令不会覆盖ENTRYPOINT，</span><br><span class="line">    而docker run命令中指定的任何参数，都会被当做参数再次传递给ENTRYPOINT。Dockerfile中只允许有一个ENTRYPOINT命令，多指定时会覆盖前面的设置，而只执行最后的ENTRYPOINT指令。</span><br></pre></td></tr></table></figure><p><strong>CMD和 ENTRYPOINT 区别：</strong></p><ul><li>CMD：多个CMD会覆盖前面一个，只会执行最后一个CMD命令</li><li>ENTRYPOINT ： 可以追加后面的参数</li></ul><ol start="8"><li><strong>LABEL：用于为镜像添加元数据</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span><br><span class="line">示例：</span><br><span class="line">　　LABEL version="1.0" description="这是一个Web服务器" by="IT笔录"</span><br><span class="line">注：</span><br><span class="line">　　使用LABEL指定元数据时，一条LABEL指定可以指定一或多条元数据，指定多条元数据时不同元数据之间通过空格分隔。推荐将所有的元数据通过一条LABEL指令指定，以免生成过多的中间镜像。</span><br></pre></td></tr></table></figure><p><strong>9. ENV: 设置环境变量</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    ENV &lt;key&gt; &lt;value&gt;  #&lt;key&gt;之后的所有内容均会被视为其&lt;value&gt;的组成部分，因此，一次只能设置一个变量</span><br><span class="line">    ENV &lt;key&gt;=&lt;value&gt; ...  #可以设置多个变量，每个变量为一个"&lt;key&gt;=&lt;value&gt;"的键值对，如果&lt;key&gt;中包含空格，可以使用\来进行转义，也可以通过""来进行标示；另外，反斜线也可以用于续行</span><br><span class="line">示例：</span><br><span class="line">    ENV myName John Doe</span><br><span class="line">    ENV myDog Rex The Dog</span><br><span class="line">    ENV myCat=fluffy</span><br></pre></td></tr></table></figure><ol start="10"><li><strong>EXPOSE：指定于外界交互的端口</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    EXPOSE &lt;port&gt; [&lt;port&gt;...]</span><br><span class="line">示例：</span><br><span class="line">    EXPOSE 80 443</span><br><span class="line">    EXPOSE 8080    EXPOSE 11211/tcp 11211/udp</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    注：</span><br><span class="line">    EXPOSE并不会让容器的端口访问到主机。</span><br><span class="line">    要使其可访问，需要在docker run运行容器时通过-p来发布这些端口，或通过-P参数来发布EXPOSE导出的所有端口</span><br></pre></td></tr></table></figure><ol start="11"><li><strong>VOLUME：用于指定持久化目录</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    VOLUME ["/path/to/dir"]</span><br><span class="line">示例：</span><br><span class="line">    VOLUME ["/data"]</span><br><span class="line">    VOLUME ["/var/www", "/var/log/apache2", "/etc/apache2"]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    注：　　</span><br><span class="line">    一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能：</span><br><span class="line">1 卷可以容器间共享和重用</span><br><span class="line">2 容器并不一定要和其它容器共享卷</span><br><span class="line">3 修改卷后会立即生效</span><br><span class="line">4 对卷的修改不会对镜像产生影响</span><br><span class="line">5 卷会一直存在，直到没有任何容器在使用它</span><br></pre></td></tr></table></figure><ol start="12"><li><strong>WORKDIR：工作目录，类似于cd命令</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    WORKDIR /path/to/workdir</span><br><span class="line">示例：</span><br><span class="line">    WORKDIR /a  (这时工作目录为/a)</span><br><span class="line">    WORKDIR b  (这时工作目录为/a/b)</span><br><span class="line">    WORKDIR c  (这时工作目录为/a/b/c)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    注意：</span><br><span class="line">    通过WORKDIR设置工作目录以后，</span><br><span class="line">    Dockerfile 中其后所有的命令RUN，CMD,ENTRYPOINT,ADD,COPY等命令都会在该目录下执行。</span><br><span class="line">    在使用docker run 运行容器时，可以通过-w 参数覆盖构建时所设置的工作目录</span><br></pre></td></tr></table></figure><ol start="13"><li><p><strong>USER</strong></p><p>指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户。</p><p>使用USER指定用户时，可以使用用户名、UID或GID，或是两者的组合。当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">格式:　　</span><br><span class="line">USER user　　</span><br><span class="line">USER user:group　　</span><br><span class="line">USER uid　　</span><br><span class="line">USER uid:gid　　</span><br><span class="line">USER user:gid　　</span><br><span class="line">USER uid:group</span><br><span class="line"> </span><br><span class="line"> 示例：    　　USER www</span><br><span class="line"> 注：</span><br><span class="line">　　使用USER指定用户后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT都将使用该用户。镜像构建完成后，通过docker run运行容器时，可以通过-u参数来覆盖所指定的用户。</span><br></pre></td></tr></table></figure><ol start="14"><li><strong>ARG：用于指定传递给构建运行时的变量</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    ARG &lt;name&gt;[=&lt;default value&gt;]</span><br><span class="line">示例：</span><br><span class="line">    ARG site</span><br><span class="line">    ARG build_user=www</span><br></pre></td></tr></table></figure><ol start="15"><li><strong>ONBUILD：用于设置镜像触发器</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">　　ONBUILD [INSTRUCTION]</span><br><span class="line">示例：</span><br><span class="line">　　ONBUILD ADD . /app/src</span><br><span class="line">　　ONBUILD RUN /usr/local/bin/python-build --dir /app/src</span><br><span class="line">注：</span><br><span class="line">　　当所构建的镜像被用做其它镜像的基础镜像，该镜像中的触发器将会被钥触发</span><br></pre></td></tr></table></figure><h2 id="3-综合例子"><a href="#3-综合例子" class="headerlink" title="3. 综合例子"></a>3. 综合例子</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> This my first nginx Dockerfile</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Version 1.0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Base images 基础镜像</span></span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">MAINTAINER 维护者信息</span></span><br><span class="line">MAINTAINER Zhuuu</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">ENV 设置环境变量</span></span><br><span class="line">ENV PATH /usr/local/nginx/sbin:$PATH</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">ADD  文件放在当前目录下，拷过去会自动解压</span></span><br><span class="line">ADD nginx-1.8.0.tar.gz /usr/local/  </span><br><span class="line">ADD epel-release-latest-7.noarch.rpm /usr/local/  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">RUN 执行以下命令 </span></span><br><span class="line">RUN rpm -ivh /usr/local/epel-release-latest-7.noarch.rpm</span><br><span class="line">RUN yum install -y wget lftp gcc gcc-c++ make openssl-devel pcre-devel pcre &amp;&amp; yum clean all</span><br><span class="line">RUN useradd -s /sbin/nologin -M www</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">WORKDIR 相当于<span class="built_in">cd</span></span></span><br><span class="line">WORKDIR /usr/local/nginx-1.8.0 </span><br><span class="line"></span><br><span class="line">RUN ./configure --prefix=/usr/local/nginx --user=www --group=www --with-http_ssl_module --with-pcre &amp;&amp; make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">RUN echo "daemon off;" &gt;&gt; /etc/nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">EXPOSE 映射端口</span></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">CMD 运行以下命令</span></span><br><span class="line">CMD ["nginx"]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-07-DockerFile&quot;&gt;&lt;a href=&quot;#Docker-07-DockerFile&quot; class=&quot;headerlink&quot; title=&quot;Docker-07-DockerFile&quot;&gt;&lt;/a&gt;Docker-07-DockerFile&lt;/h1&gt;&lt;p&gt;官网文档：&lt;a href=&quot;https://docs.docker.com/engine/reference/builder/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.docker.com/engine/reference/builder/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考博客：&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/dockerfile_inside_introduction.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/edisonchou/p/dockerfile_inside_introduction.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​                    &lt;a href=&quot;https://www.cnblogs.com/panwenbin-logs/p/8007348.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/panwenbin-logs/p/8007348.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Docker" scheme="http://zhuuu.work/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-041-缺失的第一个正数</title>
    <link href="http://zhuuu.work/2020/05/26/Leetcode/Leetcode-041-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/"/>
    <id>http://zhuuu.work/2020/05/26/Leetcode/Leetcode-041-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</id>
    <published>2020-05-26T06:22:53.000Z</published>
    <updated>2020-06-27T07:44:31.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-041-First-Missing-Positive"><a href="#Leecode-041-First-Missing-Positive" class="headerlink" title="Leecode-041-First Missing Positive"></a>Leecode-041-<a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">First Missing Positive</a></h1><h2 id="思路：自哈希"><a href="#思路：自哈希" class="headerlink" title="思路：自哈希"></a>思路：自哈希</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [1,2,0]</span><br><span class="line">输出: 3</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [3,4,-1,1]</span><br><span class="line">输出: 2</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: [7,8,9,11,12]</span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure><p><strong>你的算法的时间复杂度应为O(<em>n</em>)，并且只能使用常数级别的额外空间。</strong></p><p><strong>做完本题，请继续做以下题目</strong></p><p>Leetcode–041 : <a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/first-missing-positive/</a></p><p>Leetcode–442 : <a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/</a></p><p>Leetcode–448 : <a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/</a></p><a id="more"></a><p><strong>Solution：</strong></p><p>参考题解：[leetcode-041][<a href="https://leetcode-cn.com/problems/first-missing-positive/solution/tong-pai-xu-python-dai-ma-by-liweiwei1419/]" target="_blank" rel="noopener">https://leetcode-cn.com/problems/first-missing-positive/solution/tong-pai-xu-python-dai-ma-by-liweiwei1419/]</a></p><p><strong>我们来循序渐进的看这个问题</strong></p><h2 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h2><p><strong>话在前头：此方法空间复杂度不符合要求</strong></p><ul><li>按照刚才读题的思路，其实我们只需要从最小的正整数1开始，依次判断2，3，4直到数组长度N是否在数组中。</li><li>如果当前考虑的数不在这个数组中，我们就找到了这个最小正整数。</li><li>由于我们需要依次判断某一个正整数是否在这个数组中，我们可以先把这个数组中所有的元素放进哈希表。接下来在遍历的时候，就能以O(1) 的时间复杂度判断某个正整数是否在这个数组中。</li><li>由于题目要求我们<strong>只能使用常数级别的空间</strong>，而哈希表的大小与数组的长度是线性相关的，因此空间复杂度不符合题目要求。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历一遍数组，全部都放进去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再遍历一遍set，如果不存在就说明找到了那个正数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(i))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 极端情况下是最后一个元素</span></span><br><span class="line">        <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(N)  这里 N 表示数组的长度。</li><li><strong>空间复杂度</strong>：O(N)  把 N个数存在哈希表里面，使用了 N个空间。</li></ul><h2 id="方法二：排序-二分查找"><a href="#方法二：排序-二分查找" class="headerlink" title="方法二：排序 + 二分查找"></a>方法二：排序 + 二分查找</h2><p><strong>话在前头：这个方法时间复杂度不符合要求</strong></p><ul><li>根据刚才的分析，这个问题其实就是要我们查找一个元素，而查找一个元素，如果是在有序数组中查找，会快一些；</li><li>因此我们可以将<strong>数组先排序</strong>，<strong>再使用二分查找</strong>法从最小的正整数 1 开始查找，找不到就返回这个正整数；</li><li>这个思路需要先对数组排序，而排序使用的时间复杂度是 O<em>(</em>N<em>log</em>N)，是不符合这个问题的时间复杂度要求。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// 排序时间复杂度O(NlogN)</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二分查找去查找每一个正数</span></span><br><span class="line">        <span class="comment">// 二分查找时间复杂度O（logn）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="comment">// 一个一个去找</span></span><br><span class="line">            <span class="keyword">int</span> res = binarySearch(nums, i);</span><br><span class="line">            <span class="comment">// 如果没找到这个数，说明就是缺少的最小正整数</span></span><br><span class="line">            <span class="keyword">if</span> (res == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常用二分查找模板</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// JDK源码中就是这么写的</span></span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法三：自哈希"><a href="#方法三：自哈希" class="headerlink" title="方法三：自哈希"></a>方法三：自哈希</h2><p><strong>所以自哈希 ：也就是将数组自身视为哈希表</strong></p><ul><li><p>我们可以<strong>把原始的数组当做哈希表来使用，事实上，哈希表本身其实也是一个数组。</strong></p></li><li><p>我们要找的数就在 <code>[1, N + 1]</code> 里，最后 <code>N + 1</code> 这个元素我们不用找。因为在前面的 <code>N</code> 个元素都找不到的情况下，我们才返回 <code>N + 1</code>；</p></li><li><p><strong>那么我们采用这样的思路</strong></p><ul><li>1 这个数 放到下标是0的位置</li><li>2 这个数 放到下标是1的位置</li><li>。。。</li><li>按照这个思路整理一遍数组</li></ul></li><li><p>然后我们再遍历一次数组，第一个遇到它的值不等于下标的那个数，就是我们要找的确实的第一个正数。</p></li><li><p><strong>这个思想就相当于我们自己编写哈希函数，这个哈希函数的规则特别简单，那就是数值是 i 的数映射到下标为 i-1 的位置</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对数组自己做哈希：数值为i的数字映射到下标 i - 1的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= len &amp;&amp; nums[nums[i] - <span class="number">1</span>] != nums[i])&#123;</span><br><span class="line">                <span class="comment">// 满足在指定范围内，并且没有放在正确的位置上，才交换</span></span><br><span class="line">                <span class="comment">// 例如：数值3应该放在索引2的位置上</span></span><br><span class="line">                swap(nums,nums[i] - <span class="number">1</span>,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组找到缺失的最小正数</span></span><br><span class="line">        <span class="comment">// 缺失的正整数是下标 + 1（i 从0 开始）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 都正确范围数组长度 + 1</span></span><br><span class="line">        <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)<ul><li><code>while</code>循环不会每一次都把数组里面的所有元素过一遍。如果有一些元素在这一次循环中被交换到他们应该在的位置上，那么在后序的遍历中，由于他们已经在正确的位置上了，代码执行到他们的时候，就会被跳过（<strong>相当于是一个剪枝的处理）</strong></li><li>最极端的一种情况是，在第 1 个位置经过这个 while 就把所有的元素都看了一遍，这个所有的元素都被放置在它们应该在的位置，那么 for 循环后面的部分的 while 的循环体都不会被执行。</li><li>平均下来，每次元素只要被看一次就可以了。<code>while</code> 循环体被执行很多次的情况不会发生。这样的复杂度分析的方法叫做<strong>均摊复杂度分析。</strong></li></ul></li><li>空间复杂度：O(1) </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-041-First-Missing-Positive&quot;&gt;&lt;a href=&quot;#Leecode-041-First-Missing-Positive&quot; class=&quot;headerlink&quot; title=&quot;Leecode-041-First Missing Positive&quot;&gt;&lt;/a&gt;Leecode-041-&lt;a href=&quot;https://leetcode-cn.com/problems/first-missing-positive/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;First Missing Positive&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：自哈希&quot;&gt;&lt;a href=&quot;#思路：自哈希&quot; class=&quot;headerlink&quot; title=&quot;思路：自哈希&quot;&gt;&lt;/a&gt;思路：自哈希&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,2,0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [3,4,-1,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [7,8,9,11,12]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!--more--&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;你的算法的时间复杂度应为O(&lt;em&gt;n&lt;/em&gt;)，并且只能使用常数级别的额外空间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;做完本题，请继续做以下题目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Leetcode–041 : &lt;a href=&quot;https://leetcode-cn.com/problems/first-missing-positive/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/first-missing-positive/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Leetcode–442 : &lt;a href=&quot;https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Leetcode–448 : &lt;a href=&quot;https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="自哈希" scheme="http://zhuuu.work/tags/%E8%87%AA%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-287-寻找重复数字</title>
    <link href="http://zhuuu.work/2020/05/25/Leetcode/Leetcode-287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97/"/>
    <id>http://zhuuu.work/2020/05/25/Leetcode/Leetcode-287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97/</id>
    <published>2020-05-25T05:52:53.000Z</published>
    <updated>2020-06-08T14:29:16.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-287-Find-the-Duplicate-Number"><a href="#Leetcode-287-Find-the-Duplicate-Number" class="headerlink" title="Leetcode-287-Find the Duplicate Number"></a>Leetcode-287-<a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">Find the Duplicate Number</a></h1><h2 id="思路：二分法"><a href="#思路：二分法" class="headerlink" title="思路：二分法"></a>思路：二分法</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包含 <code>n + 1</code>个整数的数组nums,其数字都在1到n之间（包括1和n）</p><p>可知至少存在一个重复的整数。假设只有一个重复的数字，找出这个重复的数字。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,1,3,4,2]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li><strong>不能更改原数组（假设数组是只读的）。– &gt; 不能排序</strong></li><li><strong>只能使用额外的 O(1) 的空间。 – &gt; 不能使用set</strong></li><li><strong>时间复杂度小于 O(n^2) 。– &gt; 不能使用set</strong></li><li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li></ol><a id="more"></a><p><strong>Solution：二分法</strong></p><ul><li><p><strong>如果测试数据不在这个范围里，二分法失效</strong>。</p></li><li><p><strong>二分法的常见作用：可以用来确定一个有范围的整数</strong></p></li></ul><p>预备知识：</p><p>抽屉原理：假设要把10个苹果放进9个柜子，那么一定有一个柜子放了不止一个。</p><p>容易想到的方法有：</p><ul><li>使用哈希表判重，这违反了限制 2；</li><li>将原始数组排序，排序以后，重复的数相邻，即找到了重复数，这违反了限制 1；</li><li>使用类似「力扣」第 41 题：缺失的第一个正数 （原地哈希）的思路，当两个数发现要放在同一个地方的时候，就发现了这个重的元素，这违反了限制 1；</li><li>既然要定位数，这个数恰好是一个整数，可以在「整数的有效范围内」做二分查找，但是比较烦的一点是得反复看整个数组好几次，本题解就介绍通过二分法定位一个有范围的整数；</li><li>还可以使用「快慢指针」来完成，不过这种做法太有技巧性了，不是通用的做法，可以查看官方题解。</li></ul><p><strong>思路：</strong></p><ul><li><p>二分法的思路是先猜一个数（有效范围 <code>[left, right]</code>里的中间数 <code>mid</code>）</p></li><li><p>然后统计原始数组中<strong>小于等于</strong>这个中间数的元素的个数 count , 如果count <strong>严格大于</strong> mid ，注意我加了着重号的部分「小于等于」、「严格大于」）。</p></li><li><p>根据抽屉原理，重复的元素就在区间 <code>[left, mid]</code> 里；</p></li></ul><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><strong>Solution :</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="comment">//在 Java 里可以这么用，</span></span><br><span class="line">            <span class="comment">// 当 left + right 溢出的时候，无符号右移保证结果依然正确</span></span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每次更新 count 会被重置为0</span></span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 统计原始数组中小于等于这个中间数元素的个数count</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= mid)&#123;</span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据抽屉原理，count如果严格大于mid个</span></span><br><span class="line">            <span class="comment">// 此时重复元素一定在[1,mid]之间</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; mid)&#123;</span><br><span class="line">                <span class="comment">// 重复元素位于[left,mid]之间</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 重复元素位于[mid + 1, right] 之间</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// left = right 的时候推出循环，结果就是重复的数字</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：O(nlogn)</strong> - 二分法的时间复杂度是O(logn) ,并且在二分法内部执行了一次 for 循环 ，时间复杂度是O(n), 所以总的复杂度是O(nlogn)。</li><li><strong>空间复杂度O(1)</strong> : 使用了一个count变量</li></ul><p>测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">    System.out.println(solution.findDuplicate(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>&#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-287-Find-the-Duplicate-Number&quot;&gt;&lt;a href=&quot;#Leetcode-287-Find-the-Duplicate-Number&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-287-Find the Duplicate Number&quot;&gt;&lt;/a&gt;Leetcode-287-&lt;a href=&quot;https://leetcode-cn.com/problems/find-the-duplicate-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Find the Duplicate Number&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：二分法&quot;&gt;&lt;a href=&quot;#思路：二分法&quot; class=&quot;headerlink&quot; title=&quot;思路：二分法&quot;&gt;&lt;/a&gt;思路：二分法&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个包含 &lt;code&gt;n + 1&lt;/code&gt;个整数的数组nums,其数字都在1到n之间（包括1和n）&lt;/p&gt;
&lt;p&gt;可知至少存在一个重复的整数。假设只有一个重复的数字，找出这个重复的数字。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,3,4,2,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [3,1,3,4,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;不能更改原数组（假设数组是只读的）。– &amp;gt; 不能排序&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;只能使用额外的 O(1) 的空间。 – &amp;gt; 不能使用set&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;时间复杂度小于 O(n^2) 。– &amp;gt; 不能使用set&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;数组中只有一个重复的数字，但它可能不止重复出现一次。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Docker-04-命令实战练习</title>
    <link href="http://zhuuu.work/2020/05/25/Docker/Docker-04-%E5%91%BD%E4%BB%A4%E5%AE%9E%E6%88%98%E7%BB%83%E4%B9%A0/"/>
    <id>http://zhuuu.work/2020/05/25/Docker/Docker-04-%E5%91%BD%E4%BB%A4%E5%AE%9E%E6%88%98%E7%BB%83%E4%B9%A0/</id>
    <published>2020-05-25T04:44:24.000Z</published>
    <updated>2020-05-25T10:10:21.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-04-命令实战练习"><a href="#Docker-04-命令实战练习" class="headerlink" title="Docker-04-命令实战练习"></a>Docker-04-命令实战练习</h1><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200525/112944540.png" alt="mark"></p><p>镜像下载：<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p><a id="more"></a><h2 id="1-Docker-安装-Nginx"><a href="#1-Docker-安装-Nginx" class="headerlink" title="1. Docker 安装 Nginx"></a>1. Docker 安装 Nginx</h2><p><code>dockerhub-nginx:</code> <a href="https://hub.docker.com/search?q=nginx&amp;type=image" target="_blank" rel="noopener">https://hub.docker.com/search?q=nginx&amp;type=image</a></p><p>需要用到的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 搜索镜像</span></span><br><span class="line">docker search nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 下载镜像</span></span><br><span class="line">docker pull nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 开启nginx(后台运行 名字是nginx01 端口号映射 服务名称)</span></span><br><span class="line">docker run -d --name nginx01 -p:3344:80 nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 本机测试</span></span><br><span class="line">curl localhost:3344</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 进入容器</span></span><br><span class="line">docker exec -it nginx01 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6. 退出容器</span></span><br><span class="line">docker stop 容器id</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200525/121949685.png" alt="mark"></p><p><strong>端口原理分析：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200525/122230224.png" alt="mark"></p><p><strong>外网测试：（ip+port访问docker镜像）</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200525/122536548.png" alt="mark"></p><p><strong>思考问题：</strong></p><ul><li>每次配置nginx配置文件，都需要进入容器内部，那么如何在外部修改做到同步到容器内部呢？</li></ul><p>答：数据卷技术（后面会详细说明）</p><h2 id="2-Docker-安装-Tomcat"><a href="#2-Docker-安装-Tomcat" class="headerlink" title="2. Docker 安装 Tomcat"></a>2. Docker 安装 Tomcat</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 下载</span></span><br><span class="line">docker pull tomcat:9.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 启动运行</span></span><br><span class="line">docker run -d -p 3355:8080 --name tomcat01 tomcat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 出现的问题</span></span><br><span class="line">从外部访问出现404 error</span><br><span class="line">原因：阉割版本的（保证最小可运行的环境）</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 4. 解决 将webapps.dist 拷贝到 webapps目录即可</span></span></span><br></pre></td></tr></table></figure><p><strong>思考问题：</strong></p><ul><li>每次配置tomcat配置文件，都需要进入容器内部，那么如何在外部修改做到同步到容器内部呢？</li></ul><p>答：数据卷技术（后面会详细说明）(提供一个映射路径)</p><h2 id="3-Docker-部署-ES-kibana"><a href="#3-Docker-部署-ES-kibana" class="headerlink" title="3. Docker 部署 ES+kibana"></a>3. Docker 部署 ES+kibana</h2><p>官方文档：<a href="https://hub.docker.com/_/elasticsearch" target="_blank" rel="noopener">https://hub.docker.com/_/elasticsearch</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> es暴露的端口很多</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> es十分耗内存</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 下载启动</span></span><br><span class="line">docker run -d --name elasticsearch01 -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:tag</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 启动了之后发现linux卡死</span></span><br><span class="line">原因：es非常耗内存</span><br><span class="line">（docker stats） 此时可以查看docker占cpu的资源</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 修改配置增加内存限制</span></span><br><span class="line">docker run -d --name elasticsearch02 -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xmx512m" elasticsearch:tag</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 测试</span></span><br><span class="line">curl localhost:9200</span><br></pre></td></tr></table></figure><p><strong>那么问题来了 kibana一般和ES是同时使用的，既然docker的核心是进程隔离，那么我们怎么做到相互之间的通信呢？</strong></p><p>答：Docker的网络原理（通过内网转发）</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200525/180934060.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-04-命令实战练习&quot;&gt;&lt;a href=&quot;#Docker-04-命令实战练习&quot; class=&quot;headerlink&quot; title=&quot;Docker-04-命令实战练习&quot;&gt;&lt;/a&gt;Docker-04-命令实战练习&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200525/112944540.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;镜像下载：&lt;a href=&quot;https://hub.docker.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://hub.docker.com/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Docker" scheme="http://zhuuu.work/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker-05-镜像原理</title>
    <link href="http://zhuuu.work/2020/05/25/Docker/Docker-05-%E9%95%9C%E5%83%8F%E5%8E%9F%E7%90%86/"/>
    <id>http://zhuuu.work/2020/05/25/Docker/Docker-05-%E9%95%9C%E5%83%8F%E5%8E%9F%E7%90%86/</id>
    <published>2020-05-25T04:44:24.000Z</published>
    <updated>2020-05-28T10:08:50.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-05-镜像原理"><a href="#Docker-05-镜像原理" class="headerlink" title="Docker-05-镜像原理"></a>Docker-05-镜像原理</h1><h2 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h2><ol><li>什么是镜像？</li></ol><p>我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： <strong><a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></strong></p><p>我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。</p><a id="more"></a><h2 id="2-Docker镜像-加载原理"><a href="#2-Docker镜像-加载原理" class="headerlink" title="2. Docker镜像 加载原理"></a>2. Docker镜像 加载原理</h2><h3 id="2-1-联合文件系统（UnionFS）"><a href="#2-1-联合文件系统（UnionFS）" class="headerlink" title="2.1 联合文件系统（UnionFS）"></a>2.1 联合文件系统（UnionFS）</h3><ul><li>假设一个Dockerfile内容如下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:14.04</span><br><span class="line">ADD run.sh /</span><br><span class="line">VOLUME /data</span><br><span class="line">CMD [<span class="string">"./run.sh"</span>]</span><br></pre></td></tr></table></figure><ul><li>联合文件系统对应的层次图如下所示</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200527/123858608.png" alt="mark"></p><ol><li>FROM ubuntu:14.04 :设置基础镜像，此时会使用基础镜像ubuntu:14.04的所有镜像层，为简单起见，图中将其作为一个整体展示。</li><li>ADD run.sh /:将Dockerfile所在目录的文件run.sh加至镜像的根目录，此时新一层的镜像只有一项内容，即根目录下的run.sh.</li><li>VOLUME /data:设定镜像的VOLUME，此VOLUME在容器内部的路径为/data。需要注意的是，此时并未在新一层的镜像中添加任何文件，但更新了镜像的json文件，以便通过此镜像启动容器时获取这方面的信息。</li><li>CMD [“./run.sh”]:设置镜像的默认执行入口，此命令同样不会在新建镜像中添加任何文件，仅仅在上一层镜像json文件的基础上更新新建镜像的json文件。</li></ol><p><strong>总结：是一层一层的折叠上去</strong></p><p>图上顶上的两层，是Docker为Docker容器新建的内容，而<strong>这两层属于容器范畴。</strong>这两层分别为Docker容器的初始层(Init Layer)与可读写层(Read－Write Layer)。</p><ul><li>初始层<ul><li>大多是初始化容器环境的时候，与容器相关的环境信息，如容器主机名，主机host信息以及域名服务文件等。</li></ul></li><li>读写层<ul><li>Docker容器内的进程支队可读写层拥有权限，其他层对进程而言都是只读的(Read-Only)。另外，关于VOLUME以及容器的hosts、hostname、resolv.conf文件等都会挂载到这里。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200527/124242053.png" alt="mark"></p><h3 id="2-2-Commit-镜像"><a href="#2-2-Commit-镜像" class="headerlink" title="2.2 Commit 镜像"></a>2.2 Commit 镜像</h3><p>创建一个修改过的镜像</p><p><strong>docker commit :</strong>从容器创建一个新的镜像。</p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><strong>-a :</strong>提交的镜像作者；</p></li><li><p><strong>-c :</strong>使用Dockerfile指令来创建镜像；</p></li><li><p><strong>-m :</strong>提交时的说明文字；</p></li><li><p><strong>-p :</strong>在commit时，将容器暂停。</p></li></ul><p>实例</p><p>将容器a404c6c174a2  保存为新的镜像,并添加提交人信息和说明信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker commit -a &quot;Zhuuu&quot; -m &quot;my apache&quot; a404c6c174a2  mymysql:v1 </span><br><span class="line">sha256:37af1236adef1544e8886be23010b66577647a40bc02c0885a6600b33ee28057</span><br><span class="line">runoob@runoob:~$ docker images mymysql:v1</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mymysql             v1                  37af1236adef        15 seconds ago      329 MB</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p><strong>如果你想要保存当前镜像的状态，就可以通过commit进行提交</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-05-镜像原理&quot;&gt;&lt;a href=&quot;#Docker-05-镜像原理&quot; class=&quot;headerlink&quot; title=&quot;Docker-05-镜像原理&quot;&gt;&lt;/a&gt;Docker-05-镜像原理&lt;/h1&gt;&lt;h2 id=&quot;前序&quot;&gt;&lt;a href=&quot;#前序&quot; class=&quot;headerlink&quot; title=&quot;前序&quot;&gt;&lt;/a&gt;前序&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;什么是镜像？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： &lt;strong&gt;&lt;a href=&quot;https://hub.docker.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://hub.docker.com/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Docker" scheme="http://zhuuu.work/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker-06-数据卷技术</title>
    <link href="http://zhuuu.work/2020/05/25/Docker/Docker-06-%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%8A%80%E6%9C%AF/"/>
    <id>http://zhuuu.work/2020/05/25/Docker/Docker-06-%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%8A%80%E6%9C%AF/</id>
    <published>2020-05-25T04:44:24.000Z</published>
    <updated>2020-05-29T04:13:15.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-06-数据卷技术"><a href="#Docker-06-数据卷技术" class="headerlink" title="Docker-06-数据卷技术"></a>Docker-06-数据卷技术</h1><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200528/200523893.png" alt="mark"></p><a id="more"></a><h2 id="1-什么是数据卷？"><a href="#1-什么是数据卷？" class="headerlink" title="1. 什么是数据卷？"></a>1. 什么是数据卷？</h2><p>数据卷是一个可供容器使用的特殊目录，它绕过文件系统，可以提供很多有用的特性：</p><ol><li>数据卷可以在容器之间共享和重用。</li><li>对数据卷的更改会立即生效。</li><li>对数据卷的更新不会影响镜像。</li><li>数据卷会一直存在，直到没有容器使用。</li></ol><p>数据卷的使用，类似于 linux 下对目录或文件进行 mount 操作。</p><h2 id="2-使用数据卷的场景"><a href="#2-使用数据卷的场景" class="headerlink" title="2. 使用数据卷的场景"></a>2. 使用数据卷的场景</h2><ul><li><p>在多个容器之间共享数据，多个容器可以同时以只读或者读写的方式挂载同一个数据卷，从而共享数据卷中的数据。</p></li><li><p>当宿主机不能保证一定存在某个目录或一些固定路径的文件时，使用数据卷可以规避这种限制带来的问题。</p></li><li><p>当你想把容器中的数据存储在宿主机之外的地方时，比如远程主机上或云存储上。</p></li><li><p>当你需要把容器数据在不同的宿主机之间备份、恢复或迁移时，数据卷是很好的选择。</p></li></ul><h2 id="3-数据卷原理"><a href="#3-数据卷原理" class="headerlink" title="3. 数据卷原理"></a>3. 数据卷原理</h2><p>下图描述了 docker 容器挂载数据的三种方式： </p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200528/200523893.png" alt="mark"></p><p>docker数据卷的本质是容器中一个特殊目录。在容器创建过程中，docker会将宿主机上的指定目录（一个以数据卷ID为名称的目录）挂在到容器指定的目录上。这里使用的挂载方式是（bind mount），所以挂载完成后的宿主机目录和目标目录表现一致。</p><p>比如我们执行下面的命令创建数据卷 hello，并挂载到容器 testcon 的 /world 目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker volume create hello</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -id --name testcon --mount <span class="built_in">type</span>=volume,<span class="built_in">source</span>=hello,target=/world ubuntu /bin/bash</span></span><br></pre></td></tr></table></figure><p>实际上在容器的创建过程中，类似于在容器中执行了下面的代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 将数据卷 hello 在宿主机上的目录绑定挂载到 rootfs 中指定的挂载点 /world 上</span><br><span class="line">mount("/var/lib/docker/volumes/hello/_data", "rootfs/world", "none", MS_BIND, NULL)</span><br></pre></td></tr></table></figure><h2 id="4-具名挂载-匿名挂载"><a href="#4-具名挂载-匿名挂载" class="headerlink" title="4. 具名挂载 匿名挂载"></a>4. 具名挂载 匿名挂载</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如何确定是具名挂载还是匿名挂载，还是指定路径挂载</span></span><br><span class="line">-v 容器内路径        <span class="comment"># 匿名挂载</span></span><br><span class="line">-v 卷名:容器内路径   <span class="comment"># 具名挂载</span></span><br><span class="line">-v /宿主机路径:容器内路径 <span class="comment"># 指定路径挂载</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ro   read-only</span></span><br><span class="line"><span class="comment"># rw   read-write</span></span><br><span class="line"><span class="comment"># 如果设置了ro，说明只能通过外部宿主机改变容器内操作，容器内部无法操作。</span></span><br></pre></td></tr></table></figure><h2 id="5-数据卷的创建，挂载"><a href="#5-数据卷的创建，挂载" class="headerlink" title="5. 数据卷的创建，挂载"></a>5. 数据卷的创建，挂载</h2><ol><li><strong>创建随机名字的volume，并挂载到容器的/data目录(匿名挂载)</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker  run  -it  -d --name u1  -v /data  ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p><strong>说明：  在用 docker run 命令的时候，使用 -v 标记可以在容器内创建一个数据卷。多次使用 -v 标记可以创建多个数据卷</strong></p><ol start="2"><li><strong>创建命名的数据卷并挂载（具名挂载）</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">法1:</span><br><span class="line">docker volume create  u1_vol <span class="comment">#创建</span></span><br><span class="line">docker run -it -d --name u1 -v u1_vol:/data  ubuntu <span class="comment">#将数据卷u1_vol挂载到容器的/data目录</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">法2：</span><br><span class="line">直接下面这条命令会创建命名数据卷后挂载。</span><br><span class="line">docker run -it -d --name u1 -v u1_vol:/data</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>将宿主机目录 挂载到容器(指定路径挂载)</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run  -it -d  --name u1  -v /tmp:/opt  ubuntu  /bin/bash</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>将单个文件作为volume挂载到容器中.</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将当前目录下的t.txt 文件挂载为 容器的/opt/t.txt</span></span><br><span class="line">docker run  -it -d  --name u1  -v $(<span class="built_in">pwd</span>)/t.txt:/opt/t.txt  ubuntu  /bin/bash</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>挂载数据卷为只读 ro</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -d --name u1 -v u1_vol:/data:ro  ubuntu</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>使用Dockerfile 添加volume</strong> </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用VOLUME 指令向容器添加volume，与上面(1)相同</span></span><br><span class="line">VOLUME  /data</span><br><span class="line"></span><br><span class="line">VOLUME [<span class="string">"/data1"</span>,<span class="string">"/data2"</span>] <span class="comment">#添加多个</span></span><br></pre></td></tr></table></figure><p>在使用 docker build 命令生成镜像并且以该镜像启动容器时会挂载一个数据卷到 /data 目录。根据我们已知的数据覆盖规则，如果镜像中存在 /data 目录，这个目录中的内容将全部被复制到宿主机中对应的目录中，并且根据容器中的文件设置合适的权限和所有者。</p><p><strong>注意：</strong></p><ul><li><p><strong>VOLUME 指定不能挂载主机中的指定目录。这是为了保证DockerFile的一致性，因为不能保证所有的宿主机都有对应的目录。</strong></p></li><li><p>在实际的使用中，还有一个陷阱需要大家注意：<strong>在Dockerfile使用VOLUME指令之后的代码，如果尝试对这个数据卷进行修改，这些修改都不会生效</strong></p></li></ul><p>下面是一个这样的例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">RUN useradd nick</span><br><span class="line">VOLUME /data     #VOLUME添加数据卷</span><br><span class="line">RUN touch /data/test.txt   #对上面的数据卷修改是不会生效的</span><br><span class="line">RUN chown -R nick:nick /data</span><br></pre></td></tr></table></figure><p>通过这个 Dockerfile 创建镜像并启动容器后，该容器中存在用户 nick，并且能够看到 /data 目录挂载的数据卷。<strong>但是 /data 目录内并没有文件 test.txt，更别说 test.txt 文件的所有者属性了</strong>。要解释这个现象需要我们了解通过 Dockerfile 创建镜像的过程：<br>Dockerfile 中除了 FROM 指令的<strong>每一行都是基于上一行生成的临时镜像运行一个容器</strong>，执行一条指令并执行类似 docker commit 的命令得到一个新的镜像。这条类似 docker commit 的命令不会对挂载的数据卷进行保存。<br>所以上面的 Dockerfile 最后两行执行时，都会在一个临时的容器上挂载 /data，并对这个临时的数据卷进行操作，<strong>但是这一行指令执行并提交后，这个临时的数据卷并没有被保存</strong>。因而我们最终通过镜像创建的容器所挂载的数据卷是没有被最后两条指令操作过的。我们姑且叫它 “Dockerfile 中数据卷的初始化问题”。</p><p><strong>下面的写法可以解决 Dockerfile 中数据卷的初始化问题：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">RUN useradd nick</span><br><span class="line">RUN mkdir /data &amp;&amp; touch /data/test.txt</span><br><span class="line">RUN chown -R nick:nick /data</span><br><span class="line">VOLUME /data</span><br></pre></td></tr></table></figure><p>通过这个 Dockerfile 创建镜像并启动容器后，数据卷的初始化是符合预期的。这是由于在挂载数据卷时，/data 已经存在，/data 中的文件以及它们的权限和所有者设置会被复制到数据卷中。<br><strong>还有另外一种方法可以解决 Dockerfile 中数据卷的初始化问题。就是利用 CMD 指令和 ENTRYPOINT 指令的执行特点：与 RUN 指令在镜像构建过程中执行不同，CMD 指令和 ENTRYPOINT 指令是在容器启动时执行。</strong>因此使用下面的 Dockerfile 也可以达到对数据卷的初始化目的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">RUN useradd nick</span><br><span class="line">VOLUME /data</span><br><span class="line">CMD touch /data/test.txt &amp;&amp; chown -R nick:nick /data &amp;&amp; /bin/bash</span><br></pre></td></tr></table></figure><h2 id="6-数据的覆盖问题"><a href="#6-数据的覆盖问题" class="headerlink" title="6. 数据的覆盖问题"></a>6. 数据的覆盖问题</h2><ul><li>如果挂载一个空的数据卷到容器的一个非空目录中，那么这个目录下的文件会被复制到数据卷中</li><li>如果挂载一个非空的数据卷到容器的一个目录中，那么容器中的目录会显示数据卷的数据。如果原来容器中的目录有数据，那么这些原始数据会被隐藏掉</li></ul><p>总结：</p><p>灵活利用第一个规则可以帮助我们初始化数据卷中的内容。</p><p>掌握第二条规则可以保证挂载数据卷后的数据总是你期望的数据。</p><h2 id="7-共享数据卷与数据卷容器"><a href="#7-共享数据卷与数据卷容器" class="headerlink" title="7. 共享数据卷与数据卷容器"></a>7. 共享数据卷与数据卷容器</h2><p>数据卷的共享有两种方式:</p><h3 id="7-1-两个docker之间直接共享数据卷"><a href="#7-1-两个docker之间直接共享数据卷" class="headerlink" title="7.1 两个docker之间直接共享数据卷"></a>7.1 两个docker之间直接共享数据卷</h3><p><code>--volumes-from</code>:相当于继承的概念</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# docker run  -it -d  --name u1  -v share_vol:/opt   ubuntu:14.04  /bin/bash  #将数据卷share_vol挂载到容器的/opt</span><br><span class="line">7c9bcad41f3d9172699f0add3d6ba65d4a50c6ebac57fc5a042938198896e951</span><br><span class="line">root@ubuntu:~# docker run  -it -d  --name u2  --volumes-from u1  ubuntu:14.04  /bin/bash   #u2 使用u1的数据卷</span><br><span class="line">58a1a4dad1bed5372d9c30d6a8d13644f376426c1fa603de5bab5b52199a6095</span><br><span class="line">root@ubuntu:~# docker exec -it u1 /bin/bash    #在容器u1 /opt 中新建文件</span><br><span class="line">root@7c9bcad41f3d:/# cd opt/</span><br><span class="line">root@7c9bcad41f3d:/opt# echo "u1"&gt;&gt;1.txt</span><br><span class="line">root@7c9bcad41f3d:/opt# exit</span><br><span class="line">root@ubuntu:~# docker exec -it u2 /bin/bash   #容器u2与u1用的是共享数据卷，所以也能看见u1创建的文件,反之.</span><br><span class="line">root@58a1a4dad1be:/# cd opt/</span><br><span class="line">root@58a1a4dad1be:/opt# ls</span><br><span class="line">1.txt</span><br><span class="line">root@58a1a4dad1be:/opt#</span><br></pre></td></tr></table></figure><h3 id="7-2-单独创建一个数据容器，其他容器与之共享volume，推荐使用这种方式"><a href="#7-2-单独创建一个数据容器，其他容器与之共享volume，推荐使用这种方式" class="headerlink" title="7.2 单独创建一个数据容器，其他容器与之共享volume，推荐使用这种方式"></a>7.2 单独创建一个数据容器，其他容器与之共享volume，推荐使用这种方式</h3><p><code>--volumes-from</code>:相当于继承的概念</p><ul><li><p>如果用户需要在容器之间共享一些持续更新的数据，最简单的方式是使用数据卷容器。数据卷容器其实就是一个普通的容器，专门用它提供数据卷供其他容器挂载。</p></li><li><p>一个容器挂载了一个volume，即使这个容器停止运行，该volume仍然存在，其他容器也可以使用<code>--volumes-from</code> 与这个容器共享卷</p></li></ul><ol><li>创建数据卷容器，给容器挂载一个 volume后容器停止，好节约资源.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name share_docker  -v share_vol:&#x2F;data  ubuntu &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><ol start="2"><li>然后再其他容器中使用 <code>--volumes-from</code> 来挂在 share_docker 容器中的数据卷</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# docker run -it -d --name u1 --volumes-from share_docker  ubuntu /bin/bash</span><br><span class="line">fdc15fca2a7e2545b0751315797cbe8fe868b7fd37c295cff8df8189f3254e5f</span><br><span class="line">root@ubuntu:~# docker run -it -d --name u2 --volumes-from share_docker  ubuntu /bin/bash</span><br><span class="line">98e511fb3ef5e6fe3a06ac0b6aa3a97e8881ffaeb48ccb585d3b8cd92b429d1d</span><br><span class="line"></span><br><span class="line">(注意，命令中没有指定数据卷的信息，也就是说新容器中挂载数据卷的目录和源容器中是一样的。)</span><br></pre></td></tr></table></figure><h2 id="8-备份，恢复或者迁移-volume"><a href="#8-备份，恢复或者迁移-volume" class="headerlink" title="8. 备份，恢复或者迁移 volume"></a>8. 备份，恢复或者迁移 volume</h2><p>volume作为数据的载体，在很多情况下需要对其中的数据进行备份迁移。</p><p>一个很容易想到的办法是使用 docker inspect 查找到volume 在宿主机上对应的文件夹的位置，然后复制其中的内容或者打包。这种做法不推荐，推荐使用  –volumes-from来实现.</p><h3 id="8-1-备份"><a href="#8-1-备份" class="headerlink" title="8.1 备份"></a>8.1 备份</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker run --rm --volumes-from share_docker -v $(pwd):/backup ubuntu tar cvf /backup/data.tar /data</span></span><br><span class="line">/data/</span><br><span class="line">/data/2.txt</span><br><span class="line">/data/1.txt</span><br><span class="line">tar: Removing leading `/<span class="string">' from member names</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">说明：share_docker容器包含了我们希望备份的一个volume,上面这行命令启动了另外一个临时容器，这个容器挂载了两个volume，第一个volume来自 share_docker 的共享，也就是需要备份的volume。第二个volume将宿主机的当前目录挂载到临时容器的/backup目录。容器运行后要将备份内容(/data文件夹)备份到容器的/backup/data.tar.然后删除容器，备份后的data.tar就留在了宿主机的当前目录.</span></span><br></pre></td></tr></table></figure><h3 id="8-2-恢复"><a href="#8-2-恢复" class="headerlink" title="8.2 恢复"></a>8.2 恢复</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">创建需要恢复数据的目标容器：</span><br><span class="line">root@ubuntu:~<span class="comment"># docker run -it -d --name back_docker -v  back_vol:/data ubuntu /bin/bash </span></span><br><span class="line">e24b5e898c2016b7ebda93a266a351c6d9a47e6a3f828dac3c8a56cadfc0ce26</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">启动临时容器用于恢复。</span><br><span class="line">docker run --rm --volumes-from  back_docker -v $(<span class="built_in">pwd</span>):/backup ubuntu tar xvf /backup/data.tar -C /</span><br><span class="line"></span><br><span class="line">data/</span><br><span class="line">data/2.txt</span><br><span class="line">data/1.txt</span><br><span class="line">root@ubuntu:~<span class="comment"># docker exec  -it back_docker  /bin/bash  #查看发现数据恢复</span></span><br><span class="line">root@e24b5e898c20:/<span class="comment"># cd data/</span></span><br><span class="line">root@e24b5e898c20:/data<span class="comment"># ls</span></span><br><span class="line">1.txt  2.txt</span><br></pre></td></tr></table></figure><h2 id="9-使用mount语法挂载数据卷"><a href="#9-使用mount语法挂载数据卷" class="headerlink" title="9. 使用mount语法挂载数据卷"></a>9. 使用mount语法挂载数据卷</h2><p>之前我们使用 –volume(-v) 选项来挂载数据卷，现在docker提供了更强大的 –mount 选项来管理数据卷。</p><p>mount 选项可以通过逗号分割多个键值对一次提供多个配置项，因此mount 选项可以提供比volume 选项更详细的配置</p><p>使用 mount 选项的常用配置如下：</p><ul><li><strong>type</strong> 指定挂载方式，我们这里用到的是 volume，其实还可以有 bind 和 tmpfs。</li><li><strong>volume-driver</strong> 指定挂载数据卷的驱动程序，默认值是 local。</li><li><strong>source</strong> 指定挂载的源，对于一个命名的数据卷，这里应该指定这个数据卷的名称。在使用时可以写 source，也可以简写为 src。</li><li><strong>destination</strong> 指定挂载的数据在容器中的路径。在使用时可以写 destination，也可以简写为 dst 或 target。</li><li><strong>readonly</strong> 指定挂载的数据为只读。</li><li><strong>volume-opt</strong> 可以指定多次，用来提高更多的 mount 相关的配置。</li></ul><p>下面我们来看具体的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create hello</span><br><span class="line">$ docker run -id --mount <span class="built_in">type</span>=volume,<span class="built_in">source</span>=hello,target=/world ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>我们创建了名称为 hello 的数据卷，然后把它挂在到容器中的 /world 目录。通过 inspect 命令查看容器的详情中的 “Mounts” 信息可以验证实际的数据卷挂载结果.</p><ul><li><strong>使用volume driver 把数据存储到别的地方（远程）</strong></li></ul><p>除了默认的把数据卷中的数据存储在宿主机，docker 还允许我们通过指定 volume driver 的方式把数据卷中的数据存储在其它的地方，比如 Azrue Storge 或 AWS 的 S3。<br>简单起见，我们接下来的 demo 演示如何通过 vieux/sshfs 驱动把数据卷的存储在其它的主机上。</p><ol><li>docker 默认是不安装 vieux/sshfs 插件的，我们可以通过下面的命令进行安装：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker plugin install --grant-all-permissions vieux/sshfs</span><br></pre></td></tr></table></figure><ol start="2"><li>然后通过 vieux/sshfs 驱动创建数据卷，并指定远程主机的登录用户名、密码和数据存放目录：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker volume create --driver vieux/sshfs \</span><br><span class="line">    -o sshcmd=nick@39.106.171.56:/home/nick/sshvolume \</span><br><span class="line">    -o password=yourpassword \</span><br><span class="line">    mysshvolume</span><br></pre></td></tr></table></figure><p>注意，请确保你指定的远程主机上的挂载点目录是存在的(demo 中是 /home/nick/sshvolume 目录)，否则在启动容器时会报错。</p><ol start="3"><li>最后在启动容器的时候指定挂载这个数据卷：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -id \</span><br><span class="line">    --name testcon \</span><br><span class="line">    --mount type=volume,volume-driver=vieux/sshfs,source=mysshvolume,target=/world \</span><br><span class="line">    ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>你在容器中 /world 目录下操作的文件都存储在远程主机的 /home/nick/sshvolume 目录中。进入容器testcon然后在 /world 目录下创建一个文件，然后打开远程主机/home/nick/sshvolume 目录进行查看，你新建的文件看看是不是已经在那里了！</p><ul><li><strong>docker volume 使用NFS存储</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">NFS服务端,配置nfs共享</span></span><br><span class="line">yum install nfs-utils rpcbind -y</span><br><span class="line">mkdir -p /data/nfs/docker</span><br><span class="line">echo "/data/nfs *(rw,no_root_squash,sync)"&gt;&gt;/etc/exports</span><br><span class="line">exportfs -r</span><br><span class="line">systemctl start rpcbind nfs-server</span><br><span class="line">systemctl enable rpcbind nfs-server</span><br><span class="line">showmount -e localhost</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"> #</span><span class="bash">nfs客户端</span></span><br><span class="line">yum install -y nfs-utils rpcbind</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"> #</span><span class="bash">创建volume 连接 39.106.171.56:/data/nfs</span></span><br><span class="line">docker volume create --driver local \</span><br><span class="line">  --opt type=nfs \</span><br><span class="line">  --opt o=addr=39.106.171.56,rw \</span><br><span class="line">  --opt device=:/data/nfs \</span><br><span class="line">  volume-nfs</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"> #</span><span class="bash">查看</span></span><br><span class="line">docker volume ls</span><br><span class="line">docker volume inspect volume-nfs</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"> #</span><span class="bash">容器使用volume-nfs</span></span><br><span class="line">docker run -dit --name busybox7 -v volume-nfs:/nfs busybox</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"> #</span><span class="bash">查看</span></span><br><span class="line">docker inspect -f &#123;&#123;.Mounts&#125;&#125; busybox7</span><br><span class="line">df -h |grep /data/nfs</span><br><span class="line"><span class="meta"> #</span><span class="bash">volume目录/var/lib/docker/volumes/volume-nfs/_data自动挂载到了nfs服务上</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"> #</span><span class="bash">容器创文件测试</span></span><br><span class="line">docker exec busybox7 touch /nfs/testfiles.txt</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-06-数据卷技术&quot;&gt;&lt;a href=&quot;#Docker-06-数据卷技术&quot; class=&quot;headerlink&quot; title=&quot;Docker-06-数据卷技术&quot;&gt;&lt;/a&gt;Docker-06-数据卷技术&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200528/200523893.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Docker" scheme="http://zhuuu.work/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-005-最长回文子串</title>
    <link href="http://zhuuu.work/2020/05/24/Leetcode/Leetcode-005-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://zhuuu.work/2020/05/24/Leetcode/Leetcode-005-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</id>
    <published>2020-05-24T05:30:53.000Z</published>
    <updated>2020-05-27T08:17:37.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-005-Longest-Palindromic-Substring"><a href="#Leecode-005-Longest-Palindromic-Substring" class="headerlink" title="Leecode-005-Longest Palindromic Substring"></a>Leecode-005-<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">Longest Palindromic Substring</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法一-：-中心扩散法"><a href="#方法一-：-中心扩散法" class="headerlink" title="方法一 ： 中心扩散法"></a>方法一 ： 中心扩散法</h2><p><strong>中心扩散法的思路是：</strong></p><ul><li><p>遍历每一个索引，以这个索引为中心，利用“回文串”中心对称的特点，往两边扩散，看最多能扩散到多远。</p></li><li><p>枚举“中心位置”时间复杂度为 O<em>(</em>N)，同时从“中心位置”扩散得到“回文子串”的时间复杂度为 O<em>(</em>N<em>)，因此时间复杂度可以降到O</em>(N^2)。</p></li><li><p>在这里要注意一个细节：回文串在长度为奇数和偶数的时候，“回文中心”的形式是不一样的。</p><ul><li><strong>奇数回文串</strong>的中心是一个具体的字符。例如：回文串 <code>&quot;aba&quot;</code> 的中心是字符 <code>&quot;b&quot;</code>；</li><li><strong>偶数回文串</strong>的中心是两个字符的空隙，例如：回文串串 <code>&quot;abba&quot;</code> 的中心是两个 <code>&quot;b&quot;</code> 中间的那个“空隙”。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200527/153444124.png" alt="mark"></p><p>那么接下来问题的就是回文子串的中心在哪里？</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200527/153532821.png" alt="mark"></p><ul><li>我们可以设计一个方法，兼容以上两种情况：</li></ul><p>1、如果<strong>传入重合的索引编码</strong>，进行中心扩散，此时得到的回文子串的长度是奇数；</p><p>2、如果<strong>传入相邻的索引编码</strong>，进行中心扩散，此时得到的回文子串的长度是偶数。</p><p>具体编码细节在以下的代码的注释中体现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化最大回文子串的起点和终点</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end   = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个位置，当做中心位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 分别拿到奇数偶数的回文子串长度</span></span><br><span class="line">            <span class="keyword">int</span> len_odd = expandCenter(s,i,i);</span><br><span class="line">            <span class="keyword">int</span> len_even = expandCenter(s,i,i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 对比最大的长度</span></span><br><span class="line">            <span class="keyword">int</span> len = Math.max(len_odd,len_even);</span><br><span class="line">            <span class="comment">// 计算对应最大回文子串的起点和终点</span></span><br><span class="line">            <span class="keyword">if</span> (len &gt; end - start)&#123;</span><br><span class="line">                start = i - (len - <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                end = i + len/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意：这里的end + 1是因为 java自带的左闭右开的原因</span></span><br><span class="line">        <span class="keyword">return</span> s.substring(start,end + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s             输入的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left          起始的左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right         起始的右边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>              回文串的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expandCenter</span><span class="params">(String s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">// left = right 的时候，此时回文中心是一个字符，回文串的长度是奇数</span></span><br><span class="line">        <span class="comment">// right = left + 1 的时候，此时回文中心是一个空隙，回文串的长度是偶数</span></span><br><span class="line">        <span class="comment">// 跳出循环的时候恰好满足 s.charAt(left) ！= s.charAt(right)</span></span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回文串的长度是right-left+1-2 = right - left - 1</span></span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(n^2)</li><li><strong>空间复杂度</strong>：O(1)，只使用到常数个临时变量，与字符串长度无关。</li></ul><h2 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h2><p>从回文串的定义展开讨论：</p><ul><li>如果一个字符串的头尾两个字符都不相等，那么这个字符串一定不是回文串；</li><li>如果一个字符串的头尾两个字符相等，才有必要继续判断下去。<ul><li>如果里面的子串是回文，整体就是回文串；</li><li>如果里面的子串不是回文串，整体就不是回文串。</li></ul></li></ul><ol><li><strong>定义状态</strong></li></ol><p><code>dp[i][j]</code> 表示子串s[i…j] 是否是回文串，这里子串 <code>s[i..j]</code> 定义为左闭右闭区间，可以取到 <code>s[i]</code> 和 <code>s[j]</code>。</p><ol start="2"><li><strong>状态转移方程</strong></li></ol><p>在这一步分类讨论（根据头尾字符是否相等），根据上面的分析得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] &#x3D; (s[i] &#x3D;&#x3D; s[j]) and dp[i + 1][j - 1]</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><p>「动态规划」事实上是在填一张二维表格，由于构成子串，因此 i 和 j 的关系是 i &lt;= j ，因此，只需要填这张表格对角线以上的部分。</p></li><li><p>看到 <code>dp[i + 1][j - 1]</code> 就得考虑边界情况。</p></li></ul><p><strong>边界条件：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">边界条件是：</span><br><span class="line">表达式 [i + 1, j - 1] 不构成区间，即长度严格小于 2，</span><br><span class="line">即 j - 1 - (i + 1) + 1 &lt; 2 ，</span><br><span class="line">整理得 j - i &lt; 3。</span><br></pre></td></tr></table></figure><p>这个结论很显然：</p><ul><li><pre><code>j - i &lt; 3 等价于 j - i + 1 &lt; 4<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 即当子串的长度等于2或者等于3的时候，其实只要判断一下头尾两个字符是否相等就可以直接下结论了。</span><br><span class="line">  - 如果子串 &#96;s[i + 1..j - 1]&#96; 只有 1 个字符，即去掉两头，剩下中间部分只有 11 个字符，显然是回文；</span><br><span class="line">  - 如果子串 &#96;s[i + 1..j - 1]&#96; 为空串，那么子串 &#96;s[i, j]&#96; 一定是回文子串。</span><br><span class="line"></span><br><span class="line">- 因此在 ， s[i] &#x3D;&#x3D; s[j]的前提下，直接可以下结论，&#96;dp[i][j] &#x3D; true&#96;，否则才执行状态转移。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. **初始化**</span><br><span class="line"></span><br><span class="line">初始化的时候，单个字符一定是回文串，因此把对角线先初始化为 true，即 dp[i][i] &#x3D; true 。</span><br><span class="line"></span><br><span class="line">事实上，初始化的部分都可以省去。因为只有一个字符的时候一定是回文，dp[i][i] 根本不会被其它状态值所参考。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. **考虑输出**</span><br><span class="line"></span><br><span class="line">只要一得到&#96;dp[i][j] &#x3D; true&#96;，就记录子串的长度和起始位置，没有必要进行截取</span><br><span class="line"></span><br><span class="line">记录此时回文串的起始位置和回文长度即可</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public String longestPalindrome(String s) &#123;</span><br><span class="line">        int len &#x3D; s.length();</span><br><span class="line">        &#x2F;&#x2F; 特判</span><br><span class="line">        if (len &lt; 2)&#123;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int maxLen &#x3D; 1;</span><br><span class="line">        int begin  &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 1. 状态定义</span><br><span class="line">        &#x2F;&#x2F; dp[i][j] 表示s[i...j] 是否是回文串</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2. 初始化</span><br><span class="line">        boolean[][] dp &#x3D; new boolean[len][len];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        char[] chars &#x3D; s.toCharArray();</span><br><span class="line">        &#x2F;&#x2F; 3. 状态转移</span><br><span class="line">        &#x2F;&#x2F; 注意：先填左下角</span><br><span class="line">        &#x2F;&#x2F; 填表规则：先一列一列的填写，再一行一行的填，保证左下方的单元格先进行计算</span><br><span class="line">        for (int j &#x3D; 1;j &lt; len;j++)&#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; j; i++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 头尾字符不相等，不是回文串</span><br><span class="line">                if (chars[i] !&#x3D; chars[j])&#123;</span><br><span class="line">                    dp[i][j] &#x3D; false;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    &#x2F;&#x2F; 相等的情况下</span><br><span class="line">                    &#x2F;&#x2F; 考虑头尾去掉以后没有字符剩余，或者剩下一个字符的时候，肯定是回文串</span><br><span class="line">                    if (j - i &lt; 3)&#123;</span><br><span class="line">                        dp[i][j] &#x3D; true;</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        &#x2F;&#x2F; 状态转移</span><br><span class="line">                        dp[i][j] &#x3D; dp[i + 1][j - 1];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 只要dp[i][j] &#x3D;&#x3D; true 成立，表示s[i...j] 是否是回文串</span><br><span class="line">                &#x2F;&#x2F; 此时更新记录回文长度和起始位置</span><br><span class="line">                if (dp[i][j] &amp;&amp; j - i + 1 &gt; maxLen)&#123;</span><br><span class="line">                    maxLen &#x3D; j - i + 1;</span><br><span class="line">                    begin &#x3D; i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 4. 返回值</span><br><span class="line">        return s.substring(begin,begin + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-005-Longest-Palindromic-Substring&quot;&gt;&lt;a href=&quot;#Leecode-005-Longest-Palindromic-Substring&quot; class=&quot;headerlink&quot; title=&quot;Leecode-005-Longest Palindromic Substring&quot;&gt;&lt;/a&gt;Leecode-005-&lt;a href=&quot;https://leetcode-cn.com/problems/longest-palindromic-substring/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Longest Palindromic Substring&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt;，找到 &lt;code&gt;s&lt;/code&gt; 中最长的回文子串。你可以假设 &lt;code&gt;s&lt;/code&gt; 的最大长度为 1000。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;babad&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;bab&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;注意: &amp;quot;aba&amp;quot; 也是一个有效答案。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;cbbd&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;bb&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://zhuuu.work/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="中心扩散" scheme="http://zhuuu.work/tags/%E4%B8%AD%E5%BF%83%E6%89%A9%E6%95%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-172-阶乘后的0个数</title>
    <link href="http://zhuuu.work/2020/05/23/Leetcode/Leetcode-172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%840%E4%B8%AA%E6%95%B0/"/>
    <id>http://zhuuu.work/2020/05/23/Leetcode/Leetcode-172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%840%E4%B8%AA%E6%95%B0/</id>
    <published>2020-05-23T07:06:53.000Z</published>
    <updated>2020-05-23T07:18:32.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-172-Factorial-Trailing-Zeroes"><a href="#Leecode-172-Factorial-Trailing-Zeroes" class="headerlink" title="Leecode-172-Factorial Trailing Zeroes"></a>Leecode-172-<a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/" target="_blank" rel="noopener">Factorial Trailing Zeroes</a></h1><h2 id="思路：数学题"><a href="#思路：数学题" class="headerlink" title="思路：数学题"></a>思路：数学题</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数 <em>n</em>，返回 <em>n</em>! 结果尾数中零的数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 0</span><br><span class="line">解释: 3! &#x3D; 6, 尾数中没有零。</span><br><span class="line"></span><br><span class="line">输入: 5</span><br><span class="line">输出: 1</span><br><span class="line">解释: 5! &#x3D; 120, 尾数中有 1 个零.</span><br></pre></td></tr></table></figure><p>你算法的时间复杂度应为 <em>O</em>(log <em>n</em>)</p><a id="more"></a><p><strong>Solution：</strong></p><ul><li>首先肯定不能依赖于把阶乘算出来再去判断有多少个零了，因为阶乘很容易就溢出了，所以先一步一步理一下思路吧</li><li>首先末尾有多少个 <code>0</code> ，只需要给当前数<strong>乘以一个 <code>10</code></strong> 就可以加一个 <code>0</code>。</li><li>再具体对于 5!，也就是 5 * 4 * 3 * 2 * 1 = 120，我们发现结果会有一个 0，原因就是 2 和 5 相乘构成了一个 10。而对于 10 的话，其实也只有 2 * 5 可以构成，所以我们<strong>只需要找有多少对 2/5。</strong></li></ul><p><strong>举个例子看一下：</strong></p><p><code>11! = 11 * 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1 = 11 * (2 * 5) * 9 * (4 * 2) * 7 * (3 * 2) * (1 * 5) * (2 * 2) * 3 * (1 * 2) * 1</code></p><ul><li><p>对于含2的因子的是：1 * 2, 2 * 2, 3 * 2, 4 * 2 …</p></li><li><p>对于含5的因子的是：1 * 5, 2 * 5…</p></li><li><p><strong>含2的因子每两个出现一次，含有5的因子每5个出现一次，所以2出现的个数远远多余5，换而言之，只需要找到一个5，那么一定会有一个2和他匹配。所以我们只需要找多少个5就好</strong></p><ul><li>每隔 <code>5</code> 个数出现一个 <code>5</code>，所以计算出现了多少个 <code>5</code>，我们只需要用 <code>n/5</code> 就可以算出来。</li><li>每隔 <code>25</code> 个数字，出现的是两个 <code>5</code>，所以除了每隔 <code>5</code> 个数算作一个 <code>5</code>，每隔 <code>25</code> 个数，还需要多算一个 <code>5</code></li><li>同理我们还会发现每隔 <code>5 * 5 * 5 = 125</code>个数字，会出现 <code>3</code> 个 <code>5</code>，所以我们还需要再加上 <code>n / 125</code> 。</li><li>最终5的个数就是 <code>n/5 + n/25 + n/125 ....</code></li></ul></li></ul><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><strong>写程序的话，如果按照上面的式子计算，分母很可能会溢出。所以计算n/25的时候，我们先把n更新，在n = n/5 ，然后再计算 n/5 即可。</strong></p><p><strong>Solution :</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录5出现的个数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 计算阶乘中5的个数</span></span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 5  出现一个 5</span></span><br><span class="line">            <span class="comment">// 25 出现两个 5</span></span><br><span class="line">            <span class="comment">// 125 出现三个 5</span></span><br><span class="line">            <span class="comment">// .....</span></span><br><span class="line">            count += n/<span class="number">5</span>;</span><br><span class="line">            <span class="comment">// 更新n</span></span><br><span class="line">            n = n/<span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><strong>Solution :</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-172-Factorial-Trailing-Zeroes&quot;&gt;&lt;a href=&quot;#Leecode-172-Factorial-Trailing-Zeroes&quot; class=&quot;headerlink&quot; title=&quot;Leecode-172-Factorial Trailing Zeroes&quot;&gt;&lt;/a&gt;Leecode-172-&lt;a href=&quot;https://leetcode-cn.com/problems/factorial-trailing-zeroes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Factorial Trailing Zeroes&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：数学题&quot;&gt;&lt;a href=&quot;#思路：数学题&quot; class=&quot;headerlink&quot; title=&quot;思路：数学题&quot;&gt;&lt;/a&gt;思路：数学题&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个整数 &lt;em&gt;n&lt;/em&gt;，返回 &lt;em&gt;n&lt;/em&gt;! 结果尾数中零的数量。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 3! &amp;#x3D; 6, 尾数中没有零。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 5! &amp;#x3D; 120, 尾数中有 1 个零.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;你算法的时间复杂度应为 &lt;em&gt;O&lt;/em&gt;(log &lt;em&gt;n&lt;/em&gt;)&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Docker-03-常用命令</title>
    <link href="http://zhuuu.work/2020/05/23/Docker/Docker-03-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://zhuuu.work/2020/05/23/Docker/Docker-03-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2020-05-23T06:44:24.000Z</published>
    <updated>2020-05-25T03:36:14.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-03-常用命令"><a href="#Docker-03-常用命令" class="headerlink" title="Docker-03-常用命令"></a>Docker-03-常用命令</h1><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200525/112944540.png" alt="mark"></p><p>本篇所用到的命令来自于：<a href="https://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-tutorial.html</a></p><a id="more"></a><h2 id="1-帮助命令"><a href="#1-帮助命令" class="headerlink" title="1. 帮助命令"></a>1. 帮助命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br><span class="line">docker info</span><br><span class="line">docker 命令 --<span class="built_in">help</span>  <span class="comment">## 命令的帮助</span></span><br></pre></td></tr></table></figure><p>命令查询地址：<a href="https://www.runoob.com/docker/docker-command-manual.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-command-manual.html</a></p><h2 id="2-镜像命令"><a href="#2-镜像命令" class="headerlink" title="2. 镜像命令"></a>2. 镜像命令</h2><ol><li><strong>docker images :</strong> 列出本地镜像。</li></ol><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><strong>-a :</strong>列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</li><li><strong>–digests :</strong>显示镜像的摘要信息；</li><li><strong>-f :</strong>显示满足条件的镜像；</li><li><strong>–format :</strong>指定返回值的模板文件；</li><li><strong>–no-trunc :</strong>显示完整的镜像信息；</li><li><strong>-q :</strong>只显示镜像ID。</li></ul><ol start="2"><li><p><strong>docker search :</strong> 从Docker Hub查找镜像</p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search [OPTIONS] TERM</span><br></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><strong>–automated :</strong>只列出 automated build类型的镜像；</li><li><strong>–no-trunc :</strong>显示完整的镜像描述；</li><li><strong>-s :</strong>列出收藏数不小于指定值的镜像。</li></ul></li></ol><ol start="3"><li><p><strong>docker pull :</strong> 从镜像仓库中拉取或者更新指定镜像</p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><strong>-a :</strong>拉取所有 tagged 镜像</p></li><li><p><strong>–disable-content-trust :</strong>忽略镜像的校验,默认开启</p></li></ul></li></ol><p>   实例</p><p>   从Docker Hub下载java最新版镜像。</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull java</span><br></pre></td></tr></table></figure><p>   从Docker Hub下载REPOSITORY为java的所有镜像。</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull -a java</span><br></pre></td></tr></table></figure><ol start="4"><li><p><strong>docker rmi :</strong> 删除本地一个或多少镜像。</p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><strong>-f :</strong>强制删除；</li><li><strong>–no-prune :</strong>不移除该镜像的过程镜像，默认移除；</li></ul></li></ol><h2 id="3-容器命令"><a href="#3-容器命令" class="headerlink" title="3. 容器命令"></a>3. 容器命令</h2><ul><li><strong>说明：我们有了镜像才可以创建容器</strong></li></ul><p>先下载一个linux镜像 <code>docker pull centos</code></p><ul><li><strong>新建容器并启动</strong></li></ul><ol><li><strong>docker run ：</strong>创建一个新的容器并运行一个命令</li></ol><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><strong>-a stdin:</strong> 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</li><li><strong>-d:</strong> 后台运行容器，并返回容器ID；</li><li><strong>-i:</strong> 以交互模式运行容器，通常与 -t 同时使用；</li><li><strong>-P:</strong> 随机端口映射，容器内部端口<strong>随机</strong>映射到主机的高端口</li><li><strong>-p:</strong> 指定端口映射，格式为：<strong>主机(宿主)端口:容器端口</strong></li><li><strong>-t:</strong> 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li><li><strong>–name=”nginx-lb”:</strong> 为容器指定一个名称；</li><li><strong>–dns 8.8.8.8:</strong> 指定容器使用的DNS服务器，默认和宿主一致；</li><li><strong>–dns-search example.com:</strong> 指定容器DNS搜索域名，默认和宿主一致；</li><li><strong>-h “mars”:</strong> 指定容器的hostname；</li><li><strong>-e username=”ritchie”:</strong> 设置环境变量；</li><li><strong>–env-file=[]:</strong> 从指定文件读入环境变量；</li><li><strong>–cpuset=”0-2” or –cpuset=”0,1,2”:</strong> 绑定容器到指定CPU运行；</li><li><strong>-m :</strong>设置容器使用内存最大值；</li><li><strong>–net=”bridge”:</strong> 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</li><li><strong>–link=[]:</strong> 添加链接到另一个容器；</li><li><strong>–expose=[]:</strong> 开放一个端口或一组端口；</li><li><strong>–volume , -v:</strong> 绑定一个卷</li></ul><p><strong>测试：启动并进入容器</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200525/092521825.png" alt="mark"></p><p><strong>查看正在后台执行的容器</strong>： <code>docker ps</code></p><p>​        </p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200525/092831142.png" alt="mark"></p><ol start="2"><li><p><strong>docker ps :</strong> 列出容器</p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><strong>-a :</strong>显示所有的容器，包括未运行的。</li><li><strong>-f :</strong>根据条件过滤显示的内容。</li><li><strong>–format :</strong>指定返回值的模板文件。</li><li><strong>-l :</strong>显示最近创建的容器。</li><li><strong>-n :</strong>列出最近创建的n个容器。</li><li><strong>–no-trunc :</strong>不截断输出。</li><li><strong>-q :</strong>静默模式，只显示容器编号。</li><li><strong>-s :</strong>显示总的文件大小。</li></ul></li></ol><p>   实例</p><p>   列出所有在运行的容器信息。</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker ps</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                ...  PORTS                    NAMES</span><br><span class="line">09b93464c2f7   nginx:latest   &quot;nginx -g &#39;daemon off&quot; ...  80&#x2F;tcp, 443&#x2F;tcp          myrunoob</span><br><span class="line">96f7f14e99ab   mysql:5.6      &quot;docker-entrypoint.sh&quot; ...  0.0.0.0:3306-&gt;3306&#x2F;tcp   mymysql</span><br></pre></td></tr></table></figure><p>   输出详情介绍：</p><p>   <strong>CONTAINER ID:</strong> 容器 ID。</p><p>   <strong>IMAGE:</strong> 使用的镜像。</p><p>   <strong>COMMAND:</strong> 启动容器时运行的命令。</p><p>   <strong>CREATED:</strong> 容器的创建时间。</p><p>   <strong>STATUS:</strong> 容器状态。</p><p>   状态有7种：</p><ul><li>created（已创建）</li><li>restarting（重启中）</li><li>running（运行中）</li><li>removing（迁移中）</li><li>paused（暂停）</li><li>exited（停止）</li><li>dead（死亡）</li></ul><p>   <strong>PORTS:</strong> 容器的端口信息和使用的连接类型（tcp\udp）。</p><p>   <strong>NAMES:</strong> 自动分配的容器名称。</p><p>   列出最近创建的5个容器信息。</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker ps -n 5</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                   CREATED           </span><br><span class="line">09b93464c2f7        nginx:latest        &quot;nginx -g &#39;daemon off&quot;    2 days ago   ...     </span><br><span class="line">b8573233d675        nginx:latest        &quot;&#x2F;bin&#x2F;bash&quot;               2 days ago   ...     </span><br><span class="line">b1a0703e41e7        nginx:latest        &quot;nginx -g &#39;daemon off&quot;    2 days ago   ...    </span><br><span class="line">f46fb1dec520        5c6e1090e771        &quot;&#x2F;bin&#x2F;sh -c &#39;set -x \t&quot;   2 days ago   ...   </span><br><span class="line">a63b4a5597de        860c279d2fec        &quot;bash&quot;                    2 days ago   ...</span><br></pre></td></tr></table></figure><p>   列出所有创建的容器ID。</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker ps -a -q</span><br><span class="line">09b93464c2f7</span><br><span class="line">b8573233d675</span><br><span class="line">b1a0703e41e7</span><br><span class="line">f46fb1dec520</span><br><span class="line">a63b4a5597de</span><br><span class="line">6a4aa42e947b</span><br><span class="line">de7bb36e7968</span><br><span class="line">43a432b73776</span><br><span class="line">664a8ab1a585</span><br><span class="line">ba52eb632bbd</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="3"><li><p><strong>退出容器并关闭</strong>：<code>exit</code></p></li><li><p><strong>退出容器不关闭</strong><code>ctrl+p+q</code></p></li><li><p><strong>docker rm ：</strong>删除一个或多个容器。</p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><strong>-f :</strong>通过 SIGKILL 信号强制删除一个运行中的容器。</li><li><strong>-l :</strong>移除容器间的网络连接，而非容器本身。</li><li><strong>-v :</strong>删除与容器关联的卷。</li></ul></li></ol><p>   实例</p><p>   强制删除容器 db01、db02：</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f db01 db02</span><br></pre></td></tr></table></figure><p>   移除容器 nginx01 对容器 db01 的连接，连接名 db：</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -l db</span><br></pre></td></tr></table></figure><p>   删除容器 nginx01, 并删除容器挂载的数据卷：</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -v nginx01</span><br></pre></td></tr></table></figure><p>   删除所有已经停止的容器：</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure><ol start="6"><li>启动和停止容器</li></ol><p><strong>docker start</strong> :启动一个或多个已经被停止的容器</p><p><strong>docker stop</strong> :停止一个运行中的容器</p><p><strong>docker restart</strong> :重启容器</p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker start [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">docker stop [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">docker restart [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>实例</p><p>启动已被停止的容器myrunoob</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start myrunoob</span><br></pre></td></tr></table></figure><p>停止运行中的容器myrunoob</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop myrunoob</span><br></pre></td></tr></table></figure><p>重启容器myrunoob</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart myrunoob</span><br></pre></td></tr></table></figure><ol start="7"><li><p><strong>docker kill</strong> :杀掉一个运行中的容器。</p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><strong>-s :</strong>向容器发送一个信号</li></ul></li></ol><p>   实例</p><p>   杀掉运行中的容器mynginx</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker kill -s KILL mynginx</span><br><span class="line">mynginx</span><br></pre></td></tr></table></figure><h2 id="4-常用的其他命令"><a href="#4-常用的其他命令" class="headerlink" title="4.常用的其他命令"></a>4.常用的其他命令</h2><ol><li><strong>后台启动容器</strong></li></ol><p><code>docker run -d  centos</code></p><p>问题：docker ps 之后发现centos停止了</p><p>答：docker容器使用后台运行，就必须要有一个前台进程,docker如果发现没有前台应用了，就会自动停止。（如nginx）</p><ol start="2"><li>查看日志</li></ol><p><strong>docker logs :</strong> 获取容器的日志</p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><strong>-f :</strong> 跟踪日志输出</li><li><strong>–since :</strong>显示某个开始时间的所有日志</li><li><strong>-t :</strong> 显示时间戳</li><li><strong>–tail :</strong>仅列出最新N条容器日志</li></ul><p>实例</p><p>跟踪查看容器mynginx的日志输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker logs -f mynginx</span><br><span class="line">192.168.239.1 - - [10&#x2F;Jul&#x2F;2016:16:53:33 +0000] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 612 &quot;-&quot; &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;45.0.2454.93 Safari&#x2F;537.36&quot; &quot;-&quot;</span><br><span class="line">2016&#x2F;07&#x2F;10 16:53:33 [error] 5#5: *1 open() &quot;&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;favicon.ico&quot; failed (2: No such file or directory), client: 192.168.239.assqwsddffdws000] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;45.0.2454.93 Safari&#x2F;537.36&quot; &quot;-&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>查看容器mynginx从2016年7月1日后的最新10条日志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs --since&#x3D;&quot;2016-07-01&quot; --tail&#x3D;10 mynginx</span><br></pre></td></tr></table></figure><ol start="3"><li>查看容器内部的进程信息</li></ol><p><strong>docker top :</strong>查看容器中运行的进程信息，支持 ps 命令参数。</p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top [OPTIONS] CONTAINER [ps OPTIONS]</span><br></pre></td></tr></table></figure><p>容器运行时不一定有/bin/bash终端来交互执行top命令，而且容器还不一定有top命令，可以使用docker top来实现查看container中正在运行的进程。</p><p>实例</p><p>查看容器mymysql的进程信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~&#x2F;mysql$ docker top mymysql</span><br><span class="line">UID    PID    PPID    C      STIME   TTY  TIME       CMD</span><br><span class="line">999    40347  40331   18     00:58   ?    00:00:02   mysqld</span><br></pre></td></tr></table></figure><p>查看所有运行容器的进程信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in  &#96;docker ps |grep Up|awk &#39;&#123;print $1&#125;&#39;&#96;;do echo \ &amp;&amp;docker top $i; done</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>查看容器/镜像的元数据</strong></li></ol><p><strong>docker inspect :</strong> 获取容器/镜像的元数据。</p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [OPTIONS] NAME|ID [NAME|ID...]</span><br></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><strong>-f :</strong>指定返回值的模板文件。</li><li><strong>-s :</strong>显示总的文件大小。</li><li><strong>–type :</strong>为指定类型返回JSON。</li></ul><p>实例</p><p>获取镜像mysql:5.6的元信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker inspect mysql:5.6</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;sha256:2c0964ec182ae9a045f866bbc2553087f6e42bfc16074a74fb820af235f070ec&quot;,</span><br><span class="line">        &quot;RepoTags&quot;: [</span><br><span class="line">            &quot;mysql:5.6&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;RepoDigests&quot;: [],</span><br><span class="line">        &quot;Parent&quot;: &quot;&quot;,</span><br><span class="line">        &quot;Comment&quot;: &quot;&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2016-05-24T04:01:41.168371815Z&quot;,</span><br><span class="line">        &quot;Container&quot;: &quot;e0924bc460ff97787f34610115e9363e6363b30b8efa406e28eb495ab199ca54&quot;,</span><br><span class="line">        &quot;ContainerConfig&quot;: &#123;</span><br><span class="line">            &quot;Hostname&quot;: &quot;b0cf605c7757&quot;,</span><br><span class="line">            &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">            &quot;User&quot;: &quot;&quot;,</span><br><span class="line">            &quot;AttachStdin&quot;: false,</span><br><span class="line">            &quot;AttachStdout&quot;: false,</span><br><span class="line">            &quot;AttachStderr&quot;: false,</span><br><span class="line">            &quot;ExposedPorts&quot;: &#123;</span><br><span class="line">                &quot;3306&#x2F;tcp&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>进入当前正在运行的容器</strong></li></ol><ul><li>通常容器都是以后台方式运行的，需要进入容器，修改一些配置</li></ul><p><strong>docker exec ：</strong>在运行的容器中执行命令</p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</span><br></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><strong>-d :</strong>分离模式: 在后台运行</li><li><strong>-i :</strong>即使没有附加也保持STDIN 打开</li><li><strong>-t :</strong>分配一个伪终端</li></ul><p>实例</p><p>在容器 mynginx 中以交互模式执行容器内 /root/runoob.sh 脚本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker exec -it mynginx &#x2F;bin&#x2F;sh &#x2F;root&#x2F;runoob.sh</span><br><span class="line">http:&#x2F;&#x2F;www.runoob.com&#x2F;</span><br></pre></td></tr></table></figure><p>在容器 mynginx 中开启一个交互模式的终端:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker exec -i -t  mynginx &#x2F;bin&#x2F;bash</span><br><span class="line">root@b1a0703e41e7:&#x2F;#</span><br></pre></td></tr></table></figure><p>也可以通过 <strong>docker ps -a</strong> 命令查看已经在运行的容器，然后使用容器 ID 进入容器。</p><p>查看已经在运行的容器 ID：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># docker ps -a </span><br><span class="line">...</span><br><span class="line">9df70f9a0714        openjdk             &quot;&#x2F;usercode&#x2F;script.sh…&quot; </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>第一列的 9df70f9a0714 就是容器 ID。</p><p>通过 exec 命令对指定的容器执行 bash:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker exec -it 9df70f9a0714 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><ol start="6"><li><p><strong>docker attach :</strong>连接到正在运行中的容器。</p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure><p>要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。</p><p>官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，<strong>detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上–sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。</strong></p></li></ol><p>   实例</p><p>   容器mynginx将访问日志指到标准输出，连接到容器查看访问信息。</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker attach --sig-proxy&#x3D;false mynginx</span><br><span class="line">192.168.239.1 - - [10&#x2F;Jul&#x2F;2016:16:54:26 +0000] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;45.0.2454.93 Safari&#x2F;537.36&quot; &quot;-&quot;</span><br></pre></td></tr></table></figure><p><strong>与docker exec的区别</strong></p><ul><li>docker exec    开启一个新的终端，进入容器</li><li>docker attach  进入容器正在进行的终端，不会启动新的会话</li></ul><ol start="7"><li><strong>容器主机互相拷贝</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">docker cp :用于容器与主机之间的数据拷贝。</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</span><br><span class="line">docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</span><br><span class="line">OPTIONS说明：</span><br><span class="line"></span><br><span class="line">-L :保持源目标中的链接</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">将主机&#x2F;www&#x2F;runoob目录拷贝到容器96f7f14e99ab的&#x2F;www目录下。</span><br><span class="line"></span><br><span class="line">docker cp &#x2F;www&#x2F;runoob 96f7f14e99ab:&#x2F;www&#x2F;</span><br><span class="line">将主机&#x2F;www&#x2F;runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www。</span><br><span class="line"></span><br><span class="line">docker cp &#x2F;www&#x2F;runoob 96f7f14e99ab:&#x2F;www</span><br><span class="line">将容器96f7f14e99ab的&#x2F;www目录拷贝到主机的&#x2F;tmp目录中。</span><br><span class="line"></span><br><span class="line">docker cp  96f7f14e99ab:&#x2F;www &#x2F;tmp&#x2F;</span><br></pre></td></tr></table></figure><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200525/112944540.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-03-常用命令&quot;&gt;&lt;a href=&quot;#Docker-03-常用命令&quot; class=&quot;headerlink&quot; title=&quot;Docker-03-常用命令&quot;&gt;&lt;/a&gt;Docker-03-常用命令&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200525/112944540.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;本篇所用到的命令来自于：&lt;a href=&quot;https://www.runoob.com/docker/docker-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.runoob.com/docker/docker-tutorial.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Docker" scheme="http://zhuuu.work/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker-01-简介</title>
    <link href="http://zhuuu.work/2020/05/23/Docker/Docker-01-%E7%AE%80%E4%BB%8B/"/>
    <id>http://zhuuu.work/2020/05/23/Docker/Docker-01-%E7%AE%80%E4%BB%8B/</id>
    <published>2020-05-23T00:22:24.000Z</published>
    <updated>2020-05-25T00:46:03.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-01-简介"><a href="#Docker-01-简介" class="headerlink" title="Docker-01-简介"></a>Docker-01-简介</h1><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200523/093923608.png" alt="mark"></p><p><strong>Docker官网</strong>：<a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a></p><p><strong>Docker文档：</strong><a href="https://docs.docker.com/" target="_blank" rel="noopener">https://docs.docker.com/</a></p><p><strong>Docker社区：</strong><a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p><h2 id="1-为什么会有Docker"><a href="#1-为什么会有Docker" class="headerlink" title="1. 为什么会有Docker?"></a>1. 为什么会有Docker?</h2><p>对于一款产品来说：</p><ul><li><p>两套环境（应用环境，应用配置）</p></li><li><p>对于开发人员，运维人员（我在我的电脑上可以，版本更新，导致服务不可用）</p></li><li><p>环境配置十分麻烦：每一个集群都要布置环境（集群的配置）</p></li><li><p><strong>设想一个情景（jar + (Redis Mysql jdk, ES)）:项目带上环境打包</strong></p><ul><li>之前在服务器配置一个应用的环境Redis Mysql jdk, ES(环境十分麻烦)</li></ul></li><li><p><strong>如果有了Docker，开发打包部署上线，一套流程做完</strong></p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200523/094018098.png" alt="mark"></p><a id="more"></a><ul><li>Docker的思想来自于集装箱</li></ul><p>JRE–&gt; 多个应用（端口冲突） – &gt; 原来都是交叉的！</p><p><strong>隔离是Docker的核心思想（打包装箱，每一个箱子是互相隔离的）</strong></p><p><strong>总结：</strong></p><p>由于以上出现的问题，所以才出现了Docker</p><p>由于不同的机器有不同的操作系统，以及不同的库和组件，在将一个应用部署到多台机器上需要进行大量的环境配置操作。</p><p><strong>Docker 主要解决环境配置问题</strong>，它是一种虚拟化技术，<strong>对进程进行隔离</strong>，被隔离的进程独立于宿主操作系统和其它隔离的进程。使用 Docker 可以不修改应用程序代码，不需要开发人员学习特定环境下的技术，就能够将现有的应用程序部署在其它机器上。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200523/094358988.png" alt="mark"></p><h2 id="2-与虚拟机的比较"><a href="#2-与虚拟机的比较" class="headerlink" title="2. 与虚拟机的比较"></a>2. 与虚拟机的比较</h2><p>虚拟机也是一种虚拟化技术，它与 Docker 最大的区别在于它是通过模拟硬件。</p><p>并在硬件上安装操作系统来实现。</p><ul><li>虚拟机模拟一套完整的操作系统</li><li>容器内的引用直接运行在宿主机上（没有虚拟我们的硬件）</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200523/103754852.png" alt="mark"></p><h3 id="2-1-启动速度"><a href="#2-1-启动速度" class="headerlink" title="2.1 启动速度"></a>2.1 启动速度</h3><ul><li>启动虚拟机需要先启动虚拟机的操作系统，再启动应用，这个过程非常慢；</li><li>而启动 Docker 相当于启动宿主操作系统上的一个进程。（可能还是秒级）</li></ul><h3 id="2-2-占用资源"><a href="#2-2-占用资源" class="headerlink" title="2.2 占用资源"></a>2.2 占用资源</h3><ul><li>虚拟机是一个完整的操作系统，需要占用大量的磁盘，内存和CPU资源，一台机器只能开启几十个虚拟机</li><li>Docker 只是一个进程，只需要将应用以及相关的组件打包，在运行时占用很少的资源，一台机器可以开启成千上万个Docker</li></ul><h3 id="2-3-DevOps-开发，运维"><a href="#2-3-DevOps-开发，运维" class="headerlink" title="2.3 DevOps(开发，运维)"></a>2.3 DevOps(开发，运维)</h3><ul><li><strong>更快速的交付和部署</strong><ul><li>传统：一堆帮助文档和安装程序</li><li>Docker：一键运行，打包镜像，一键运行</li></ul></li><li><strong>更快捷的升级的扩容</strong><ul><li>软件的版本升级</li></ul></li><li><strong>更简单的系统运维</strong><ul><li>开发，测试环境可以高度一致</li></ul></li><li><strong>更高效的计算资源利用</strong><ul><li>Docker是内核级别的虚拟化，可以在一个物理机上运行更多的容器实例</li></ul></li></ul><h2 id="3-Docker的安装"><a href="#3-Docker的安装" class="headerlink" title="3. Docker的安装"></a>3. Docker的安装</h2><h3 id="3-1-基本组成"><a href="#3-1-基本组成" class="headerlink" title="3.1 基本组成"></a>3.1 基本组成</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200523/110739177.png" alt="mark"></p><ul><li>镜像（image）: 通过这个镜像可以创建多个容器</li><li>服务器(container) : Docker利用容器技术，独立运行一个或者一组应用</li><li>仓库(repository)  : 仓库就是放镜像的地方（公有仓库和私有仓库）（类似github）</li></ul><h3 id="3-2-安装"><a href="#3-2-安装" class="headerlink" title="3.2 安装"></a>3.2 安装</h3><ul><li>环境准备<ul><li>Xshell连接远程服务器</li><li>Linux服务器（Centos,ubuntu）</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200523/111826088.png" alt="mark"></p><p>官方安装文档：<a href="https://docs.docker.com/engine/install/ubuntu/" target="_blank" rel="noopener">https://docs.docker.com/engine/install/ubuntu/</a></p><p><strong>中文版菜鸟教程（Ubuntu）</strong> : <a href="https://www.runoob.com/docker/ubuntu-docker-install.html" target="_blank" rel="noopener">https://www.runoob.com/docker/ubuntu-docker-install.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Ubuntu 18.04 安装 Docker-ce</span><br><span class="line"></span><br><span class="line">1.更换国内软件源，推荐中国科技大学的源，稳定速度快（可选）</span><br><span class="line"></span><br><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">sudo sed -i <span class="string">'s/archive.ubuntu.com/mirrors.ustc.edu.cn/g'</span> /etc/apt/sources.list</span><br><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line">2.安装需要的包</span><br><span class="line"></span><br><span class="line">sudo apt install apt-transport-https ca-certificates software-properties-common curl</span><br><span class="line"></span><br><span class="line">3.添加 GPG 密钥，并添加 Docker-ce 软件源，这里还是以中国科技大学的 Docker-ce 源为例</span><br><span class="line"></span><br><span class="line">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">sudo add-apt-repository <span class="string">"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \</span></span><br><span class="line"><span class="string"><span class="variable">$(lsb_release -cs)</span> stable"</span></span><br><span class="line"></span><br><span class="line">4.添加成功后更新软件包缓存</span><br><span class="line"></span><br><span class="line">sudo apt update</span><br><span class="line">5.安装 Docker-ce</span><br><span class="line"></span><br><span class="line">sudo apt install docker-ce</span><br><span class="line">6.设置开机自启动并启动 Docker-ce（安装成功后默认已设置并启动，可忽略）</span><br><span class="line"></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">sudo systemctl start docker</span><br><span class="line">7.测试运行</span><br><span class="line"></span><br><span class="line">sudo docker run hello-world</span><br><span class="line">8.添加当前用户到 docker 用户组，可以不用 sudo 运行 docker（可选）</span><br><span class="line"></span><br><span class="line">sudo groupadd docker</span><br><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br><span class="line"></span><br><span class="line">9.测试添加用户组（可选）</span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p><strong>安装完之后</strong>：运行<code>docker version</code></p><p>出现以下提示代表安装成功</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200523/113104868.png" alt="mark"></p><p><strong>或者运行</strong><code>docker run hello world</code></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200523/113405933.png" alt="mark"></p><p><strong>查看镜像</strong> <code>docker images</code></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200523/113512894.png" alt="mark"></p><p><strong>docker默认安装路径</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200523/113615086.png" alt="mark"></p><h3 id="3-3-配置阿里云镜像加速"><a href="#3-3-配置阿里云镜像加速" class="headerlink" title="3.3 配置阿里云镜像加速"></a>3.3 配置阿里云镜像加速</h3><ul><li><p>登录阿里云，找到<strong>容器镜像服务</strong></p></li><li><p>配置<strong>镜像加速器</strong></p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200523/114207887.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200523/114310867.png" alt="mark"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 创建目录</span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"><span class="comment"># 2. 配置镜像</span></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://nruhnhhs.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 重启daemon</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 重启docker</span></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-01-简介&quot;&gt;&lt;a href=&quot;#Docker-01-简介&quot; class=&quot;headerlink&quot; title=&quot;Docker-01-简介&quot;&gt;&lt;/a&gt;Docker-01-简介&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200523/093923608.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Docker官网&lt;/strong&gt;：&lt;a href=&quot;https://www.docker.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.docker.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Docker文档：&lt;/strong&gt;&lt;a href=&quot;https://docs.docker.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.docker.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Docker社区：&lt;/strong&gt;&lt;a href=&quot;https://hub.docker.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://hub.docker.com/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-为什么会有Docker&quot;&gt;&lt;a href=&quot;#1-为什么会有Docker&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么会有Docker?&quot;&gt;&lt;/a&gt;1. 为什么会有Docker?&lt;/h2&gt;&lt;p&gt;对于一款产品来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;两套环境（应用环境，应用配置）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于开发人员，运维人员（我在我的电脑上可以，版本更新，导致服务不可用）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;环境配置十分麻烦：每一个集群都要布置环境（集群的配置）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;设想一个情景（jar + (Redis Mysql jdk, ES)）:项目带上环境打包&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;之前在服务器配置一个应用的环境Redis Mysql jdk, ES(环境十分麻烦)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;如果有了Docker，开发打包部署上线，一套流程做完&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200523/094018098.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Docker" scheme="http://zhuuu.work/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker-02-Hello-World</title>
    <link href="http://zhuuu.work/2020/05/23/Docker/Docker-02-Hello-World/"/>
    <id>http://zhuuu.work/2020/05/23/Docker/Docker-02-Hello-World/</id>
    <published>2020-05-23T00:22:24.000Z</published>
    <updated>2020-05-23T06:53:33.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-02-Hello-World"><a href="#Docker-02-Hello-World" class="headerlink" title="Docker-02-Hello-World"></a>Docker-02-Hello-World</h1><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200523/093923608.png" alt="mark"></p><p><code>docker run</code> 命令</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200523/113405933.png" alt="mark"></p><ul><li>Docker在本机寻找镜像<ul><li>有，直接使用</li><li>没有，去docker hub上下载</li></ul></li></ul><h2 id="1-docker-原理"><a href="#1-docker-原理" class="headerlink" title="1. docker 原理"></a>1. docker 原理</h2><h3 id="1-1-Docker工作方式"><a href="#1-1-Docker工作方式" class="headerlink" title="1.1 Docker工作方式"></a>1.1 Docker工作方式</h3><ul><li>Docker是一个Client-Server结构的系统，Docker的守护进行在主机上，通过Socket链接</li><li>Docker Server 接受Docker Client的指令，并且执行这个命令！</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200523/145017509.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker-02-Hello-World&quot;&gt;&lt;a href=&quot;#Docker-02-Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Docker-02-Hello-World&quot;&gt;&lt;/a&gt;Docker-02-Hello-World&lt;/
      
    
    </summary>
    
    
    
      <category term="Docker" scheme="http://zhuuu.work/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1371-每个元音包含偶数次的最长子字符串</title>
    <link href="http://zhuuu.work/2020/05/21/Leetcode/Leetcode-1371-%E6%AF%8F%E4%B8%AA%E5%85%83%E9%9F%B3%E5%8C%85%E5%90%AB%E5%81%B6%E6%95%B0%E6%AC%A1%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://zhuuu.work/2020/05/21/Leetcode/Leetcode-1371-%E6%AF%8F%E4%B8%AA%E5%85%83%E9%9F%B3%E5%8C%85%E5%90%AB%E5%81%B6%E6%95%B0%E6%AC%A1%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-05-21T03:52:53.000Z</published>
    <updated>2020-05-23T08:56:32.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-1371-Find-the-Longest-Substring-Containing-Vowels-in-Even-Counts"><a href="#Leecode-1371-Find-the-Longest-Substring-Containing-Vowels-in-Even-Counts" class="headerlink" title="Leecode-1371-Find the Longest Substring Containing Vowels in Even Counts"></a>Leecode-1371-<a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/" target="_blank" rel="noopener">Find the Longest Substring Containing Vowels in Even Counts</a></h1><h2 id="思路：前缀和-位运算"><a href="#思路：前缀和-位运算" class="headerlink" title="思路：前缀和+位运算"></a>思路：前缀和+位运算</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 <code>s</code> ，请你返回满足以下条件的<strong>最长子字符串的长度</strong>：</p><ul><li>每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ ，在子字符串中都恰好出现了偶数次。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;eleetminicoworoep&quot;</span><br><span class="line">输出：13</span><br><span class="line">解释：最长子字符串是 &quot;leetminicowor&quot; ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;leetcodeisgreat&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：最长子字符串是 &quot;leetc&quot; ，其中包含 2 个 e 。</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;bcbcbc&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：这个示例中，字符串 &quot;bcbcbc&quot; 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Solution：</strong></p><ol><li><strong>二进制用来压缩状态</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aeiou 分别对应二进制 </span><br><span class="line">00001，00010，00100，01000，10000</span><br><span class="line">其中 0 表示对应元音出现了偶数次数，1 表示奇数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">那么问题来了？为什么我们要这么搞？</span><br><span class="line">答：因为这样可以用到位运算，在二进制中，1^0 &#x3D; 1 ,0^0 &#x3D; 0(那么当出现偶数次的话对应位就是0，奇数次对应位就是1)</span><br></pre></td></tr></table></figure><p>所以由这个规律可以断定，当一个状态重复出现的时候，一定出现了偶数次，举例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">31--&gt;30--&gt;28--&gt;29--&gt;31</span><br><span class="line"></span><br><span class="line">对应的二进制位 [11111]--&gt;[11110]--&gt;[11100]--&gt;[11101]--&gt;[11111]</span><br><span class="line"></span><br><span class="line">一个合理的字符串变化：</span><br><span class="line">aeiou --&gt; aeioua --&gt;aeiouae--&gt;aeiouaea--&gt;aeiouaeae</span><br></pre></td></tr></table></figure><p>由此可见，从 <code>aeiou</code> 到 <code>aeiouaeae</code> 这个过程中，多余出来的 <code>aeae</code> 为符合条件的字符串。</p><p>所以在这个过程中，不管中间发生了什么变化，这两个状态之间对应的元音为偶数，也就是一定符合题目的字符串。</p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><strong>Solution :</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTheLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> state  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="comment">// 为了计算长度方便定义，</span></span><br><span class="line">        <span class="comment">// 或者理解为，</span></span><br><span class="line">        <span class="comment">// 开始计算前，参照点在第一个字符之前，也就是 -1 的位置</span></span><br><span class="line">        map.put(<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a e i o u 分别在第12345个bit，来表示出现次数的奇偶性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 遍历每个索引位置，是元音进行异或运算</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'a'</span>)&#123;</span><br><span class="line">                state ^= <span class="number">1</span>&lt;&lt;<span class="number">0</span>;  <span class="comment">// 1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'e'</span>)&#123;</span><br><span class="line">                state ^= <span class="number">1</span>&lt;&lt;<span class="number">1</span>;  <span class="comment">// 2</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'i'</span>)&#123;</span><br><span class="line">                state ^= <span class="number">1</span>&lt;&lt;<span class="number">2</span>;  <span class="comment">// 4</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'o'</span>)&#123;</span><br><span class="line">                state ^= <span class="number">1</span>&lt;&lt;<span class="number">3</span>;  <span class="comment">// 8</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'u'</span>)&#123;</span><br><span class="line">                state ^= <span class="number">1</span>&lt;&lt;<span class="number">4</span>;  <span class="comment">// 16</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对状态进行判断，如果这个状态之前出现过（说明出现了偶数次）(辅音或者重复的元音都要计算长度)</span></span><br><span class="line">            <span class="comment">// 更新最大长度即可</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(state))&#123;</span><br><span class="line">                maxlen = Math.max(maxlen,i - map.get(state));</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果当前的 state 没有出现过，</span></span><br><span class="line">                <span class="comment">// 那么以这个 state 为键，记录下当前位置，也就是索引的位置</span></span><br><span class="line">                map.put(state,i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">    System.out.println(solution.findTheLongestSubstring(<span class="string">"leetcodeo"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：其中 n 为字符串 s 的长度。我们只需要遍历一遍字符串即可求得答案，因此时间复杂度为 <em>O</em>(<em>n</em>)。</li><li>空间复杂度：O(S)  S = 32 ，用来存储状态的集合长度 </li></ul><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><strong>Solution :</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-1371-Find-the-Longest-Substring-Containing-Vowels-in-Even-Counts&quot;&gt;&lt;a href=&quot;#Leecode-1371-Find-the-Longest-Substring-Containing-Vowels-in-Even-Counts&quot; class=&quot;headerlink&quot; title=&quot;Leecode-1371-Find the Longest Substring Containing Vowels in Even Counts&quot;&gt;&lt;/a&gt;Leecode-1371-&lt;a href=&quot;https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Find the Longest Substring Containing Vowels in Even Counts&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：前缀和-位运算&quot;&gt;&lt;a href=&quot;#思路：前缀和-位运算&quot; class=&quot;headerlink&quot; title=&quot;思路：前缀和+位运算&quot;&gt;&lt;/a&gt;思路：前缀和+位运算&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt; ，请你返回满足以下条件的&lt;strong&gt;最长子字符串的长度&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ ，在子字符串中都恰好出现了偶数次。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;eleetminicoworoep&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：最长子字符串是 &amp;quot;leetminicowor&amp;quot; ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;leetcodeisgreat&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：最长子字符串是 &amp;quot;leetc&amp;quot; ，其中包含 2 个 e 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;bcbcbc&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：这个示例中，字符串 &amp;quot;bcbcbc&amp;quot; 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="位运算" scheme="http://zhuuu.work/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-131-分割回文串</title>
    <link href="http://zhuuu.work/2020/05/20/Leetcode/Leetcode-131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <id>http://zhuuu.work/2020/05/20/Leetcode/Leetcode-131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</id>
    <published>2020-05-20T09:22:53.000Z</published>
    <updated>2020-05-20T08:10:36.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-131-Palindrome-Partitioning"><a href="#Leecode-131-Palindrome-Partitioning" class="headerlink" title="Leecode-131-Palindrome Partitioning"></a>Leecode-131-<a href="https://leetcode-cn.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">Palindrome Partitioning</a></h1><h2 id="思路：回溯-剪枝"><a href="#思路：回溯-剪枝" class="headerlink" title="思路：回溯+剪枝"></a>思路：回溯+剪枝</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 <em>s</em>，将 <em>s</em> 分割成一些子串，使每个子串都是回文串。</p><p>返回 <em>s</em> 所有可能的分割方案。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;aab&quot;</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Solution：回溯</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200520/154901015.png" alt="mark"></p><ul><li><p>每一个结点表示剩余没有扫描到的字符串，产生分支是<strong>截取了剩余字符串的前缀</strong>；</p></li><li><p>判断前缀字符串是不是回文串</p><ul><li>是，则可以产生分支和节点</li><li>不是，进行剪枝</li></ul></li><li><p>当叶子节点是空字符串的时候，返回从根节点到叶子节点的路径，当做一个结果集</p></li><li><p>最后用一个总的结果集包含上述一个个的结果集</p></li></ul><p>废话如下：</p><ul><li>采用一个路径变量 <code>path</code> 搜索，<code>path</code> 全局使用一个（注意结算的时候，需要生成一个拷贝</li><li>因此在递归执行方法结束以后需要回溯，即将递归之前添加进来的元素拿出去；</li><li><code>path</code> 的操作只在列表的末端，因此合适的数据结构是栈。</li></ul><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><strong>Solution :</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="comment">// 存放最终结果</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Stack这个类Java文档里推荐写成</span></span><br><span class="line">        <span class="comment">// Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();</span></span><br><span class="line">        Deque&lt;String&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        backtracking(s,<span class="number">0</span>,len,stack,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s     传入的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 起始字符的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len   字符串s的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path  记录从根节点到叶子节点的路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res   记录所有的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> len, Deque&lt;String&gt; path, List&lt;List&lt;String&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 达到最大深度，返回结果</span></span><br><span class="line">        <span class="keyword">if</span> (start == len)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 前缀字符串不是回文</span></span><br><span class="line">            <span class="keyword">if</span> (!isPalindrome(s,start,i))&#123;</span><br><span class="line">                <span class="comment">// 剪枝退出本轮循环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 前缀字符串是回文，把前缀加到结果</span></span><br><span class="line">            path.addLast(s.substring(start,i + <span class="number">1</span>));</span><br><span class="line">            <span class="comment">// 向下判断</span></span><br><span class="line">            backtracking(s,i + <span class="number">1</span>,len,path,res);</span><br><span class="line">            <span class="comment">// 回溯操作</span></span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否回文串</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left) != s.charAt(right))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn) 栈的深度</li><li>空间复杂度：O(logn) 栈的深度</li></ul><p>测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">    System.out.println(solution.getMoneyAmount(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><strong>Solution :</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-131-Palindrome-Partitioning&quot;&gt;&lt;a href=&quot;#Leecode-131-Palindrome-Partitioning&quot; class=&quot;headerlink&quot; title=&quot;Leecode-131-Palindrome Partitioning&quot;&gt;&lt;/a&gt;Leecode-131-&lt;a href=&quot;https://leetcode-cn.com/problems/palindrome-partitioning/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Palindrome Partitioning&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：回溯-剪枝&quot;&gt;&lt;a href=&quot;#思路：回溯-剪枝&quot; class=&quot;headerlink&quot; title=&quot;思路：回溯+剪枝&quot;&gt;&lt;/a&gt;思路：回溯+剪枝&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个字符串 &lt;em&gt;s&lt;/em&gt;，将 &lt;em&gt;s&lt;/em&gt; 分割成一些子串，使每个子串都是回文串。&lt;/p&gt;
&lt;p&gt;返回 &lt;em&gt;s&lt;/em&gt; 所有可能的分割方案。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;aab&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&amp;quot;aa&amp;quot;,&amp;quot;b&amp;quot;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="回溯" scheme="http://zhuuu.work/tags/%E5%9B%9E%E6%BA%AF/"/>
    
      <category term="剪枝" scheme="http://zhuuu.work/tags/%E5%89%AA%E6%9E%9D/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-680-验证回文串II</title>
    <link href="http://zhuuu.work/2020/05/20/Leetcode/Leetcode-680-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2II/"/>
    <id>http://zhuuu.work/2020/05/20/Leetcode/Leetcode-680-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2II/</id>
    <published>2020-05-20T08:22:53.000Z</published>
    <updated>2020-05-20T07:45:52.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-680-Valid-Palindrome-II"><a href="#Leecode-680-Valid-Palindrome-II" class="headerlink" title="Leecode-680-Valid Palindrome II"></a>Leecode-680-<a href="https://leetcode-cn.com/problems/valid-palindrome-ii/" target="_blank" rel="noopener">Valid Palindrome II</a></h1><h2 id="思路：双指针"><a href="#思路：双指针" class="headerlink" title="思路：双指针"></a>思路：双指针</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非空字符串 <code>s</code>，<strong>最多</strong>删除一个字符。判断是否能成为回文字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;aba&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abca&quot;</span><br><span class="line">输出: True</span><br><span class="line">解释: 你可以删除c字符。</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Solution：</strong></p><ul><li><p>本题<strong>基于Leetcode–125题基础上</strong>增加了可以删除一个字母达到回文串的效果</p></li><li><p>首先我们来看一下如果判断回文串的代码</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrime</span><span class="params">(String s,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">        <span class="comment">// 如果两个指针不相等</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) != s.charAt(j))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 相等的话就各移动一位</span></span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全都满足返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>思路：两次回文串判断</strong><ul><li><strong>第一次：如上代码，判断一个字符串是不是回文串</strong></li><li><strong>第二次：如果不是，给你一次机会（这里指的机会是：删除一个字母）</strong><ul><li>（删除的含义：<code>递归判断左指针+1 到右指针 或者 左指针到右指针-1</code>）这两者其一是不是回文串。</li></ul></li></ul></li></ul><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><strong>Solution :</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第二次判断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>||s.equals(<span class="string">""</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = s.length() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="comment">// 如果当前左右指针不相等</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left) != s.charAt(right))&#123;</span><br><span class="line">                <span class="comment">// 判断左指针+1 到右指针 或者 左指针到右指针-1</span></span><br><span class="line">                <span class="comment">// 两者其一是不是回文串</span></span><br><span class="line">                <span class="keyword">return</span> isPalindrime(s,left + <span class="number">1</span>,right)||isPalindrime(s,left,right - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 是的话就各移动一位</span></span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次判断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrime</span><span class="params">(String s,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">            <span class="comment">// 如果两个指针不相等</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 相等的话就各移动一位</span></span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 全都满足返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><strong>Solution :</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-680-Valid-Palindrome-II&quot;&gt;&lt;a href=&quot;#Leecode-680-Valid-Palindrome-II&quot; class=&quot;headerlink&quot; title=&quot;Leecode-680-Valid Palindrome II&quot;&gt;&lt;/a&gt;Leecode-680-&lt;a href=&quot;https://leetcode-cn.com/problems/valid-palindrome-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Valid Palindrome II&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：双指针&quot;&gt;&lt;a href=&quot;#思路：双指针&quot; class=&quot;headerlink&quot; title=&quot;思路：双指针&quot;&gt;&lt;/a&gt;思路：双指针&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个非空字符串 &lt;code&gt;s&lt;/code&gt;，&lt;strong&gt;最多&lt;/strong&gt;删除一个字符。判断是否能成为回文字符串。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;aba&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: True&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;abca&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: True&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 你可以删除c字符。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-125-验证回文串</title>
    <link href="http://zhuuu.work/2020/05/20/Leetcode/Leetcode-125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <id>http://zhuuu.work/2020/05/20/Leetcode/Leetcode-125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</id>
    <published>2020-05-20T07:22:53.000Z</published>
    <updated>2020-06-20T01:31:47.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-125-Valid-Palindrome"><a href="#Leecode-125-Valid-Palindrome" class="headerlink" title="Leecode-125-Valid Palindrome"></a>Leecode-125-<a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">Valid Palindrome</a></h1><h2 id="思路：双指针"><a href="#思路：双指针" class="headerlink" title="思路：双指针"></a>思路：双指针</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串，验证它是否是回文串，</p><ul><li><strong>只考虑字母和数字字符，</strong>  (Character.isLettorOrDigit())</li><li><strong>可以忽略字母的大小写。</strong>（toLowerCase()）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Solution：</strong></p><ul><li><p>左右指针遍历字符串</p></li><li><p>左指针不是字符或者数字（向右移动一位，结束本次循环）</p></li><li><p>右指针不是字符或者数字（向左移动一位，结束本次循环）</p></li><li><p>左右对应字母或者数字相等（同时移动一位，继续判断下一位是否相等）</p></li></ul><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><strong>Solution :</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 空字符串也是回文串</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 全部转化成小写比较</span></span><br><span class="line">        String low = s.toLowerCase();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = s.length() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="comment">// 如果左指针不是数字或者字母</span></span><br><span class="line">            <span class="keyword">if</span> (!Character.isLetterOrDigit(low.charAt(left)))&#123;</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果右指针不是数字或者字母</span></span><br><span class="line">            <span class="keyword">if</span> (!Character.isLetterOrDigit(low.charAt(right)))&#123;</span><br><span class="line">                right--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果两个指针不相等</span></span><br><span class="line">            <span class="keyword">if</span> (low.charAt(left) != low.charAt(right))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>： O(n) 遍历一遍字符串</li><li><strong>空间复杂度</strong>： O(1) 不需要额外的空间</li></ul><p>测试用例：<code>race a car</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">    System.out.println(solution.isPalindrome(<span class="string">"race a car"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-125-Valid-Palindrome&quot;&gt;&lt;a href=&quot;#Leecode-125-Valid-Palindrome&quot; class=&quot;headerlink&quot; title=&quot;Leecode-125-Valid Palindrome&quot;&gt;&lt;/a&gt;Leecode-125-&lt;a href=&quot;https://leetcode-cn.com/problems/valid-palindrome/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Valid Palindrome&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：双指针&quot;&gt;&lt;a href=&quot;#思路：双指针&quot; class=&quot;headerlink&quot; title=&quot;思路：双指针&quot;&gt;&lt;/a&gt;思路：双指针&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个字符串，验证它是否是回文串，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;只考虑字母和数字字符，&lt;/strong&gt;  (Character.isLettorOrDigit())&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可以忽略字母的大小写。&lt;/strong&gt;（toLowerCase()）&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;A man, a plan, a canal: Panama&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;race a car&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>��Դ��Ŀ-01-ELAdmin</title>
    <link href="http://zhuuu.work/2020/05/20/Project/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-01-ELAdmin/"/>
    <id>http://zhuuu.work/2020/05/20/Project/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-01-ELAdmin/</id>
    <published>2020-05-20T03:02:24.000Z</published>
    <updated>2020-05-20T07:01:07.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="��Դ��L-01-ELAdmin"><a href="#��Դ��L-01-ELAdmin" class="headerlink" title="��Դ��Ŀ-01-ELAdmin"></a>��Դ��Ŀ-01-ELAdmin</h1><h2 id="j��"><a href="#j��" class="headerlink" title="ǰ��"></a>ǰ��</h2><p>����ܻ�����඼ok��ʱ���������Ҹ���Դ��Ŀ��һ����</p><p>�����и�����Ŀ�Դǰ��˷�����Ŀ-ELAdmin</p><p>[][<a href="https://docs.auauz.net/]" target="_blank" rel="noopener">https://docs.auauz.net/]</a></p><p>[][<a href="https://docs.auauz.net/]" target="_blank" rel="noopener">https://docs.auauz.net/]</a></p><p>[����][<a href="https://docs.auauz.net/]" target="_blank" rel="noopener">https://docs.auauz.net/]</a></p><p>[Gitee���ص�ַ��ǰ��][<a href="https://gitee.com/elunez/eladmin-web]" target="_blank" rel="noopener">https://gitee.com/elunez/eladmin-web]</a></p><p>[Gitee���ص�ַ�����][<a href="https://gitee.com/elunez/eladmin]" target="_blank" rel="noopener">https://gitee.com/elunez/eladmin]</a></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200520/111839444.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200520/111901387.png" alt="mark"></p><a id="more"></a><h2 id="1-����ע��"><a href="#1-����ע��" class="headerlink" title="1. ����ע��"></a>1. ����ע��</h2><p>������ϣ�Ȼ���ѹ������ʹ���������أ�</p><p>��ѹ���Ȳ�Ҫ�ż����У�</p><p><strong>�۲죺</strong></p><p>1��������Щ���� ��Springboot��Vue��Redis��MQ…�� </p><p>2���Ƿ������ݿ� ��MySQL�� </p><p>3����Ļ����Ƿ�ƥ�䣨Java��Maven��npm��nodejs��redis, …..��</p><p>ͨ���ˣ�Ȼ������취���У�</p><h2 id="2-�������g�һ��"><a href="#2-�������g�һ��" class="headerlink" title="2. �������ǵ�һ��"></a>2. �������ǵ�һ��</h2><p>1����װ���ݿ⣬ִ��SQL</p><p>2��ǰ����Ҫ��������</p><p>3�������Ŀ����������! </p><p>4�����������Ŀ��</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200520/113715269.png" alt="mark"></p><p>ֻҪ������Swagger����ô�������ĵ�һ�������Ƚ���Swagger-uiҳ�棡��Ϊ�����涼�ǽӿڣ�</p><p>�����鿴�����ļ��� Ĭ�϶˿ڣ�����Щ���ã���Ҫ��Ϊ�Լ�����Ŀ�ͻ�����ַ��</p><p>ǰ�˾��ǰ�װ�����������������У����ӿ��Ƿ�������</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200520/130935339.png" alt="mark"></p><p>������֮������ͼ��ʾ��</p><h2 id="3-j��˷�����L�L̶���·"><a href="#3-j��˷�����L�L̶���·" class="headerlink" title="3. ǰ��˷�����Ŀ�Ĺ̶���·"></a>3. ǰ��˷�����Ŀ�Ĺ̶���·</h2><ol><li><p>��ǰ�˿�ʼ�������򿪿���̨����һ���ӿڣ�����һ�����ù�ϵ��</p></li><li><p>ǰ��˵��ö˿ڲ�һ��</p><ul><li>�ص㣺�ҵ��ӿڵĵ��ù�ϵ</li><li>SpringBoot�ṩ����ǰ�˵��ýӿڣ�Vue������Ⱦҳ�棡</li></ul></li><li><p>Controller–&gt;Service–&gt;DAO</p></li></ol><p>���Ҫ����ѧϰһ��ģ�飬�����ģ�������ȡ�������ɣ�</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;��Դ��L-01-ELAdmin&quot;&gt;&lt;a href=&quot;#��Դ��L-01-ELAdmin&quot; class=&quot;headerlink&quot; title=&quot;��Դ��Ŀ-01-ELAdmin&quot;&gt;&lt;/a&gt;��Դ��Ŀ-01-ELAdmin&lt;/h1&gt;&lt;h2 id=&quot;j��&quot;&gt;&lt;a href=&quot;#j��&quot; class=&quot;headerlink&quot; title=&quot;ǰ��&quot;&gt;&lt;/a&gt;ǰ��&lt;/h2&gt;&lt;p&gt;����ܻ�����඼ok��ʱ���������Ҹ���Դ��Ŀ��һ����&lt;/p&gt;
&lt;p&gt;�����и�����Ŀ�Դǰ��˷�����Ŀ-ELAdmin&lt;/p&gt;
&lt;p&gt;[][&lt;a href=&quot;https://docs.auauz.net/]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.auauz.net/]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[][&lt;a href=&quot;https://docs.auauz.net/]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.auauz.net/]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[����][&lt;a href=&quot;https://docs.auauz.net/]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.auauz.net/]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[Gitee���ص�ַ��ǰ��][&lt;a href=&quot;https://gitee.com/elunez/eladmin-web]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://gitee.com/elunez/eladmin-web]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[Gitee���ص�ַ�����][&lt;a href=&quot;https://gitee.com/elunez/eladmin]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://gitee.com/elunez/eladmin]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200520/111839444.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200520/111901387.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="��Դ��Ŀ" scheme="http://zhuuu.work/tags/%EF%BF%BD%EF%BF%BD%D4%B4%EF%BF%BD%EF%BF%BDL/"/>
    
      <category term="ǰ��˷���" scheme="http://zhuuu.work/tags/j%EF%BF%BD%EF%BF%BD%CB%B7%EF%BF%BD%EF%BF%BD%EF%BF%BD/"/>
    
  </entry>
  
  <entry>
    <title>Spring-08-声明式事务</title>
    <link href="http://zhuuu.work/2020/05/20/Spring/Spring-08-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>http://zhuuu.work/2020/05/20/Spring/Spring-08-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/</id>
    <published>2020-05-20T00:22:24.000Z</published>
    <updated>2020-05-27T03:47:45.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-08-声明式事务"><a href="#Spring-08-声明式事务" class="headerlink" title="Spring-08-声明式事务"></a>Spring-08-声明式事务</h1><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200508/203155619.png" alt="mark"></p><h2 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h2><p>官网mybatis-spring : <a href="http://mybatis.org/spring/zh/index.html" target="_blank" rel="noopener">http://mybatis.org/spring/zh/index.html</a></p><a id="more"></a><h2 id="1-回顾事务"><a href="#1-回顾事务" class="headerlink" title="1. 回顾事务"></a>1. 回顾事务</h2><ul><li>事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！</li><li>事务管理是企业级应用程序开发中必备技术，用来确保数据的完整性和一致性。</li></ul><p>事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用。</p><p>事务的ACID原则：</p><ol><li><p>原子性（atomicity）</p></li><li><ul><li>事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用</li></ul></li><li><p>一致性（consistency）</p></li><li><ul><li>一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中</li></ul></li><li><p>隔离性（isolation）</p></li><li><ul><li>可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏</li></ul></li><li><p>持久性（durability）</p></li><li><ul><li>事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持久化存储器中</li></ul></li></ol><h2 id="2-普通事务测试"><a href="#2-普通事务测试" class="headerlink" title="2. 普通事务测试"></a>2. 普通事务测试</h2><p>将上一篇的代码拷贝到一个新的项目中</p><ol><li>在之前的案例中，我们给userDao接口新增两个方法，删除和增加用户；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加一个用户</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据id删除用户</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>mapper文件，我们故意把 deletes 写错，测试！</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.kuang.pojo.User"</span>&gt;</span></span><br><span class="line">insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteUser"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">deletes from user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>编写接口的实现类，在实现类中，我们去操作一波</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//增加一些操作</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       User user = <span class="keyword">new</span> User(<span class="number">4</span>,<span class="string">"小明"</span>,<span class="string">"123456"</span>);</span><br><span class="line">       UserMapper mapper = getSqlSession().getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">       mapper.addUser(user);</span><br><span class="line">       mapper.deleteUser(<span class="number">4</span>);</span><br><span class="line">       <span class="keyword">return</span> mapper.selectUser();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//新增</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">       UserMapper mapper = getSqlSession().getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">       <span class="keyword">return</span> mapper.addUser(user);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">//删除</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">       UserMapper mapper = getSqlSession().getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">       <span class="keyword">return</span> mapper.deleteUser(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>测试：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">   ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">   UserMapper mapper = (UserMapper) context.getBean(<span class="string">"userDao"</span>);</span><br><span class="line">   List&lt;User&gt; user = mapper.selectUser();</span><br><span class="line">   System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候发现报错：sql异常，delete写错了</p><p>结果：插入成功，并没有回滚</p><p>没有进行事务的管理；我们想让他们都成功才成功，有一个失败，就都失败，我们就应该需要<strong>事务！</strong></p><p>以前我们都需要自己手动管理事务，十分麻烦！</p><p>但是Spring给我们提供了事务管理，我们只需要配置即可；</p><h2 id="3-Spring中的事务管理"><a href="#3-Spring中的事务管理" class="headerlink" title="3. Spring中的事务管理"></a>3. Spring中的事务管理</h2><p>Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制。Spring支持编程式事务管理和声明式的事务管理。</p><ul><li><strong>编程式事务管理</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200527/113346799.png" alt="mark"></p><p>​    将事务管理代码嵌到业务方法中来控制事务的提交和回滚</p><p>​    缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码</p><ul><li><strong>声明式事务管理（只用这个,基本配置也是固定的）</strong><ul><li>一般情况下比编程式事务好用。</li><li>将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。</li><li>将事务管理作为横切关注点，<strong>通过aop方法模块化</strong>。Spring中通过Spring AOP框架支持声明式事务管理。</li></ul></li></ul><ol><li>使用Spring管理事务，注意头文件的约束导入：<strong>tx</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xmlns:tx="http://www.springframework.org/schema/tx"</span><br><span class="line"></span><br><span class="line">http://www.springframework.org/schema/tx</span><br><span class="line">http://www.springframework.org/schema/tx/spring-tx.xsd"&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>事务管理器</li></ol><ul><li>无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。</li><li>就是 Spring的核心事务管理抽象，管理封装了一组独立于技术的方法。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>配置好事务管理器后我们需要去配置事务的通知</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置事务通知--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"add"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"delete"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"update"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"search*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"get"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>spring事务传播特性：</strong></p><p>事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为：</p><ul><li><strong>propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。</strong></li><li>propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。</li><li>propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。</li><li>propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。</li><li>propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li>propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。</li><li>propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作</li></ul><p>Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">假设 ServiveX#methodX() 都工作在事务环境下（即都被 Spring 事务增强了），</span><br><span class="line">假设程序中存在如下的调用链：</span><br><span class="line">Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()，</span><br><span class="line">那么这 3 个服务类的 3 个方法通过 Spring 的事务传播机制都工作在同一个事务中。</span><br></pre></td></tr></table></figure><p>就好比，我们刚才的几个方法存在调用，所以会被放在一组事务当中！</p><ol start="4"><li>配置AOP</li></ol><ul><li><p>导入aop的头文件</p></li><li><p>aop 织入</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置aop织入事务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"txPointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.zhuuu.dao.*.*(..))"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"txPointcut"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>测试</li></ol><p>删掉刚才插入的数据，再次测试！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">   ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">   UserMapper mapper = (UserMapper) context.getBean(<span class="string">"userDao"</span>);</span><br><span class="line">   List&lt;User&gt; user = mapper.selectUser();</span><br><span class="line">   System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果发现：因为插入失败，所以事务进行了回滚！！</strong></p><p>参考文档：<a href="http://mybatis.org/spring/zh/transactions.html" target="_blank" rel="noopener">http://mybatis.org/spring/zh/transactions.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring-08-声明式事务&quot;&gt;&lt;a href=&quot;#Spring-08-声明式事务&quot; class=&quot;headerlink&quot; title=&quot;Spring-08-声明式事务&quot;&gt;&lt;/a&gt;Spring-08-声明式事务&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200508/203155619.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前序&quot;&gt;&lt;a href=&quot;#前序&quot; class=&quot;headerlink&quot; title=&quot;前序&quot;&gt;&lt;/a&gt;前序&lt;/h2&gt;&lt;p&gt;官网mybatis-spring : &lt;a href=&quot;http://mybatis.org/spring/zh/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mybatis.org/spring/zh/index.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Spring" scheme="http://zhuuu.work/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="http://zhuuu.work/2020/05/19/GoF23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zhuuu.work/2020/05/19/GoF23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-05-19T07:22:24.000Z</published>
    <updated>2020-06-29T01:34:53.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>为什么要学习代理模式，因为AOP的底层机制就是动态代理！</p><p>代理模式：</p><ul><li>静态代理</li><li>动态代理</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200519/193958809.png" alt="mark"></p><a id="more"></a><h2 id="1-静态代理"><a href="#1-静态代理" class="headerlink" title="1. 静态代理"></a>1. 静态代理</h2><ul><li>抽象角色：一般使用接口或者抽象类实现</li><li>真实角色：被代理的角色</li><li>代理角色：代理真实角色，代理真实角色后，一般会做一些附属的操作。</li><li>客户：使用代理角色来进行一些操作。</li></ul><ol><li>Rent.java 即抽象角色</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提升的功能(也就是抽象角色)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Host.java 即真实角色</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//真实角色: 房东，房东要出租房子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> <span class="keyword">implements</span> <span class="title">Rent</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是房东，我要出租房子"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Proxy.java 即代理角色</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理角色：中介</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Rent</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找房东</span></span><br><span class="line">    <span class="keyword">private</span> Host host;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许new中介</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Host host)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        seeHouse();</span><br><span class="line">        host.rent();</span><br><span class="line">        fare();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"收中介费"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">seeHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"带客官看房"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>Client.java  客户</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户类，一般客户都会去找代理！</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 房东这个人首先要活着</span></span><br><span class="line">        Host host = <span class="keyword">new</span> Host();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再去找中介</span></span><br><span class="line">        Proxy proxy = <span class="keyword">new</span> Proxy(host);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中介给你房子</span></span><br><span class="line">        proxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是一个非常轻松易懂的租房攻略（哦 不对 ，代理模式例子）</p><p>分析：在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧租到了房东的房子通过代理，这就是所谓的代理模式，程序源自于生活，所以学编程的人，一般能够更加抽象的看待生活中发生的事情。</p><p><strong>静态代理的好处:</strong></p><ul><li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li><li>公共的业务由代理来完成 . 实现了业务的分工 ,</li><li>公共业务发生扩展时变得更加集中和方便 .</li></ul><p><strong>缺点：</strong></p><ul><li>类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 .</li></ul><p><strong>当改进了静态代理的缺点之后，动态代理就产生了！</strong></p><h2 id="2-静态代理再理解"><a href="#2-静态代理再理解" class="headerlink" title="2. 静态代理再理解"></a>2. 静态代理再理解</h2><ol><li>创建一个抽象角色（增删改查）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象角色：增删改查业务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>真实对象完成增删改查任务</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//真实对象，完成增删改查操作的人</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"增加了一个用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除了一个用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"更新了一个用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"查询了一个用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>现在添加一个需求，增加一个日志功能</li></ol><ul><li>思路1：在实现类上增加代码 【麻烦！】</li><li><strong>思路2：交给代理去做（在不改变原有代码的基础上，实现此功能）</strong></li></ul><ol start="4"><li>设置一个代理类来处理日志（代理角色）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代理代理谁？</span></span><br><span class="line">    <span class="keyword">private</span> UserServiceImpl userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring会通过set注入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserService</span><span class="params">(UserServiceImpl userService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log(<span class="string">"add"</span>);</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log(<span class="string">"delete"</span>);</span><br><span class="line">        userService.delete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log(<span class="string">"update"</span>);</span><br><span class="line">        userService.update();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log(<span class="string">"query"</span>);</span><br><span class="line">        userService.query();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 日志功能</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行了"</span> + msg + <span class="string">"方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>测试(客户端)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 被代理的首先要活着</span></span><br><span class="line">        UserServiceImpl userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 代理类来代理业务</span></span><br><span class="line">        UserServiceProxy proxy = <span class="keyword">new</span> UserServiceProxy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用代理类实现日志功能</span></span><br><span class="line">        proxy.setUserService(userService);</span><br><span class="line">        proxy.add();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，到了现在代理模式大家应该都没有什么问题了，重点大家需要理解其中的思想；</p><ul><li>我们在不改变原来的代码的情况下，实现了对原有功能的增强，</li><li>这是AOP中最核心的思想</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200519/200935050.png" alt="mark"></p><h2 id="3-动态代理（反射实现）"><a href="#3-动态代理（反射实现）" class="headerlink" title="3. 动态代理（反射实现）"></a>3. 动态代理（反射实现）</h2><ul><li>动态代理的角色和静态代理一样</li><li>动态代理的代理类是动态生成的，静态代理的代理类是我们提前写好的</li><li>动态代理分为两类：一类是<strong>基于接口的动态代理</strong>，一类是<strong>基于类的动态代理</strong><ul><li>基于接口的动态代理：JDK动态代理（Proxy,InvocationHandler）</li><li>基于类的动态代理:cglib</li><li>现在用得比较多的是javasist来生成动态代理（可以百度一下）</li></ul></li></ul><p>我们这里使用JDK原生代码来实现，其余道理是一样的。</p><h3 id="3-1-两个类"><a href="#3-1-两个类" class="headerlink" title="3.1 两个类"></a>3.1 两个类</h3><p>核心：</p><ul><li>InvocationHandler  </li><li>Proxy</li></ul><p>【InvocationHandler：调用处理程序】</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200520/101709174.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.reflect;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">proxy - 调用该方法的代理实例</span></span><br><span class="line"><span class="comment">method - 代理接口方法的实例</span></span><br><span class="line"><span class="comment">args - 代理接口方法的实例的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>【Proxy  : 代理】</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="comment">// 主要是newProxyInstance方法，动态生成代理类</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">        <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            Throwable t = e.getCause();</span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-通用动态代理实现类"><a href="#3-2-通用动态代理实现类" class="headerlink" title="3.2 通用动态代理实现类"></a>3.2 通用动态代理实现类</h3><p>编写一个通用的动态代理实现的类！所有的代理对象设置为Object即可！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成代理类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                <span class="keyword">this</span>.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// proxy ： 代理类</span></span><br><span class="line">    <span class="comment">// method : 代理类中要代理的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">        <span class="comment">// 业务逻辑代码</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(target,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-实例探究"><a href="#3-3-实例探究" class="headerlink" title="3.3 实例探究"></a>3.3 实例探究</h3><p>抽象角色和真实角色和之前的一样！</p><ol><li>抽象角色</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.invokeProxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提升的功能(也就是抽象角色)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>真实角色</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//真实角色: 房东，房东要出租房子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> <span class="keyword">implements</span> <span class="title">Rent</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是房东，我要出租房子"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>代理角色(动态代理)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RentProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代理的功能</span></span><br><span class="line">    <span class="keyword">private</span> Rent rent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRent</span><span class="params">(Rent rent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rent = rent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成代理类，重点是第二个参数，获取要代理的抽象角色！</span></span><br><span class="line">    <span class="comment">// 之前都是一个角色，现在可以代理一类角色</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                <span class="keyword">this</span>.getClass().getClassLoader(),</span><br><span class="line">                rent.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理代理实例上的方法调用并返回结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        seeHouse();</span><br><span class="line">        Object result = method.invoke(rent, args);</span><br><span class="line">        fare();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//看房</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seeHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"带房客看房"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//收中介费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fare</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"收中介费"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>Client.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先一样的，房东要活着</span></span><br><span class="line">        Host host = <span class="keyword">new</span> Host();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 代理角色代理房东</span></span><br><span class="line">        RentProxy pih = <span class="keyword">new</span> RentProxy();</span><br><span class="line">        pih.setRent(host);<span class="comment">//将真实角色放置进去！</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态生成对应的代理类(注意返回类型是接口)</span></span><br><span class="line">        Rent proxy = (Rent) pih.getProxy();</span><br><span class="line">        proxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心：</p><ul><li>一个动态代理<ul><li><strong>一般代理某一类业务，</strong></li><li><strong>一个动态代理可以代理多个类</strong></li><li><strong>代理的是接口</strong></li></ul></li></ul><h3 id="3-4-优点总结"><a href="#3-4-优点总结" class="headerlink" title="3.4 优点总结"></a>3.4 优点总结</h3><p>静态代理有的它都有，静态代理没有的，它也有！</p><ul><li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li><li>公共的业务由代理来完成 . 实现了业务的分工 ,</li><li>公共业务发生扩展时变得更加集中和方便 .</li><li>一个动态代理 , 一般代理某一类业务</li><li>一个动态代理可以代理多个类，代理的是接口！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h1&gt;&lt;p&gt;为什么要学习代理模式，因为AOP的底层机制就是动态代理！&lt;/p&gt;
&lt;p&gt;代理模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态代理&lt;/li&gt;
&lt;li&gt;动态代理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200519/193958809.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="设计者模式" scheme="http://zhuuu.work/tags/%E8%AE%BE%E8%AE%A1%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-阿里巴巴开发手册</title>
    <link href="http://zhuuu.work/2020/05/19/Guide/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/"/>
    <id>http://zhuuu.work/2020/05/19/Guide/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/</id>
    <published>2020-05-19T04:30:53.000Z</published>
    <updated>2020-05-25T14:40:56.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读书笔记-阿里巴巴开发手册"><a href="#读书笔记-阿里巴巴开发手册" class="headerlink" title="读书笔记-阿里巴巴开发手册"></a>读书笔记-阿里巴巴开发手册</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本笔记针对最新版本-<strong>泰山版</strong>开发手册进行阐述分析</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200519/123256378.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200519/123313920.png" alt="mark"></p><p>希望各位未来可以有所大成，达到（会当凌绝顶，一览众山小）的境界。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200519/224430806.png" alt="mark"></p><p>废话不多说，我们直接来看正文….</p><a id="more"></a><h2 id="1-编码规约"><a href="#1-编码规约" class="headerlink" title="1. 编码规约"></a>1. 编码规约</h2><h3 id="1-1-命名风格"><a href="#1-1-命名风格" class="headerlink" title="1.1 命名风格"></a>1.1 命名风格</h3><p>【强制】代码中的命名均<strong>不能以下划线或美元符号</strong>开始，也不能以下划线或美元符号结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反例：_name / __name / $name / name_ / name$ / name__</span><br></pre></td></tr></table></figure><p>尽管 <code>$</code> 可以作为标识符使用，然而我们应该尽量避免对其使用。</p><ul><li>原因：<code>$</code> 通常在编译器生成的标识符名称中使用，如果我们也使用这个符号，可能会有一些意想不到的错误发生….</li><li>意向不到的错误示例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>$<span class="title">VIP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        User.VIP vip = user.<span class="keyword">new</span> VIP();</span><br><span class="line">        vip.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">VIP</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"成员类"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细阅读以下，似乎并没有什么问题，代码也比较简单，但正在我们编译的时候，IDEA提示我们：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200519/124327435.png" alt="mark"></p><p>定义了重复的代码？归根到底，都是 <code>$</code> 惹的祸！因为 <code>$</code> 被编译器所使用，在源文件（.java文件）编译成字节码（.class文件）中，会被称为顶层类型与嵌套类型之间的连接符。</p><p>例如：如果存在一个顶层类A,在其内声明一个成员类B,那么编译之后就会产生两个class文件，分别是<code>A.class</code> 与 <code>A$B.class</code>。</p><p>就本程序来说，会生成 3 个 class 文件（如果可以编译的话），分别是 <code>User$VIP.class</code>（顶层类）、<code>User.class</code> 与 <code>User$VIP.class</code>（User 类的成员类，也就是类 VIP）。由于试图存在两个 <code>User$VIP.class</code> 所以才会报错！</p><ul><li>编程相关的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正例：ali / alibaba / taobao / cainiao/ aliyun/ youku / hangzhou 等国际通用的名称，可视同英文。</span><br><span class="line">反例：DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3</span><br></pre></td></tr></table></figure><ul><li><strong>类名</strong>要使用<strong>UpperCamelCase</strong>风格（大驼峰命名）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正例：ForceCode / UserDO / HtmlDTO / XmlService / TcpUdpDeal / TaPromotion</span><br><span class="line">反例：forcecode / UserDo / HTMLDto / XMLService / TCPUDPDeal / TAPromotion</span><br></pre></td></tr></table></figure><ul><li><strong>方法名</strong>，参数名，成员变量，局部变量统一使用<strong>lowerCamelCase</strong>（小驼峰命名）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正例： localValue &#x2F; getHttpMessage() &#x2F; inputUserId</span><br></pre></td></tr></table></figure><ul><li>常量名全部大写，单词间用下划线隔开。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正例：MAX_STOCK_COUNT &#x2F; CACHE_EXPIRED_TIME</span><br><span class="line">反例：MAX_COUNT &#x2F; EXPIRED_TIME</span><br></pre></td></tr></table></figure><ul><li><p>抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类</p><p>命名以它要测试的类的名称开始，以 Test 结尾。</p></li><li><p>类型中括号紧挨相邻来表示数组<code>数组 int[] arrayDemo;</code></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正例：定义整形数组 int[] arrayDemo;</span><br><span class="line">反例：在 main 参数中，使用 String args[]来定义。</span><br></pre></td></tr></table></figure><ul><li><p>POJO 类中的任何布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列</p><p>化错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定义为基本数据类型 boolean isSuccess;的属性，它的方法也是 isSuccess() ，RPC框架在反向解析的时候，“以为”对应的属性名称是 success ，导致属性获取不到，进而抛出异常。</span><br></pre></td></tr></table></figure></li></ul><ul><li>包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。</li><li>包名统一使用<strong>单数</strong>形式，但是如果类名有复数的含义，类名也可以使用负数形式。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">包名：util</span><br><span class="line">类名：RedisUtils</span><br></pre></td></tr></table></figure><ul><li>避免在子父类成员变量之间，或者不同代码块的局部变量之间采用完全相同的命名，使可读性降低。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">说明：子类、父类成员变量名相同，即使是 public 类型的变量也是能够通过编译，而局部变量在同一方法</span><br><span class="line">内的不同代码块中同名也是合法的，但是要避免使用。对于非 setter&#x2F;getter 的参数名称也要避免与成员变</span><br><span class="line">量名称相同。</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200519/225803154.png" alt="mark"></p><ul><li><p>为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组</p><p>合来表达。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正例：在 JDK 中，对某个对象引用的 volatile 字段进行原子更新的类名为：AtomicReferenceFieldUpdater。</span><br><span class="line">反例：常见的方法内变量为 int a;的定义方式。</span><br></pre></td></tr></table></figure><ul><li>在常量变量命名的时候，表示类型的名词放在词尾，来提高辨识度</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正例：startTime &#x2F; workQueue &#x2F; nameList &#x2F; TERMINATED_THREAD_COUNT</span><br><span class="line">反例：startedAt &#x2F; QueueOfWork &#x2F; listName &#x2F; COUNT_TERMINATED_THREAD</span><br></pre></td></tr></table></figure><ul><li>如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。</span><br><span class="line">正例： public class OrderFactory;</span><br><span class="line"> public class LoginProxy;</span><br><span class="line"> public class ResourceObserver;</span><br></pre></td></tr></table></figure><ul><li><strong>接口类中的方法和属性不要加任何修饰符号</strong>（public 也不要加），保持代码的间接性，并加上有效的Javadoc注释。 （<strong>尽量不要在接口中定义变量，如果一定要定义变量，确定与接口方法相关，并且是整个应用的基础常量</strong>。）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">正例：接口方法签名 void commit();</span><br><span class="line">  接口基础常量 String COMPANY &#x3D; &quot;alibaba&quot;;</span><br><span class="line">  </span><br><span class="line">反例：接口方法定义 public abstract void f();</span><br><span class="line">说明：JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现。</span><br></pre></td></tr></table></figure><ul><li><strong>接口和实现类的两套规则</strong></li></ul><ol><li><strong>对于Service和DAO类，基于SOA理念，暴露出来的一定是接口，内部的实现类用Impl的后缀与接口相区别</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正例：CacheServiceImpl 实现 CacheService 接口。</span><br></pre></td></tr></table></figure><ol start="2"><li>如果是形容能力的接口名称，取对应的形容词为接口名（通常是–able 的形容词）。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正例：AbstractTranslator 实现 Translatable 接口。</span><br></pre></td></tr></table></figure><ul><li>枚举类带上Enum后缀，枚举成员名称需要全部大写，单词用下换线隔开</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">说明：枚举是特殊的常量类，且构造方法被默认强制私有。</span><br><span class="line">正例：枚举名字是ProcessStatusEnum的成员名称：SUCCESS&#x2F;UNKNOWN_REASON</span><br></pre></td></tr></table></figure><ul><li><strong>各层命名规约：</strong><ul><li>Service/DAO 层方法命名规约<ul><li>获取单个对象的方法用get做前缀</li><li>获取多个对象的方法用list做前缀，复数结尾 如<code>listObjects</code></li><li>获取统计值的方法用count做前缀</li><li>插入的方法用save/insert做前缀</li><li>删除的方法用remove/delete做前缀</li><li>修改的方法用update做前缀</li></ul></li><li>领域模型命名规约<ul><li>数据对象：<code>xxxDO</code>, 其中xxx是数据表名</li><li>数据传输对象： <code>xxxDTO</code>  ,xxx 为业务领域相关的名称。</li><li>展示对象：<code>xxxVO</code>, 其中xxx一般是网页的名字</li><li>POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO</li></ul></li></ul></li></ul><h3 id="1-2-常量定义"><a href="#1-2-常量定义" class="headerlink" title="1.2 常量定义"></a>1.2 常量定义</h3><ul><li>不允许任何魔法值（即未经预先定义的常量）直接出现在代码中。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">反例：</span><br><span class="line">&#x2F;&#x2F;本例中同学 A 定义了缓存的 key，然后缓存提取的同学 B 使用了 Id#taobao 来提取，少了下划线，导致故障。</span><br><span class="line">String key &#x3D; &quot;Id#taobao_&quot; + tradeId;</span><br><span class="line">cache.put(key, value);</span><br></pre></td></tr></table></figure><ul><li><strong>在long或者Long赋值时候，数值使用大写的L,不能是小写的l,小写容易跟数字搞混</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">说明：Long a &#x3D; 2l; 写的是数字的 21，还是 Long 型的 2。</span><br></pre></td></tr></table></figure><ul><li>不要使用一个常量类维护所有的常量，要按常量功能进行分类，分开维护</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">说明：大而全的常量类，杂乱无章，不利于理解和维护</span><br><span class="line">正例：缓存相关的放到CacheConsts下，系统配置的放到ConfigConsts下</span><br></pre></td></tr></table></figure><ul><li>常量的复用层次有五层<ul><li>跨应用共享常量</li><li>应用内共享常量</li><li>子工程内共享常量</li><li>包内共享常量</li><li>类内共享常量</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类内共享常量：private static final 来定义</span><br><span class="line">包内共享常量： 即当前包下单独constant目录下</span><br><span class="line">子工程内部共享常量: 子工程constant目录下</span><br></pre></td></tr></table></figure><ul><li>如果一个变量值仅在一个固定范围内变化用enum类型来定义</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 说明：如果存在名称之外的延伸类型应使用enum类型，下面正例中的数字就是延伸信息，表示一年中的第几个季节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SeasonEnum&#123;</span><br><span class="line">    SPRING(<span class="number">1</span>),SUMMER(<span class="number">2</span>),AUTUMN(<span class="number">3</span>),WINTER(<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> seq;</span><br><span class="line">    </span><br><span class="line">    SeasonEnum(<span class="keyword">int</span> seq)&#123;</span><br><span class="line">        <span class="keyword">this</span>.seq = seq;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSeq</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-代码格式"><a href="#1-3-代码格式" class="headerlink" title="1.3 代码格式"></a>1.3 代码格式</h3><ul><li><p>如果是大括号内为空，则简洁地写成{}即可，大括号中间无需换行和空格；如果是非</p><p>空代码块则： </p><p>1） 左大括号前不换行。</p><p>2） 左大括号后换行。</p><p>3） 右大括号前换行。</p><p>4） 右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行。</p></li></ul><ul><li><p>左小括号和右边相邻字符之间不出现空格；右小括号和左边相邻字符之间也不出现空</p><p>格；而左大括号前需要加空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反例：if (空格 a &#x3D;&#x3D; b 空格)</span><br></pre></td></tr></table></figure></li></ul><ul><li>if/for/while/switch/do 等保留字与括号之间都必须加空格</li></ul><ul><li>任何二目、三目运算符的左右两边都需要加一个空格。</li></ul><ul><li>采用4个空格的缩进，禁止使用tab字符</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200525/223953251.png" alt="mark"></p><ul><li>注释的双斜线与注释内容只有一个空格。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;读书笔记-阿里巴巴开发手册&quot;&gt;&lt;a href=&quot;#读书笔记-阿里巴巴开发手册&quot; class=&quot;headerlink&quot; title=&quot;读书笔记-阿里巴巴开发手册&quot;&gt;&lt;/a&gt;读书笔记-阿里巴巴开发手册&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本笔记针对最新版本-&lt;strong&gt;泰山版&lt;/strong&gt;开发手册进行阐述分析&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200519/123256378.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200519/123313920.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;希望各位未来可以有所大成，达到（会当凌绝顶，一览众山小）的境界。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200519/224430806.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;废话不多说，我们直接来看正文….&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="开发手册" scheme="http://zhuuu.work/tags/%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/"/>
    
      <category term="读书笔记" scheme="http://zhuuu.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-371-两整数之和</title>
    <link href="http://zhuuu.work/2020/05/17/Leetcode/Leetcode-371-%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://zhuuu.work/2020/05/17/Leetcode/Leetcode-371-%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2020-05-17T03:52:53.000Z</published>
    <updated>2020-05-18T07:56:08.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-371-Sum-of-Two-Integers"><a href="#Leecode-371-Sum-of-Two-Integers" class="headerlink" title="Leecode-371-Sum of Two Integers"></a>Leecode-371-<a href="https://leetcode-cn.com/problems/sum-of-two-integers/" target="_blank" rel="noopener">Sum of Two Integers</a></h1><h2 id="思路：位运算"><a href="#思路：位运算" class="headerlink" title="思路：位运算"></a>思路：位运算</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>不使用运算符 + 个 - ，计算两整数 a,b之和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: a &#x3D; 1, b &#x3D; 2</span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入: a &#x3D; -2, b &#x3D; 3</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>Solution：位运算</strong></p><ul><li>在二进制中的计算就是通过位操作来得到结果的低位和高位</li></ul><a id="more"></a><table><thead><tr><th>a</th><th>b</th><th>低位</th><th>高位</th><th></th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td></td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td></td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td><td></td></tr><tr><td>1</td><td>1</td><td>0</td><td>1</td><td></td></tr></tbody></table><ul><li><strong>从上面表格可以发现</strong><ul><li><strong>低位是  <code>a ^ b</code></strong></li><li><strong>高位是 <code>a &amp; b</code></strong></li></ul></li></ul><ul><li>回想一下在十进制的计算中，如果进位一直大于0，就得往后面进行计算，在这里也是一样。</li><li>只要进位不是0，那么我们就得一直重复计算低位和进位的操作（需要在下一次计算之前把进位向左移动一位，这样进位才能和更高位进行运算。）</li><li><strong>这个时候的a 和 b 就是刚才计算的低位和高位</strong></li></ul><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><strong>Solution :</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二进制的计算中就是要通过位操作来得到结果的低位和进位</span></span><br><span class="line"><span class="comment">// 低位 = a^b，进位 = a &amp; b</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lower = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> carrier = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只要进位不是0，就得一直重复计算低位和进位的操作</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            lower = a^b;  <span class="comment">// 计算低位</span></span><br><span class="line">            carrier = a&amp;b; <span class="comment">// 计算进位</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (carrier == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            a = lower;</span><br><span class="line">            b = carrier&lt;&lt;<span class="number">1</span>; <span class="comment">// 需要在下一次计算之前要把进位向左移动一位,这样进位才能和更高位进行运算</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lower;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">    System.out.println(solution.getSum(<span class="number">9</span>, <span class="number">8</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong> ： O(1) 计算进位的时间</li><li><strong>空间复杂度</strong> ： O(1) 不需要额外的空间</li></ul><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><strong>Solution :</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-371-Sum-of-Two-Integers&quot;&gt;&lt;a href=&quot;#Leecode-371-Sum-of-Two-Integers&quot; class=&quot;headerlink&quot; title=&quot;Leecode-371-Sum of Two Integers&quot;&gt;&lt;/a&gt;Leecode-371-&lt;a href=&quot;https://leetcode-cn.com/problems/sum-of-two-integers/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sum of Two Integers&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：位运算&quot;&gt;&lt;a href=&quot;#思路：位运算&quot; class=&quot;headerlink&quot; title=&quot;思路：位运算&quot;&gt;&lt;/a&gt;思路：位运算&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;不使用运算符 + 个 - ，计算两整数 a,b之和&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: a &amp;#x3D; 1, b &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: a &amp;#x3D; -2, b &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;Solution：位运算&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在二进制中的计算就是通过位操作来得到结果的低位和高位&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="位运算" scheme="http://zhuuu.work/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Spring-07-整合MyBatis</title>
    <link href="http://zhuuu.work/2020/05/17/Spring/Spring-07-%E6%95%B4%E5%90%88MyBatis/"/>
    <id>http://zhuuu.work/2020/05/17/Spring/Spring-07-%E6%95%B4%E5%90%88MyBatis/</id>
    <published>2020-05-17T00:22:24.000Z</published>
    <updated>2020-05-27T02:21:29.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-07-整合MyBatis"><a href="#Spring-07-整合MyBatis" class="headerlink" title="Spring-07-整合MyBatis"></a>Spring-07-整合MyBatis</h1><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200508/203155619.png" alt="mark"></p><h2 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h2><p>官网mybatis-spring : <a href="http://mybatis.org/spring/zh/index.html" target="_blank" rel="noopener">http://mybatis.org/spring/zh/index.html</a></p><a id="more"></a><p>环境准备：</p><ul><li>junit</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;4.12&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><ul><li><p>mybatis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;3.5.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>mysql-connector-java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;5.1.47&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>spring相关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;5.1.10.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;5.1.10.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure></li></ul><ul><li>aspectJ AOP 织入器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.aspectj&#x2F;aspectjweaver --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.9.4&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>配置Maven静态资源过滤问题！</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">   &lt;resources&gt;</span><br><span class="line">       &lt;resource&gt;</span><br><span class="line">           &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;</span><br><span class="line">           &lt;includes&gt;</span><br><span class="line">               &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;</span><br><span class="line">               &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;</span><br><span class="line">           &lt;&#x2F;includes&gt;</span><br><span class="line">           &lt;filtering&gt;true&lt;&#x2F;filtering&gt;</span><br><span class="line">       &lt;&#x2F;resource&gt;</span><br><span class="line">   &lt;&#x2F;resources&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure><h2 id="1-回忆MyBatis"><a href="#1-回忆MyBatis" class="headerlink" title="1. 回忆MyBatis"></a>1. 回忆MyBatis</h2><ol><li>编写实体类 pojo/User</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.pojo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", pwd='"</span> + pwd + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPwd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPwd</span><span class="params">(String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name, String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>编写mybatis-config.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.zhuuu.pojo"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf8<span class="symbol">&amp;amp;</span>serverTimezone=GMT%2B8"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.zhuuu.dao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>编写mapper  (dao/UserMapper)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhuuu.pojo.User;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>编写mapper对应的xml (dao/UserMapper.xml)</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.zhuuu.dao.UserMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String resource = <span class="string">"mybaits-config.xml"</span>;</span><br><span class="line"></span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line"></span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; userList = mapper.selectUser();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果显示如下：（当然这是我自己创建的数据库）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">User&#123;id=1, name='zhuuu', pwd='123456'&#125;</span><br><span class="line">User&#123;id=2, name='张三', pwd='abcdeft'&#125;</span><br><span class="line">User&#123;id=3, name='李四', pwd='435354353'&#125;</span><br><span class="line">User&#123;id=5, name='李五', pwd='123213123'&#125;</span><br><span class="line">User&#123;id=7, name='小明', pwd='123456'&#125;</span><br><span class="line">User&#123;id=8, name='root', pwd='123456'&#125;</span><br></pre></td></tr></table></figure><h2 id="2-学习MyBatis-Spring"><a href="#2-学习MyBatis-Spring" class="headerlink" title="2. 学习MyBatis-Spring"></a>2. 学习MyBatis-Spring</h2><p>官网mybatis-spring : <a href="http://mybatis.org/spring/zh/index.html" target="_blank" rel="noopener">http://mybatis.org/spring/zh/index.html</a></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200527/092328496.png" alt="mark"></p><p>MyBatis-Spring 需要以下版本：</p><table><thead><tr><th align="left">MyBatis-Spring</th><th align="left">MyBatis</th><th align="left">Spring 框架</th><th align="left">Spring Batch</th><th align="left">Java</th></tr></thead><tbody><tr><td align="left">2.0</td><td align="left">3.5+</td><td align="left">5.0+</td><td align="left">4.0+</td><td align="left">Java 8+</td></tr><tr><td align="left">1.3</td><td align="left">3.4+</td><td align="left">3.2.2+</td><td align="left">2.1+</td><td align="left">Java 6+</td></tr></tbody></table><p>如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>要和Spring一起使用MyBatis，需要在Spring应用上下文中至少定义两样东西</strong></p><ul><li><strong>sqlSessionFactory</strong></li><li><strong>数据映射器类</strong></li></ul><ol><li>在 MyBatis-Spring 中，可使用 <code>SqlSessionFactoryBean</code>来创建 <code>SqlSessionFactory</code>。 要配置这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：SqlSessionFactory需要一个 DataSource（数据源）。这可以是任意的 DataSource，只需要和配置其它 Spring 数据库连接一样配置它就可以了。</p><ul><li><strong>在基础的 MyBatis 用法中，是通过 SqlSessionFactoryBuilder 来创建 SqlSessionFactory 的，而在 MyBatis-Spring 中，则使用 SqlSessionFactoryBean 来创建。</strong></li></ul><p>在 MyBatis 中，你可以使用 SqlSessionFactory 来创建 SqlSession。一旦你获得一个 session 之后，你可以使用它来执行映射了的语句，提交或回滚连接，最后，当不再需要它的时候，你可以关闭 session。</p><p>一个常用的属性是 configLocation，它用来指定 MyBatis 的 XML 配置文件路径。它在需要修改 MyBatis 的基础配置非常有用。通常，基础配置指的是 &lt; settings&gt; 或 &lt; typeAliases&gt;元素。</p><p>需要注意的是，这个配置文件并不需要是一个完整的 MyBatis 配置。确切地说，任何环境配置（<code>&lt;environments&gt;</code>），数据源（<code>&lt;DataSource&gt;</code>）和 MyBatis 的事务管理器（<code>&lt;transactionManager&gt;</code>）都会被忽略。SqlSessionFactoryBean 会创建它自有的 MyBatis 环境配置（Environment），并按要求设置自定义环境的值。</p><ul><li><strong>同时，<code>SqlSessionTemplate</code>是<code>MyBatis-Spring</code>的核心，作为<code>SqlSession</code>的一个实现，这就意味着可以使用它无缝替换你代码中已经使用的<code>sqlSession</code>。</strong></li></ul><p>模板可以参与到 Spring 的事务管理中，并且由于其是线程安全的，可以供多个映射器类使用，你应该总是用 SqlSessionTemplate 来替换 MyBatis 默认的 DefaultSqlSession 实现。在同一应用程序中的不同类之间混杂使用可能会引起数据一致性的问题。</p><p>可以使用 SqlSessionFactory 作为构造方法的参数来创建 SqlSessionTemplate 对象.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSession"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionTemplate"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>现在，这个 bean 就可以直接注入到你的 DAO bean 中了。你需要在你的 bean 中添加一个 SqlSession 属性，就像下面这样：(<strong>也就是需要写一个接口的实现类</strong>)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> SqlSession sqlSession;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSession</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> sqlSession.getMapper...;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>按下面这样，注入 SqlSessionTemplate：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.sample.dao.UserDaoImpl"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSession"</span> <span class="attr">ref</span>=<span class="string">"sqlSession"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-MyBaits-Spring-整合实现方式一"><a href="#3-MyBaits-Spring-整合实现方式一" class="headerlink" title="3. MyBaits-Spring 整合实现方式一"></a>3. MyBaits-Spring 整合实现方式一</h2><p><strong>这些配置大部分都是固定的！！</strong></p><ol><li>引入Spring配置文件beans.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置数据源替换mybaits的数据源</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf8<span class="symbol">&amp;amp;</span>serverTimezone=GMT%2B8"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>配置SqlSessionFactory，关联MyBatis</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置sqlSessionFactory--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--关联mybatis--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybaits-config.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:com/zhuuu/dao/*.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>注册sqlSessionTemplate，关联sqlSessionFactory；</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册sqlSessionTemplate并且关联sqlSessionFactory--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSession"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionTemplate"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--利用构造器注入：因为sqlSessionTemplate 没有set方法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200527/094502075.png" alt="mark"></p><ol start="5"><li>增加Dao接口的实现类；私有化sqlSessionTemplate</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhuuu.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.SqlSessionTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperImpl</span> <span class="keyword">implements</span> <span class="title">UserMapper</span></span>&#123;</span><br><span class="line">    <span class="comment">// sqlSession不用我们自己创建，Spring来自己管理</span></span><br><span class="line">    <span class="keyword">private</span> SqlSessionTemplate sqlSession;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSession</span><span class="params">(SqlSessionTemplate sqlSession)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>).<span class="title">selectUser</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>把实现类注入到beans.xml中</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册bean实现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.dao.UserMapperImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSession"</span> <span class="attr">ref</span>=<span class="string">"sqlSession"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="7"><li>测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestII</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line"></span><br><span class="line">        UserMapper mapper = context.getBean(<span class="string">"userDao"</span>, UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; users = mapper.selectUser();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果成功输出！现在我们的Mybatis配置文件的状态！发现都可以被Spring整合！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.zhuuu.pojo"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-MyBaits-Spring-整合实现方式二"><a href="#4-MyBaits-Spring-整合实现方式二" class="headerlink" title="4. MyBaits-Spring 整合实现方式二"></a>4. MyBaits-Spring 整合实现方式二</h2><p>mybatis-spring1.2.3版以上的才有这个 .</p><p>官方文档截图 :</p><p>dao继承Support类 , 直接利用 getSqlSession() 获得 , 然后直接注入SqlSessionFactory . 比起方式1 , 不需要管理SqlSessionTemplate , 而且对事务的支持更加友好 . 可跟踪源码查看</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200527/101946586.png" alt="mark"></p><ol><li>将我们上面写的UserDaoImpl修改一下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       UserMapper mapper = getSqlSession().getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">       <span class="keyword">return</span> mapper.selectUser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>修改bean的配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.dao.UserDaoImpl"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">   ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">   UserMapper mapper = (UserMapper) context.getBean(<span class="string">"userDao"</span>);</span><br><span class="line">   List&lt;User&gt; user = mapper.selectUser();</span><br><span class="line">   System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结 : 整合到spring以后可以完全不要mybatis的配置文件，除了这些方式可以实现整合之外，我们还可以使用注解来实现，这个等我们后面学习SpringBoot的时候还会测试整合！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring-07-整合MyBatis&quot;&gt;&lt;a href=&quot;#Spring-07-整合MyBatis&quot; class=&quot;headerlink&quot; title=&quot;Spring-07-整合MyBatis&quot;&gt;&lt;/a&gt;Spring-07-整合MyBatis&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200508/203155619.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前序&quot;&gt;&lt;a href=&quot;#前序&quot; class=&quot;headerlink&quot; title=&quot;前序&quot;&gt;&lt;/a&gt;前序&lt;/h2&gt;&lt;p&gt;官网mybatis-spring : &lt;a href=&quot;http://mybatis.org/spring/zh/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mybatis.org/spring/zh/index.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Spring" scheme="http://zhuuu.work/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>排序-01-堆排序</title>
    <link href="http://zhuuu.work/2020/05/16/Sort/%E6%8E%92%E5%BA%8F-01-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhuuu.work/2020/05/16/Sort/%E6%8E%92%E5%BA%8F-01-%E5%A0%86%E6%8E%92%E5%BA%8F/</id>
    <published>2020-05-16T10:32:24.000Z</published>
    <updated>2020-05-30T09:48:38.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序-01-堆排序"><a href="#排序-01-堆排序" class="headerlink" title="排序-01-堆排序"></a>排序-01-堆排序</h1><p>参考博客 ： <a href="https://www.cnblogs.com/skywang12345/p/3603935.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3603935.html</a></p><h2 id="1-堆排序介绍"><a href="#1-堆排序介绍" class="headerlink" title="1. 堆排序介绍"></a>1. 堆排序介绍</h2><ul><li>堆排序(Heap Sort) 是指利用堆这种数据结构所涉及的一种排序算法。</li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;排序-01-堆排序&quot;&gt;&lt;a href=&quot;#排序-01-堆排序&quot; class=&quot;headerlink&quot; title=&quot;排序-01-堆排序&quot;&gt;&lt;/a&gt;排序-01-堆排序&lt;/h1&gt;&lt;p&gt;参考博客 ： &lt;a href=&quot;https://www.cnblogs.com/sk
      
    
    </summary>
    
    
    
      <category term="排序算法" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Spring-06-AOP</title>
    <link href="http://zhuuu.work/2020/05/15/Spring/Spring-06-AOP/"/>
    <id>http://zhuuu.work/2020/05/15/Spring/Spring-06-AOP/</id>
    <published>2020-05-15T00:22:24.000Z</published>
    <updated>2020-05-23T01:10:06.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-06-AOP"><a href="#Spring-06-AOP" class="headerlink" title="Spring-06-AOP"></a>Spring-06-AOP</h1><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200508/203155619.png" alt="mark"></p><h2 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h2><p>上一讲中我们讲解了代理模式，这是AOP的基础，一定要先搞懂它</p><p>那我们接下来就来聊聊AOP吧！</p><a id="more"></a><h2 id="1-什么是AOP"><a href="#1-什么是AOP" class="headerlink" title="1. 什么是AOP?"></a>1. 什么是AOP?</h2><p>AOP（Aspect Oriented Programming）意为：<strong>面向切面编程</strong></p><ul><li><p>通过<strong>预编译方式</strong>和<strong>运行期动态代理</strong>实现程序功能的统一维护的一种技术</p></li><li><p>AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型</p></li><li><p>利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200523/084831520.png" alt="mark"></p><h2 id="2-AOP的作用"><a href="#2-AOP的作用" class="headerlink" title="2. AOP的作用"></a>2. AOP的作用</h2><p>提供声明式事务；允许用户自定义切面</p><p>以下名词需要了解下：</p><ul><li>横切关注点</li><li>切面（ASPECT）  横切关注点 被模块化 的特殊对象。即，<strong>它是一个类。</strong></li><li>通知（Advice)        切面必须要完成的工作。即，<strong>它是类中的一个方法。</strong></li><li>目标（target）        被通知对象。</li><li>代理（Proxy）       向目标对象应用通知之后创建的对象。</li><li>切入点（PointCut）切面通知 执行的 “地点”的定义。</li><li>连接点（JointPoint）与切入点匹配的执行点。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200523/085109655.png" alt="mark"></p><p>SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice:</p><h2 id="3-AOP-通知的类型"><a href="#3-AOP-通知的类型" class="headerlink" title="3. AOP 通知的类型"></a>3. AOP 通知的类型</h2><p>(1)Before:在目标方法被调用之前做增强处理,@Before只需要指定切入点表达式即可</p><p>(2)AfterReturning:在目标方法正常完成后做增强,@AfterReturning除了指定切入点表达式后，还可以指定一个返回值形参名returning,代表目标方法的返回值</p><p>(3)AfterThrowing:主要用来处理程序中未处理的异常,@AfterThrowing除了指定切入点表达式后，还可以指定一个throwing的返回值形参名,可以通过该形参名来访问目标方法中所抛出的异常对象</p><p>(4)After:在目标方法完成之后做增强，无论目标方法时候成功完成。@After可以指定一个切入点表达式</p><p>(5)Around:环绕通知,在目标方法完成前后做增强处理,环绕通知是最重要的通知类型,像事务,日志等都是环绕通知,注意编程中核心是一个ProceedingJoinPoint</p><h2 id="4-AOP的使用"><a href="#4-AOP的使用" class="headerlink" title="4. AOP的使用"></a>4. AOP的使用</h2><p>【重点】使用AOP织入，需要导入一个依赖包！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-1-通过Spring-API实现"><a href="#4-1-通过Spring-API实现" class="headerlink" title="4.1 通过Spring API实现"></a>4.1 通过Spring API实现</h3><ul><li>首先编写我们的业务接口和实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"增加用户"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"删除用户"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"更新用户"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"查询用户"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//method : 要执行的目标对象的方法</span></span><br><span class="line">   <span class="comment">//objects : 被调用的方法的参数</span></span><br><span class="line">   <span class="comment">//Object : 目标对象</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] objects, Object o)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">       System.out.println( o.getClass().getName() + <span class="string">"的"</span> + method.getName() + <span class="string">"方法被执行了"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterLog</span> <span class="keyword">implements</span> <span class="title">AfterReturningAdvice</span> </span>&#123;</span><br><span class="line">   <span class="comment">//returnValue 返回值</span></span><br><span class="line">   <span class="comment">//method被调用的方法</span></span><br><span class="line">   <span class="comment">//args 被调用的方法的对象的参数</span></span><br><span class="line">   <span class="comment">//target 被调用的目标对象</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"执行了"</span> + target.getClass().getName()</span><br><span class="line">       +<span class="string">"的"</span>+method.getName()+<span class="string">"方法,"</span></span><br><span class="line">       +<span class="string">"返回值："</span>+returnValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后去Spring中注册，并实现aop切入实现，注意导入约束</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--注册bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.service.UserServiceImpl"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"log"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.log.log"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"afterLog"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.log.AfterLog"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--配置aop--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 切入点   expression（要执行的位置） 表达式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.zhuuu.service.UserServiceImpl.*(..))"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用环绕增加--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"log"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"afterLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 .</p><p><strong>Spring的AOP就是将公共的业务（日志，安全等）和领域业务结合起来</strong></p><ul><li><strong>当执行领域业务会把公共业务加进来，实现公共业务的重复利用</strong></li><li><strong>领域业务更加纯粹，AOP其本质还是动态代理</strong></li></ul><h3 id="4-2-自定义类来实现AOP"><a href="#4-2-自定义类来实现AOP" class="headerlink" title="4.2 自定义类来实现AOP"></a>4.2 自定义类来实现AOP</h3><p>目标业务类不变依旧是userServiceImpl</p><ul><li>第一步 : 写我们自己的一个切入类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiyPointCut</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===执行前==="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===执行后==="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>去spring中配置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--第二种方式自定义实现--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注册bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"diy"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.config.DiyPointcut"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--aop的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--第二种方式：使用AOP的标签实现--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"diy"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"diyPonitcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.zhuuu.service.UserServiceImpl.*(..))"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"diyPonitcut"</span> <span class="attr">method</span>=<span class="string">"before"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut-ref</span>=<span class="string">"diyPonitcut"</span> <span class="attr">method</span>=<span class="string">"after"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>测试：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">       ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">       UserService userService = (UserService) context.getBean(<span class="string">"userService"</span>);</span><br><span class="line">       userService.add();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-注解实现"><a href="#4-3-注解实现" class="headerlink" title="4.3 注解实现"></a>4.3 注解实现</h3><ul><li>编写注解实现的增强类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.anno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用注解方式实现aop</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 注解这个类是一个切面，本质就是一个插入的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnoPointCut</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.zhuuu.service.UserServiceImpl.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===执行前==="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"execution(* com.zhuuu.service.UserServiceImpl.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===执行后==="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在Spring配置文件中，注册bean，并增加支持注解的配置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--第三种方式:注解实现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"annotationPointcut"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.anno.AnnoPointCut;"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--开启aop注解支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-class属性，默认为false，</span></span><br><span class="line"><span class="comment">表示使用jdk动态代理织入增强，</span></span><br><span class="line"><span class="comment">当配为&lt;aop:aspectj-autoproxy  poxy-target-class="true"/&gt;时，表示使用CGLib动态代理技术织入增强。</span></span><br><span class="line"><span class="comment">不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring-06-AOP&quot;&gt;&lt;a href=&quot;#Spring-06-AOP&quot; class=&quot;headerlink&quot; title=&quot;Spring-06-AOP&quot;&gt;&lt;/a&gt;Spring-06-AOP&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200508/203155619.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前序&quot;&gt;&lt;a href=&quot;#前序&quot; class=&quot;headerlink&quot; title=&quot;前序&quot;&gt;&lt;/a&gt;前序&lt;/h2&gt;&lt;p&gt;上一讲中我们讲解了代理模式，这是AOP的基础，一定要先搞懂它&lt;/p&gt;
&lt;p&gt;那我们接下来就来聊聊AOP吧！&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Spring" scheme="http://zhuuu.work/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-136-只出现一次的数字</title>
    <link href="http://zhuuu.work/2020/05/14/Leetcode/Leetcode-136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://zhuuu.work/2020/05/14/Leetcode/Leetcode-136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2020-05-14T06:22:53.000Z</published>
    <updated>2020-05-14T06:38:10.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-136-Single-Number"><a href="#Leecode-136-Single-Number" class="headerlink" title="Leecode-136-Single Number"></a>Leecode-136-<a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">Single Number</a></h1><h2 id="思路：异或"><a href="#思路：异或" class="headerlink" title="思路：异或"></a>思路：异或</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给定一个<strong>非空</strong>整数数组</li><li>除了某个元素只出现一次以外，其余每个元素均出现两次</li><li>找出那个只出现了一次的元素。</li></ul><p><strong>注意：不能使用额外的空间</strong></p><a id="more"></a><p><strong>Solution：异或</strong></p><ul><li><p>如果没有时间复杂度和空间复杂度的限制，这道题有很多种解法</p></li><li><p>不能使用额外的空间：使用位运算</p></li></ul><p><strong>对于这道题，可使用异或运算XOR。异或运算有以下三个性质。</strong></p><ul><li><p>任何数字和0做异或运算，结果仍然是原来的数字，即 a<em>⊕0=</em>a。</p></li><li><p>任何数字和自己做异或运算，结果是0，即 <em>a</em>⊕<em>a</em>=0。</p></li><li><p>异或运算满足结合律和交换律。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕<span class="number">0</span>=b。</span><br></pre></td></tr></table></figure><p><strong>举例描述：[参考力扣官方题解][<a href="https://leetcode-cn.com/problems/single-number/solution/zhi-chu-xian-yi-ci-de-shu-zi-by-leetcode-solution/]" target="_blank" rel="noopener">https://leetcode-cn.com/problems/single-number/solution/zhi-chu-xian-yi-ci-de-shu-zi-by-leetcode-solution/]</a></strong></p><ol><li><strong>任何数字和0做异或运算，结果仍然是原来的数字</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200514/143549167.png" alt="mark"></p><ol start="2"><li><strong>任何数字和自己做异或运算，结果是0</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200514/143613368.png" alt="mark"></p><ol start="3"><li><strong>异或运算满足结合律和交换律</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200514/143634424.png" alt="mark"></p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><strong>Solution :</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异或解决</span></span><br><span class="line"><span class="comment">// 1. 一个数异或本身得0</span></span><br><span class="line"><span class="comment">// 2. 异或满足结合律和交换律</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿第一个数 依次异或 后面的数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            nums[<span class="number">0</span>] ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回异或的结果</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>： O（n）  遍历一遍数组</li><li><strong>空间复杂度</strong>： O（1）  没有使用额外的空间</li></ul><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><strong>Solution :</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-136-Single-Number&quot;&gt;&lt;a href=&quot;#Leecode-136-Single-Number&quot; class=&quot;headerlink&quot; title=&quot;Leecode-136-Single Number&quot;&gt;&lt;/a&gt;Leecode-136-&lt;a href=&quot;https://leetcode-cn.com/problems/single-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Single Number&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：异或&quot;&gt;&lt;a href=&quot;#思路：异或&quot; class=&quot;headerlink&quot; title=&quot;思路：异或&quot;&gt;&lt;/a&gt;思路：异或&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给定一个&lt;strong&gt;非空&lt;/strong&gt;整数数组&lt;/li&gt;
&lt;li&gt;除了某个元素只出现一次以外，其余每个元素均出现两次&lt;/li&gt;
&lt;li&gt;找出那个只出现了一次的元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：不能使用额外的空间&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="位运算" scheme="http://zhuuu.work/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Spring-05-使用注解开发</title>
    <link href="http://zhuuu.work/2020/05/13/Spring/Spring-05-%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/"/>
    <id>http://zhuuu.work/2020/05/13/Spring/Spring-05-%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/</id>
    <published>2020-05-13T07:55:24.000Z</published>
    <updated>2020-05-17T12:33:36.109Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-05-使用注解开发"><a href="#Spring-05-使用注解开发" class="headerlink" title="Spring-05-使用注解开发"></a>Spring-05-使用注解开发</h1><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200508/203155619.png" alt="mark"></p><h2 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h2><p>在spring4之后，想要使用注解形式，必须得要引入aop的包</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200517/201802462.png" alt="mark"></p><p>在配置文件当中，还得要引入一个context约束</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启注解的支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="1-Bean的实现"><a href="#1-Bean的实现" class="headerlink" title="1. Bean的实现"></a>1. Bean的实现</h2><p>我们之前都是使用 bean 的标签进行bean注入，但是实际开发中，我们一般都会使用注解！</p><ol><li>配置扫描哪些包下的注解</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--扫描包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.zhuuu"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在指定包下编写类，增加注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Scope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于在applicationContext.xml写了一个bean</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String name = <span class="string">"朱酱酱"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.zhuuu.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mytest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line"></span><br><span class="line">        User user = (User) context.getBean(<span class="string">"user"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(user.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-属性注入"><a href="#2-属性注入" class="headerlink" title="2. 属性注入"></a>2. 属性注入</h2><p>使用注解注入属性</p><ol><li>可以不使用Set方法，直接在属性上增加@Value(“值”)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="comment">// 相当于配置文件中 &lt;bean id="user" class="当前注解的类"/&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Value</span>(<span class="string">"朱酱酱"</span>)</span><br><span class="line">   <span class="comment">// 相当于配置文件中 &lt;property name="name" value="秦疆"/&gt;</span></span><br><span class="line">   <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>如果提供了set方法，在set方法上添加@value(“值”);</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"朱酱酱"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-衍生注解"><a href="#3-衍生注解" class="headerlink" title="3. 衍生注解"></a>3. 衍生注解</h2><p><strong>@Component三个衍生注解</strong></p><p>为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。</p><ul><li>@Controller：web层</li><li>@Service：service层</li><li>@Repository：dao层</li></ul><p>写上这些注解，就相当于将这个类交给Spring管理装配了</p><h2 id="4-作用域"><a href="#4-作用域" class="headerlink" title="4. 作用域"></a>4. 作用域</h2><p><strong>@scope</strong></p><ul><li>singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。</li><li>prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价于在applicationContext.xml写了一个bean</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">// 作用域</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"singleton"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"朱酱酱"</span>)</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p><strong>XML与注解比较</strong></p><ul><li>XML可以适用任何场景 ，结构清晰，维护方便</li><li>注解不是自己提供的类使用不了，开发简单方便</li></ul><p><strong>最佳配合</strong></p><ul><li>xml管理bean</li><li>注解完成属性的注入</li><li>使用过程中，扫描主街上的类</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>作用：</p><ul><li>进行注解驱动注册，从而使注解生效</li><li>用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册</li><li>如果不扫描包，就需要手动配置bean</li><li>如果不加注解驱动，则注入的值为null</li></ul><h2 id="6-基于Java类进行配置"><a href="#6-基于Java类进行配置" class="headerlink" title="6. 基于Java类进行配置"></a>6. 基于Java类进行配置</h2><p>JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。</p><p><strong>这个作用就可以完全避免配置applicationContext.xml</strong></p><ol><li>编写一个实体类User(本质就是一个Bean)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本质就是一个Bean</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"朱酱酱"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>新建一个config包，编写一个MyConfig配置类(相当于是一个beans(applicationContext.xml))</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于是一个beans(applicationContext.xml)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.zhuuu.pojo"</span>)</span><br><span class="line"><span class="comment">//@Import()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册一个bean（就相当于之前xml中写的一个bean）</span></span><br><span class="line">    <span class="comment">// 方法名：对应id</span></span><br><span class="line">    <span class="comment">// 返回值：相当于bean标签中的class属性</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.zhuuu.config.MyConfig;</span><br><span class="line"><span class="keyword">import</span> com.zhuuu.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mytest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里完全使用了配置类去做</span></span><br><span class="line">        <span class="comment">// 我们通过AnnotationConfig上下文来获取容器</span></span><br><span class="line"></span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(MyConfig<span class="class">.<span class="keyword">class</span>)</span>;;</span><br><span class="line"></span><br><span class="line">        User user = (User) context.getBean(<span class="string">"getUser"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法名就是Bean的名字</span></span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>导入其他配置如何做呢？</strong></p><ol><li>我们再编写一个配置类！</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//代表这是一个配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig2</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在之前的配置类中我们来选择导入这个配置类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//导入合并其他配置类，类似于配置文件中的 inculde 标签</span></span><br><span class="line"><span class="meta">@Import</span>(MyConfig2<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册一个bean（就相当于之前xml中写的一个bean）</span></span><br><span class="line">    <span class="comment">// 方法名：对应id</span></span><br><span class="line">    <span class="comment">// 返回值：相当于bean标签中的class属性</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这种Java类的配置方式，我们在之后的SpringBoot 和 SpringCloud中还会大量看到，我们需要知道这些注解的作用即可！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring-05-使用注解开发&quot;&gt;&lt;a href=&quot;#Spring-05-使用注解开发&quot; class=&quot;headerlink&quot; title=&quot;Spring-05-使用注解开发&quot;&gt;&lt;/a&gt;Spring-05-使用注解开发&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200508/203155619.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前序&quot;&gt;&lt;a href=&quot;#前序&quot; class=&quot;headerlink&quot; title=&quot;前序&quot;&gt;&lt;/a&gt;前序&lt;/h2&gt;&lt;p&gt;在spring4之后，想要使用注解形式，必须得要引入aop的包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200517/201802462.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;在配置文件当中，还得要引入一个context约束&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;beans&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;xmlns&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;       &lt;span class=&quot;attr&quot;&gt;xmlns:xsi&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;       &lt;span class=&quot;attr&quot;&gt;xmlns:context&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;       &lt;span class=&quot;attr&quot;&gt;xsi:schemaLocation&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;http://www.springframework.org/schema/beans&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;string&quot;&gt;        https://www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;string&quot;&gt;        http://www.springframework.org/schema/context&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;string&quot;&gt;        http://www.springframework.org/schema/context/spring-context.xsd&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&amp;lt;!--开启注解的支持--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;context:annotation-config&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;beans&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Spring" scheme="http://zhuuu.work/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-155-最小栈</title>
    <link href="http://zhuuu.work/2020/05/12/Leetcode/Leetcode-155-%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <id>http://zhuuu.work/2020/05/12/Leetcode/Leetcode-155-%E6%9C%80%E5%B0%8F%E6%A0%88/</id>
    <published>2020-05-12T07:52:53.000Z</published>
    <updated>2020-05-12T08:56:51.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-155-Min-Stack"><a href="#Leecode-155-Min-Stack" class="headerlink" title="Leecode-155-Min Stack"></a>Leecode-155-<a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">Min Stack</a></h1><h2 id="思路：辅助栈-数据同步"><a href="#思路：辅助栈-数据同步" class="headerlink" title="思路：辅助栈/数据同步"></a>思路：辅助栈/数据同步</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push(x) ——   将元素 x 推入栈中。</span><br><span class="line">pop() ——     删除栈顶的元素。</span><br><span class="line">top() ——     获取栈顶元素。</span><br><span class="line">getMin() —— 检索栈中的最小元素。</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"MinStack"</span>,<span class="string">"push"</span>,<span class="string">"push"</span>,<span class="string">"push"</span>,<span class="string">"getMin"</span>,<span class="string">"pop"</span>,<span class="string">"top"</span>,<span class="string">"getMin"</span>]</span><br><span class="line">[[],[-<span class="number">2</span>],[<span class="number">0</span>],[-<span class="number">3</span>],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,-<span class="number">3</span>,<span class="keyword">null</span>,<span class="number">0</span>,-<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MinStack minStack = <span class="keyword">new</span> MinStack();</span><br><span class="line">minStack.push(-<span class="number">2</span>);</span><br><span class="line">minStack.push(<span class="number">0</span>);</span><br><span class="line">minStack.push(-<span class="number">3</span>);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -<span class="number">3</span>.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 <span class="number">0</span>.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -<span class="number">2</span>.</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Solution：辅助栈和数据栈同步</strong></p><ul><li>特点：编写简单，不需要考虑一些边界情况（缺点：可能会存储一些多余的元素）</li><li>规则如下：<ul><li><strong>辅助栈为空的时候，必须放进来新的数字</strong></li><li>新来的数小于等于辅助栈栈顶元素的时候，才放入（<strong>这里“等于要考虑进去”，因为出栈的时候，相等的并且是最小值的元素要同步出栈</strong>），要不然就放入辅助栈栈顶自己</li><li><strong>出栈的时候，辅助栈的栈顶元素要等于数据栈栈顶的元素才出栈</strong></li></ul></li></ul><p><strong>总结：</strong></p><ul><li><strong>出栈的时候，最小值出栈才同步</strong></li><li><strong>入栈的时候，最小值入栈才同步</strong></li></ul><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><strong>Solution :</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据栈</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助栈</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; helper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * initialize your data structure here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        data =   <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        helper = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 思路1：数据栈和辅助栈在任何时候都要同步</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        data.add(x);</span><br><span class="line">        <span class="keyword">if</span> (helper.isEmpty() || helper.peek() &gt;= x)&#123;</span><br><span class="line">            helper.add(x);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            helper.add(helper.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 两个栈都需要pop操作</span></span><br><span class="line">        <span class="keyword">if</span> (!data.isEmpty())&#123;</span><br><span class="line">            helper.pop();</span><br><span class="line">            data.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!data.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> data.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈元素为空"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!helper.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> helper.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈元素为空"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MinStack minStack = <span class="keyword">new</span> MinStack();</span><br><span class="line">        minStack.push(-<span class="number">2</span>);</span><br><span class="line">        minStack.push(<span class="number">0</span>);</span><br><span class="line">        minStack.push(-<span class="number">3</span>);</span><br><span class="line">        minStack.getMin();</span><br><span class="line">        minStack.pop();</span><br><span class="line">        minStack.top();</span><br><span class="line">        minStack.getMin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(1) 栈的操作</li><li><strong>空间复杂度</strong>：O(n) 需要一个辅助栈的空间</li></ul><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><strong>Solution :</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-155-Min-Stack&quot;&gt;&lt;a href=&quot;#Leecode-155-Min-Stack&quot; class=&quot;headerlink&quot; title=&quot;Leecode-155-Min Stack&quot;&gt;&lt;/a&gt;Leecode-155-&lt;a href=&quot;https://leetcode-cn.com/problems/min-stack/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Min Stack&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：辅助栈-数据同步&quot;&gt;&lt;a href=&quot;#思路：辅助栈-数据同步&quot; class=&quot;headerlink&quot; title=&quot;思路：辅助栈/数据同步&quot;&gt;&lt;/a&gt;思路：辅助栈/数据同步&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;push(x) ——   将元素 x 推入栈中。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pop() ——     删除栈顶的元素。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;top() ——     获取栈顶元素。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getMin() —— 检索栈中的最小元素。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;示例：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;string&quot;&gt;&quot;MinStack&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;push&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;push&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;push&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;getMin&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;pop&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;top&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;getMin&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[],[-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],[-&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;],[],[],[],[]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;,-&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MinStack minStack = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MinStack();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;minStack.push(-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;minStack.push(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;minStack.push(-&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;minStack.getMin();   --&amp;gt; 返回 -&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;minStack.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;minStack.top();      --&amp;gt; 返回 &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;minStack.getMin();   --&amp;gt; 返回 -&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="栈" scheme="http://zhuuu.work/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>IO-07-随机访问文件流</title>
    <link href="http://zhuuu.work/2020/05/12/FileIO/IO-07-%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%96%87%E4%BB%B6%E6%B5%81/"/>
    <id>http://zhuuu.work/2020/05/12/FileIO/IO-07-%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%96%87%E4%BB%B6%E6%B5%81/</id>
    <published>2020-05-12T07:38:38.000Z</published>
    <updated>2020-05-12T08:35:33.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO-随机访问文件流"><a href="#IO-随机访问文件流" class="headerlink" title="IO-随机访问文件流"></a>IO-随机访问文件流</h1><h2 id="1-什么是随机访问文件流？"><a href="#1-什么是随机访问文件流？" class="headerlink" title="1. 什么是随机访问文件流？"></a>1. 什么是随机访问文件流？</h2><ul><li><strong>RandomAccessFile</strong></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IO-随机访问文件流&quot;&gt;&lt;a href=&quot;#IO-随机访问文件流&quot; class=&quot;headerlink&quot; title=&quot;IO-随机访问文件流&quot;&gt;&lt;/a&gt;IO-随机访问文件流&lt;/h1&gt;&lt;h2 id=&quot;1-什么是随机访问文件流？&quot;&gt;&lt;a href=&quot;#1-什么是随机访
      
    
    </summary>
    
    
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>IO-06-序列化和反序列化</title>
    <link href="http://zhuuu.work/2020/05/12/FileIO/IO-06-%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://zhuuu.work/2020/05/12/FileIO/IO-06-%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2020-05-12T07:38:38.000Z</published>
    <updated>2020-05-12T07:54:37.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO-序列化和反序列化"><a href="#IO-序列化和反序列化" class="headerlink" title="IO-序列化和反序列化"></a>IO-序列化和反序列化</h1><h2 id="1-什么是序列化和反序列化？"><a href="#1-什么是序列化和反序列化？" class="headerlink" title="1. 什么是序列化和反序列化？"></a>1. 什么是序列化和反序列化？</h2><ul><li><p><strong>序列化</strong>：把堆内存上的Java对象数据，通过某种方式把对象存储到磁盘文件中或者传递给其他网络节点。这个过程称为序列化，<strong>通俗来说就是将数据结构或者对象转换成二进制串的过程。</strong></p></li><li><p><strong>反序列化</strong>：把磁盘文件中的对象数据或者把网络节点上的对象数据，恢复成Java对象模型的过程。<strong>也就是将在序列化过程中所产生的二进制串转换成数据结构或者对象的过程。</strong></p></li></ul><a id="more"></a><h2 id="2-为什么要做序列化？"><a href="#2-为什么要做序列化？" class="headerlink" title="2. 为什么要做序列化？"></a>2. 为什么要做序列化？</h2><ul><li>在分布式的系统中，此时需要把对象在网络上传输，就是得把对象转换成二进制的形式。如需要共享的JavaBean对象，都得做序列化。</li><li>服务器钝化：<ul><li>如果服务器发现某些对象好久没有活动了，那么服务器就会把这些内存中的对象持久化到本地磁盘文件中（Java对象转换成二进制文件）；</li><li>如果服务器发现某些对象需要活动的时候，先去内存中寻找，找不到再去磁盘文件中反序列化我们的对象数据，恢复成Java对象，这样能节省服务器内存。</li></ul></li></ul><h2 id="3-Java如何进行序列化？"><a href="#3-Java如何进行序列化？" class="headerlink" title="3. Java如何进行序列化？"></a>3. Java如何进行序列化？</h2><ol><li>需要做序列化的对象的类，必须实现序列化接口：Java.lang.Serializable 接口（这是一个标志接口，没有任何抽象方法），Java 中大多数类都实现了该接口，比如：String，Integer</li><li>底层会判断，如果当前对象是Serializable 的实例，才允许做序列化，（Java对象 instance of Serializable 来判断）</li><li>在Java中使用对象流来完成序列化和反序列化<ul><li><strong>ObjectOutputStream</strong>:通过 writeObject()方法做序列化操作</li><li><strong>ObjectInputStream</strong>:通过 readObject() 方法做反序列化操作</li></ul></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200512/153840577.png" alt="mark"></p><p>实例演示：</p><ol><li><strong>第一步：创建一个JavaBean对象</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>第二步：使用ObjectOutputStream对象来实现序列化</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Serlize</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        OutputStream op = <span class="keyword">new</span> FileOutputStream(<span class="string">"io"</span> + File.separator + <span class="string">"a.txt"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化对象</span></span><br><span class="line">        ObjectOutputStream ops = <span class="keyword">new</span> ObjectOutputStream(op);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化操作</span></span><br><span class="line">        ops.writeObject(<span class="keyword">new</span> Person(<span class="string">"vue"</span>,<span class="number">1</span>));</span><br><span class="line">        ops.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们打开 a.txt 文件，发现里面的内容乱码，</li><li>注意这不需要我们来看懂，这是二进制文件，计算机能读懂就行了。</li></ul><p><strong>注意事项：</strong></p><ul><li>如果新建的 Person 对象没有实现 Serializable 接口，那么上面的操作会报错：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200512/154354069.png" alt="mark"></p><ol start="3"><li><strong>第三步：使用ObjectInputStream 来进行反序列化</strong></li></ol><p><strong>需要注意的：</strong></p><ul><li><strong>反序列化的对象必须要提供该对象的字节码文件.class</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnSerlize</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"io"</span> + File.separator + <span class="string">"a.txt"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化对象</span></span><br><span class="line">        ObjectInputStream os = <span class="keyword">new</span> ObjectInputStream(in);</span><br><span class="line">        Person p = (Person) os.readObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取操作</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        os.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person&#123;name=<span class="string">'vue'</span>, age=<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="4-问题总结"><a href="#4-问题总结" class="headerlink" title="4. 问题总结"></a>4. 问题总结</h2><ol><li><strong>如果某些数据不需要做序列化（比如密码，年龄）</strong><ul><li>解决方案：在字段前加上<code>transient</code></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;<span class="comment">//需要序列化</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">private</span> <span class="keyword">int</span> age;<span class="comment">//不需要序列化</span></span><br></pre></td></tr></table></figure><p>那么我们在反序列化的时候，打印出来的就是<code>Person [name=vae, age=0]</code>，整型数据默认值为 0 </p><ol start="2"><li><strong>序列化版本的问题，在完成序列化之后，由于项目的升级或者修改，可能我们会对序列化对象进行修改，比如增加某个字段，那么在反序列化上就会报错</strong></li></ol><p>比如在上面的Person类中加入一个字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br></pre></td></tr></table></figure><p><strong>报错：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200512/155008063.png" alt="mark"></p><p><strong>解决方案：</strong>在JavaBean中增加一个 <code>serialVersionUID</code>   字段，用来固定这个版本，无论我们怎么修改，版本都是一致的，就能进行反序列化了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">678397537617897505L</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IO-序列化和反序列化&quot;&gt;&lt;a href=&quot;#IO-序列化和反序列化&quot; class=&quot;headerlink&quot; title=&quot;IO-序列化和反序列化&quot;&gt;&lt;/a&gt;IO-序列化和反序列化&lt;/h1&gt;&lt;h2 id=&quot;1-什么是序列化和反序列化？&quot;&gt;&lt;a href=&quot;#1-什么是序列化和反序列化？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是序列化和反序列化？&quot;&gt;&lt;/a&gt;1. 什么是序列化和反序列化？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;序列化&lt;/strong&gt;：把堆内存上的Java对象数据，通过某种方式把对象存储到磁盘文件中或者传递给其他网络节点。这个过程称为序列化，&lt;strong&gt;通俗来说就是将数据结构或者对象转换成二进制串的过程。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;反序列化&lt;/strong&gt;：把磁盘文件中的对象数据或者把网络节点上的对象数据，恢复成Java对象模型的过程。&lt;strong&gt;也就是将在序列化过程中所产生的二进制串转换成数据结构或者对象的过程。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Spring-04-自动装配</title>
    <link href="http://zhuuu.work/2020/05/12/Spring/Spring-04-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"/>
    <id>http://zhuuu.work/2020/05/12/Spring/Spring-04-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</id>
    <published>2020-05-12T07:02:24.000Z</published>
    <updated>2020-05-17T12:16:20.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-04-自动装配"><a href="#Spring-04-自动装配" class="headerlink" title="Spring-04-自动装配"></a>Spring-04-自动装配</h1><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200508/203155619.png" alt="mark"></p><a id="more"></a><h2 id="1-自动装配说明"><a href="#1-自动装配说明" class="headerlink" title="1. 自动装配说明"></a>1. 自动装配说明</h2><ul><li>自动装配是使用spring满足bean依赖的一种方法</li><li>spring会在应用上下文中为某个bean寻找其依赖的bean。</li></ul><p>Spring中bean有三种装配机制，分别是：</p><ol><li>在xml中显式配置；</li><li>在java中显式配置；</li><li>隐式的bean发现机制和自动装配。</li></ol><p>这里我们主要讲第三种：自动化的装配bean</p><p>Spring的自动装配要从两个角度实现，或者说是两个操作</p><ol><li>组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean；</li><li>自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI；</li></ol><p>组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。</p><p><strong>推荐不使用自动装配xml配置 , 而使用注解 .</strong></p><h2 id="2-测试环境搭建"><a href="#2-测试环境搭建" class="headerlink" title="2. 测试环境搭建"></a>2. 测试环境搭建</h2><ol><li>实体类 Dog.java/Cat.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"miao~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"wang~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>用户类User</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Cat cat;</span><br><span class="line">   <span class="keyword">private</span> Dog dog;</span><br><span class="line">   <span class="keyword">private</span> String str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>编写Spring配置文件</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">      xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">      xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=<span class="string">"dog"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.kuang.pojo.Dog"</span>/&gt;</span><br><span class="line">   &lt;bean id=<span class="string">"cat"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.kuang.pojo.Cat"</span>/&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=<span class="string">"user"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.zhuuu.pojo.User"</span>&gt;</span><br><span class="line">       &lt;property name=<span class="string">"cat"</span> ref=<span class="string">"cat"</span>/&gt;</span><br><span class="line">       &lt;property name=<span class="string">"dog"</span> ref=<span class="string">"dog"</span>/&gt;</span><br><span class="line">       &lt;property name=<span class="string">"str"</span> value=<span class="string">"朱酱酱"</span>/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethodAutowire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">       User user = (User) context.getBean(<span class="string">"user"</span>);</span><br><span class="line">       user.getCat().shout();</span><br><span class="line">       user.getDog().shout();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-ByName-ByType"><a href="#3-ByName-ByType" class="headerlink" title="3. ByName/ByType"></a>3. ByName/ByType</h2><h3 id="3-1-ByName"><a href="#3-1-ByName" class="headerlink" title="3.1 ByName"></a>3.1 ByName</h3><p><strong>autowire byName (按名称自动装配)</strong></p><p>由于在手动配置xml过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。</p><p>采用自动装配将避免这些错误，并且使配置简单化。</p><p><strong>小结：</strong></p><p>当一个bean节点带有 autowire byName的属性时。</p><ul><li>将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母 小写的字符串</li><li>去spring容器中查找是否有此字符串的名称id对象</li><li>如果有，就取出注入，没有就报空指针异常错误。</li></ul><h3 id="3-2-ByType"><a href="#3-2-ByType" class="headerlink" title="3.2 ByType"></a>3.2 ByType</h3><p><strong>autowire byType (按类型自动装配)</strong></p><p>使用autowire byType首先需要保证：同一类型的对象，在spring容器中唯一。如果不唯一，会报不唯一的异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NoUniqueBeanDefinitionException</span><br></pre></td></tr></table></figure><p>小结：</p><ul><li>一个类只能出现一次注入（不然就会因重复而报错）</li></ul><h2 id="4-使用注解"><a href="#4-使用注解" class="headerlink" title="4. 使用注解"></a>4. 使用注解</h2><p>jdk1.5开始支持注解，spring2.5开始全面支持注解。</p><p>准备工作：利用注解的方式注入属性。</p><ol><li>在spring配置文件中引入context文件头</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xmlns:context="http://www.springframework.org/schema/context"</span><br><span class="line"></span><br><span class="line">http://www.springframework.org/schema/context</span><br><span class="line">http://www.springframework.org/schema/context/spring-context.xsd</span><br></pre></td></tr></table></figure><ol start="2"><li>开启注解支持</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-1-AutoWired"><a href="#4-1-AutoWired" class="headerlink" title="4.1 @AutoWired"></a>4.1 @AutoWired</h3><ul><li>@Autowired是按类型自动转配的，不支持id匹配。</li><li>需要导入 spring-aop的包！</li></ul><ol><li>将User类中的set方法去掉，使用@Autowired注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> Cat cat;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> Dog dog;</span><br><span class="line">   <span class="keyword">private</span> String str;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Cat <span class="title">getCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> cat;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Dog <span class="title">getDog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> dog;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>此时配置文件的内容</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启注解的支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.pojo.Dog"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.pojo.Cat"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"people"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.pojo.People"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>测试，成功输出结果！</li></ol><p>PS:</p><p><code>@Autowired(required=false)</code></p><ul><li>false 说明对象可以是null</li><li>true说明不能为null</li></ul><h3 id="4-2-Qualifiers"><a href="#4-2-Qualifiers" class="headerlink" title="4.2 @Qualifiers"></a>4.2 @Qualifiers</h3><ul><li>@Autowired是根据类型自动装配的,加上@Qualifiers就可以根据byName方法自动装配</li><li>@Qualifier不能单独使用。</li></ul><p>测试步骤</p><ol><li>配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog1"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.pojo.Dog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog2"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.pojo.Dog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat1"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.pojo.Cat"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat2"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.pojo.Cat"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>没有加Qualifier测试，直接报错</li><li>在属性上添加Qualifier注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(value = <span class="string">"cat2"</span>)</span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(value = <span class="string">"dog2"</span>)</span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure><h3 id="4-3-Resource"><a href="#4-3-Resource" class="headerlink" title="4.3 @Resource"></a>4.3 @Resource</h3><ul><li>@Resource如有指定的name属性，先按该属性进行byName方式查找装配；</li><li>其次再进行默认的byName方式进行装配；</li><li>如果以上都不成功，则按byType的方式自动装配。</li><li>都不成功，则报异常</li></ul><ol><li>实体类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="comment">//如果允许对象为null，设置required = false,默认为true</span></span><br><span class="line">   <span class="meta">@Resource</span>(name = <span class="string">"cat2"</span>)</span><br><span class="line">   <span class="keyword">private</span> Cat cat;</span><br><span class="line">   <span class="meta">@Resource</span></span><br><span class="line">   <span class="keyword">private</span> Dog dog;</span><br><span class="line">   <span class="keyword">private</span> String str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>applicaionContext.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.pojo.Dog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat1"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.pojo.Cat"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat2"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.pojo.Cat"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.pojo.User"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>测试：结果OK</p><p>配置文件2：beans.xml ， 删掉cat2</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.pojo.Dog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat1"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.pojo.Cat"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>实体类上只保留注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure><p>结果：OK</p><p>结论：</p><ul><li>先进行byName查找</li><li>失败了在进行byType查找</li></ul><h3 id="4-4-小结"><a href="#4-4-小结" class="headerlink" title="4.4 小结"></a>4.4 小结</h3><p>@Autowired与@Resource异同：</p><ul><li>@Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。</li><li>@Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用</li><li>@Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。</li><li>它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring-04-自动装配&quot;&gt;&lt;a href=&quot;#Spring-04-自动装配&quot; class=&quot;headerlink&quot; title=&quot;Spring-04-自动装配&quot;&gt;&lt;/a&gt;Spring-04-自动装配&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200508/203155619.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Spring" scheme="http://zhuuu.work/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>IO-05-包装流</title>
    <link href="http://zhuuu.work/2020/05/12/FileIO/IO-05-%E5%8C%85%E8%A3%85%E6%B5%81/"/>
    <id>http://zhuuu.work/2020/05/12/FileIO/IO-05-%E5%8C%85%E8%A3%85%E6%B5%81/</id>
    <published>2020-05-12T03:38:38.000Z</published>
    <updated>2020-05-12T07:28:33.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO-包装流"><a href="#IO-包装流" class="headerlink" title="IO-包装流"></a>IO-包装流</h1><p><strong>根据功能分为节点流和包装流（处理流）</strong></p><ul><li><p>节点流：可以从或向一个特定的地方(节点)读写数据。如FileReader</p></li><li><p>处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据的读写。如BufferedReader,处理流的构造方法总是要带一个其他的流的参数做对象。一个流对象经过其他流的多次包装，称为流的链接。</p></li></ul><a id="more"></a><h2 id="1-包装流"><a href="#1-包装流" class="headerlink" title="1. 包装流"></a>1. 包装流</h2><ol><li><strong>什么是包装流？</strong></li></ol><ul><li>包装流隐藏了底层节点流的差异，并对外提供了更方便的输入/输出的功能，让我们只关心这个高级流的操作就好</li><li>使用包装流包装了节点流，程序直接操作包装流，而底层还是节点流和IO设备。</li><li>关闭包装流的时候，只需要关闭包装流即可。</li></ul><h2 id="2-缓冲流"><a href="#2-缓冲流" class="headerlink" title="2. 缓冲流"></a>2. 缓冲流</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200512/135302648.png" alt="mark"></p><p>*<em>缓冲流就是一个包装流，目的是缓存作用，加快读取和写入数据的速度。- *</em></p><ul><li>字符缓冲流：BufferedInputStream、BufferedOutputStream</li><li>字节缓冲流：BufferedReader、BufferedWriter</li></ul><p><strong>看一个例子：</strong></p><ul><li><p><strong>之前的操作：我们在将字符输入输出流，字节输入输出流的时候。读取/写入操作，通常都会定义一个字节或者字符数组，将读取/写入的数据先存放到这个数组里面，然后在取数组中的数据。这比我们一个一个读取要快很多。这也是缓冲流的由来。</strong></p></li><li><p><strong>只不过缓冲流定义了一个数组用来存储我们读取/写入的数据</strong></p></li><li><p><strong>当内部定义的数组满了（注意：我们操作的时候外部还是会定义一个小的数组，小数组放到内部数组中），就会执行下一步的操作</strong></p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200512/135814640.png" alt="mark"></p><ul><li>下面是一个没有使用缓冲流的例子：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNoBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1、创建目标对象，输入流表示那个文件的数据保存到程序中。不写盘符，默认该文件是在该项目的根目录下</span></span><br><span class="line">        <span class="comment">//a.txt 保存的文件内容为：AAaBCDEF</span></span><br><span class="line">        File target = <span class="keyword">new</span> File(<span class="string">"io"</span>+File.separator+<span class="string">"a.txt"</span>);</span><br><span class="line">        <span class="comment">//2、创建输入流对象</span></span><br><span class="line">        InputStream in = <span class="keyword">new</span> FileInputStream(target);</span><br><span class="line">        <span class="comment">//3、具体的 IO 操作（读取 a.txt 文件中的数据到程序中）</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 注意：读取文件中的数据，读到最后没有数据时，返回-1</span></span><br><span class="line"><span class="comment">         *  int read():读取一个字节，返回读取的字节</span></span><br><span class="line"><span class="comment">         *  int read(byte[] b):读取多个字节,并保存到数组 b 中，从数组 b 的索引为 0 的位置开始存储，返回读取了几个字节</span></span><br><span class="line"><span class="comment">         *  int read(byte[] b,int off,int len):读取多个字节，并存储到数组 b 中，从数组b 的索引为 0 的位置开始，长度为len个字节</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//int read():读取一个字节，返回读取的字节</span></span><br><span class="line">        <span class="keyword">int</span> data1 = in.read();<span class="comment">//获取 a.txt 文件中的数据的第一个字节</span></span><br><span class="line">        System.out.println((<span class="keyword">char</span>)data1); <span class="comment">//A</span></span><br><span class="line">        <span class="comment">//int read(byte[] b):读取多个字节保存到数组b 中</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer  = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];<span class="comment">//这里我们定义了一个 长度为 10 的字节数组，用来存储读取的数据</span></span><br><span class="line">        in.read(buffer);<span class="comment">//获取 a.txt 文件中的前10 个字节，并存储到 buffer 数组中</span></span><br><span class="line">        System.out.println(Arrays.toString(buffer)); <span class="comment">//[65, 97, 66, 67, 68, 69, 70, 0, 0, 0]</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(buffer)); <span class="comment">//AaBCDEF[][][]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//int read(byte[] b,int off,int len):读取多个字节，并存储到数组 b 中,从索引 off 开始到 len</span></span><br><span class="line">        in.read(buffer, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(Arrays.toString(buffer)); <span class="comment">//[65, 97, 66, 0, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(buffer)); <span class="comment">//AaB[][][][][][][]</span></span><br><span class="line">        <span class="comment">//4、关闭流资源</span></span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接下来，我们去看缓冲流的JDK底层源码<ul><li>可以看到，程序中定义了这样的<strong>缓存数组，大小是8192</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_BUFFER_SIZE = <span class="number">8192</span>;</span><br></pre></td></tr></table></figure><ul><li>最后我们来使用一下</li></ul><ol><li><strong>字节缓冲输入/输出流</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBufferedStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 字节缓冲输入流</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"io"</span> + File.separator + <span class="string">"a.txt"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个字节数组，用来存储数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((len=bis.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(buffer,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭资源流</span></span><br><span class="line">        bis.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字节缓冲输出流</span></span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"io"</span> + File.separator + <span class="string">"a.txt"</span>));</span><br><span class="line">        bos.write(<span class="string">"ABCD"</span>.getBytes());</span><br><span class="line">        bos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>字符缓冲输入/输出流</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBufferedReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 字符缓冲输入流</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"io"</span>+ File.separator+<span class="string">"a.txt"</span>));</span><br><span class="line">        <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len=br.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(buffer,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 字符缓冲输出流</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"io"</span> + File.separator + <span class="string">"a.txt"</span>));</span><br><span class="line">        bw.write(<span class="string">"ABCD"</span>);</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-转换流"><a href="#3-转换流" class="headerlink" title="3. 转换流"></a>3. 转换流</h2><ul><li><strong>转换流：把字节流转换成字符流</strong><ul><li><strong>InputStreamReader:把字节输入流转换成字符输入流</strong></li><li><strong>OutputStreamWriter:把字节输出流转换成字符输出流</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用转换流进行文件的复制</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConvert</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建源和目标</span></span><br><span class="line">        File srcFile = <span class="keyword">new</span> File(<span class="string">"io"</span>+File.separator+<span class="string">"a.txt"</span>);</span><br><span class="line">        File descFile = <span class="keyword">new</span> File(<span class="string">"io"</span>+File.separator+<span class="string">"b.txt"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建字节输入输出流对象</span></span><br><span class="line">        InputStream  in  = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">        OutputStream out = <span class="keyword">new</span> FileOutputStream(descFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 创建转换输入输出对象</span></span><br><span class="line">        Reader rd = <span class="keyword">new</span> InputStreamReader(in);</span><br><span class="line">        Writer wt = <span class="keyword">new</span> OutputStreamWriter(out);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 读取和写入操作</span></span><br><span class="line">        <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>]; <span class="comment">//创建一个容量为 10 的字符数组，存储已经读取的数据</span></span><br><span class="line">        <span class="keyword">int</span> len = -<span class="number">1</span>; <span class="comment">//表示已经读取了多少个字符，如果是 -1，表示已经读取到文件的末尾</span></span><br><span class="line">        <span class="keyword">while</span> ((len=rd.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            wt.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 关闭流资源</span></span><br><span class="line">        rd.close();</span><br><span class="line">        wt.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-内存流-数组流"><a href="#4-内存流-数组流" class="headerlink" title="4. 内存流(数组流)"></a>4. 内存流(数组流)</h2><ul><li>把数据先临时存在数组中，也就是内存中。</li><li>所以这个关闭内存流是无效的，关闭后还能再次调用这个方法。</li><li>底层的close()方法是一个空方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Closing a &lt;tt&gt;ByteArrayOutputStream&lt;/tt&gt; has no effect. The methods in</span></span><br><span class="line"><span class="comment"> * this class can be called after the stream has been closed without</span></span><br><span class="line"><span class="comment"> * generating an &lt;tt&gt;IOException&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>①、字节内存流：ByteArrayOutputStream 、ByteArrayInputStream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArrayStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 字节数组输出流：程序-》内存</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数据写到内存中</span></span><br><span class="line">        bos.write(<span class="string">"ABCD"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个新分配的字节数组。</span></span><br><span class="line">        <span class="comment">// 其大小是当前大小，缓冲区的有效内容已经被复制到其中</span></span><br><span class="line">        <span class="keyword">byte</span>[] temp = bos.toByteArray();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(temp,<span class="number">0</span>,temp.length));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">// 字节数组输入流：内存-》程序</span></span><br><span class="line">        ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(temp);</span><br><span class="line">        <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((len=bis.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(buffer,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里不写也没事，因为源码中的 close()是一个空的方法体</span></span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②、字符内存流：CharArrayReader、CharArrayWriter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArrayReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 字符数组输出流</span></span><br><span class="line">        CharArrayWriter caw = <span class="keyword">new</span> CharArrayWriter();</span><br><span class="line">        caw.write(<span class="string">"ABCD"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回内存数据的副本</span></span><br><span class="line">        <span class="keyword">char</span>[] temp = caw.toCharArray();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(temp));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符数组输入流</span></span><br><span class="line">        CharArrayReader car = <span class="keyword">new</span> CharArrayReader(temp);</span><br><span class="line">        <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((len=car.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(buffer,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③、字符串流：StringReader,StringWriter（把数据临时存储到字符串中）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStringReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 字符串输出流,底层采用 StringBuffer 进行拼接</span></span><br><span class="line">        StringWriter sw = <span class="keyword">new</span> StringWriter();</span><br><span class="line">        sw.write(<span class="string">"ABCD"</span>);</span><br><span class="line">        sw.write(<span class="string">"朱酱酱"</span>);</span><br><span class="line">        System.out.println(sw.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符串输入流</span></span><br><span class="line">        StringReader sr = <span class="keyword">new</span> StringReader(sw.toString());</span><br><span class="line">        <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((len=sr.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(buffer,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-合并流"><a href="#5-合并流" class="headerlink" title="5. 合并流"></a>5. 合并流</h2><ul><li>把多个输入和输出合并成一个流，也叫做顺序流，因为在读取的时候先读取了第一个，读完了再去读取下一个流。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 定义字节输入合并流</span></span><br><span class="line">        SequenceInputStream seinput = <span class="keyword">new</span> SequenceInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"io/a.txt"</span>), <span class="keyword">new</span> FileInputStream(<span class="string">"io/b.txt"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len=seinput.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(buffer,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        seinput.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IO-包装流&quot;&gt;&lt;a href=&quot;#IO-包装流&quot; class=&quot;headerlink&quot; title=&quot;IO-包装流&quot;&gt;&lt;/a&gt;IO-包装流&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;根据功能分为节点流和包装流（处理流）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;节点流：可以从或向一个特定的地方(节点)读写数据。如FileReader&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据的读写。如BufferedReader,处理流的构造方法总是要带一个其他的流的参数做对象。一个流对象经过其他流的多次包装，称为流的链接。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>IO-04-字符输入输出流</title>
    <link href="http://zhuuu.work/2020/05/12/FileIO/IO-04-%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/"/>
    <id>http://zhuuu.work/2020/05/12/FileIO/IO-04-%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/</id>
    <published>2020-05-12T00:38:38.000Z</published>
    <updated>2020-05-12T02:39:40.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO-字符输入输出流"><a href="#IO-字符输入输出流" class="headerlink" title="IO-字符输入输出流"></a>IO-字符输入输出流</h1><p>这篇我们将的是字符输入输出流：<strong>Reader,Writer</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200512/090013104.png" alt="mark"></p><a id="more"></a><ol><li><p><strong>为什么要使用字符流？</strong></p><p>因为使用字节流操作汉字或者特殊语言符号的时候特别容易乱码，因为汉字不止一个字节，<strong>为了解决这个问题，建议使用字符流。</strong></p></li><li><p><strong>什么情况下使用字符流？</strong></p><p><strong>一般可以用记事本打开的文件，我们可以看到内容不乱码。就是文本文件，可以使用字符流。而操作二进制文件（比如图片，音频，视频）必须使用字节流。</strong></p></li></ol><h2 id="1-Writer"><a href="#1-Writer" class="headerlink" title="1. Writer"></a>1. Writer</h2><ul><li>用于写入字符流的抽象类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">Closeable</span>, <span class="title">Flushable</span></span></span><br></pre></td></tr></table></figure><ul><li>方法摘要：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200512/090537759.png" alt="mark"></p><ul><li>举例介绍：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> FileWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWriter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建源</span></span><br><span class="line">        File srcFile = <span class="keyword">new</span> File(<span class="string">"io"</span> + File.separator + <span class="string">"a.txt"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建字符输出流对象</span></span><br><span class="line">        Writer out = <span class="keyword">new</span> FileWriter(srcFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 具体的IO操作</span></span><br><span class="line">        <span class="comment">/***</span></span><br><span class="line"><span class="comment">         * void write(int c):向外写出一个字符</span></span><br><span class="line"><span class="comment">         * void write(char[] buffer):向外写出多个字符 buffer</span></span><br><span class="line"><span class="comment">         * void write(char[] buffer,int off,int len):把 buffer 数组中从索引 off 开始到 len个长度的数据写出去</span></span><br><span class="line"><span class="comment">         * void write(String str):向外写出一个字符串</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//void write(int c):向外写出一个字符</span></span><br><span class="line">        out.write(<span class="number">65</span>);  <span class="comment">//将 A 写入 a.txt 文件中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//void write(char[] buffer):向外写出多个字符 buffer</span></span><br><span class="line">        out.write(<span class="string">"Aa刷酱酱"</span>.toCharArray());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//void write(char[] buffer,int off,int len)</span></span><br><span class="line">        out.write(<span class="string">"Aa刷酱酱"</span>.toCharArray(),<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//void write(String str):向外写出一个字符串</span></span><br><span class="line">        out.write(<span class="string">"Aa刷酱酱"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 关闭系统资源</span></span><br><span class="line">        <span class="comment">/***</span></span><br><span class="line"><span class="comment">         * 注意如果这里有一个 缓冲的概念，如果写入文件的数据没有达到缓冲的数组长度，那么数据是不会写入到文件中的</span></span><br><span class="line"><span class="comment">         * 解决办法：手动刷新缓冲区 flush()</span></span><br><span class="line"><span class="comment">         * 或者直接调用 close() 方法，这个方法会默认刷新缓冲区</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// AAa刷酱酱AaAa刷酱酱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Reader"><a href="#2-Reader" class="headerlink" title="2. Reader"></a>2. Reader</h2><ul><li>用于读取字符流的抽象类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Reader</span> <span class="keyword">implements</span> <span class="title">Readable</span>, <span class="title">Closeable</span></span></span><br></pre></td></tr></table></figure><ul><li>方法摘要：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200512/091248573.png" alt="mark"></p><ul><li>下面我们用 <strong>字符输入流Reader的 典型实现类FileReader</strong> 来介绍这个类的用法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> FileReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建源</span></span><br><span class="line">        File srcFile = <span class="keyword">new</span> File(<span class="string">"io"</span> + File.separator + <span class="string">"a.txt"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建字符输入流对象</span></span><br><span class="line">        Reader in = <span class="keyword">new</span> FileReader(srcFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 具体的IO操作</span></span><br><span class="line">        <span class="comment">/***</span></span><br><span class="line"><span class="comment">         * int read():每次读取一个字符，读到最后返回 -1</span></span><br><span class="line"><span class="comment">         * int read(char[] buffer):将字符读进字符数组,返回结果为读取的字符数</span></span><br><span class="line"><span class="comment">         * int read(char[] buffer,int off,int len):将读取的字符存储进字符数组 buffer，返回结果为读取的字符数，从索引 off 开始，长度为 len</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//int read():每次读取一个字符，读到最后返回 -1</span></span><br><span class="line">        <span class="keyword">int</span> len = -<span class="number">1</span>; <span class="comment">//定义当前读取字符的数量</span></span><br><span class="line">        <span class="keyword">while</span>((len = in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 打印a.txt中的所有内容</span></span><br><span class="line">            System.out.println((<span class="keyword">char</span>) len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//int read(char[] buffer):将字符读进字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len=in.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(buffer,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//int read(char[] buffer,int off,int len)</span></span><br><span class="line">        <span class="keyword">while</span> ((len=in.read(buffer,<span class="number">0</span>,<span class="number">10</span>))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(buffer,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 关闭流资源</span></span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-用字符流完成文件的复制"><a href="#3-用字符流完成文件的复制" class="headerlink" title="3. 用字符流完成文件的复制"></a>3. 用字符流完成文件的复制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> FileReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建源和目标</span></span><br><span class="line">        File srcFile = <span class="keyword">new</span> File(<span class="string">"io"</span> + File.separator + <span class="string">"a.txt"</span>);</span><br><span class="line">        File destFile = <span class="keyword">new</span> File(<span class="string">"io"</span> + File.separator + <span class="string">"b.txt"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建字符输入输出流对象</span></span><br><span class="line">        Reader in  = <span class="keyword">new</span> FileReader(srcFile);</span><br><span class="line">        Writer out = <span class="keyword">new</span> FileWriter(destFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 读取和写入操作</span></span><br><span class="line">        <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>]; <span class="comment">//创建一个容量是10的数组，用于存储已经读取的数据</span></span><br><span class="line">        <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 读进来</span></span><br><span class="line">        <span class="keyword">while</span> ((len=in.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 写出去</span></span><br><span class="line">            out.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 关闭流资源</span></span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IO-字符输入输出流&quot;&gt;&lt;a href=&quot;#IO-字符输入输出流&quot; class=&quot;headerlink&quot; title=&quot;IO-字符输入输出流&quot;&gt;&lt;/a&gt;IO-字符输入输出流&lt;/h1&gt;&lt;p&gt;这篇我们将的是字符输入输出流：&lt;strong&gt;Reader,Writer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200512/090013104.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-101-对称二叉树</title>
    <link href="http://zhuuu.work/2020/05/12/Leetcode/Leetcode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://zhuuu.work/2020/05/12/Leetcode/Leetcode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-05-12T00:22:53.000Z</published>
    <updated>2020-05-27T06:12:24.331Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-101-Symmetric-Tree"><a href="#Leetcode-101-Symmetric-Tree" class="headerlink" title="Leetcode-101-Symmetric Tree"></a>Leetcode-101-<a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">Symmetric Tree</a></h1><h2 id="思路：递归-迭代"><a href="#思路：递归-迭代" class="headerlink" title="思路：递归/迭代"></a>思路：递归/迭代</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Solution：递归</strong></p><p>如果一个树的左子树与右子树镜像对称，那么这个树是对称的。</p><p>因此，该问题可以转化为：<strong>两个树</strong>在什么情况下互为镜像？</p><ul><li>他们的根节点有相同的值</li><li>每个树右子树和另一个树的左子树镜像对称</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200527/140945315.png" alt="mark"></p><p>就像人站在镜子前审视自己那样。镜中的反射与现实中的人具有相同的头部，但反射的右臂对应于人的左臂，反之亦然。</p><p>上面的解释可以很自然地转换为一个递归函数，如下所示：</p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><strong>Solution :</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isMirror(root,root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMirror</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归到最深层null的时候 判断叶子节点的val否相等</span></span><br><span class="line">        <span class="comment">// 相等向上一层返回true</span></span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不相等向上一层返回false</span></span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 镜像左子树和右子树</span></span><br><span class="line">        <span class="keyword">return</span> (t1.val == t2.val)</span><br><span class="line">                &amp;&amp; isMirror(t1.right,t2.left)</span><br><span class="line">                &amp;&amp; isMirror(t1.left,t2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n) 遍历树中节点的总数</li><li>空间复杂度：O(n) 递归需要的栈深度</li></ul><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><strong>Solution :</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-101-Symmetric-Tree&quot;&gt;&lt;a href=&quot;#Leetcode-101-Symmetric-Tree&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-101-Symmetric Tree&quot;&gt;&lt;/a&gt;Leetcode-101-&lt;a href=&quot;https://leetcode-cn.com/problems/symmetric-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Symmetric Tree&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：递归-迭代&quot;&gt;&lt;a href=&quot;#思路：递归-迭代&quot; class=&quot;headerlink&quot; title=&quot;思路：递归/迭代&quot;&gt;&lt;/a&gt;思路：递归/迭代&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个二叉树，检查它是否是镜像对称的。&lt;/p&gt;
&lt;p&gt;例如，二叉树 &lt;code&gt;[1,2,2,3,4,4,3]&lt;/code&gt; 是对称的。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2   2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#x2F; \ &amp;#x2F; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3  4 4  3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;但是下面这个 &lt;code&gt;[1,2,2,null,3,null,3]&lt;/code&gt; 则不是镜像对称的:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;  1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#x2F; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2   2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; \   \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 3    3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="递归" scheme="http://zhuuu.work/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>Spring-03-配置和依赖注入</title>
    <link href="http://zhuuu.work/2020/05/10/Spring/Spring-03-%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    <id>http://zhuuu.work/2020/05/10/Spring/Spring-03-%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</id>
    <published>2020-05-10T07:02:24.000Z</published>
    <updated>2020-05-17T11:56:30.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-03-配置和依赖注入"><a href="#Spring-03-配置和依赖注入" class="headerlink" title="Spring-03-配置和依赖注入"></a>Spring-03-配置和依赖注入</h1><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200508/203155619.png" alt="mark"></p><a id="more"></a><h2 id="1-Spring-配置"><a href="#1-Spring-配置" class="headerlink" title="1. Spring-配置"></a>1. Spring-配置</h2><h3 id="1-1-配置别名"><a href="#1-1-配置别名" class="headerlink" title="1.1 配置别名"></a>1.1 配置别名</h3><p>alias 设置别名 , 为bean设置别名 , 可以设置多个别名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置别名：在获取Bean的时候可以使用别名获取--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"userT"</span> <span class="attr">alias</span>=<span class="string">"userNew"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-Bean的配置"><a href="#1-2-Bean的配置" class="headerlink" title="1.2 Bean的配置"></a>1.2 Bean的配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--bean就是java对象,由Spring创建和管理--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符</span></span><br><span class="line"><span class="comment">   如果配置id,又配置了name,那么name是别名</span></span><br><span class="line"><span class="comment">   name可以设置多个别名,可以用逗号,分号,空格隔开</span></span><br><span class="line"><span class="comment">   如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class是bean的全限定名=包名+类名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"hello"</span> <span class="attr">name</span>=<span class="string">"hello2 h2,h3;h4"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.pojo.Hello"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Spring"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-import"><a href="#1-3-import" class="headerlink" title="1.3 import"></a>1.3 import</h3><p>团队的合作通过import实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"&#123;path&#125;/beans.xml"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-依赖注入（DI）"><a href="#2-依赖注入（DI）" class="headerlink" title="2. 依赖注入（DI）"></a>2. 依赖注入（DI）</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><ul><li>依赖注入（Dependency Injection,DI）。</li><li>依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 .</li><li>注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配 .</li></ul><h3 id="2-2-Set-注入（重点）"><a href="#2-2-Set-注入（重点）" class="headerlink" title="2.2 Set 注入（重点）"></a>2.2 Set 注入（重点）</h3><ul><li><p><strong>要求被注入的属性，必须要有set方法</strong></p></li><li><p><strong>set方法的方法名由set + 属性首字母大写</strong></p></li></ul><ol><li>复杂类型 Address.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Address&#123;"</span> +</span><br><span class="line">                <span class="string">"address='"</span> + address + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>用户类 Student.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] books;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbys;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; card;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; games;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Properties info;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String wife;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", address="</span> + address.toString() +</span><br><span class="line">                <span class="string">", books="</span> + Arrays.toString(books) +</span><br><span class="line">                <span class="string">", hobbys="</span> + hobbys +</span><br><span class="line">                <span class="string">", card="</span> + card +</span><br><span class="line">                <span class="string">", games="</span> + games +</span><br><span class="line">                <span class="string">", info="</span> + info +</span><br><span class="line">                <span class="string">", wife='"</span> + wife + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Address <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(Address address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getBooks() &#123;</span><br><span class="line">        <span class="keyword">return</span> books;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBooks</span><span class="params">(String[] books)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.books = books;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getHobbys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hobbys;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHobbys</span><span class="params">(List&lt;String&gt; hobbys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hobbys = hobbys;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getCard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> card;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCard</span><span class="params">(Map&lt;String, String&gt; card)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.card = card;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getGames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> games;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGames</span><span class="params">(Set&lt;String&gt; games)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.games = games;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(Properties info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWife</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> wife;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWife</span><span class="params">(String wife)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.wife = wife;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以上就是搭建一个环境的过程，接下来我们看看每种数据结构如何注入</strong></p><ol><li><strong>常量注入</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.pojo.Student"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--普通值注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"朱酱酱"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>Bean引用类型注入</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"address"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.pojo.Address"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.pojo.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"小明"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">ref</span>=<span class="string">"addr"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>数组注入</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--数组类型注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"books"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>红楼梦<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>西游记<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>三国演义<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li><strong>List注入</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hobbys"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>敲代码<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>看电影<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>听歌<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li><strong>Map注入</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"card"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"身份证"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"银行卡"</span> <span class="attr">value</span>=<span class="string">"2"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="6"><li><strong>set 集合注入</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Set注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"games"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>LOL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>COC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>BOB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="7"><li><strong>null值注入</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--NUll注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"wife"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="8"><li><strong>Properties 配置注入</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Properties注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"学号"</span>&gt;</span>121801<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"准考证号"</span>&gt;</span>121801<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"性别"</span>&gt;</span>男<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-P命名和C命名注入"><a href="#3-P命名和C命名注入" class="headerlink" title="3. P命名和C命名注入"></a>3. P命名和C命名注入</h2><ol><li>User.java（注意：这里没有有参构造器）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> String name;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                 <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                 <span class="string">", age="</span> + age +</span><br><span class="line">                 <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-P命名空间注入"><a href="#3-1-P命名空间注入" class="headerlink" title="3.1 P命名空间注入"></a>3.1 P命名空间注入</h3><ol><li>需要在头文件中加入约束文件</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">导入约束 : xmlns:p="http://www.springframework.org/schema/p"</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.pojo.User"</span> <span class="attr">p:name</span>=<span class="string">"朱酱酱"</span> <span class="attr">p:age</span>=<span class="string">"18"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-C命名空间注入"><a href="#3-2-C命名空间注入" class="headerlink" title="3.2 C命名空间注入"></a>3.2 C命名空间注入</h3><ol><li>需要在头文件中加入约束文件</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">导入约束 : xmlns:c="http://www.springframework.org/schema/c"</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--C(构造: Constructor)命名空间 , 属性依然要设置set方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.pojo.User"</span> <span class="attr">c:name</span>=<span class="string">"朱酱酱"</span> <span class="attr">c:age</span>=<span class="string">"18"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>发现问题：爆红了，刚才我们没有写有参构造！</li><li>解决：把有参构造器加上，这里也能知道，c 就是所谓的构造器注入！</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    User user = (User) context.getBean(<span class="string">"user"</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Bean的作用域"><a href="#4-Bean的作用域" class="headerlink" title="4. Bean的作用域"></a>4. Bean的作用域</h2><p>在Spring中，那些组成应用程序的主题及由Spring IOC容器所管理的对象，被称之为Bean。</p><p>简单来说，bean就是由IOC容器初始化，装配及管理的对象。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200517/195000008.png" alt="mark"></p><p>几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。</p><h3 id="4-1-Singleton"><a href="#4-1-Singleton" class="headerlink" title="4.1 Singleton"></a>4.1 Singleton</h3><ul><li><p>当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，<strong>则只会返回bean的同一实例。</strong></p></li><li><p>Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的默认作用域</p></li></ul><p>要在XML中将bean定义成singleton，可以这样配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"ServiceImpl"</span> <span class="attr">class</span>=<span class="string">"cn.csdn.service.ServiceImpl"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    User user = (User) context.getBean(<span class="string">"user"</span>);</span><br><span class="line">    User user2 = (User) context.getBean(<span class="string">"user"</span>);</span><br><span class="line">    System.out.println(user==user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-Prototype"><a href="#4-2-Prototype" class="headerlink" title="4.2 Prototype"></a>4.2 Prototype</h3><ul><li>当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会<strong>创建一个新的bean实例</strong></li><li>Prototype是原型模式，它允许我们每次获取到的对象都不是同一对象</li><li>根据经验，对有状态的bean应该是用prototype作用域，而对无状态的bean应该采用singleton作用域。</li></ul><p>在XML中将bean定义成prototype，可以这样配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"account"</span> <span class="attr">class</span>=<span class="string">"com.foo.DefaultAccount"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span>  </span><br><span class="line"> 或者</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"account"</span> <span class="attr">class</span>=<span class="string">"com.foo.DefaultAccount"</span> <span class="attr">singleton</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-3-Request"><a href="#4-3-Request" class="headerlink" title="4.3 Request"></a>4.3 Request</h3><ul><li><p>当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例；即<strong>每个HTTP请求都会有各自的bean实例</strong>，</p></li><li><p>该作用域仅在基于web的Spring ApplicationContext情形下有效。</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loginAction"</span> <span class="attr">class</span>=<span class="string">cn.csdn.LoginAction</span>" <span class="attr">scope</span>=<span class="string">"request"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean<strong>实例仅在当前HTTP request内有效。</strong></p></li><li><p>因此可以根据需要<strong>放心的更改所建实例的内部状态</strong>，而<strong>其他</strong>请求中根据loginAction bean定义创建的实例，<strong>将不会看到这些特定于某个请求的状态变化。</strong></p></li><li><p>当处理请求结束，request作用域的bean实例将被销毁。</p></li></ul><h3 id="4-4-Session"><a href="#4-4-Session" class="headerlink" title="4.4 Session"></a>4.4 Session</h3><ul><li>当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userPreferences"</span> <span class="attr">class</span>=<span class="string">"com.foo.UserPreferences"</span> <span class="attr">scope</span>=<span class="string">"session"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean<strong>仅在当前HTTP Session内有效。</strong></p></li><li><p>与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。</p></li><li><p>当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring-03-配置和依赖注入&quot;&gt;&lt;a href=&quot;#Spring-03-配置和依赖注入&quot; class=&quot;headerlink&quot; title=&quot;Spring-03-配置和依赖注入&quot;&gt;&lt;/a&gt;Spring-03-配置和依赖注入&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200508/203155619.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Spring" scheme="http://zhuuu.work/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-062-不同路径</title>
    <link href="http://zhuuu.work/2020/05/09/Leetcode/Leetcode-062-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>http://zhuuu.work/2020/05/09/Leetcode/Leetcode-062-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</id>
    <published>2020-05-09T03:52:53.000Z</published>
    <updated>2020-05-13T01:22:16.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-062-Unique-Paths"><a href="#Leecode-062-Unique-Paths" class="headerlink" title="Leecode-062-Unique Paths"></a>Leecode-062-<a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">Unique Paths</a></h1><h2 id="思路：动态规划"><a href="#思路：动态规划" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200513/085447414.png" alt="mark"></p><p>一个机器人位于一个 <em>m x n</em> 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）</p><p>问总共有多少条不同的路径？</p><ul><li><strong>注意（这里有个坑，m是列数,n才是行数）</strong></li></ul><a id="more"></a><p><strong>Solution：动态规划</strong></p><ul><li><p><strong>确定状态方程</strong></p><ul><li>使用一个二维数组 <code>dp</code> 来存储答案，<code>dp[i][j]</code>的值是从起始点（也就是<code>(0,0)</code>）走到<code>(i, j)</code>的路径数。</li></ul></li><li><p><strong>初始化</strong></p><ul><li>第一行和第一列都初始化为1</li><li>当 <code>i == 0</code>或者<code>j==0</code>的时候，<code>i-1</code>和<code>j-1</code>会越界</li></ul></li><li><p>状态转移</p><ul><li>假设我们全都知道<code>dp[i][j]</code>的值，题目中说到，小机器人只能往右或者往下，那么<code>dp[i][j]</code>的值就是第 i 行第 j 列这个格子的上面那个格子的值加上左边那个格子的值(<strong>本质也就是杨辉三角</strong>)</li><li>也就是<code>dp[i][j]</code> = <code>dp[i-1][j] + dp[i][j-1]</code>，因为这两个格子都可以走到<code>dp[i][j]</code>这个格子，那么他们的路径数之和就是<code>dp[i][j]</code>的值。</li></ul></li></ul><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><strong>Solution :</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 状态转移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>时间复杂度</strong>:  <em>O</em>(<em>m</em>∗<em>n</em>)</p></li><li><p><strong>空间复杂度</strong>：<em>O</em>(<em>m</em>∗<em>n</em>)</p></li></ul><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><strong>Solution :</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-062-Unique-Paths&quot;&gt;&lt;a href=&quot;#Leecode-062-Unique-Paths&quot; class=&quot;headerlink&quot; title=&quot;Leecode-062-Unique Paths&quot;&gt;&lt;/a&gt;Leecode-062-&lt;a href=&quot;https://leetcode-cn.com/problems/unique-paths/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Unique Paths&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：动态规划&quot;&gt;&lt;a href=&quot;#思路：动态规划&quot; class=&quot;headerlink&quot; title=&quot;思路：动态规划&quot;&gt;&lt;/a&gt;思路：动态规划&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200513/085447414.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;一个机器人位于一个 &lt;em&gt;m x n&lt;/em&gt; 网格的左上角 （起始点在下图中标记为“Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）&lt;/p&gt;
&lt;p&gt;问总共有多少条不同的路径？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;注意（这里有个坑，m是列数,n才是行数）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://zhuuu.work/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Spring-02-快速上手</title>
    <link href="http://zhuuu.work/2020/05/08/Spring/Spring-02-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    <id>http://zhuuu.work/2020/05/08/Spring/Spring-02-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</id>
    <published>2020-05-08T07:02:24.000Z</published>
    <updated>2020-05-13T14:31:05.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-02-快速上手"><a href="#Spring-02-快速上手" class="headerlink" title="Spring-02-快速上手"></a>Spring-02-快速上手</h1><h2 id="1-快速上手"><a href="#1-快速上手" class="headerlink" title="1. 快速上手"></a>1. 快速上手</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200508/203155619.png" alt="mark"></p><p>上一期中我们理解了IOC的基本思想，我们现在来看下Spring的应用</p><ol><li>导入Jar包</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编写一个Hello实体类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String str;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStr</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello&#123;"</span> +</span><br><span class="line">                <span class="string">"str='"</span> + str + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在resources/applicationContext.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--使用Spring来创建对象，在Spring中称为Bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"hello"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.pojo.Hello"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"str"</span> <span class="attr">value</span>=<span class="string">"Spring"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.zhuuu.pojo.Hello;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Spring上下文对象！,现在所有对象都在Spring管理了</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line"></span><br><span class="line">        Hello hello = (Hello) context.getBean(<span class="string">"hello"</span>);</span><br><span class="line">        System.out.println(hello.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-思考"><a href="#2-思考" class="headerlink" title="2. 思考"></a>2. 思考</h2><ul><li>Hello对象是由谁创建的？<ul><li>答：Spring创建的</li></ul></li><li>Hello 对象的属性是怎么设置的 ?<ul><li>答：hello 对象的属性是由Spring容器设置的</li></ul></li></ul><p>这个过程就叫控制反转 :</p><ul><li>控制：谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的</li><li>反转：程序本身不创建对象 , 而变成被动的接收对象 .</li></ul><p><strong>依赖注入</strong></p><ul><li><p>就是利用set方法来进行注入的</p><p><strong>IOC是一种编程思想，由主动的编程变成被动的接收</strong></p></li></ul><h2 id="3-IOC创建对象的方式"><a href="#3-IOC创建对象的方式" class="headerlink" title="3. IOC创建对象的方式"></a>3. IOC创建对象的方式</h2><h3 id="3-1-通过无参构造方法创建"><a href="#3-1-通过无参构造方法创建" class="headerlink" title="3.1 通过无参构造方法创建"></a>3.1 通过无参构造方法创建</h3><ol><li>User.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入了User的无参构造"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"name"</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>applicationContext.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.pojo.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"朱酱酱"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>测试类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.zhuuu.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line"></span><br><span class="line">        User user = (User) context.getBean(<span class="string">"user"</span>);</span><br><span class="line">        user.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果可以发现，在调用show方法之前，<strong>User对象已经通过无参构造初始化了</strong>！</p><h3 id="3-2-通过有参构造方法创建"><a href="#3-2-通过有参构造方法创建" class="headerlink" title="3.2 通过有参构造方法创建"></a>3.2 通过有参构造方法创建</h3><ol><li>UserT.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserT</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserT</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"name="</span>+ name );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>有参构造的三种注入方式</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第一种根据index参数下标设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userT"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.pojo.UserT"</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- index指构造方法 , 下标从0开始 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"朱酱酱2"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第二种根据参数名字设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userT"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.pojo.UserT"</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- name指参数名 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"朱酱酱2"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第三种根据参数类型设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userT"</span> <span class="attr">class</span>=<span class="string">"com.zhuuu.pojo.UserT"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"朱酱酱2"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.zhuuu.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line"></span><br><span class="line">        UserT user = (UserT) context.getBean(<span class="string">"userT"</span>);</span><br><span class="line">        user.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论：在配置文件加载的时候。其中管理的对象都已经初始化了！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-02-快速上手&quot;&gt;&lt;a href=&quot;#Spring-02-快速上手&quot; class=&quot;headerlink&quot; title=&quot;Spring-02-快速上手&quot;&gt;&lt;/a&gt;Spring-02-快速上手&lt;/h1&gt;&lt;h2 id=&quot;1-快速上手&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
    
      <category term="Spring" scheme="http://zhuuu.work/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-070-爬楼梯</title>
    <link href="http://zhuuu.work/2020/05/06/Leetcode/Leetcode-070-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>http://zhuuu.work/2020/05/06/Leetcode/Leetcode-070-%E7%88%AC%E6%A5%BC%E6%A2%AF/</id>
    <published>2020-05-06T00:52:53.000Z</published>
    <updated>2020-05-13T00:51:38.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-070-Climbing-Stairs"><a href="#Leecode-070-Climbing-Stairs" class="headerlink" title="Leecode-070-Climbing Stairs"></a>Leecode-070-<a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">Climbing Stairs</a></h1><h2 id="思路：动态规划"><a href="#思路：动态规划" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>每次爬楼梯可以爬1个或者2个台阶，你有多少种不同的方法可以爬到楼顶？</p><p>注意：给定的n是一个正整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Solution：</strong></p><ul><li>第 i 阶可以由以下两种方法得到：<ul><li>在第 (<em>i</em>−1) 阶后向上爬一阶。</li><li>在第(<em>i</em>−2) 阶后向上爬 22 阶。</li></ul></li></ul><p>所以到达第 i 阶的方法总数就是到第(<em>i</em>−1) 阶和第 (<em>i</em>−2) 阶的方法数之和。</p><p>令 <code>dp[i]</code>表示能到达第 i 阶的方法总数：</p><p>​                                                            <em>dp</em>[<em>i</em>]=<em>dp</em>[<em>i</em>−1]+<em>dp</em>[<em>i</em>−2]</p><p>例如：6级台阶是由5级和4级台阶构成</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200513/085052174.png" alt="mark"></p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><strong>Solution :</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 初始化(长度为 n+1 的原因是 有0索引的存在)</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 状态转移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回第n个台阶有多少种爬法</span></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n) 遍历n次。</li><li>空间复杂度：O(n)使用了一个dp数组存储元素。</li></ul><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><strong>Solution :</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-070-Climbing-Stairs&quot;&gt;&lt;a href=&quot;#Leecode-070-Climbing-Stairs&quot; class=&quot;headerlink&quot; title=&quot;Leecode-070-Climbing Stairs&quot;&gt;&lt;/a&gt;Leecode-070-&lt;a href=&quot;https://leetcode-cn.com/problems/climbing-stairs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Climbing Stairs&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：动态规划&quot;&gt;&lt;a href=&quot;#思路：动态规划&quot; class=&quot;headerlink&quot; title=&quot;思路：动态规划&quot;&gt;&lt;/a&gt;思路：动态规划&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;每次爬楼梯可以爬1个或者2个台阶，你有多少种不同的方法可以爬到楼顶？&lt;/p&gt;
&lt;p&gt;注意：给定的n是一个正整数。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入： 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出： 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释： 有两种方法可以爬到楼顶。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.  1 阶 + 1 阶&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.  2 阶&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入： 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出： 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释： 有三种方法可以爬到楼顶。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.  1 阶 + 1 阶 + 1 阶&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.  1 阶 + 2 阶&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.  2 阶 + 1 阶&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://zhuuu.work/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-337-打家劫舍III</title>
    <link href="http://zhuuu.work/2020/05/05/Leetcode/Leetcode-337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII/"/>
    <id>http://zhuuu.work/2020/05/05/Leetcode/Leetcode-337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII/</id>
    <published>2020-05-05T00:52:53.000Z</published>
    <updated>2020-05-02T02:24:36.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-337-打家劫舍-III"><a href="#Leecode-337-打家劫舍-III" class="headerlink" title="Leecode-337-打家劫舍 III"></a>Leecode-337-<a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">打家劫舍 III</a></h1><h2 id="思路：动态规划"><a href="#思路：动态规划" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>你又是一个专业的小偷。。。。</p><p>小偷又发现了一个新的可行窃的地区。这个地区<strong>只有一个入口，我们称之为“根”</strong>。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 <strong>如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3,null,3,null,1]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   3</span><br><span class="line">    \   \ </span><br><span class="line">     3   1</span><br><span class="line"></span><br><span class="line">输出: 7 </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 &#x3D; 3 + 3 + 1 &#x3D; 7.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,5,1,3,null,1]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \   \ </span><br><span class="line"> 1   3   1</span><br><span class="line"></span><br><span class="line">输出: 9</span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 &#x3D; 4 + 5 &#x3D; 9.</span><br></pre></td></tr></table></figure><a id="more"></a><p>下面介绍三种方法：其中最后一种的是最优方法</p><p><strong>Solution1：最优子结构（暴力递归）</strong></p><ol><li><p>首先要明确相邻的节点不能偷，也就是爷爷选择偷，儿子就不能偷了，但是孙子可以偷</p></li><li><p>二叉树只有左右两个孩子，一个爷爷最多 2 个儿子，4 个孙子</p></li><li><p>可以得出单个节点的钱该怎么算（<strong>4个孙子投的钱+爷爷的钱 VS 两个儿子偷的钱，哪个组合多，哪个就能做最大钱数。这就是动态规划的最优子结构</strong>）</p></li></ol><ul><li><p><strong>状态定义</strong>：result 即能偷到的钱最多的数量</p></li><li><p><strong>转移方程</strong>：</p><ul><li>4 个孙子投的钱加上爷爷的钱如下<br><code>int method1 = root.val + rob(root.left.left) + rob(root.left.right) + rob(root.right.left) + rob(root.right.right)</code></li><li>两个儿子偷的钱如下<br><code>int method2 = rob(root.left) + rob(root.right);</code></li><li>最多的钱为：<code>int result = Math.max(method1, method2);</code></li></ul></li><li><p><strong>返回值</strong>：result最多的钱数</p><ul><li>最多的钱为：<code>int result = Math.max(method1, method2);</code></li></ul></li></ul><p><strong>Solution 2:记忆化优化-解决重复问题</strong></p><p>针对解法一种速度太慢的问题，经过分析其实现，我们发现爷爷在计算自己能偷多少钱的时候，<strong>同时计算了4个孙子能偷最多的钱数量的同时，两个儿子的钱也算了</strong></p><p><strong>这样在儿子当爷爷的时候，又重新算了一遍孙子节点</strong></p><p>对于重复子问题而言：</p><p>这一步针对重复子问题进行优化，在做斐波那契数列的时候，使用的优化方案是记忆化，但是之前的问题都是使用数组解决的，把每次计算的结构都存起来，下次要用就从缓存中取，这样保证每个数字就计算了一次。</p><p>但是这里二叉树不适合用数组当缓存，我们使用哈希表来存储结果。</p><ul><li>TreeNode当做key</li><li>偷的钱当做value</li></ul><p><strong>Solution 3:省去记忆化</strong></p><ul><li><p>状态定义：每个节点可选择偷或者不偷两种状态，根据题目意思，相连节点不能一起偷</p><ul><li>当前节点选择偷时，那么两个孩子节点就不能选择偷了</li><li>当前节点选择不偷的话，两个孩子节点只要拿出最多的钱加一起就行了（两个孩子节点偷不偷没有任何关系）</li></ul></li><li><p>转移方程</p><ul><li><pre><code class="java">root[<span class="number">0</span>] = Math.max(rob(root.left)[<span class="number">0</span>], rob(root.left)[<span class="number">1</span>]) + Math.max(rob(root.right)[<span class="number">0</span>], rob(root.right)[<span class="number">1</span>])root[<span class="number">1</span>] = rob(root.left)[<span class="number">0</span>] + rob(root.right)[<span class="number">0</span>] + root.val;&lt;!--￼<span class="number">2</span>--&gt;</code></pre></li></ul></li></ul><p><strong>Solution 2:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 用map来存放结果，避免重复计算</span></span><br><span class="line">        HashMap&lt;TreeNode, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> rob_helper(root,map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob_helper</span><span class="params">(TreeNode root, HashMap&lt;TreeNode, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果之前这个节点已经计算过了，直接获取这个节点</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(root)) <span class="keyword">return</span> map.get(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> money = root.val;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 四个孙子节点</span></span><br><span class="line">        <span class="keyword">if</span> (root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            money += (rob_helper(root.left.left,map)+rob_helper(root.left.right,map)); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            money += (rob_helper(root.right.left,map)+rob_helper(root.right.right,map));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 孙子+爷爷 VS 两个儿子</span></span><br><span class="line">        <span class="keyword">int</span> result = Math.max(money,rob_helper(root.left,map)+rob_helper(root.right,map));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把这个节点算过的钱放进map中</span></span><br><span class="line">        map.put(root,result);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Solution 3:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 返回rob产生的数组，比较root节点偷或者不偷能拿到最多的钱</span></span><br><span class="line">        <span class="keyword">int</span>[] result = rob_helper(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(result[<span class="number">0</span>],result[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] rob_helper(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// root为null,返回一个[0,0]数组</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 左节点能偷的钱数</span></span><br><span class="line">        <span class="keyword">int</span>[] left = rob_helper(root.left);</span><br><span class="line">        <span class="comment">// 右节点能偷的钱数</span></span><br><span class="line">        <span class="keyword">int</span>[] right = rob_helper(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当前节点不偷的话，递归下一个节点偷或者不偷的情况</span></span><br><span class="line">        result[<span class="number">0</span>] = Math.max(left[<span class="number">0</span>],left[<span class="number">1</span>]) + Math.max(right[<span class="number">0</span>],right[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 当前节点偷的话，下一个节点只能选择不偷</span></span><br><span class="line">        result[<span class="number">1</span>] = left[<span class="number">0</span>] + right[<span class="number">0</span>] +root.val;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><strong>Solution :</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-337-打家劫舍-III&quot;&gt;&lt;a href=&quot;#Leecode-337-打家劫舍-III&quot; class=&quot;headerlink&quot; title=&quot;Leecode-337-打家劫舍 III&quot;&gt;&lt;/a&gt;Leecode-337-&lt;a href=&quot;https://leetcode-cn.com/problems/house-robber-iii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;打家劫舍 III&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：动态规划&quot;&gt;&lt;a href=&quot;#思路：动态规划&quot; class=&quot;headerlink&quot; title=&quot;思路：动态规划&quot;&gt;&lt;/a&gt;思路：动态规划&lt;/h2&gt;&lt;h3 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h3&gt;&lt;p&gt;你又是一个专业的小偷。。。。&lt;/p&gt;
&lt;p&gt;小偷又发现了一个新的可行窃的地区。这个地区&lt;strong&gt;只有一个入口，我们称之为“根”&lt;/strong&gt;。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 &lt;strong&gt;如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [3,2,3,null,3,null,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#x2F; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   2   3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    \   \ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     3   1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 7 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 小偷一晚能够盗取的最高金额 &amp;#x3D; 3 + 3 + 1 &amp;#x3D; 7.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [3,4,5,1,3,null,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#x2F; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   4   5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#x2F; \   \ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 1   3   1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 小偷一晚能够盗取的最高金额 &amp;#x3D; 4 + 5 &amp;#x3D; 9.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://zhuuu.work/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1306-跳跃游戏III</title>
    <link href="http://zhuuu.work/2020/05/04/Leetcode/Leetcode-1306-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FIII/"/>
    <id>http://zhuuu.work/2020/05/04/Leetcode/Leetcode-1306-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FIII/</id>
    <published>2020-05-04T07:52:53.000Z</published>
    <updated>2020-05-06T02:29:29.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-1306-Jump-Game-III"><a href="#Leecode-1306-Jump-Game-III" class="headerlink" title="Leecode-1306-Jump Game III"></a>Leecode-1306-<a href="https://leetcode-cn.com/problems/jump-game-iii/" target="_blank" rel="noopener">Jump Game III</a></h1><h2 id="思路：深度优先遍历-DFS"><a href="#思路：深度优先遍历-DFS" class="headerlink" title="思路：深度优先遍历/DFS"></a>思路：深度优先遍历/DFS</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>这里有一个非负整数数组 <code>arr</code>，你最开始位于该数组的起始下标 <code>start</code> 处。</p></li><li><p>当你位于下标 <code>i</code> 处时，你可以跳到 <code>i + arr[i]</code> 或者 <code>i - arr[i]</code>。</p></li><li><p>请你判断自己是否能够跳到对应元素值为 0 的 <strong>任意</strong> 下标处</p></li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [4,2,3,0,3,1,2], start &#x3D; 5</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">到达值为 0 的下标 3 有以下可能方案： </span><br><span class="line">下标 5 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3 </span><br><span class="line">下标 5 -&gt; 下标 6 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [4,2,3,0,3,1,2], start &#x3D; 0</span><br><span class="line">输出：true </span><br><span class="line">解释：</span><br><span class="line">到达值为 0 的下标 3 有以下可能方案： </span><br><span class="line">下标 0 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [3,0,2,1,2], start &#x3D; 2</span><br><span class="line">输出：false</span><br><span class="line">解释：无法到达值为 0 的下标 1 处。</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Solution：DFS</strong></p><ul><li>初始化一个长度为arr的boolean数组，记录已访问过的位置</li><li>递归进入判断当前位置是否是0<ul><li>不是的话：处理start左边的元素（索引递减，往左走找0）；处理start右边的元素（索引递增，往右走找0）, 最后还找不到的话返回false</li><li>是的话：返回true</li></ul></li></ul><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><strong>Solution :</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canReach</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 初始化一个长度为arr的boolean数组，记录已访问过的位置</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[arr.length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深度优先遍历</span></span><br><span class="line">        <span class="keyword">return</span> dfs(arr,start,visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归进入判断当前位置是否是0</span></span><br><span class="line">        <span class="keyword">if</span> (arr[start] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录start位置已被访问</span></span><br><span class="line">        visited[start] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理start左边的元素（索引递减，往左走找0）</span></span><br><span class="line">        <span class="keyword">int</span> left = start - arr[start];</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= <span class="number">0</span> &amp;&amp; !visited[left] &amp;&amp; dfs(arr,left,visited))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理start右边的元素（索引递增，往右走找0）</span></span><br><span class="line">        <span class="keyword">int</span> right = start + arr[start];</span><br><span class="line">        <span class="keyword">if</span> (right &lt; arr.length &amp;&amp; !visited[right] &amp;&amp; dfs(arr,right,visited))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有能达到0的位置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间复杂度：O(n)   n是数组的长度</p></li><li><p>空间复杂度：O(n)   boolean数组的长度</p></li></ul><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><strong>Solution :</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-1306-Jump-Game-III&quot;&gt;&lt;a href=&quot;#Leecode-1306-Jump-Game-III&quot; class=&quot;headerlink&quot; title=&quot;Leecode-1306-Jump Game III&quot;&gt;&lt;/a&gt;Leecode-1306-&lt;a href=&quot;https://leetcode-cn.com/problems/jump-game-iii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Jump Game III&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：深度优先遍历-DFS&quot;&gt;&lt;a href=&quot;#思路：深度优先遍历-DFS&quot; class=&quot;headerlink&quot; title=&quot;思路：深度优先遍历/DFS&quot;&gt;&lt;/a&gt;思路：深度优先遍历/DFS&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这里有一个非负整数数组 &lt;code&gt;arr&lt;/code&gt;，你最开始位于该数组的起始下标 &lt;code&gt;start&lt;/code&gt; 处。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当你位于下标 &lt;code&gt;i&lt;/code&gt; 处时，你可以跳到 &lt;code&gt;i + arr[i]&lt;/code&gt; 或者 &lt;code&gt;i - arr[i]&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;请你判断自己是否能够跳到对应元素值为 0 的 &lt;strong&gt;任意&lt;/strong&gt; 下标处&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：arr &amp;#x3D; [4,2,3,0,3,1,2], start &amp;#x3D; 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;到达值为 0 的下标 3 有以下可能方案： &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;下标 5 -&amp;gt; 下标 4 -&amp;gt; 下标 1 -&amp;gt; 下标 3 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;下标 5 -&amp;gt; 下标 6 -&amp;gt; 下标 4 -&amp;gt; 下标 1 -&amp;gt; 下标 3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：arr &amp;#x3D; [4,2,3,0,3,1,2], start &amp;#x3D; 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;到达值为 0 的下标 3 有以下可能方案： &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;下标 0 -&amp;gt; 下标 4 -&amp;gt; 下标 1 -&amp;gt; 下标 3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：arr &amp;#x3D; [3,0,2,1,2], start &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：无法到达值为 0 的下标 1 处。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="深度优先搜索" scheme="http://zhuuu.work/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-543-二叉树的最大直径</title>
    <link href="http://zhuuu.work/2020/05/04/Leetcode/Leetcode-543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9B%B4%E5%BE%84/"/>
    <id>http://zhuuu.work/2020/05/04/Leetcode/Leetcode-543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9B%B4%E5%BE%84/</id>
    <published>2020-05-04T07:21:53.000Z</published>
    <updated>2020-05-06T04:26:10.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-543-Diameter-of-Binary-Tree"><a href="#Leecode-543-Diameter-of-Binary-Tree" class="headerlink" title="Leecode-543-Diameter of Binary Tree"></a>Leecode-543-<a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">Diameter of Binary Tree</a></h1><h2 id="思路：深度优先搜索"><a href="#思路：深度优先搜索" class="headerlink" title="思路：深度优先搜索"></a>思路：深度优先搜索</h2><h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>说在前面：看本题之前，先去把<code>Leetcode-104-二叉树的最大深度</code> 做一下，效果会更好。（这两题有异曲同工之妙）。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定如下一个二叉树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line"> &#x2F; \     </span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><p><strong>求任意两个节点之间距离的最大值（可能不经过根节点）</strong></p><p><strong>Solution：DFS</strong></p><ul><li><p>思路：首先我们知道<strong>一条路径长度是该路径经过的节点数量减一</strong>，所以求直径等效于（求路径经过节点的最大值 ）。</p></li><li><p>其中任意一条路径均可以被看做由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到的。（如下图所示）</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200506/121247111.png" alt="mark"></p><p>从上图可以看出：</p><ul><li><p>路径<code>[9,4,2,5,7,8]</code> 可以看作2为起点，从其左儿子向下遍历的路径<code>[2,4,9]</code>和其右儿子<code>[2,5,7,8]</code> 拼接得到。</p></li><li><p><strong>对于该节点的左儿子向下遍历经过最多的节点数 L（即以左儿子为根的子树的深度），其右儿子向下遍历经过最多的节点数 R （即以右儿子为根的子树的深度）。那么以该节点为起点的路径经过的节点数的最大值为<code>L+R+1</code></strong></p></li></ul><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><strong>Solution :</strong></p><ol><li>定义一个递归函数 <code>depth(node)</code> 来计算d_node的值，函数返回该节点为根的子树的深度。</li><li>那么以节点为根的子树深度就是      <code>max(L,R) + 1</code></li><li>那么该节点的d_node的值就是 <code>L + R + 1</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="comment">// 全局变量</span></span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        depth(root);</span><br><span class="line">        <span class="comment">// 结果是最大节点数-1 （也就是路径直径）</span></span><br><span class="line">        <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最大节点数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 访问到空节点了，返回0</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左儿子为根的子树的深度</span></span><br><span class="line">        <span class="keyword">int</span> L = depth(node.left);</span><br><span class="line">        <span class="comment">// 右儿子为根的子树的深度</span></span><br><span class="line">        <span class="keyword">int</span> R = depth(node.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算d_node即L+R+1 并更新ans</span></span><br><span class="line">        ans = Math.max(ans,L + R + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 返回该节点为根的子树的深度</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(L,R) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>:    O（n) 。其中n是二叉树的节点数，即遍历一棵二叉树的时间复杂度，每个节点只访问一次。</li><li><strong>空间复杂度</strong>：O(height)。其中<code>height</code>是二叉树的高度。由于递归过程中每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，而递归的深度就是二叉树的高度，并且每次递归调用只使用了常数个变量(即ans)。</li></ul><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><strong>Solution :</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-543-Diameter-of-Binary-Tree&quot;&gt;&lt;a href=&quot;#Leecode-543-Diameter-of-Binary-Tree&quot; class=&quot;headerlink&quot; title=&quot;Leecode-543-Diameter of Binary Tree&quot;&gt;&lt;/a&gt;Leecode-543-&lt;a href=&quot;https://leetcode-cn.com/problems/diameter-of-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Diameter of Binary Tree&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：深度优先搜索&quot;&gt;&lt;a href=&quot;#思路：深度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;思路：深度优先搜索&quot;&gt;&lt;/a&gt;思路：深度优先搜索&lt;/h2&gt;&lt;h2 id=&quot;说在前面&quot;&gt;&lt;a href=&quot;#说在前面&quot; class=&quot;headerlink&quot; title=&quot;说在前面&quot;&gt;&lt;/a&gt;说在前面&lt;/h2&gt;&lt;p&gt;说在前面：看本题之前，先去把&lt;code&gt;Leetcode-104-二叉树的最大深度&lt;/code&gt; 做一下，效果会更好。（这两题有异曲同工之妙）。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="二叉树" scheme="http://zhuuu.work/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="深度优先搜索" scheme="http://zhuuu.work/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-045-跳跃游戏II</title>
    <link href="http://zhuuu.work/2020/05/04/Leetcode/Leetcode-045-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/"/>
    <id>http://zhuuu.work/2020/05/04/Leetcode/Leetcode-045-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/</id>
    <published>2020-05-04T00:52:53.000Z</published>
    <updated>2020-05-06T02:04:13.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-045-Jump-Game-II"><a href="#Leecode-045-Jump-Game-II" class="headerlink" title="Leecode-045-Jump Game II"></a>Leecode-045-<a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">Jump Game II</a></h1><h2 id="思路：贪心算法"><a href="#思路：贪心算法" class="headerlink" title="思路：贪心算法"></a>思路：贪心算法</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>本题是上一题（Leetode-55-跳跃游戏）的扩展题。</p><p>来看题目描述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 <span class="number">2</span>。</span><br><span class="line">     从下标为 <span class="number">0</span> 跳到下标为 <span class="number">1</span> 的位置，跳 <span class="number">1</span> 步，然后跳 <span class="number">3</span> 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure><ul><li>给定一个非负整数数组，你最初位于数组的第一个位置。</li><li>数组中的每个元素代表你在该位置可以跳跃的最大长度。</li><li><strong>目标是使用最少的跳跃次数到达数组的最后一个位置。</strong></li></ul><a id="more"></a><p><strong>Solution：</strong></p><ul><li>思路：贪心算法<ul><li>每次在可跳范围内再次选择可以跳的更远的位置</li></ul></li></ul><ol><li>如下图所示：</li></ol><ul><li>开始的时候位置是2，可跳范围是橙色的。</li><li>但是因为3可以跳的更远，所以跳到3的位置。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200506/095948893.png" alt="mark"></p><ol start="2"><li>如下图所示：</li></ol><ul><li>开始的位置是3</li><li>能跳的范围是橙色表示</li><li>但是因为4可以跳的更远，所以下次跳到4的位置</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200506/100034882.png" alt="mark"></p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><strong>Solution :</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 记录能跳的最大位置</span></span><br><span class="line">        <span class="keyword">int</span> rightmost = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 返回的步数</span></span><br><span class="line">        <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用来判断结果</span></span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不去判断最后一个元素是否能跳，所以是 n-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 记录每个点能跳的最远距离</span></span><br><span class="line">            rightmost = Math.max(rightmost,i + nums[i]);</span><br><span class="line">            <span class="comment">// 遇到边界，就更新边界，并且步数加一</span></span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                end = rightmost;</span><br><span class="line">                steps++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> steps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)  遍历一遍数组（<code>0 - n-1</code>的索引位置） </li><li>空间复杂度：O(1)   没有额外的空间</li></ul><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><strong>Solution :</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-045-Jump-Game-II&quot;&gt;&lt;a href=&quot;#Leecode-045-Jump-Game-II&quot; class=&quot;headerlink&quot; title=&quot;Leecode-045-Jump Game II&quot;&gt;&lt;/a&gt;Leecode-045-&lt;a href=&quot;https://leetcode-cn.com/problems/jump-game-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Jump Game II&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：贪心算法&quot;&gt;&lt;a href=&quot;#思路：贪心算法&quot; class=&quot;headerlink&quot; title=&quot;思路：贪心算法&quot;&gt;&lt;/a&gt;思路：贪心算法&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;本题是上一题（Leetode-55-跳跃游戏）的扩展题。&lt;/p&gt;
&lt;p&gt;来看题目描述：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 跳到最后一个位置的最小跳跃数是 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     从下标为 &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; 跳到下标为 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 的位置，跳 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 步，然后跳 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; 步到达数组的最后一个位置。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;给定一个非负整数数组，你最初位于数组的第一个位置。&lt;/li&gt;
&lt;li&gt;数组中的每个元素代表你在该位置可以跳跃的最大长度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目标是使用最少的跳跃次数到达数组的最后一个位置。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="春招每日一题" scheme="http://zhuuu.work/tags/%E6%98%A5%E6%8B%9B%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
      <category term="贪心算法" scheme="http://zhuuu.work/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.8源码-10-java.util.Stack</title>
    <link href="http://zhuuu.work/2020/05/03/jdk_SourceCode/JDK1.8-10-Stack/"/>
    <id>http://zhuuu.work/2020/05/03/jdk_SourceCode/JDK1.8-10-Stack/</id>
    <published>2020-05-03T11:52:53.000Z</published>
    <updated>2020-05-09T04:30:46.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK1-8源码-10-java-util-Stack"><a href="#JDK1-8源码-10-java-util-Stack" class="headerlink" title="JDK1.8源码-10-java.util.Stack"></a>JDK1.8源码-10-java.util.Stack</h1><p>前序：之前我们学完了Vector,接下来开始学习Stack。<strong>Stack很简单，它继承了Vector。</strong></p><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><ul><li>Stack叫做栈</li><li>特性是：先进后出（FILO:First in Last Out）</li></ul><ul><li>java工具包中的Stack继承于Vecotr(矢量队列)</li><li>由于Vector是通过数组实现的，这<strong>就意味着Stack也是通过数组实现的。</strong></li><li>当然LinkedList也可以当做栈使用。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200509/121600405.png" alt="mark"></p><a id="more"></a><p>由于Stack和继承于Vector，因此<strong>它也包含Vector中的全部API</strong>。</p><h2 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a>2. 构造函数</h2><ol><li>只有一个构造函数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an empty Stack.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-push"><a href="#3-push" class="headerlink" title="3. push"></a>3. push</h2><ul><li><pre><code>push函数：将元素存入栈顶<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Pushes an item onto the top of this stack. This has exactly</span><br><span class="line">     * the same effect as:</span><br><span class="line">     * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line">     * addElement(item)&lt;&#x2F;pre&gt;&lt;&#x2F;blockquote&gt;</span><br><span class="line">     *</span><br><span class="line">     * @param   item   the item to be pushed onto this stack.</span><br><span class="line">     * @return  the &lt;code&gt;item&lt;&#x2F;code&gt; argument.</span><br><span class="line">     * @see     java.util.Vector#addElement</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public E push(E item) &#123;</span><br><span class="line">        &#x2F;&#x2F; 调用Vector的addElement方法</span><br><span class="line">        &#x2F;&#x2F; 将元素存入栈顶</span><br><span class="line">        addElement(item);</span><br><span class="line"></span><br><span class="line">        return item;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><h2 id="4-peek"><a href="#4-peek" class="headerlink" title="4. peek"></a>4. peek</h2><ul><li><pre><code> peek函数：返回栈顶元素，不执行删除操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Looks at the object at the top of this stack without removing it</span><br><span class="line">     * from the stack.</span><br><span class="line">     *</span><br><span class="line">     * @return  the object at the top of this stack (the last item</span><br><span class="line">     *          of the &lt;tt&gt;Vector&lt;&#x2F;tt&gt; object).</span><br><span class="line">     * @throws  EmptyStackException  if this stack is empty.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public synchronized E peek() &#123;</span><br><span class="line">        int     len &#x3D; size();</span><br><span class="line"></span><br><span class="line">        if (len &#x3D;&#x3D; 0)</span><br><span class="line">            throw new EmptyStackException();</span><br><span class="line">       &#x2F;&#x2F; 返回栈顶元素</span><br><span class="line">        return elementAt(len - 1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><h2 id="5-pop"><a href="#5-pop" class="headerlink" title="5. pop"></a>5. pop</h2><ul><li><pre><code>pop函数：返回栈顶元素，并将其从栈中删除<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Removes the object at the top of this stack and returns that</span><br><span class="line">     * object as the value of this function.</span><br><span class="line">     *</span><br><span class="line">     * @return  The object at the top of this stack (the last item</span><br><span class="line">     *          of the &lt;tt&gt;Vector&lt;&#x2F;tt&gt; object).</span><br><span class="line">     * @throws  EmptyStackException  if this stack is empty.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public synchronized E pop() &#123;</span><br><span class="line">        E       obj;</span><br><span class="line">        int     len &#x3D; size();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取栈顶元素</span><br><span class="line">        obj &#x3D; peek();</span><br><span class="line">        &#x2F;&#x2F; 调用Vector的删除方法：将栈顶元素删除</span><br><span class="line">        removeElementAt(len - 1);</span><br><span class="line"></span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><h2 id="6-empty"><a href="#6-empty" class="headerlink" title="6. empty"></a>6. empty</h2><ul><li>判断栈是否为空</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tests if this stack is empty.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  &lt;code&gt;true&lt;/code&gt; if and only if this stack contains</span></span><br><span class="line"><span class="comment"> *          no items; &lt;code&gt;false&lt;/code&gt; otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-search"><a href="#7-search" class="headerlink" title="7. search"></a>7. search</h2><ul><li><pre><code>// 查找“元素o”在栈中的位置：由栈底向栈顶方向数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns the 1-based position where an object is on this stack.</span><br><span class="line">     * If the object &lt;tt&gt;o&lt;&#x2F;tt&gt; occurs as an item in this stack, this</span><br><span class="line">     * method returns the distance from the top of the stack of the</span><br><span class="line">     * occurrence nearest the top of the stack; the topmost item on the</span><br><span class="line">     * stack is considered to be at distance &lt;tt&gt;1&lt;&#x2F;tt&gt;. The &lt;tt&gt;equals&lt;&#x2F;tt&gt;</span><br><span class="line">     * method is used to compare &lt;tt&gt;o&lt;&#x2F;tt&gt; to the</span><br><span class="line">     * items in this stack.</span><br><span class="line">     *</span><br><span class="line">     * @param   o   the desired object.</span><br><span class="line">     * @return  the 1-based position from the top of the stack where</span><br><span class="line">     *          the object is located; the return value &lt;code&gt;-1&lt;&#x2F;code&gt;</span><br><span class="line">     *          indicates that the object is not on the stack.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public synchronized int search(Object o) &#123;</span><br><span class="line">        &#x2F;&#x2F; 从后往前获取元素第一次出现的索引</span><br><span class="line">        int i &#x3D; lastIndexOf(o);</span><br><span class="line"></span><br><span class="line">        if (i &gt;&#x3D; 0) &#123;</span><br><span class="line">            return size() - i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><ul><li>Stack其实也是通过数组实现的<ul><li>执行push方法的时候，是将元素追加在数组的末尾</li><li>执行peek方法的时候，是返回数组末尾的元素（取出栈顶元素，不执行删除）</li><li>执行pop方法的时候，是返回数组末尾的元素同时删除末尾的元素（取出栈顶元素并删除）</li></ul></li><li>Stack继承于Vector，可以使用Vector的所有API方法。</li></ul><h2 id="9-Stack-演示用例"><a href="#9-Stack-演示用例" class="headerlink" title="9. Stack 演示用例"></a>9. Stack 演示用例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stack stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 入栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        stack.push(String.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. for遍历打印栈</span></span><br><span class="line">    RandomGet(stack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 查找位置</span></span><br><span class="line">    <span class="keyword">int</span> pos = stack.search(<span class="string">"2"</span>);</span><br><span class="line">    System.out.println(<span class="string">"the position is "</span>+ pos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. pop元素之后再打印栈</span></span><br><span class="line">    stack.pop();</span><br><span class="line">    IteratorStack(stack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. peek元素之后再打印栈</span></span><br><span class="line">    stack.peek();</span><br><span class="line">    IteratorStack(stack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 通过iterator打印栈</span></span><br><span class="line">    IteratorStack(stack);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for循环打印</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RandomGet</span><span class="params">(List list)</span></span>&#123;</span><br><span class="line">    String val = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">        val = (String) list.get(i);</span><br><span class="line">        System.out.println(val);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器打印</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">IteratorStack</span><span class="params">(List list)</span></span>&#123;</span><br><span class="line">    String val = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Iterator it = list.iterator();it.hasNext();)&#123;</span><br><span class="line">        val = (String)it.next();</span><br><span class="line">        System.out.println(val);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JDK1-8源码-10-java-util-Stack&quot;&gt;&lt;a href=&quot;#JDK1-8源码-10-java-util-Stack&quot; class=&quot;headerlink&quot; title=&quot;JDK1.8源码-10-java.util.Stack&quot;&gt;&lt;/a&gt;JDK1.8源码-10-java.util.Stack&lt;/h1&gt;&lt;p&gt;前序：之前我们学完了Vector,接下来开始学习Stack。&lt;strong&gt;Stack很简单，它继承了Vector。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Stack叫做栈&lt;/li&gt;
&lt;li&gt;特性是：先进后出（FILO:First in Last Out）&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;java工具包中的Stack继承于Vecotr(矢量队列)&lt;/li&gt;
&lt;li&gt;由于Vector是通过数组实现的，这&lt;strong&gt;就意味着Stack也是通过数组实现的。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当然LinkedList也可以当做栈使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200509/121600405.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JDK源码分析" scheme="http://zhuuu.work/tags/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.8源码-09-java.util.Vector</title>
    <link href="http://zhuuu.work/2020/05/03/jdk_SourceCode/JDK1.8-09-Vector/"/>
    <id>http://zhuuu.work/2020/05/03/jdk_SourceCode/JDK1.8-09-Vector/</id>
    <published>2020-05-03T10:52:53.000Z</published>
    <updated>2020-05-09T03:31:33.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK1-8源码-09-java-util-Vector"><a href="#JDK1-8源码-09-java-util-Vector" class="headerlink" title="JDK1.8源码-09-java.util.Vector"></a>JDK1.8源码-09-java.util.Vector</h1><p>学完ArrayList和LinkedList之后，我们接着学习Vector。</p><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>Vector是<strong>矢量队列</strong>，它是JDK1.0版本添加的类。继承于AbstractList,实现了List接口。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200504/111755673.png" alt="mark"></p><a id="more"></a><ul><li><p>实现了List:所以<strong>它是一个队列，支持相关的添加，删除，修改，遍历功能。</strong></p></li><li><p>Vector 实现了RandmoAccess接口，即<strong>提供了随机访问功能</strong>。（其中RandomAccess接口，是java中用来被List实现，为List提供快速访问功能的。）</p></li><li><p>在Vector中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</p></li><li><p>Vector实现了Cloneable接口，即实现了clone()函数，它能被克隆。</p></li></ul><p><strong>注意：</strong></p><ul><li><strong>和Arraylist不同的是，Vector中的操作是线程安全的！！！。</strong></li></ul><h2 id="2-字段"><a href="#2-字段" class="headerlink" title="2. 字段"></a>2. 字段</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200504/113203131.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">// 1. elementData是“Object []类型的数组”，它保存了添加到Vector中的元素</span></span><br><span class="line"><span class="comment">// elementData是一个动态数组，如果初始化Vector时，没有指定动态数组的大小，则默认使用大小10。</span></span><br><span class="line"><span class="comment">// 随着Vector中元素的增加，Vector的容量也会增加。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">// elementCount是动态数组的实际大小。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> elementCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. capacityIncrement是动态数组的增长系数</span></span><br><span class="line"><span class="comment">// 如果在创建Vector,指定了capacityIncrement的大小，那就传入指定大小</span></span><br><span class="line"><span class="comment">// 每次当Vector中动态数组容量增加的时候，增加的大小都是capacityIncrement</span></span><br><span class="line"><span class="comment">// 具体的增长方式，请参考源码分析中的ensureCapacity()函数。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> capacityIncrement;</span><br></pre></td></tr></table></figure><p><strong>小结：</strong></p><ul><li><p>Vector实际上是通过一个<strong>数组</strong>去保存数据的。当我们构造Vector时候，若使用默认的构造函数，那么<strong>默认容量大小是10.</strong></p></li><li><p>当Vector容量不足以容纳全部元素的时候，<strong>若容量增加系数 &gt;0，则将容量的值增加“容量增加系数”；否则，将容量大小增加一倍。</strong></p></li><li><p>Vector的克隆函数，就是将全部元素克隆到一个数组中。</p></li></ul><h2 id="3-构造函数"><a href="#3-构造函数" class="headerlink" title="3. 构造函数"></a>3. 构造函数</h2><ol><li>无参数构造函数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty vector so that its internal data array</span></span><br><span class="line"><span class="comment">     * has size &#123;<span class="doctag">@code</span> 10&#125; and its standard capacity increment is</span></span><br><span class="line"><span class="comment">     * zero.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认是调用Vector(int initialCapacity)</span></span><br><span class="line"><span class="comment">// elementData是一个动态数组，如果初始化Vector时，没有指定动态数组的大小，则默认使用大小10。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>带初始化容量大小的构造方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    * <span class="meta">@param</span>   initialCapacity   the initial capacity of the vector</span><br><span class="line">    * <span class="meta">@throws</span> IllegalArgumentException <span class="keyword">if</span> the specified initial capacity</span><br><span class="line">    *         is negative</span><br><span class="line">    */</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 默认是调用Vector(int initialCapacity, int capacityIncrement)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>带初始化容量和容量增量的构造方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty vector with the specified initial capacity and</span></span><br><span class="line"><span class="comment">     * capacity increment.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   initialCapacity     the initial capacity of the vector</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   capacityIncrement   the amount by which the capacity is</span></span><br><span class="line"><span class="comment">     *                              increased when the vector overflows</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment">     *         is negative</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// capacity是Vector的默认容量大小</span></span><br><span class="line"><span class="comment">// capacityIncrement是每次Vector容量增加时的增量值。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="comment">// 如果初始化长度为0，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="comment">// 新建一个数组，数组容量是initialCapacity</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        <span class="comment">// 设置增长系数</span></span><br><span class="line">        <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>带Colleciton参数的构造方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a vector containing the elements of the specified</span></span><br><span class="line"><span class="comment">     * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment">     * iterator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c the collection whose elements are to be placed into this</span></span><br><span class="line"><span class="comment">     *       vector</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span>   1.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取“集合(c)”的数组，并将其赋值给elementData</span></span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="comment">// 设置数组长度</span></span><br><span class="line">        elementCount = elementData.length;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, elementCount, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是Arrays.copyOf的源码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        T[] copy = ((Object)newType == (Object)Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">            ? (T[]) new Object[newLength]</span><br><span class="line">            : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">        System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                         Math.min(original.length, newLength));</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4-copyInto"><a href="#4-copyInto" class="headerlink" title="4. copyInto"></a>4. copyInto</h2><p>调用本地方法：System.arraycopy</p><ul><li>把数组Vector的全部元素都拷贝到数组anArray中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Object[] anArray)</span> </span>&#123;</span><br><span class="line">       System.arraycopy(elementData, <span class="number">0</span>, anArray, <span class="number">0</span>, elementCount);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="5-trimToSize"><a href="#5-trimToSize" class="headerlink" title="5. trimToSize"></a>5. trimToSize</h2><p>将当前容量值更新为实际元素的个数，方便GC的回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 操作数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 当前容量值更新为实际元素的个数</span></span><br><span class="line">    <span class="keyword">if</span> (elementCount &lt; oldCapacity) &#123;</span><br><span class="line">        elementData = Arrays.copyOf(elementData, elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-ensureCapacity"><a href="#6-ensureCapacity" class="headerlink" title="6. ensureCapacity"></a>6. ensureCapacity</h2><p><strong>以下几个函数作用于确定Vector的容量大小，以及扩容操作。</strong></p><p>这里和ArrayList相比</p><p>除了扩容倍数有区别以外，其他几乎毫无区别</p><ul><li><strong>ArrayList：1.5倍</strong></li><li><strong>Vector:  2 倍</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 将Vector的改变统计数+1</span></span><br><span class="line">            modCount++;</span><br><span class="line">            ensureCapacityHelper(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确认“Vector容量”的帮助函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="comment">// 当Vector容量不足以容纳当前全部元素，进行扩容。</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="comment">// 拿到原来数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="comment">// 如果容量增量系数&gt;0，则容量增大capacityIncrement</span></span><br><span class="line">        <span class="comment">// 如果没指定capacityIncrement，容量扩大一倍(变为原来两倍)</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                         capacityIncrement : oldCapacity);</span><br><span class="line">        <span class="comment">// 当新数组长度仍然比minCapacity小，则为保证最小长度，新数组等于minCapacity</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 扩大为最小要求容量</span></span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">// 当新得到的数组长度比MAX_ARRAY_SIZE大的时候，</span></span><br><span class="line">        <span class="comment">// 调用hugeCapacity来处理大数组</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 调用大数组扩容操作</span></span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// 调用Arrays.copyOf将原数组拷贝到</span></span><br><span class="line">        <span class="comment">// 一个大小为newCapacity大小的新数组中（注意是拷贝引用）</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="comment">// minCapacity &gt; MAX_ARRAY_SIZE,</span></span><br><span class="line">        <span class="comment">// 则新数组大小为Integer.MAX_VALUE</span></span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="7-setSize"><a href="#7-setSize" class="headerlink" title="7. setSize"></a>7. setSize</h2><ul><li>给Vector设置新的size大小<ul><li>若 “newSize 大于 Vector容量”，则调整Vector的大小。</li><li>如果“newSize” 小于等于Vector的容量，则将从newSize位置开始的元素都设置为null</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 设置容量是newSize</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">    <span class="comment">//  若 "newSize 大于 Vector容量"，则调整Vector的大小。</span></span><br><span class="line">        <span class="keyword">if</span> (newSize &gt; elementCount) &#123;</span><br><span class="line">            ensureCapacityHelper(newSize);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果“newSize” 小于等于Vector的容量，</span></span><br><span class="line">            <span class="comment">// 则将从newSize位置开始的元素都设置为null</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize ; i &lt; elementCount ; i++) &#123;</span><br><span class="line">                elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        elementCount = newSize;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="8-Capacity-amp-amp-Size"><a href="#8-Capacity-amp-amp-Size" class="headerlink" title="8. Capacity&amp;&amp;Size"></a>8. Capacity&amp;&amp;Size</h2><ul><li>capacity返回<strong>Vector总的容量大小</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the current capacity of this vector.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  the current capacity (the length of its internal</span></span><br><span class="line"><span class="comment"> *          data array, kept in the field &#123;<span class="doctag">@code</span> elementData&#125;</span></span><br><span class="line"><span class="comment"> *          of this vector)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> elementData.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>size返回Vector实际的容量大小：（Vector中的元素个数）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the number of components in this vector.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  the number of components in this vector</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> elementCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-isEmpty"><a href="#9-isEmpty" class="headerlink" title="9. isEmpty"></a>9. isEmpty</h2><ul><li>判读Vector是否为空</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tests if this vector has no components.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> true&#125; if and only if this vector has</span></span><br><span class="line"><span class="comment"> *          no components, that is, its size is zero;</span></span><br><span class="line"><span class="comment"> *          &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> elementCount == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-Enumeration-lt-E-gt-elements"><a href="#10-Enumeration-lt-E-gt-elements" class="headerlink" title="10. Enumeration&lt; E &gt; elements()"></a>10. Enumeration&lt; E &gt; elements()</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200504/130822838.png" alt="mark"></p><ul><li><p>Enumeration只有两个方法：</p><ul><li><pre><code class="java"><span class="function"><span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span></span>;&lt;!--￼<span class="number">13</span>--&gt;</code></pre></li></ul></li><li><p>它只能从首个元素遍历到最后一个元素，并不能根据位置拿到具体的元素。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an enumeration of the components of this vector. The</span></span><br><span class="line"><span class="comment"> * returned &#123;<span class="doctag">@code</span> Enumeration&#125; object will generate all items in</span></span><br><span class="line"><span class="comment"> * this vector. The first item generated is the item at index &#123;<span class="doctag">@code</span> 0&#125;,</span></span><br><span class="line"><span class="comment"> * then the item at index &#123;<span class="doctag">@code</span> 1&#125;, and so on.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  an enumeration of the components of this vector</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Iterator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Enumeration&lt;E&gt; <span class="title">elements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过匿名类实现Enumeration</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Enumeration&lt;E&gt;() &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否存在下一个元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count &lt; elementCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 获取下一个元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">nextElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count &lt; elementCount) &#123;</span><br><span class="line">                    <span class="keyword">return</span> elementData(count++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Vector Enumeration"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-contains-containsAll"><a href="#11-contains-containsAll" class="headerlink" title="11 contains/containsAll"></a>11 contains/containsAll</h2><ul><li>判断Vector中是否包含对象o</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@code</span> true&#125; if this vector contains the specified element.</span></span><br><span class="line"><span class="comment"> * More formally, returns &#123;<span class="doctag">@code</span> true&#125; if and only if this vector</span></span><br><span class="line"><span class="comment"> * contains at least one element &#123;<span class="doctag">@code</span> e&#125; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element whose presence in this vector is to be tested</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this vector contains the specified element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, <span class="number">0</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断Vector中是否包含一个集合c</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns true if this Vector contains all of the elements in the</span></span><br><span class="line"><span class="comment"> * specified Collection.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   c a collection whose elements will be tested for containment</span></span><br><span class="line"><span class="comment"> *          in this Vector</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if this Vector contains all of the elements in the</span></span><br><span class="line"><span class="comment"> *         specified collection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.containsAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-indexOf-lastIndexOF"><a href="#12-indexOf-lastIndexOF" class="headerlink" title="12. indexOf/lastIndexOF"></a>12. indexOf/lastIndexOF</h2><ul><li>从index位置开始向后查找元素(o)。</li><li>只返回第一个找到的位置索引，找不到返回-1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> indexOf(o, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从index位置开始向后查找元素(o)。</span></span><br><span class="line"><span class="comment">// 只返回第一个找到的位置索引，找不到返回-1</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 若查找元素为null，则正向找出null元素，并返回它对应的序号</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = index ; i &lt; elementCount ; i++)</span><br><span class="line">               <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 若查找元素不为null，则正向找出该元素，并返回它对应的序号</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = index ; i &lt; elementCount ; i++)</span><br><span class="line">               <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>lastIndexOf:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> lastIndexOf(o, elementCount-<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若找到，则返回元素的“索引值”；否则，返回-1。</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(index + <span class="string">" &gt;= "</span>+ elementCount);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 若查找元素为null，则反向找出null元素，并返回它对应的序号</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">               <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 若查找元素不为null，则反向找出该元素，并返回它对应的序号</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">               <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="13-elementAt"><a href="#13-elementAt" class="headerlink" title="13 elementAt"></a>13 elementAt</h2><h3 id="13-1-elementAt"><a href="#13-1-elementAt" class="headerlink" title="13.1 elementAt"></a>13.1 elementAt</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">elementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 越界，则抛出异常</span></span><br><span class="line">      <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> + elementCount);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 返回index下标的元素</span></span><br><span class="line">      <span class="keyword">return</span> elementData(index);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="13-2-firstElement"><a href="#13-2-firstElement" class="headerlink" title="13.2 firstElement"></a>13.2 firstElement</h3><ul><li>返回Vector中index=0位置的元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回Vector中index=0位置的元素。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">firstElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elementData(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="13-3-lastElement"><a href="#13-3-lastElement" class="headerlink" title="13.3 lastElement"></a>13.3 lastElement</h3><ul><li>获取Vector中的最后一个元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Vector中的最后一个元素。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">lastElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elementData(elementCount - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="13-4-修改元素"><a href="#13-4-修改元素" class="headerlink" title="13.4 修改元素"></a>13.4 修改元素</h3><ul><li>设置index位置的元素为obj</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> +</span><br><span class="line">                                                 elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-5-删除元素"><a href="#13-5-删除元素" class="headerlink" title="13.5 删除元素"></a>13.5 删除元素</h3><ul><li>本质是把index+1位置后面的元素拷贝到index位置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeElementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> +</span><br><span class="line">                                                 elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拿到要删除的下标</span></span><br><span class="line">    <span class="keyword">int</span> j = elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 本质是把index+1位置后面的元素拷贝到index位置</span></span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</span><br><span class="line">    &#125;</span><br><span class="line">    elementCount--;</span><br><span class="line">    <span class="comment">// 将删除的位置置为null,翻遍GC回收</span></span><br><span class="line">    elementData[elementCount] = <span class="keyword">null</span>; <span class="comment">/* to let gc do its work */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-6-插入元素"><a href="#13-6-插入元素" class="headerlink" title="13.6 插入元素"></a>13.6 插入元素</h3><ul><li>把index+1位置后面的元素拷贝到index位置</li><li>再把index位置的元素改为obj</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index</span><br><span class="line">                                                 + <span class="string">" &gt; "</span> + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 首先保证Vector的大小</span></span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 把index+1位置后面的元素拷贝到index位置</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</span><br><span class="line">    <span class="comment">// 再把index位置的元素改为obj</span></span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">    elementCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-添加元素-add"><a href="#14-添加元素-add" class="headerlink" title="14. 添加元素/add"></a>14. 添加元素/add</h2><ul><li>在末尾添加元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(E obj)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 首先保证Vector的大小</span></span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 在末尾添加元素</span></span><br><span class="line">    elementData[elementCount++] = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this Vector.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this Vector</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    insertElementAt(element, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>addAll()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityHelper(elementCount + numNew);</span><br><span class="line">    <span class="comment">// 将集合c全部添加到Vector的末尾</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, elementCount, numNew);</span><br><span class="line">    elementCount += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityHelper(elementCount + numNew);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = elementCount - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 将集合c添加到index位置</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    elementCount += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-removeElement-remove"><a href="#15-removeElement-remove" class="headerlink" title="15. removeElement/remove"></a>15. removeElement/remove</h2><ul><li><strong>删除对应obj的索引位置的元素</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">removeElement</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 拿到obj对应的索引值</span></span><br><span class="line">    <span class="keyword">int</span> i = indexOf(obj);</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用删除方法</span></span><br><span class="line">        removeElementAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--elementCount] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>删除所有的元素</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有元素置为null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeAllElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">// Let gc do its work</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elementCount; i++)</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        elementCount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes all of the elements from this Vector.  The Vector will</span></span><br><span class="line"><span class="comment"> * be empty after this call returns (unless it throws an exception).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    removeAllElements();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>删除集合</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除不是集合c中的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.retainAll(c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除集合c中的元素 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.removeAll(c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>删除范围元素</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = elementCount - toIndex;</span><br><span class="line">    <span class="comment">// 相当于把fromindex到toindex之间抹掉了</span></span><br><span class="line">    System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                     numMoved);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let gc do its work</span></span><br><span class="line">    <span class="keyword">int</span> newElementCount = elementCount - (toIndex-fromIndex);</span><br><span class="line">    <span class="keyword">while</span> (elementCount != newElementCount)</span><br><span class="line">        elementData[--elementCount] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16-clone"><a href="#16-clone" class="headerlink" title="16. clone"></a>16. clone</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Vector&lt;E&gt; v = (Vector&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="comment">// 将当前Vector的全部元素拷贝到v中</span></span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, elementCount);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-toArray"><a href="#17-toArray" class="headerlink" title="17. toArray"></a>17. toArray</h2><ul><li>toArray</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns an array containing all of the elements in this Vector</span></span><br><span class="line"><span class="comment">    * in the correct order.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 返回Object的数组</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">synchronized</span> Object[] toArray() &#123;</span><br><span class="line">       <span class="keyword">return</span> Arrays.copyOf(elementData, elementCount);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>toArray(T[] a)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="comment">// 若数组a的大小 &lt; Vector元素的个数</span></span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; elementCount)</span><br><span class="line">        <span class="comment">// 则新建一个T[] 数组，数组大小是elementCount(Vector元素大小)</span></span><br><span class="line">        <span class="comment">// 并且把Vector全部拷贝到新数组中</span></span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, elementCount, a.getClass());</span><br><span class="line"></span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, elementCount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若数组a的大小 &gt; Vector元素的个数</span></span><br><span class="line">    <span class="comment">// 把大于部分的元素都置为null</span></span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; elementCount)</span><br><span class="line">        a[elementCount] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-获取元素-get"><a href="#18-获取元素-get" class="headerlink" title="18. 获取元素/get"></a>18. 获取元素/get</h2><ul><li>获取index位置的元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the element at the specified position in this Vector.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index of the element to return</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> object at the specified index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ArrayIndexOutOfBoundsException if the index is out of range</span></span><br><span class="line"><span class="comment"> *            (&#123;<span class="doctag">@code</span> index &lt; 0 || index &gt;= size()&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-修改元素-set"><a href="#19-修改元素-set" class="headerlink" title="19. 修改元素/set"></a>19. 修改元素/set</h2><ul><li>将index位置的元素置为element,并返回index位置的原始值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces the element at the specified position in this Vector with the</span></span><br><span class="line"><span class="comment"> * specified element.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index of the element to replace</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element element to be stored at the specified position</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element previously at the specified position</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ArrayIndexOutOfBoundsException if the index is out of range</span></span><br><span class="line"><span class="comment"> *         (&#123;<span class="doctag">@code</span> index &lt; 0 || index &gt;= size()&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20-equals-hashcode-toString"><a href="#20-equals-hashcode-toString" class="headerlink" title="20. equals/hashcode/toString"></a>20. equals/hashcode/toString</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断两个对象的引用是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.equals(o);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the hash code value for this Vector.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.hashCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a string representation of this Vector, containing</span></span><br><span class="line"><span class="comment"> * the String representation of each element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="21-subList"><a href="#21-subList" class="headerlink" title="21. subList"></a>21. subList</h2><ul><li>获取Vector中fromIndex到toIndex的子集</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.synchronizedList(<span class="keyword">super</span>.subList(fromIndex, toIndex),</span><br><span class="line">                                        <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="22-内部类Itr迭代器"><a href="#22-内部类Itr迭代器" class="headerlink" title="22. 内部类Itr迭代器"></a>22. 内部类Itr迭代器</h2><ul><li>用游标代替链表指向（这里在之前的LinkedArrayList中有详细讲过，这里不再阐述）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An optimized version of AbstractList.ListItr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        cursor = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">int</span> i = cursor - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            cursor = i;</span><br><span class="line">            <span class="keyword">return</span> elementData(lastRet = i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            Vector.<span class="keyword">this</span>.set(lastRet, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            Vector.<span class="keyword">this</span>.add(i, e);</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="23-遍历方式"><a href="#23-遍历方式" class="headerlink" title="23. 遍历方式"></a>23. 遍历方式</h2><p>Vector支持<strong>4种遍历方式</strong>。建议使用下面的第二种去遍历Vector，因为效率问题。</p><ol><li>第一种，通过<strong>迭代器</strong>遍历。即通过Iterator去遍历。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer value = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> size = vec.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">    value = (Integer)vec.get(i);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>第二种，<strong>随机访问</strong>，通过索引值去遍历(由于Vector实现了RandomAccess接口，它支持通过索引值去随机访问元素。)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer value = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> size = vec.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">    value = (Integer)vec.get(i);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>第三种，<strong>另一种for循环</strong>。如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer value = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (Integer integ:vec) &#123;</span><br><span class="line">    value = integ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>第四种，<strong>Enumeration遍历</strong>，如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer value = <span class="keyword">null</span>;</span><br><span class="line">Enumeration enu = vec.elements();</span><br><span class="line"><span class="keyword">while</span> (enu.hasMoreElements()) &#123;</span><br><span class="line">    value = (Integer)enu.nextElement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23-1-测试效率"><a href="#23-1-测试效率" class="headerlink" title="23.1 测试效率"></a>23.1 测试效率</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorRandomAccessTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Vector vec= <span class="keyword">new</span> Vector();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100000</span>; i++)</span><br><span class="line">            vec.add(i);</span><br><span class="line">        iteratorThroughRandomAccess(vec) ;</span><br><span class="line">        iteratorThroughIterator(vec) ;</span><br><span class="line">        iteratorThroughFor2(vec) ;</span><br><span class="line">        iteratorThroughEnumeration(vec) ;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">isRandomAccessSupported</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess) &#123;</span><br><span class="line">            System.out.println(<span class="string">"RandomAccess implemented!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"RandomAccess not implemented!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iteratorThroughRandomAccess</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime;</span><br><span class="line">        <span class="keyword">long</span> endTime;</span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++) &#123;</span><br><span class="line">            list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> interval = endTime - startTime;</span><br><span class="line">        System.out.println(<span class="string">"iteratorThroughRandomAccess："</span> + interval+<span class="string">" ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iteratorThroughIterator</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime;</span><br><span class="line">        <span class="keyword">long</span> endTime;</span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(Iterator iter = list.iterator(); iter.hasNext(); ) &#123;</span><br><span class="line">            iter.next();</span><br><span class="line">        &#125;</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> interval = endTime - startTime;</span><br><span class="line">        System.out.println(<span class="string">"iteratorThroughIterator："</span> + interval+<span class="string">" ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iteratorThroughFor2</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime;</span><br><span class="line">        <span class="keyword">long</span> endTime;</span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(Object obj:list)</span><br><span class="line">            ;</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> interval = endTime - startTime;</span><br><span class="line">        System.out.println(<span class="string">"iteratorThroughFor2："</span> + interval+<span class="string">" ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iteratorThroughEnumeration</span><span class="params">(Vector vec)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime;</span><br><span class="line">        <span class="keyword">long</span> endTime;</span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(Enumeration enu = vec.elements(); enu.hasMoreElements(); ) &#123;</span><br><span class="line">            enu.nextElement();</span><br><span class="line">        &#125;</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> interval = endTime - startTime;</span><br><span class="line">        System.out.println(<span class="string">"iteratorThroughEnumeration："</span> + interval+<span class="string">" ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iteratorThroughRandomAccess：<span class="number">6</span> ms</span><br><span class="line">iteratorThroughIterator：<span class="number">9</span> ms</span><br><span class="line">iteratorThroughFor2：<span class="number">8</span> ms</span><br><span class="line">iteratorThroughEnumeration：<span class="number">7</span> ms</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：遍历Vector，使用索引的随机访问方式最快，使用迭代器最慢。</p><h2 id="24-API-示例学习"><a href="#24-API-示例学习" class="headerlink" title="24. API 示例学习"></a>24. API 示例学习</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 新建一个Vector</span></span><br><span class="line">    Vector vec = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 添加元素</span></span><br><span class="line">    vec.add(<span class="string">"1"</span>);</span><br><span class="line">    vec.add(<span class="string">"2"</span>);</span><br><span class="line">    vec.add(<span class="string">"3"</span>);</span><br><span class="line">    vec.add(<span class="string">"4"</span>);</span><br><span class="line">    vec.add(<span class="string">"5"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 设置元素</span></span><br><span class="line">    vec.set(<span class="number">0</span>, <span class="string">"100"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 获取元素</span></span><br><span class="line">    System.out.println(<span class="string">"vec.firstElement():"</span> + vec.firstElement());</span><br><span class="line">    System.out.println(<span class="string">"vec.lastElement():"</span> + vec.lastElement());</span><br><span class="line">    System.out.println(<span class="string">"vec.elementAt(2):"</span> + vec.elementAt(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 查找</span></span><br><span class="line">    System.out.println(<span class="string">"vec.indexOf(100):"</span> + vec.indexOf(<span class="number">100</span>));</span><br><span class="line">    System.out.println(<span class="string">"vec.lastIndexOf(100):"</span> + vec.lastIndexOf(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 获取Vector的大小</span></span><br><span class="line">    System.out.println(<span class="string">"size"</span> + vec.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 获取Vector的总容量</span></span><br><span class="line">    System.out.println(<span class="string">"capacity"</span> + vec.capacity());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 获取一个范围的Vector</span></span><br><span class="line">    System.out.println(<span class="string">"vec 2 to 4"</span> + vec.subList(<span class="number">1</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9. 通过Enumeration遍历Vector</span></span><br><span class="line">    Enumeration enu = vec.elements();</span><br><span class="line">    <span class="keyword">while</span> (enu.hasMoreElements()) &#123;</span><br><span class="line">        System.out.println(<span class="string">"nextElement"</span> + enu.nextElement());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10. 获取"vec"包含在retainVec中元素的集合</span></span><br><span class="line">    Vector retainVec = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    retainVec.add(<span class="string">"100"</span>);</span><br><span class="line">    retainVec.add(<span class="string">"300"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"vec.retain():"</span> + vec.retainAll(retainVec));</span><br><span class="line">    System.out.println(<span class="string">"vec:"</span> + vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 11. 获取vec对应的String数组</span></span><br><span class="line">    String[] arr = (String[]) vec.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (String string : arr) &#123;</span><br><span class="line">        System.out.println(<span class="string">"string"</span> + string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 12. 清空Vector</span></span><br><span class="line">    vec.clear();</span><br><span class="line">    vec.removeAllElements();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 13. 判断Vector是否为空</span></span><br><span class="line">    System.out.println(<span class="string">"vec.isEmpty():"</span> + vec.isEmpty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JDK1-8源码-09-java-util-Vector&quot;&gt;&lt;a href=&quot;#JDK1-8源码-09-java-util-Vector&quot; class=&quot;headerlink&quot; title=&quot;JDK1.8源码-09-java.util.Vector&quot;&gt;&lt;/a&gt;JDK1.8源码-09-java.util.Vector&lt;/h1&gt;&lt;p&gt;学完ArrayList和LinkedList之后，我们接着学习Vector。&lt;/p&gt;
&lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AbstractList&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;List&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt;, &lt;span class=&quot;title&quot;&gt;RandomAccess&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Cloneable&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;java&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Serializable&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;Vector是&lt;strong&gt;矢量队列&lt;/strong&gt;，它是JDK1.0版本添加的类。继承于AbstractList,实现了List接口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200504/111755673.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JDK源码分析" scheme="http://zhuuu.work/tags/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.8源码-08-java.util.HashSet</title>
    <link href="http://zhuuu.work/2020/05/03/jdk_SourceCode/JDK1.8-08-HashSet/"/>
    <id>http://zhuuu.work/2020/05/03/jdk_SourceCode/JDK1.8-08-HashSet/</id>
    <published>2020-05-03T09:52:53.000Z</published>
    <updated>2020-05-03T01:38:22.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK1-8源码-08-java-util-HashSet"><a href="#JDK1-8源码-08-java-util-HashSet" class="headerlink" title="JDK1.8源码-08-java.util.HashSet"></a>JDK1.8源码-08-java.util.HashSet</h1><p>在JDK1.8中，HashMap是用 数组+链表+红黑树构成，相对于早期版本的JDK HashMap实现，新增了红黑树作为底层的数据结构，在数据量较大且哈希碰撞较多的时候，能够极大的增加检索的效率。</p><p><strong>了解了HashMap的具体实现后，再来了解HashMap作为底层数据结构的HashSet。</strong></p><p>(如果不了解 HashMap 的实现原理，建议先看看 HashMap，不然直接看 HashSet 是很难看懂的）</p><a id="more"></a><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p><strong>HashSet是一个由HashMap实现的集合。元素无序且不能重复</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200503/090527948.png" alt="mark"></p><p>和前面介绍的大多数集合一样，HashSet 也实现了 Cloneable 接口和 Serializable 接口，分别用来支持克隆以及支持序列化。还实现了 Set 接口，该接口定义了 Set 集合类型的一套规范。</p><h2 id="2-字段属性"><a href="#2-字段属性" class="headerlink" title="2. 字段属性"></a>2. 字段属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// HashSet集合中的内容是通过 HashMap 数据结构来存储的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="comment">// 向Hashset添加数据的时候，数据在上面的map结构是作为key存在的，</span></span><br><span class="line"><span class="comment">// 而value统一都是PRESENT</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><ul><li>第一个定义一个 HashMap，作为实现 HashSet 的数据结构；</li><li>第二个定义的PRESENT对象，因为前面讲过的HashMap 是作为键值对key-value进行存储的，而HashSet不是键值对，那么选择HashMap作为实现，其原理就是存储在HashSet中的数据作为Map的key,而Map的value同一为PRESENT（下面介绍具体实现时会了解）。</li></ul><h2 id="3-构造函数"><a href="#3-构造函数" class="headerlink" title="3. 构造函数"></a>3. 构造函数</h2><ol><li><strong>无参构造</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接new一个HashMap 的对象出来，采用无参的HashMap 构造函数，具有默认初始容量（16）和加在因子（0.75）。</p><ol start="2"><li><strong>指定初始容量</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment"> * the specified initial capacity and default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      initialCapacity   the initial capacity of the hash table</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment"> *             than zero</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>指定初始容量和加载因子</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment"> * the specified initial capacity and the specified load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      initialCapacity   the initial capacity of the hash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      loadFactor        the load factor of the hash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment"> *             than zero, or if the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>构造包含指定集合中的元素</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new set containing the elements in the specified</span></span><br><span class="line"><span class="comment">     * collection.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with default load factor</span></span><br><span class="line"><span class="comment">     * (0.75) and an initial capacity sufficient to contain the elements in</span></span><br><span class="line"><span class="comment">     * the specified collection.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c the collection whose elements are to be placed into this set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 容量的大小是（c.size()/0.75 +1） 和 默认初始容量16的最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>集合容量很好理解，这里再次介绍一下什么是加载因子。</p><ul><li><strong>在HashMap中，能够存储元素的数量是：总的容量*加载因子</strong></li><li>新增一个元素的时候，如果HashMap集合中的元素大于前面计算公式的结果了，那么就必须进行扩容的操作，从时间和和空间考虑，加载因子一般都默认选0.75.</li></ul><h2 id="4-添加元素"><a href="#4-添加元素" class="headerlink" title="4. 添加元素"></a>4. 添加元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   HashSet 的 add(E e) 方法</span></span><br><span class="line"><span class="comment">// 会将e作为key, PRESENT作为value值插入到map集合中</span></span><br><span class="line"><span class="comment">// 如果e不存在,则插入成功并且返回true,如果存在，则返回false  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过map.put()方法来添加元素，在上一篇已经介绍过此方法。</p><ul><li><p>该方法如果新插入的key不存在,则返回null,</p></li><li><p>如果新插入的key存在，则返回key对应的value值（注意新插入的value会覆盖原来的value值）</p></li></ul><p><strong>也就是说HashSet 的 add(E e) 方法，会将e作为key, PRESENT作为value值插入到map集合中，如果e不存在,则插入成功并且返回true,如果存在，则返回false</strong></p><h2 id="5-删除元素"><a href="#5-删除元素" class="headerlink" title="5. 删除元素"></a>5. 删除元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用HashMap 的remove(Object o)方法，该方法会首先查找map集合中是否存在o，如果存在则删除，并返回该值，如果不存在则返回null。</p><p><strong>也就是说HashSet的remove(Object o)方法，删除成功返回true,删除的元素不存在会返回false。</strong></p><h2 id="6-查找元素"><a href="#6-查找元素" class="headerlink" title="6. 查找元素"></a>6. 查找元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用HashMap的containsKey(Object o)方法，找到了返回true,找不到返回false。</p><h2 id="7-遍历元素"><a href="#7-遍历元素" class="headerlink" title="7. 遍历元素"></a>7. 遍历元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    set.add(<span class="number">1</span>);</span><br><span class="line">    set.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增强for循环</span></span><br><span class="line">    <span class="keyword">for</span> (Integer i : set) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通for循环</span></span><br><span class="line">    Iterator&lt;Integer&gt; iterator = set.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HashSet底层源码不多，只有短短354行，最重要的还是HashSet的底层数据结构HashMap的实现。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JDK1-8源码-08-java-util-HashSet&quot;&gt;&lt;a href=&quot;#JDK1-8源码-08-java-util-HashSet&quot; class=&quot;headerlink&quot; title=&quot;JDK1.8源码-08-java.util.HashSet&quot;&gt;&lt;/a&gt;JDK1.8源码-08-java.util.HashSet&lt;/h1&gt;&lt;p&gt;在JDK1.8中，HashMap是用 数组+链表+红黑树构成，相对于早期版本的JDK HashMap实现，新增了红黑树作为底层的数据结构，在数据量较大且哈希碰撞较多的时候，能够极大的增加检索的效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;了解了HashMap的具体实现后，再来了解HashMap作为底层数据结构的HashSet。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(如果不了解 HashMap 的实现原理，建议先看看 HashMap，不然直接看 HashSet 是很难看懂的）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JDK源码分析" scheme="http://zhuuu.work/tags/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.8源码-07-java.util.HashMap</title>
    <link href="http://zhuuu.work/2020/05/03/jdk_SourceCode/JDK1.8-07-HashMap/"/>
    <id>http://zhuuu.work/2020/05/03/jdk_SourceCode/JDK1.8-07-HashMap/</id>
    <published>2020-05-03T07:52:53.000Z</published>
    <updated>2020-06-30T02:20:03.910Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK1-8源码-08-java-util-HashMap"><a href="#JDK1-8源码-08-java-util-HashMap" class="headerlink" title="JDK1.8源码-08-java.util.HashMap"></a>JDK1.8源码-08-java.util.HashMap</h1><p>本篇来介绍在 JDK1.8 中 HashMap 的源码实现，这也是最常用的一个集合。但是在介绍 HashMap 之前，我们先介绍什么是 Hash表。</p><a id="more"></a><h2 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1. 哈希表"></a>1. 哈希表</h2><p>Hash表也被称为散列表，也有直接译为哈希表，Hash表是一个根据关键字值（key-value）而直接进行访问的数据结构。</p><p>也就是说它通过把关键码映射到表中一个位置来访问记录，以此来加快查找的速度。</p><p><strong>在链表，数组等数据结构中</strong>，查找某个关键字，通常要遍历整个数据结构，也就是O(N)的时间复杂度，但对于哈希表来说，只是O(1)的时间复杂度。</p><p><strong>比如对于，ArrayList集合和LinkedList来说，如果要查找两个集合中的某个元素，通常是通过遍历整个集合，需要O(N)的时间复杂度。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200419/212353731.png" alt="mark"></p><p>如果是哈希表的话，它是通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个<strong>映射函数叫做散列函数</strong>，<strong>存放记录的数组叫做散列表</strong>。只需要O(1)的时间复杂度。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200419/212747630.png" alt="mark"></p><p>①、存放在哈希表中的数据是key-value 键值对，比如存放哈希表的数据为:</p><p>　　<strong>{Key1-Value1,Key2-Value2,Key3-Value3,Key4-Value4,Key5-Value5,Key6-Value6}</strong></p><p>如果我们想查找是否存在键值对 Key3-Value3，首先通过 Key3 经过散列函数，得到值 k3，然后通过 k3 和散列表对应的值找到是 Value3。</p><p>②、当然也有可能存放哈希表的值只是 Value1,Value2,Value3这种类型：</p><p><strong>{Value1,Value2,Value3,Value4,Value5,Value6}</strong></p><p>这时候我们<strong>假设Value1是等于Key1的</strong>，也就是{Value1-Value1,Value2-Value2,Value3-Value3,Value4-Value4,Value5-Value5,Value6-Value6}。可以将Value1经过散列函数转换成与散列表对应的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大家都用过汉语字典吧，汉语字典的优点是我们可以通过前面的拼音目录快速定位到所要查找的汉字。当给定我们某个汉字时，大脑会自动将汉字转换成拼音（如果我们认识，不认识可以通过偏旁部首），这个转换的过程我们可以看成是一个散列函数，之后在根据转换得到的拼音找到该字所在的页码，从而找到该汉字。</span><br></pre></td></tr></table></figure><p>汉语字典是哈希表的典型实现，但是我们仔细思考，会发现这样几个问题？</p><p><strong>①、为什么要有散列函数？</strong></p><p>对于第一个问题，散列函数的存在能够帮助我们更快的确定key和value的映射关系，试想一下，如果没有汉字和拼音的转换规则（或者汉字和偏旁部首的），给你一个汉字，你该如何从字典中找到该汉字？我想除了遍历整部字典，你没有什么更好的办法。</p><p><strong>②、多个 key 通过散列函数会得到相同的值，这时候怎么办？</strong></p><p>对于第二个问题，多个key通过散列函数得到相同的值，这其实也就是<strong>哈希表最大的问题–冲突</strong>，比如同音字汉字，我们得到的拼音就是相同的。那么我们该如何在字典中存放同音字汉字呢？有两种做法：</p><ul><li><p><strong>第一种：开放地址法</strong></p><ul><li>当我们遇到冲突了，这时候通过另一种函数再计算一遍，得到相应的映射关系。</li><li>比如对于汉语字典，一个字 “余”，拼音是“yu”，我们将其放在页码为567(假设在该位置)，这时候又来了一个汉字“于”，拼音也是“yu”，那么这时候我们要是按照转换规则，也得将其放在页码为567的位置，但是我们发现这个页码已经被占用了，这时候怎么办？我们可以在通过另一种函数，得到的值加1。那么汉字”于”就会被放在576+1=577的位置。</li></ul></li></ul><ul><li><p><strong>第二种：链地址法</strong></p><ul><li>我们可以将字典的每一页都看成是一个子数组或者子链表，<strong>当遇到冲突了，直接往当前页码的子数组或者子链表填充即可。</strong></li><li>那么我们进行同音字查找的时候，可能需要遍历其子数组或者子链表。如下图所示：</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200419/213509026.png" alt="mark"></p><p>小结：</p><ul><li>对于开放地址法，可能会遇到二次冲突，三次冲突，所以需要良好的散列函数，分布的越均匀越好。</li><li>对于链地址法，虽然不会有二次冲突，但是如果一次冲突很多，那么会造成子数组或者子链表。</li></ul><h2 id="2-什么是HashMap"><a href="#2-什么是HashMap" class="headerlink" title="2. 什么是HashMap?"></a>2. 什么是HashMap?</h2><p>听名字就知道，HashMap 是一个利用哈希表原理来存储元素的集合。遇到冲突时，<strong>HashMap 是采用的链地址法来解决，</strong></p><ul><li><p><strong>在JDK1.7中，HashMap是由数组+链表构成的。</strong></p></li><li><p><strong>但是在 JDK1.8 中，HashMap 是由 数组+链表+红黑树构成，新增了红黑树作为底层的数据结构，结构变复杂了，但是效率也更高效。</strong></p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200420/090843192.png" alt="mark"></p><h2 id="3-定义"><a href="#3-定义" class="headerlink" title="3.  定义"></a>3.  定义</h2><p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射，<strong>而且 key 和 value 都可以为 null。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200420/091324715.png" alt="mark"></p><p>首先该类实现了一个Map接口，该接口定义的一组键和值对映射的通用操作。存储的一组成对的key-value对象，提供key到value的映射。</p><p><strong>Map中的key不要求有序,不允许重复。</strong></p><p><strong>Map中的value同样不要求有序,但可以重复。</strong></p><p>但是我们发现该接口方法有很多，我们设计某个键值对的集合有时候并不想实现那么多方法，那该怎么办？</p><p><strong>JDK 还为我们提供了一个抽象类 AbstractMap ，该抽象类继承 Map 接口，所以如果我们不想实现所有的 Map 接口方法，就可以选择继承抽象类 AbstractMap 。</strong></p><p><strong>但是我们发现 HashMap 类即继承了 AbstractMap 接口，也实现了 Map 接口，这样做难道不是多此一举？后面我们会讲的 LinkedHashSet 集合也有这样的写法。</strong></p><p>毕竟 JDK 经过这么多年的发展维护，起初也是认为这样是有具体的作用的，后来找了很多资料，发现这其实完全没有任何作用。[说明链接][<a href="https://stackoverflow.com/questions/2165204/why-does-linkedhashsete-extend-hashsete-and-implement-sete]" target="_blank" rel="noopener">https://stackoverflow.com/questions/2165204/why-does-linkedhashsete-extend-hashsete-and-implement-sete]</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">据 java 集合框架的创始人Josh Bloch描述，这样的写法是一个失误。在java集合框架中，类似这样的写法很多，最开始写java集合框架的时候，他认为这样写，在某些地方可能是有价值的，直到他意识到错了。显然的，JDK的维护者，后来不认为这个小小的失误值得去修改，所以就这样存在下来了。</span><br></pre></td></tr></table></figure><p>HashMap集合还实现了Cloneable接口和Serializable接口，分别用来对对象进行克隆和序列化。</p><h2 id="4-字段属性"><a href="#4-字段属性" class="headerlink" title="4. 字段属性"></a>4. 字段属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化和反序列化时，通过该字段进行版本一致性验证</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line">   <span class="comment">//默认 HashMap 集合初始容量为16（必须是 2 的倍数）</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line">   <span class="comment">//集合的最大容量，如果通过带参构造指定的最大容量超过此数，默认还是使用此数</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">   <span class="comment">//默认的填充因子</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">   <span class="comment">//当桶(bucket)上的结点数大于这个值时会转成红黑树(JDK1.8新增)</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">   <span class="comment">//当桶(bucket)上的节点数小于这个值时会转成链表(JDK1.8新增)</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">   <span class="comment">/**(JDK1.8新增)</span></span><br><span class="line"><span class="comment">    * 当集合中的容量大于这个值时，表中的桶才能进行树形化 ，否则桶内元素太多时会扩容，</span></span><br><span class="line"><span class="comment">    * 而不是树形化 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure><p><strong>注意：后面三个字段是 JDK1.8 新增的，主要是用来进行红黑树和链表的互相转换。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化使用，长度总是 2的幂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存缓存的entrySet（）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此映射中包含的键值映射的数量。（集合存储键值对的数量）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跟前面ArrayList和LinkedList集合中的字段modCount一样，记录集合被修改的次数</span></span><br><span class="line"><span class="comment">     * 主要用于迭代器中的快速失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整大小的下一个大小值（容量*加载因子）。capacity * load factor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 散列表的加载因子。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p>下面我们重点介绍上面几个字段：</p><p><strong>①、Node&lt;K,V&gt;[] table</strong></p><p>HashMap是有数组+链表+红黑树组成，<strong>这里的数组就是table字段</strong>。后面对其进行初始化长度默认是 <code>DEFAULT_INITIAL_CAPACITY= 16</code>。</p><p>而且jdk声明数组长度总是2的n次方（<strong>一定是合数</strong>：<em>合数</em>是指在大于1的整数中除了能被1和本身整除外，还能被其他数（0除外）整除的数。）。</p><p>为什么这里要求是合数，一般我们知道<strong>哈希算法为了避免冲突都要求长度是质数</strong>，这里要求是合数。下面在介绍 HashMap 的hashCode() 方法(散列函数)，我们再进行讲解。</p><p><strong>②、size</strong></p><p>集合中存放key-value 的实时对数。</p><p><strong>③、loadFactor</strong></p><p>装载因子，是用来衡量HashMap满的程度。计算HashMap的实时装载因子的方法为：size/capacity。而不是用占用桶的数量去除以capacity，capacity是桶的数量，也就是table的长度length。</p><p><strong>默认的负载因子0.75 是对空间和时间效率的一个平衡选择，建议不要修改。</strong></p><p>除非在时间和空间都比较特殊的情况下，如果内存空间很多而对时间效率的要求很高，可以降低loadFactor的值；相反，如果内存空间紧张同时又对时间效率要求不高，可以增加loadFactor的值，这个值可以大于1。</p><p><strong>④、threshold</strong></p><p>计算公式：capacity * loadFactor 。</p><p>这个值是当前已经数组长度的最大值。超过这个数目就要进行resize(扩容)。扩容后的HashMap容量是之前容量的两倍。</p><h2 id="5-构造函数"><a href="#5-构造函数" class="headerlink" title="5. 构造函数"></a>5. 构造函数</h2><p><strong>①、默认无参构造函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认构造函数，初始化加载因子loadFactor = 0.75</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>无参构造器，初始化散列表的加载因子为0.75</p><p><strong>②、指定初始容量的构造函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 指定初始化容量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadFactor 加载因子 0.75</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化容量不能小于 0 ，否则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="comment">//如果初始化容量大于2的30次方，则初始化容量都为2的30次方</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="comment">//如果加载因子小于0，或者加载因子是一个非数值，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回大于等于initialCapacity的最小的二次幂数值。</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt; 操作符表示无符号右移，高位取0。</span></span><br><span class="line">    <span class="comment">// | 按位或运算</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="6-确定哈希桶数组索引位置"><a href="#6-确定哈希桶数组索引位置" class="headerlink" title="6. 确定哈希桶数组索引位置"></a>6. 确定哈希桶数组索引位置</h2><p>前面讲解哈希表的时候，我们知道是用散列函数来确定索引的位置。散列函数设计的越好，使得元素分布的越均匀。</p><p>HashMap 是数组+链表+红黑树的组合，我们希望在<strong>有限个数组位置的时候</strong>，尽量没有位置的元素只有一个，<strong>那么当我们用散列函数求得索引位置的时候，能马上知道对应位置的元素是不是我们想要的，而不是进行链表的遍历或者红黑树的遍历</strong>。这会大大优化我们的查询效率。</p><p>看一下HashMap中的hash算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0</span></span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    i = (table.length - <span class="number">1</span>) &amp; hash;<span class="comment">//这一步是在后面添加元素putVal()方法中进行位置的确定</span></span><br></pre></td></tr></table></figure><p>主要分为三步：</p><ol><li>取HashCode的值：key.hashCode()</li><li>高位参与运算：h&gt;&gt;&gt;16</li><li>取模运算：(n-1) &amp; hash</li></ol><p>这里获取 hashCode() 方法的值是变量，但是我们知道，对于任意给定的对象，只要它的 hashCode() 返回值相同，那么程序调用 hash(Object key) 所计算得到的 hash码 值总是相同的。</p><p>为了让数组元素分布均匀，我们首先想到的是把获得的 hash码对数组长度取模运算( hash%length)，但是计算机都是二进制进行操作，<strong>取模运算相对开销还是很大的</strong>，那该如何优化呢？</p><p>HashMap使用的方法很巧妙，<strong>它通过hash&amp;(table.length-1)来得到该对象的保存位</strong>，前面说过HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。</p><p><strong>当length总是2的n次方的时候，hash &amp; (length-1)运算等价于对 length 取模，也就是hash%length。但是&amp;比%具有更高的效率。比如 n % 32 = n &amp; (32 -1)</strong></p><p><strong>这也解释了为什么要保证数组的长度总是2的n次方。</strong></p><p>再就是在JDK1.8中还有个高位参与运算，hashCode()得到的是一个32位的int类型的值，通过hashCode()的高16位 <strong>异或</strong> 低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度，功效，质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低bit都参数Hash的计算中，同时不会有太大的开销。</p><p>下面举例说明：n为table的长度：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200420/100924560.png" alt="mark"></p><h2 id="7-添加元素"><a href="#7-添加元素" class="headerlink" title="7. 添加元素"></a>7. 添加元素</h2><p><strong>JDK1.8中put方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hash(key)就是上面讲的hash方法，对其进行了第一步和第二步处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash 索引的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value  值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent true 表示不要更改现有值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict false表示table处于创建模式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">         Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">         <span class="comment">//如果table为null或者长度为0，则进行初始化</span></span><br><span class="line">         <span class="comment">//resize()方法本来是用于扩容，由于初始化没有实际分配空间，这里用该方法进行空间分配，后面会详细讲解该方法</span></span><br><span class="line">         <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">             n = (tab = resize()).length;</span><br><span class="line">         <span class="comment">//注意：这里用到了前面讲解获得key的hash码的第三步，取模运算，下面的if-else分别是 tab[i] 为null和不为null</span></span><br><span class="line">         <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">             tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">//tab[i] 为null，直接将新的key-value插入到计算的索引i位置</span></span><br><span class="line">         <span class="keyword">else</span> &#123;<span class="comment">//tab[i] 不为null，表示该位置已经有值了</span></span><br><span class="line">             Node&lt;K,V&gt; e; K k;</span><br><span class="line">             <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                 ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                 e = p;<span class="comment">//节点key已经有值了，直接用新值覆盖</span></span><br><span class="line">             <span class="comment">//该链是红黑树</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">             <span class="comment">//该链是链表</span></span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                     <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                         p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                         <span class="comment">//链表长度大于8，转换成红黑树</span></span><br><span class="line">                         <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                             treeifyBin(tab, hash);</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">//key已经存在直接覆盖value</span></span><br><span class="line">                     <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                         ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                     p = e;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                 V oldValue = e.value;</span><br><span class="line">                 <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                     e.value = value;</span><br><span class="line">                 afterNodeAccess(e);</span><br><span class="line">                 <span class="keyword">return</span> oldValue;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         ++modCount;<span class="comment">//用作修改和新增快速失败</span></span><br><span class="line">         <span class="keyword">if</span> (++size &gt; threshold)<span class="comment">//超过最大容量，进行扩容</span></span><br><span class="line">             resize();</span><br><span class="line">         afterNodeInsertion(evict);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><p>判断键值对数组table是否为空或者为null,否则执行resize()进行扩容或进行空间分配；</p></li><li><p>根据键值对key计算hash值得到插入的数组索引i,如果table[i] == null，直接就在新建节点添加；<strong>转下下面的6</strong>,如果talbe[i] 不为空，<strong>转向3</strong></p></li><li><p>判断talbe[i]的首个元素是否和key一样，如果相同直接覆盖value，<strong>否则转向4</strong>，这里的相同指的是hashcode以及equals。</p></li><li><p>判断table[i]是否是treeNode，即table[i]是否是红黑树，如果是红黑树，则直接在树中插入键值对，<strong>否则转向5</strong></p></li><li><p>遍历table[i]，判断链表长度是否大于8，大于8的话就把链表转换成红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可。</p></li><li><p>插入成功后，判断实际存在的键值对数量size是否超过了最大容量threshold，如果超过，则进行扩容。</p></li><li><p>如果新插入的key不存在，则返回null,如果新插入的key存在，则返回原key对应的value值（注意新插入的value会覆盖原来的value值）</p></li></ol><p><strong>注意1：看第58，59行代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (++size &gt; threshold)<span class="comment">//超过最大容量，进行扩容</span></span><br><span class="line">    resize();</span><br></pre></td></tr></table></figure><p>这里有个考点，我们知道 HashMap 是由数组+链表+红黑树（JDK1.8）组成，如果在添加元素的时候，发生冲突，会将冲突的数放在链表上，当链表长度超过8时。会自动转换成红黑树。</p><p>那么有如下问题：<strong>数组上有5个元素，而某个链表上有3个元素，问此HashMap的 size 是多大？</strong></p><p>我们分析第58,59 行代码，很容易知道，<strong>只要是调用put()方法添加元素，那么就会调用++size（这里有个例外是插入重复的key的键值对，不会调用，但是重复的key元素不会影响到size）</strong></p><p><strong>所以，上面的答案是7</strong></p><p><strong>注意2：看第 53 、 60 行代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">afterNodeAccess(e);</span><br><span class="line">afterNodeInsertion(evict);</span><br></pre></td></tr></table></figure><p>这里调用的该方法，其实是调用了如下实现方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>　　这都是一个<strong>空的方法实现</strong>，我们在这里可以不用管，但是在后面<strong>介绍 LinkedHashMap 会用到</strong>，LinkedHashMap 是继承的 HashMap，并且重写了该方法，后面我们会详细介绍。</p><h2 id="8-扩容机制"><a href="#8-扩容机制" class="headerlink" title="8. 扩容机制"></a>8. 扩容机制</h2><p>扩容（resize），我们知道集合是由数组+链表+红黑树构成，向 HashMap 中插入元素时，<strong>如果HashMap 集合的元素已经大于了最大承载容量threshold（capacity * loadFactor），这里的threshold不是数组的最大长度。</strong></p><p>那么必须扩大数组的长度，Java中的数组都是无法自动扩容的，我们采用的方法是用一个更大的数组代替这个小的数组。就好比以前用的事小桶装水，现在小桶装不下了，使用一个更大的桶。</p><ul><li>JDK1.8融入了红黑树的机制，比较复杂，这里我们<strong>先介绍 JDK1.7的扩容源码</strong>，便于理解，然后在介绍JDK1.8的源码。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数 newCapacity 为新数组的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">        Entry[] oldTable = table;<span class="comment">//引用扩容前的 Entry 数组</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;<span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;<span class="comment">///修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];<span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">        transfer(newTable, initHashSeedAsNeeded(newCapacity));<span class="comment">//将数组元素转移到新数组里面</span></span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);<span class="comment">//修改阈值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;<span class="comment">//遍历数组</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                    e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);<span class="comment">//重新计算每个元素在数组中的索引位置</span></span><br><span class="line">                e.next = newTable[i];<span class="comment">//标记下一个元素，添加是链表头添加</span></span><br><span class="line">                newTable[i] = e;<span class="comment">//将元素放在链上</span></span><br><span class="line">                e = next;<span class="comment">//访问下一个 Entry 链上的元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过方法我们可以看到，JDK1.7中首先是创建一个新的大容量的数组，然后依次重新计算原集合所有元素的索引，然后重新赋值。</p><p>如果数组某个位置产生了<strong>hash冲突，使用的是单链表的头插入方式，同一个位置的新元素总是放在链表的头部，这样与原集合链表对比，扩容之后的可能就是倒序的链表了。</strong></p><p><strong>下面我们在看看JDK1.8的。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment"> * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment"> * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment"> * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment"> * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 原数组如果为null，则长度赋值0</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果原数组长度大于0</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组大小如果已经大于等于最大值(2^30)</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 原数组长度大于等于初始化长度16，并且原数组长度扩大1倍也小于2^30次方</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 阈值扩大一倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 旧阈值大于0，则将新容量直接等于旧的阈值 </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 阈值等于0，oldCap也等于0（集合未进行初始化）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 数组长度初始化为16</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        <span class="comment">// 阈值等于16*0.75 = 12 </span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新阈值的上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果原数组不为空</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 元数据j位置变为null,便于垃圾回收</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 数组没有下一个引用（不是链表）</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 红黑树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该访问分为两部分，首先是计算新桶数组的容量newCap和新阈值newThr，然后将原集合的元素重新映射到新集合中。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200420/205101975.png" alt="mark"></p><p>相比较于JDK1.7,  JDK1.8使用的是2次幂扩展（指长度扩展为原来的两倍）。所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。</p><p>在扩充HashMap的时候，不需要像JDK1.7那样重新计算hash值，只需要看看原来的hash值新增的那个bit是1还是0就好了，如果是0的话索引不变，是1的话索引变成“原索引+oldCap”。</p><h2 id="9-删除元素"><a href="#9-删除元素" class="headerlink" title="9. 删除元素"></a>9. 删除元素</h2><p>HashMap删除元素首先是要找到桶的位置，然后如果是链表，则进行链表遍历。找到需要删除的元素后，进行删除。</p><p>如果是红黑树，也就是进行树的遍历，找到元素删除后，进行平衡调节。需要注意的是，当红黑树的节点小于6的时候，会自动转换成链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the mapping for the specified key from this map if present.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  key key whose mapping is to be removed from the map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment"> *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.remove and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to match if matchValue, else ignored</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matchValue if true only remove if value is equal</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> movable if false do not move other nodes while removing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash找到桶的位置</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 如果键的值与链表的第一个节点相等，则将node指向该节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="comment">// 如果桶节点存在下一个节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//找到需要删除的红黑树节点</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 是链表的话，遍历链表，找到待删除的节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除节点，并进行调节红黑树平衡</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">// 红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">// 链表</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意第 46 行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afterNodeRemoval(node);</span><br></pre></td></tr></table></figure><p>这也是为实现 LinkedHashMap 做准备的，<strong>在这里和上面一样，是一个空方法实现</strong>，可以不用管。而在 LinkedHashMap 中进行了重写，用来维护删除节点后，链表的前后关系。</p><h2 id="10-查找元素"><a href="#10-查找元素" class="headerlink" title="10. 查找元素"></a>10. 查找元素</h2><p>①、通过 key 查找 value</p><p>首先通过key找到计算索引，找到桶位置。</p><p>先检查第一个节点，如果是则返回，如果不是，则遍历其后面的链表或者红黑树。其余情况全部返回null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.get and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据key计算的索引  检查第一个索引</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 不是第一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历树进行查找</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 遍历链表进行查找</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②、判断是否存在给定的 key 或者 value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the</span></span><br><span class="line"><span class="comment">    * specified key.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   key   The key whose presence in this map is to be tested</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified</span></span><br><span class="line"><span class="comment">    * key.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据key来吵着</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span></span><br><span class="line"><span class="comment">    * specified value.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value value whose presence in this map is to be tested</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span></span><br><span class="line"><span class="comment">    *         specified value</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">       <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//   遍历桶</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">               <span class="comment">//  遍历桶的每个节点的元素</span></span><br><span class="line">               <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                       (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="11-遍历元素"><a href="#11-遍历元素" class="headerlink" title="11. 遍历元素"></a>11. 遍历元素</h2><p>首先构造一个 HashMap 集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"A"</span>,<span class="string">"1"</span>);</span><br><span class="line">map.put(<span class="string">"B"</span>,<span class="string">"2"</span>);</span><br><span class="line">map.put(<span class="string">"C"</span>,<span class="string">"3"</span>);</span><br></pre></td></tr></table></figure><p>①、分别获取 key 集合和 value 集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、分别获取key和value的集合</span></span><br><span class="line"><span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(Object value : map.values())&#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②、获取 key 集合，然后遍历key集合，根据key分别得到相应value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 获取key集合，然后遍历key集合，根据key分别得到相应的value</span></span><br><span class="line">Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line"><span class="keyword">for</span> (Object str : keySet) &#123;</span><br><span class="line">    System.out.println(str + <span class="string">"-&gt;"</span> + map.get(str));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③、<strong>得到 Entry 集合，然后遍历 Entry</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 得到Entry集合，然后遍历Entry</span></span><br><span class="line">Set&lt;Map.Entry&lt;String, Object&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : entrySet) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">"--&gt;"</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>④、迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4. 迭代</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    Map.Entry&lt;String, Object&gt; mapEntry = iterator.next();</span><br><span class="line">    System.out.println(mapEntry.getKey()+ <span class="string">"--&gt;"</span> + mapEntry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基本上使用第三种方法的性能是最好的</strong></p><p>第一种遍历方法我们只需要key集合或者只需要value集合时候使用</p><p>第二种遍历方法效率太低，不用就行</p><p>第四种效率也还行，关键是在遍历的过程中我们可以对元素进行删除。</p><h2 id="12-总结"><a href="#12-总结" class="headerlink" title="12. 总结"></a>12. 总结</h2><p><strong>Java7 HashMap的问题：</strong></p><ol><li><p>并发环境下的死锁</p></li><li><p>可以通过精心构造的恶意请求引发Dos攻击</p></li></ol><p>HashMap总结：</p><p>①、基于JDK1.8的HashMap是由数组+链表+红黑树组成，当链表长度超过 8 时会自动转换成红黑树，当红黑树节点个数小于 6 时，又会转化成链表。相对于早期版本的 JDK HashMap 实现，新增了红黑树作为底层数据结构，在数据量较大且哈希碰撞较多时，能够极大的增加检索的效率。</p><p>②、允许 key 和 value 都为 null。key 重复会被覆盖，value 允许重复。</p><p>③、非线程安全</p><p>④、无序（遍历HashMap得到元素的顺序不是按照插入的顺序）</p><p>参考链接：</p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html#" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html#</a></p><p><a href="https://www.cnblogs.com/ysocean/p/8711071.html" target="_blank" rel="noopener">https://www.cnblogs.com/ysocean/p/8711071.html</a></p><p><a href="https://www.cnblogs.com/nullllun/p/8327664.html" target="_blank" rel="noopener">https://www.cnblogs.com/nullllun/p/8327664.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JDK1-8源码-08-java-util-HashMap&quot;&gt;&lt;a href=&quot;#JDK1-8源码-08-java-util-HashMap&quot; class=&quot;headerlink&quot; title=&quot;JDK1.8源码-08-java.util.HashMap&quot;&gt;&lt;/a&gt;JDK1.8源码-08-java.util.HashMap&lt;/h1&gt;&lt;p&gt;本篇来介绍在 JDK1.8 中 HashMap 的源码实现，这也是最常用的一个集合。但是在介绍 HashMap 之前，我们先介绍什么是 Hash表。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JDK源码分析" scheme="http://zhuuu.work/tags/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>JUC-14-JMM</title>
    <link href="http://zhuuu.work/2020/05/02/JUC/JUC-14-JMM/"/>
    <id>http://zhuuu.work/2020/05/02/JUC/JUC-14-JMM/</id>
    <published>2020-05-02T14:02:24.000Z</published>
    <updated>2020-06-29T02:24:38.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC-14-JMM"><a href="#JUC-14-JMM" class="headerlink" title="JUC-14-JMM"></a>JUC-14-JMM</h1><h2 id="1-JMM-简介"><a href="#1-JMM-简介" class="headerlink" title="1. JMM 简介"></a>1. JMM 简介</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200502/213345495.png" alt="mark"></p><ul><li><p>java内存模型（JMM）</p></li><li><p>JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在<strong>主内存</strong>（Main Memory）中，每个线程都有一个私有的<strong>本地内存</strong>（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p></li></ul><p>关于JMM的一些同步约定：</p><ul><li><p><strong>线程解锁前，必须把共享变量立刻刷回主内存</strong>。</p></li><li><p><strong>线程加锁前，必须读取主内存中最新的值到工作内存中</strong>。</p></li><li><p><strong>加锁和解锁是同一把锁。</strong></p></li></ul><a id="more"></a><h3 id="1-1-内存交互操作"><a href="#1-1-内存交互操作" class="headerlink" title="1.1 内存交互操作"></a>1.1 内存交互操作</h3><p> 　<strong>内存交互操作有8种，虚拟机实现必须保证每一个操作都是原子的，不可再分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外）</strong></p><ul><li><ul><li>lock   （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态</li><li>unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li><li>read  （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li>load   （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中</li><li>use   （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令</li><li>assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中</li><li>store  （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用</li><li>write 　（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中</li></ul></li></ul><h3 id="1-2-JMM对于内存操作的约定"><a href="#1-2-JMM对于内存操作的约定" class="headerlink" title="1.2 JMM对于内存操作的约定"></a>1.2 JMM对于内存操作的约定</h3><p><strong>JMM对这八种指令的使用，制定了如下规则：</strong></p><ul><li><ul><li>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write</li><li>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存</li><li>不允许一个线程将没有assign的数据从工作内存同步回主内存</li><li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作</li><li>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁</li><li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值</li><li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量</li><li>对一个变量进行unlock操作之前，必须把此变量同步回主内存</li></ul></li></ul><h2 id="2-Volatile-关键字"><a href="#2-Volatile-关键字" class="headerlink" title="2. Volatile 关键字"></a>2. Volatile 关键字</h2><ul><li>Volatile是Java虚拟机提供的<strong>轻量级的同步机制</strong><ul><li><strong>保证可见性</strong></li><li><strong>不保证原子性</strong></li><li><strong>禁止指令重排</strong></li></ul></li></ul><h3 id="2-1-保证可见性"><a href="#2-1-保证可见性" class="headerlink" title="2.1 保证可见性"></a>2.1 保证可见性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 主内存中的num = 0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">// main线程</span></span><br><span class="line">        <span class="comment">// 不加volatile 这个线程就会死循环</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (num == <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将工作内存修改num = 1</span></span><br><span class="line">        num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-不保证原子性"><a href="#2-2-不保证原子性" class="headerlink" title="2.2 不保证原子性"></a>2.2 不保证原子性</h3><ul><li>原子性：不可分割</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// volatile 不保证原子性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 理论上num应该是20000</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 停止条件</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt;<span class="number">2</span> )&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里出现的根本原因是：<code>num++; 不是一个原子性的操作</code></p><p><strong>解决方案：如果不加lock和synchronized，怎么保证原子性？</strong></p><ul><li><strong>使用原子类来进行原子性操作（java.util.concurrent.atomic）</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200502/215340342.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> AtomicInteger num = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        num++; // 运算不是一个原子性操作</span></span><br><span class="line">        num.getAndIncrement(); <span class="comment">// AtomicInteger + 1的方法:原理CAS操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 理论上num应该是20000</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 停止条件</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt;<span class="number">2</span> )&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Atomic的底层是Unsafe类，这里Unsafe类是一个很特殊的存在！！！</strong></p><h3 id="2-3-禁止指令重排"><a href="#2-3-禁止指令重排" class="headerlink" title="2.3 禁止指令重排"></a>2.3 禁止指令重排</h3><ol><li><strong>什么是指令重排？</strong></li></ol><p><strong>举例分析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;  <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">int</span> y = <span class="number">2</span>;<span class="comment">// 2</span></span><br><span class="line">x = x + <span class="number">5</span>;<span class="comment">// 3</span></span><br><span class="line">y = x * x;<span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">我们以前所理解的顺序是 <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">    但是计算机可能执行的顺序 <span class="number">1324</span> <span class="number">2134</span></span><br><span class="line">    但绝对不可能是 <span class="number">4123</span> 这样的</span><br></pre></td></tr></table></figure><table><thead><tr><th>线程A</th><th>线程B</th></tr></thead><tbody><tr><td>x = a</td><td>y = b</td></tr><tr><td>b = 1</td><td>a = 2</td></tr><tr><td></td><td></td></tr></tbody></table><p>还有一种情况如上所示：</p><ul><li>如果a b x y默认值都是0的前提下</li><li>正常结果是 x = 0 ; y = 0</li></ul><p>变成如下情况：</p><table><thead><tr><th>线程A</th><th>线程B</th></tr></thead><tbody><tr><td>b = 1</td><td>a = 2</td></tr><tr><td>x = a</td><td>y = b</td></tr></tbody></table><p><strong>由于指令重排：</strong></p><ul><li>可能出现 x = 2 , y = 1的诡异结果</li></ul><p><strong>解决方案：volatile可以避免指令重排</strong></p><ul><li><strong>原理：内存屏障</strong><ul><li>保证特定的操作执行顺序</li><li>可以保证某些变量的可见性</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200503/210747591.png" alt="mark"></p><h2 id="3-单例模式详解"><a href="#3-单例模式详解" class="headerlink" title="3. 单例模式详解"></a>3. 单例模式详解</h2><p><strong>禁止指令重排最主要用在单例模式上：</strong></p><h2 id="4-深入理解CAS"><a href="#4-深入理解CAS" class="headerlink" title="4. 深入理解CAS"></a>4. 深入理解CAS</h2><h3 id="4-1-底层原理"><a href="#4-1-底层原理" class="headerlink" title="4.1 底层原理"></a>4.1 底层原理</h3><p>CAS是如下的简称</p><ul><li><p><strong>compareAndSet</strong></p></li><li><p><strong>比较并交换</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically sets the value to the given updated value</span></span><br><span class="line"><span class="comment"> * if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that</span></span><br><span class="line"><span class="comment"> * the actual value was not equal to the expected value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点进AtomicInteger源码来看一看：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200504/193357107.png" alt="mark"></p><ul><li><strong>AtomicInteger 继承了 unsafe类</strong></li><li><strong>unsafe类的作用：Java操作内存</strong></li></ul><p>接下来我们来看看AtomicInteger的一个方法：getAndIncrement</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getAndIncrement ，原子类的自增操作（相当于++操作）</span></span><br><span class="line">atomicInteger.getAndIncrement();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是一个自旋锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// var1 要获取的对象</span></span><br><span class="line">        <span class="comment">// var2 要获取对象的内存地址偏移量</span></span><br><span class="line">        <span class="comment">// var5 获取的对象的内存地址偏移量</span></span><br><span class="line">        <span class="comment">// var4 = 1 ，相当于var5 + 1</span></span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结：</strong></p><ul><li>CAS：比较并交换（比较当前工作内存中的值和主内存中的值），如果这个值是期望的，那么则执行，否则不执行操作。</li><li>缺点：<ol><li>循环会耗时</li><li>一次性只能保证一个共享变量的原子性</li><li>存在ABA问题</li></ol></li></ul><h3 id="4-2-CAS的ABA的问题"><a href="#4-2-CAS的ABA的问题" class="headerlink" title="4.2 CAS的ABA的问题"></a>4.2 CAS的ABA的问题</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200504/194803494.png" alt="mark"></p><p>举一个例子：</p><p>如上图所示：两个线程拿到A=1，右边的线程先拿到了A=1,并且把1改成了3，再把3改成了1。但是左边的线程毫不知情，虽然左边的线程拿到了1，但不是原来的1了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">2020</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于平时写的sql来说：乐观锁！</span></span><br><span class="line">    atomicInteger.compareAndSet(<span class="number">2020</span>,<span class="number">2021</span>);</span><br><span class="line">    System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line">    atomicInteger.compareAndSet(<span class="number">2021</span>,<span class="number">2020</span>);</span><br><span class="line">    System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    atomicInteger.compareAndSet(<span class="number">2020</span>,<span class="number">6666</span>);</span><br><span class="line">    System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    atomicInteger.getAndIncrement();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果解决ABA的问题呢？</strong></p><p><strong>答：使用原子引用</strong></p><h3 id="4-3-原子引用"><a href="#4-3-原子引用" class="headerlink" title="4.3 原子引用"></a>4.3 原子引用</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200504/195442008.png" alt="mark"></p><p>原子引用：带版本号的原子操作(解决ABA问题)</p><p>对应思想：乐观锁。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        AtomicInteger atomicInteger = new AtomicInteger(2020);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// AtomicStampedReference需要注意的是</span></span><br><span class="line">        <span class="comment">// 如果泛型是包装类，注意对象的引用问题</span></span><br><span class="line">        AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// A线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">// 获得版本号</span></span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(<span class="string">"A+"</span>+stamp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 版本号+1  类似于乐观锁操作</span></span><br><span class="line">            System.out.println(atomicStampedReference.compareAndSet(</span><br><span class="line">                    <span class="number">1</span>,</span><br><span class="line">                    <span class="number">2</span>,</span><br><span class="line">                    atomicStampedReference.getStamp(),</span><br><span class="line">                    atomicStampedReference.getStamp() + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印A2的版本号</span></span><br><span class="line">            System.out.println(<span class="string">"A2+"</span>+atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修改回去</span></span><br><span class="line">            System.out.println(atomicStampedReference.compareAndSet(</span><br><span class="line">                    <span class="number">2</span>,</span><br><span class="line">                    <span class="number">1</span>,</span><br><span class="line">                    atomicStampedReference.getStamp(),</span><br><span class="line">                    atomicStampedReference.getStamp() + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"A3+"</span>+atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">// 获得版本号</span></span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(<span class="string">"B+"</span>+stamp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(atomicStampedReference.compareAndSet(</span><br><span class="line">                    <span class="number">1</span>,</span><br><span class="line">                    <span class="number">6</span>,</span><br><span class="line">                    atomicStampedReference.getStamp(),</span><br><span class="line">                    atomicStampedReference.getStamp() + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"B2+"</span>+atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5-各种锁的理解"><a href="#5-各种锁的理解" class="headerlink" title="5. 各种锁的理解"></a>5. 各种锁的理解</h2><h3 id="5-1-公平锁-非公平锁"><a href="#5-1-公平锁-非公平锁" class="headerlink" title="5.1 公平锁/非公平锁"></a>5.1 公平锁/非公平锁</h3><ul><li>公平锁：不能插队，必须先来后到。</li><li>非公平锁：可以插队，大家竞争。</li></ul><p><strong>默认：Synchronized和lock都是非公平锁</strong></p><h3 id="5-2-可重入锁"><a href="#5-2-可重入锁" class="headerlink" title="5.2 可重入锁"></a>5.2 可重入锁</h3><p>可重入锁：拿到外面的锁就能拿到里面的锁（自动获得）</p><ol><li>synchronized版本</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sms</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"sms"</span>);</span><br><span class="line">        call();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"call"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Asms</span><br><span class="line">Acall</span><br><span class="line">Bsms</span><br><span class="line">Bcall</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 原理：执行完最里面的锁才释放这把锁（锁中有锁）</span></span><br></pre></td></tr></table></figure><ol start="2"><li>lock版本</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReinLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">sms</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">// 与Synchronized不同的是，这里是两把锁</span></span><br><span class="line">        <span class="comment">// 还有要注意的是锁必须配对</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"sms"</span>);</span><br><span class="line">            call();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"call"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-自旋锁"><a href="#5-3-自旋锁" class="headerlink" title="5.3 自旋锁"></a>5.3 自旋锁</h3><ol><li>自己编写的锁</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 自旋锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">spinLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Thread 默认是null</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"进入了mylock"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自旋锁</span></span><br><span class="line">        <span class="keyword">while</span> (atomicReference.compareAndSet(<span class="keyword">null</span>,thread))&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myUnLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"进入了myUnlock"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        atomicReference.compareAndSet(thread,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>测试类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpinLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        reentrantLock.unlock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己的锁:用CAS实现</span></span><br><span class="line">        spinLock lock = <span class="keyword">new</span> spinLock();</span><br><span class="line">        lock.myLock();</span><br><span class="line">        lock.myUnLock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            lock.myLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.myUnLock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">            lock.myLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.myUnLock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="string">"t2"</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1进入了mylock</span><br><span class="line">t2进入了mylock</span><br><span class="line">t1进入了myUnlock</span><br><span class="line">t2进入了myUnlock</span><br></pre></td></tr></table></figure><ul><li>这里t1和t2都拿到了锁</li><li>只有等t1释放锁之后，t2才能释放锁</li></ul><h3 id="5-4-死锁"><a href="#5-4-死锁" class="headerlink" title="5.4 死锁"></a>5.4 死锁</h3><ol><li>死锁是什么？</li></ol><ul><li>两个线程互相竞争对方的资源</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200504/213522266.png" alt="mark"></p><ol start="2"><li>如何分析排除死锁？</li></ol><ul><li>先来看一个死锁的例子</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mythread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lockA;</span><br><span class="line">    <span class="keyword">private</span> String lockB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mythread</span><span class="params">(String lockA, String lockB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockA = lockA;</span><br><span class="line">        <span class="keyword">this</span>.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"lock"</span>+lockA);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"lock"</span>+lockB);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeadLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String lockA = <span class="string">"lockA"</span>;</span><br><span class="line">        String lockB = <span class="string">"lockB"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Mythread(lockA,lockB),<span class="string">"T1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Mythread(lockB,lockA),<span class="string">"T2"</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>那么如何解决这个问题？</li></ul><ol><li>使用jps定位进程号    <code>jps -l</code></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200504/214427255.png" alt="mark"></p><ol start="2"><li><code>jstack</code> 进程号 找到死锁问题</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200504/214644171.png" alt="mark"></p><p>注意：面试中遇到问题如何排查？？</p><ul><li><strong>日志</strong></li><li><strong>看一下堆栈信息</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JUC-14-JMM&quot;&gt;&lt;a href=&quot;#JUC-14-JMM&quot; class=&quot;headerlink&quot; title=&quot;JUC-14-JMM&quot;&gt;&lt;/a&gt;JUC-14-JMM&lt;/h1&gt;&lt;h2 id=&quot;1-JMM-简介&quot;&gt;&lt;a href=&quot;#1-JMM-简介&quot; class=&quot;headerlink&quot; title=&quot;1. JMM 简介&quot;&gt;&lt;/a&gt;1. JMM 简介&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200502/213345495.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;java内存模型（JMM）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在&lt;strong&gt;主内存&lt;/strong&gt;（Main Memory）中，每个线程都有一个私有的&lt;strong&gt;本地内存&lt;/strong&gt;（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于JMM的一些同步约定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;线程解锁前，必须把共享变量立刻刷回主内存&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;线程加锁前，必须读取主内存中最新的值到工作内存中&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;加锁和解锁是同一把锁。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="JUC" scheme="http://zhuuu.work/tags/JUC/"/>
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="JMM" scheme="http://zhuuu.work/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>JUC-13-异步回调</title>
    <link href="http://zhuuu.work/2020/05/02/JUC/JUC-13-%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83/"/>
    <id>http://zhuuu.work/2020/05/02/JUC/JUC-13-%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83/</id>
    <published>2020-05-02T14:02:24.000Z</published>
    <updated>2020-05-02T13:29:43.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC-13-异步回调"><a href="#JUC-13-异步回调" class="headerlink" title="JUC-13-异步回调"></a>JUC-13-异步回调</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><ol><li>Future</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200502/202835824.png" alt="mark"></p><ol start="2"><li>CompletableFuture&lt; T &gt;</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200502/202905660.png" alt="mark"></p><a id="more"></a><h2 id="2-实际使用"><a href="#2-实际使用" class="headerlink" title="2. 实际使用"></a>2. 实际使用</h2><ol><li>没有返回值的runAsync异步回调</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 没有返回值的runAsync异步回调</span></span><br><span class="line">CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 阻塞两秒，模拟ajax</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"runASync-&gt;void"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"waiting"</span>);</span><br><span class="line">completableFuture.get() ; <span class="comment">// 阻塞获取执行结果</span></span><br></pre></td></tr></table></figure><ol start="2"><li>有返回值的异步回调</li></ol><ul><li>分别有成功的回调和失败的回调</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 有返回值的异步回调</span></span><br><span class="line"><span class="comment">// 分别有成功的回调和失败的回调</span></span><br><span class="line">CompletableFuture&lt;Integer&gt; CF = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1024</span>;  <span class="comment">// 成功返回1024</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(CF.whenComplete((t, u) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"t="</span> + t); <span class="comment">// 正常的返回结果</span></span><br><span class="line">    System.out.println(<span class="string">"u="</span> + u); <span class="comment">// 如果有错，返回错误的信息</span></span><br><span class="line">&#125;).exceptionally((e) -&gt; &#123;</span><br><span class="line">    System.out.println(e.getMessage());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">233</span>; <span class="comment">// 失败返回233</span></span><br><span class="line">&#125;).get());</span><br></pre></td></tr></table></figure><p>底层源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> asyncSupplyStage(asyncPool, supplier);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">asyncSupplyStage</span><span class="params">(Executor e,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     Supplier&lt;U&gt; f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        CompletableFuture&lt;U&gt; d = <span class="keyword">new</span> CompletableFuture&lt;U&gt;();</span><br><span class="line">        e.execute(<span class="keyword">new</span> AsyncSupply&lt;U&gt;(d, f));</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenComplete</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uniWhenCompleteStage(<span class="keyword">null</span>, action);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BiConsumer</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs this operation on the given arguments.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the first input argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> u the second input argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JUC-13-异步回调&quot;&gt;&lt;a href=&quot;#JUC-13-异步回调&quot; class=&quot;headerlink&quot; title=&quot;JUC-13-异步回调&quot;&gt;&lt;/a&gt;JUC-13-异步回调&lt;/h1&gt;&lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Future&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200502/202835824.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;CompletableFuture&amp;lt; T &amp;gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200502/202905660.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JUC" scheme="http://zhuuu.work/tags/JUC/"/>
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JUC-12-forkJoin</title>
    <link href="http://zhuuu.work/2020/05/02/JUC/JUC-12-forkJoin/"/>
    <id>http://zhuuu.work/2020/05/02/JUC/JUC-12-forkJoin/</id>
    <published>2020-05-02T13:02:24.000Z</published>
    <updated>2020-05-02T12:00:15.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC-12-forkJoin"><a href="#JUC-12-forkJoin" class="headerlink" title="JUC-12-forkJoin"></a>JUC-12-forkJoin</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>在JDK1.7中出现，用于并行执行效率。<strong>(必须要在大数据量中使用forkJoin)</strong></p><p><strong>本质：分而治之</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200502/193417077.png" alt="mark"></p><a id="more"></a><h2 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h2><ul><li>工作窃取</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200502/192516795.png" alt="mark"></p><h2 id="3-具体使用"><a href="#3-具体使用" class="headerlink" title="3. 具体使用"></a>3. 具体使用</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200502/193547361.png" alt="mark"></p><ul><li><strong>RecursiveAction:没有返回值</strong></li><li><strong>RecursiveTask：有返回值</strong></li></ul><p>现在有一个需求：需要计算0到十亿的和！</p><p>（以下有三种方式去求解）</p><ol><li>单纯for循环求和（直接被开除）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10_0000_0000</span>; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> end  = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"执行了"</span> + (end-start) + <span class="string">"时间"</span>+<span class="string">",sum是"</span>+sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用forkJoin(可以调节切分的点)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用forkJoin必须要new 一个 forkJoinPool</span></span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    Test test = <span class="keyword">new</span> Test(<span class="number">0L</span>, <span class="number">10_0000_0000L</span>);</span><br><span class="line">    <span class="comment">// 提交任务</span></span><br><span class="line">    ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(test);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取结果</span></span><br><span class="line">    Long sum = submit.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> end   = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"执行了"</span> + (end-start) + <span class="string">"时间"</span> + sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 如何使用forkJoin</span></span><br><span class="line"><span class="comment">// 1. forkjoinPool 通过它来执行</span></span><br><span class="line"><span class="comment">// 2. 计算任务 execute(ForkJoinTask&lt;?&gt; task)</span></span><br><span class="line"><span class="comment">// 3. 类要继承：extends RecursiveTask&lt;&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long start;</span><br><span class="line">    <span class="keyword">private</span> Long end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临界值</span></span><br><span class="line">    <span class="keyword">private</span> Long temp = <span class="number">10000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(Long start, Long end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((end-start) &lt; temp)&#123;</span><br><span class="line">            Long sum = <span class="number">0l</span>;</span><br><span class="line">            <span class="keyword">for</span> (Long i = start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 分支合并计算 forkJoin</span></span><br><span class="line">            <span class="keyword">long</span> mid = (start + end)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 拆分任务，同时压入队列</span></span><br><span class="line">            Test test1 = <span class="keyword">new</span> Test(start, mid);</span><br><span class="line">            test1.fork();</span><br><span class="line">            Test test2 = <span class="keyword">new</span> Test(mid + <span class="number">1</span>, end);</span><br><span class="line">            test2.fork();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取子结果</span></span><br><span class="line">            <span class="keyword">return</span> test1.join() + test2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>使用Stream流计算（建议去读一下源码）</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// Stream并行流</span></span><br><span class="line">    <span class="comment">// rangeClosed (]</span></span><br><span class="line">    <span class="keyword">long</span> sum = LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">10_0000_0000L</span>).parallel().reduce(<span class="number">0</span>, Long::sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> end   = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"执行了"</span> + (end-start) + <span class="string">"时间"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JUC-12-forkJoin&quot;&gt;&lt;a href=&quot;#JUC-12-forkJoin&quot; class=&quot;headerlink&quot; title=&quot;JUC-12-forkJoin&quot;&gt;&lt;/a&gt;JUC-12-forkJoin&lt;/h1&gt;&lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h2&gt;&lt;p&gt;在JDK1.7中出现，用于并行执行效率。&lt;strong&gt;(必须要在大数据量中使用forkJoin)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本质：分而治之&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200502/193417077.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JUC" scheme="http://zhuuu.work/tags/JUC/"/>
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-160-相交链表</title>
    <link href="http://zhuuu.work/2020/05/02/Leetcode/Leetcode-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <id>http://zhuuu.work/2020/05/02/Leetcode/Leetcode-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</id>
    <published>2020-05-02T07:52:53.000Z</published>
    <updated>2020-05-03T05:17:02.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-160-Intersection-of-Two-Linked-Lists"><a href="#Leecode-160-Intersection-of-Two-Linked-Lists" class="headerlink" title="Leecode-160-Intersection of Two Linked Lists"></a>Leecode-160-<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">Intersection of Two Linked Lists</a></h1><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>编写一个程序，找到两个单链表相交的起始节点。</p><p>如下图所示：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200503/115044756.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200503/115058836.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">listA &#x3D; [4,1,8,4,5]</span><br><span class="line">listB &#x3D; [5,0,1,8,4,5]</span><br><span class="line"></span><br><span class="line">输出：Reference of the node with value &#x3D; 8</span><br></pre></td></tr></table></figure><p>不相交如下：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200503/121418279.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">listA &#x3D; [2,6,4]</span><br><span class="line">listB &#x3D; [1,5]</span><br><span class="line"></span><br><span class="line">输出：null</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Solution：</strong></p><ul><li>思路：如果两个链表相交，那么相交点之后的长度是相同的<strong>（让两个链表走过相同的路程）（消除两个链表的长度差）</strong></li></ul><pre><code>// 1. 如果pA先到达末尾，则pA = headB 继续从头遍历// 2. 如果pB先到达末尾，则pB = headA 继续从头遍历</code></pre><ol><li>初始化pA和pB</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200503/124126914.png" alt="mark"></p><ol start="2"><li>依次遍历</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200503/131056974.png" alt="mark"></p><ol start="3"><li>pB到达末尾，指向链表A的头部，此时A和B长度差是B的长度3</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200503/131139718.png" alt="mark"></p><ol start="4"><li>pA到达末尾，移动到B链表的头部</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200503/131208178.png" alt="mark"></p><ol start="5"><li>这是pA和pB到达最后null的长度就是一样的了</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200503/131252174.png" alt="mark"></p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><strong>Solution :</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 特判</span></span><br><span class="line">    <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 初始化：指针pA指向A链表，指针pB指向B链表</span></span><br><span class="line">    ListNode pA = headA, pB = headB;</span><br><span class="line">    <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">    <span class="comment">// 1. 如果pA先到达末尾，则pA = headB 继续从头遍历</span></span><br><span class="line">    <span class="comment">// 2. 如果pB先到达末尾，则pB = headA 继续从头遍历</span></span><br><span class="line">        pA = pA == <span class="keyword">null</span> ? headB : pA.next;</span><br><span class="line">        pB = pB == <span class="keyword">null</span> ? headA : pB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 相交部分即使pA也是pB</span></span><br><span class="line">    <span class="keyword">return</span> pA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>换一种解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">若相交，链表A： a+c, 链表B : b+c. a+c+b+c &#x3D; b+c+a+c 。则会在公共处c起点相遇。若不相交，a +b &#x3D; b+a 。因此相遇处是NULL</span><br></pre></td></tr></table></figure><ul><li><p>时间复杂度：O(n)    遍历链表即可</p></li><li><p>空间复杂度：O(1)    不需要额外的空间</p></li></ul><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><strong>Solution :</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-160-Intersection-of-Two-Linked-Lists&quot;&gt;&lt;a href=&quot;#Leecode-160-Intersection-of-Two-Linked-Lists&quot; class=&quot;headerlink&quot; title=&quot;Leecode-160-Intersection of Two Linked Lists&quot;&gt;&lt;/a&gt;Leecode-160-&lt;a href=&quot;https://leetcode-cn.com/problems/intersection-of-two-linked-lists/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Intersection of Two Linked Lists&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：&quot;&gt;&lt;a href=&quot;#思路：&quot; class=&quot;headerlink&quot; title=&quot;思路：&quot;&gt;&lt;/a&gt;思路：&lt;/h2&gt;&lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;p&gt;编写一个程序，找到两个单链表相交的起始节点。&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200503/115044756.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200503/115058836.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;listA &amp;#x3D; [4,1,8,4,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;listB &amp;#x3D; [5,0,1,8,4,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：Reference of the node with value &amp;#x3D; 8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;不相交如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200503/121418279.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;listA &amp;#x3D; [2,6,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;listB &amp;#x3D; [1,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：null&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-412-FizzBuzz</title>
    <link href="http://zhuuu.work/2020/05/02/Leetcode/Leetcode-412-FizzBuzz/"/>
    <id>http://zhuuu.work/2020/05/02/Leetcode/Leetcode-412-FizzBuzz/</id>
    <published>2020-05-02T03:52:53.000Z</published>
    <updated>2020-05-02T03:53:59.446Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-412-Fizz-Buzz"><a href="#Leecode-412-Fizz-Buzz" class="headerlink" title="Leecode-412-Fizz Buzz"></a>Leecode-412-<a href="https://leetcode-cn.com/problems/fizz-buzz/" target="_blank" rel="noopener">Fizz Buzz</a></h1><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>写一个程序，输出从 1 到 n 数字的字符串表示。</p><ol><li><p>如果 n 是3的倍数，输出“Fizz”；</p></li><li><p>如果 n 是5的倍数，输出“Buzz”；</p></li><li><p>如果 n 同时是3和5的倍数，输出 “FizzBuzz”。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 15,</span><br><span class="line"></span><br><span class="line">返回:</span><br><span class="line">[</span><br><span class="line">    &quot;1&quot;,</span><br><span class="line">    &quot;2&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;4&quot;,</span><br><span class="line">    &quot;Buzz&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;7&quot;,</span><br><span class="line">    &quot;8&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;Buzz&quot;,</span><br><span class="line">    &quot;11&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;13&quot;,</span><br><span class="line">    &quot;14&quot;,</span><br><span class="line">    &quot;FizzBuzz&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Solution：字符串拼接</strong></p><ul><li><pre><code>如果是3的倍数，输出fizz<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>5的倍数如果当前元素是空的话，即5的倍数，输出buzz如果当前元素不为空的话，即3和5的公倍数，输出fizzBuzz<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>如果不是3的倍数也不是5的倍数，输出当前数字<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Java</span><br><span class="line"></span><br><span class="line">**Solution :**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">class Solution&#123;</span><br><span class="line">    public List&lt;String&gt; fizzBuzz(int n)&#123;</span><br><span class="line">        &#x2F;&#x2F; 输入是0，返回空数组</span><br><span class="line">        if (n &lt;&#x3D; 0)&#123;</span><br><span class="line">            return new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] resultArr &#x3D; new String[n];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; i从第三个元素开始，如果是3的倍数，输出fizz</span><br><span class="line">        for (int i &#x3D; 2;i &lt; n;i +&#x3D; 3)&#123;</span><br><span class="line">            resultArr[i] &#x3D; &quot;Fizz&quot;;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; i从第五个元素开始</span><br><span class="line">        &#x2F;&#x2F; 如果当前元素是空的话，即5的倍数，输出buzz</span><br><span class="line">        &#x2F;&#x2F; 如果当前元素不为空的话，即3和5的公倍数，输出fizzBuzz</span><br><span class="line">        for (int i &#x3D; 4;i &lt; n;i +&#x3D;5)&#123;</span><br><span class="line">            if(resultArr[i]!&#x3D;null)&#123;</span><br><span class="line">                resultArr[i] &#x3D; &quot;FizzBuzz&quot;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                resultArr[i] &#x3D; &quot;Buzz&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果不是3的倍数也不是5的倍数，输出当前数字</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (resultArr[i] &#x3D;&#x3D; null)&#123;</span><br><span class="line">                resultArr[i] &#x3D; String.valueOf(i+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return Arrays.asList(resultArr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><p>测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">    System.out.println(solution.fizzBuzz(<span class="number">15</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度:  O(1) 不需要额外空间</li></ul><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><strong>Solution :</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-412-Fizz-Buzz&quot;&gt;&lt;a href=&quot;#Leecode-412-Fizz-Buzz&quot; class=&quot;headerlink&quot; title=&quot;Leecode-412-Fizz Buzz&quot;&gt;&lt;/a&gt;Leecode-412-&lt;a href=&quot;https://leetcode-cn.com/problems/fizz-buzz/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Fizz Buzz&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：&quot;&gt;&lt;a href=&quot;#思路：&quot; class=&quot;headerlink&quot; title=&quot;思路：&quot;&gt;&lt;/a&gt;思路：&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;写一个程序，输出从 1 到 n 数字的字符串表示。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果 n 是3的倍数，输出“Fizz”；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果 n 是5的倍数，输出“Buzz”；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果 n 同时是3和5的倍数，输出 “FizzBuzz”。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：n &amp;#x3D; 15,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;返回:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;1&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;2&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;Fizz&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;4&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;Buzz&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;Fizz&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;7&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;8&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;Fizz&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;Buzz&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;11&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;Fizz&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;13&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;14&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;FizzBuzz&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>IO-03-字节输入输出流</title>
    <link href="http://zhuuu.work/2020/05/02/FileIO/IO-03-%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/"/>
    <id>http://zhuuu.work/2020/05/02/FileIO/IO-03-%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/</id>
    <published>2020-05-02T03:38:38.000Z</published>
    <updated>2020-05-12T00:56:39.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO-字节输入输出流"><a href="#IO-字节输入输出流" class="headerlink" title="IO-字节输入输出流"></a>IO-字节输入输出流</h1><p>本篇主要讲的是<strong>字节输入输出流</strong>：</p><ul><li><strong>InputStream</strong></li><li><strong>OutputSteam</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200503/174316077.png" alt="mark"></p><a id="more"></a><h2 id="1-OutputStream"><a href="#1-OutputStream" class="headerlink" title="1. OutputStream"></a>1. OutputStream</h2><p><strong>字节输出流：OutputStream</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span>, <span class="title">Flushable</span></span></span><br></pre></td></tr></table></figure><p>这个抽象类是表示字节输出流的所有类的超类。</p><p>输出流接收输出字节并将其发送到某个接收器。</p><p>方法摘要：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200503/174658094.png" alt="mark"></p><p>下面我们用 字节输出流 OutputStream 的典型实现 FileOutputStream来介绍：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建目标对象，输出流表示把数据保存到那个文件。</span></span><br><span class="line">    <span class="comment">// 不写盘符的话，默认保存到该项目的根目录下</span></span><br><span class="line">    File target = <span class="keyword">new</span> File(<span class="string">"io"</span> + File.separator + <span class="string">"a.txt"</span>);</span><br><span class="line">    System.out.println(target.getAbsolutePath());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建文件的字节输出流对象</span></span><br><span class="line">    <span class="comment">// 第二个参数是boolean类型</span></span><br><span class="line">    <span class="comment">// true 表示后面写入的文件追加到数据后面</span></span><br><span class="line">    <span class="comment">// false 表示覆盖</span></span><br><span class="line">    OutputStream out = <span class="keyword">new</span> FileOutputStream(target, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 具体的io操作</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * void write(int b):把一个字节写入到文件中</span></span><br><span class="line"><span class="comment">     * void write(byte[] b):把数组b 中的所有字节写入到文件中</span></span><br><span class="line"><span class="comment">     * void write(byte[] b,int off,int len):把数组b 中的从 off 索引开始的 len 个字节写入到文件中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    out.write(<span class="number">65</span>); <span class="comment">// 将字符A写到文件中</span></span><br><span class="line">    out.write(<span class="string">"Aa"</span>.getBytes()); <span class="comment">//将 Aa 写入到文件中</span></span><br><span class="line">    out.write(<span class="string">"ABCDEFG"</span>.getBytes(),<span class="number">1</span>,<span class="number">5</span>); <span class="comment">//将 BCDEF 写入到文件中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 经过上面的操作，a.txt中的数据应该变成了AAaBCDEF</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 关闭流资源</span></span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IO-字节输入输出流&quot;&gt;&lt;a href=&quot;#IO-字节输入输出流&quot; class=&quot;headerlink&quot; title=&quot;IO-字节输入输出流&quot;&gt;&lt;/a&gt;IO-字节输入输出流&lt;/h1&gt;&lt;p&gt;本篇主要讲的是&lt;strong&gt;字节输入输出流&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;InputStream&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OutputSteam&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200503/174316077.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-050-pow(x,n)</title>
    <link href="http://zhuuu.work/2020/05/02/Leetcode/Leetcode-050-pow(x,n)/"/>
    <id>http://zhuuu.work/2020/05/02/Leetcode/Leetcode-050-pow(x,n)/</id>
    <published>2020-05-02T03:22:53.000Z</published>
    <updated>2020-05-18T09:55:19.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-050-Pow-x-n"><a href="#Leecode-050-Pow-x-n" class="headerlink" title="Leecode-050-Pow(x, n)"></a>Leecode-050-<a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">Pow(x, n)</a></h1><h2 id="思路：快速幂"><a href="#思路：快速幂" class="headerlink" title="思路：快速幂"></a>思路：快速幂</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.00000, 10</span><br><span class="line">Output: 1024.00000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: 2.10000, 3</span><br><span class="line">Output: 9.26100</span><br><span class="line"></span><br><span class="line">// 负数的情况</span><br><span class="line">Input: 2.00000, -2</span><br><span class="line">Output: 0.25000</span><br><span class="line">Explanation: 2-2 = 1/22 = 1/4 = 0.25</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Solution1：快速幂+递归</strong></p><ul><li>「快速幂算法」的本质是分治算法</li></ul><ul><li><p>举个例子，如果我们要计算 x^64，我们可以按照：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200518/173117908.png" alt="mark"></p><p>从 x 开始，每次直接把上一次的结果进行平方，计算 6 次就可以得到 x^64 的值</p></li></ul><ul><li>再比如我们要计算 x^77，我们可以按照</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200518/173226688.png" alt="mark"></p><p>在这些步骤中，除了直接把上一次的结果进行平方，还要再结果进行平方后，额外乘一个x。</p><p><strong>直接从左到右进行推导看上去很困难，因为在每一步中，我们不知道在将上一次的结果平方之后，还需不需要额外乘 <em>x</em>。但如果我们从右往左看，分治的思想就十分明显了：</strong></p><p>算法总结如下：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200518/173939728.png" alt="mark"></p><p><strong>Solution2 : 快速幂+迭代</strong></p><p>由于递归需要使用额外的栈空间，我们试着将递归转写为迭代。</p><p><strong>我们还是以 x^77 作为例子</strong></p><ul><li><strong>贡献计算</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200518/175119612.png" alt="mark"></p><ul><li>二进制转换</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200518/175152450.png" alt="mark"></p><ul><li>因此我们借助整数的二进制拆分，就可以得到迭代计算的方法，一般地，如果整数 n 的二进制拆分为</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200518/175229622.png" alt="mark"></p><ul><li>总结：</li></ul><ol><li><p>从x开始不断平方，得到<img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200518/175309553.png" alt="mark"></p></li><li><p>如果n的第k个（从右往左，从 0 开始计数）二进制位是1，那么就将对应的贡献<img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200518/175354819.png" alt="mark">计入答案</p></li></ol><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><strong>Solution : 快速幂+递归</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">qucikMul</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">long</span> N)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果指数是N=0</span></span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分而治之</span></span><br><span class="line">        <span class="keyword">double</span> y = qucikMul(x,N/<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// N奇数偶数判断</span></span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span>? y*y : y*y*x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 把n转换成long类型</span></span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span>? qucikMul(x,N) : <span class="number">1.0</span>/qucikMul(x,-N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O（logn） n 是递归的层数</li><li>空间复杂度：O（logn） n 是递归的层数，递归自动使用栈空间</li></ul><p><strong>Solution : 快速幂+迭代</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">long</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 贡献的初始值为 x</span></span><br><span class="line">        <span class="keyword">double</span> x_contribute = x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在对N进行二进制拆分的同时计算答案</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (N%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 如果N二进制表示的最低位是1，要计入贡献</span></span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将贡献不断的平方</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            <span class="comment">// 舍弃N二进制表示的最低位，</span></span><br><span class="line">            <span class="comment">// 这样我们每次只要判断最低位是不是1即可</span></span><br><span class="line">            N/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N&gt;<span class="number">0</span>? quickMul(x,N) : <span class="number">1.0</span>/quickMul(x,-N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(logn) 对数字n进行二进制拆分的时间复杂度</li><li><strong>空间复杂度</strong>：O(1)</li></ul><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><strong>Solution :</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-050-Pow-x-n&quot;&gt;&lt;a href=&quot;#Leecode-050-Pow-x-n&quot; class=&quot;headerlink&quot; title=&quot;Leecode-050-Pow(x, n)&quot;&gt;&lt;/a&gt;Leecode-050-&lt;a href=&quot;https://leetcode-cn.com/problems/powx-n/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pow(x, n)&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：快速幂&quot;&gt;&lt;a href=&quot;#思路：快速幂&quot; class=&quot;headerlink&quot; title=&quot;思路：快速幂&quot;&gt;&lt;/a&gt;思路：快速幂&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: 2.00000, 10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 1024.00000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: 2.10000, 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 9.26100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 负数的情况&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: 2.00000, -2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 0.25000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: 2-2 = 1/22 = 1/4 = 0.25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="快速幂算法" scheme="http://zhuuu.work/tags/%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-213-打家劫舍II</title>
    <link href="http://zhuuu.work/2020/05/01/Leetcode/Leetcode-213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII/"/>
    <id>http://zhuuu.work/2020/05/01/Leetcode/Leetcode-213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII/</id>
    <published>2020-05-01T07:52:53.000Z</published>
    <updated>2020-05-01T07:45:07.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-213-House-Robber-II"><a href="#Leecode-213-House-Robber-II" class="headerlink" title="Leecode-213-House Robber II"></a>Leecode-213-<a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">House Robber II</a></h1><h2 id="思路：动态规划"><a href="#思路：动态规划" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h2><p>题目描述：</p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure><a id="more"></a><p>这里在Leetcode198打家劫舍的基础上进行了条件追加：</p><p><strong>本质上：其实就是分成两个问题</strong></p><ul><li>在不偷窃第一个房子的情况下，求出最大可以抢的金额p1</li><li>在不偷窃最后一间房子的情况下，求出最大可以抢的金额p2</li><li>比较p1和p2。取最大值</li></ul><p><strong>Solution：动态规划</strong></p><ul><li><p>思路：<strong>环状排列</strong>意味着<strong>第一个房子和最后一个房子</strong>中只能选出一个进行偷窃</p></li><li><p>状态定义：设动态规划列表 dp ，dp[i] 代表前 i个房子在满足条件下的能偷窃到的最高金额。</p></li><li><p>初始状态</p><pre><code>dp[0] = 0;dp[1] = nums[0];</code></pre></li><li><p>状态转移方程：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] &#x3D; Math.max(dp[i-1], dp[i-2] + nums[i-1]);</span><br></pre></td></tr></table></figure><ul><li>返回值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回dp数组的最后一个元素即为结果</span><br><span class="line">return dp[len];</span><br><span class="line">return dp[-1];</span><br></pre></td></tr></table></figure><ul><li>最终返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分割成两个子问题</span></span><br><span class="line"><span class="comment">// 1. 最后一家不偷情况下的金额</span></span><br><span class="line"><span class="comment">// 2. 第一家不偷情况下的金额</span></span><br><span class="line"><span class="comment">// 3. 取最大值</span></span><br><span class="line"><span class="keyword">return</span> Math.max(</span><br><span class="line">    rob_helper(Arrays.copyOfRange(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>))  <span class="comment">// nums[0,n-1]</span></span><br><span class="line">    ,rob_helper(Arrays.copyOfRange(nums,<span class="number">1</span>,nums.length)));  <span class="comment">// nums[1,n]</span></span><br></pre></td></tr></table></figure><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><strong>Solution :</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob_helper</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp数组的长度是nums数组的长度加1</span></span><br><span class="line">        <span class="comment">// 因为dp[0] = 0</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp数组初始化</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>] + nums[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回dp数组的最后一个元素即为结果</span></span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(rob_helper(Arrays.copyOfRange(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>)),rob_helper(Arrays.copyOfRange(nums,<span class="number">1</span>,nums.length)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">    System.out.println(solution.rob(nums));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)，遍历一次nums需要的时间。</li><li>空间复杂度：O(n)，需要额外的dp数组的空间。</li></ul><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><strong>Solution :</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-213-House-Robber-II&quot;&gt;&lt;a href=&quot;#Leecode-213-House-Robber-II&quot; class=&quot;headerlink&quot; title=&quot;Leecode-213-House Robber II&quot;&gt;&lt;/a&gt;Leecode-213-&lt;a href=&quot;https://leetcode-cn.com/problems/house-robber-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;House Robber II&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：动态规划&quot;&gt;&lt;a href=&quot;#思路：动态规划&quot; class=&quot;headerlink&quot; title=&quot;思路：动态规划&quot;&gt;&lt;/a&gt;思路：动态规划&lt;/h2&gt;&lt;p&gt;题目描述：&lt;/p&gt;
&lt;p&gt;你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [2,3,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 你不能先偷窃 1 号房屋（金额 &amp;#x3D; 2），然后偷窃 3 号房屋（金额 &amp;#x3D; 2）, 因为他们是相邻的。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,2,3,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 你可以先偷窃 1 号房屋（金额 &amp;#x3D; 1），然后偷窃 3 号房屋（金额 &amp;#x3D; 3）。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     偷窃到的最高金额 &amp;#x3D; 1 + 3 &amp;#x3D; 4 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Spring-01-概述及IOC理论推导</title>
    <link href="http://zhuuu.work/2020/05/01/Spring/Spring-01-%E6%A6%82%E8%BF%B0%E5%8F%8AIOC%E7%90%86%E8%AE%BA%E6%8E%A8%E5%AF%BC/"/>
    <id>http://zhuuu.work/2020/05/01/Spring/Spring-01-%E6%A6%82%E8%BF%B0%E5%8F%8AIOC%E7%90%86%E8%AE%BA%E6%8E%A8%E5%AF%BC/</id>
    <published>2020-05-01T07:02:24.000Z</published>
    <updated>2020-05-09T10:06:24.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-01-概述及IOC理论推导"><a href="#Spring-01-概述及IOC理论推导" class="headerlink" title="Spring-01-概述及IOC理论推导"></a>Spring-01-概述及IOC理论推导</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200508/203155619.png" alt="mark"></p><p>2002年，Rod Jahnson首次推出了Spring框架雏形interface21框架。</p><p>2004年3月24日，<strong>Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版。</strong></p><p>很难想象Rod Johnson的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。</p><p>官网 : <a href="http://spring.io/" target="_blank" rel="noopener">http://spring.io/</a></p><p>官方下载地址 : <a href="https://repo.spring.io/libs-release-local/org/springframework/spring/" target="_blank" rel="noopener">https://repo.spring.io/libs-release-local/org/springframework/spring/</a></p><p>GitHub : <a href="https://github.com/spring-projects" target="_blank" rel="noopener">https://github.com/spring-projects</a></p><a id="more"></a><p>优点：</p><ul><li><strong>控制反转IOC</strong></li><li><strong>面向切面编程AOP</strong></li><li>对事务的支持，对框架的支持</li><li>Spring是一个轻量级框架，非侵入式</li></ul><p><strong>一句话概括：</strong></p><p><strong>Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。</strong></p><h3 id="1-1-组成"><a href="#1-1-组成" class="headerlink" title="1.1 组成"></a>1.1 组成</h3><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200323110430.png" alt=""></p><p>Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 .</p><p>组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下：</p><ul><li><strong>核心容器</strong>：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是BeanFactory，它是工厂模式的实现。BeanFactory 使用<em>控制反转</em>（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</li><li><strong>Spring 上下文</strong>：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</li><li><strong>Spring AOP</strong>：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。</li><li><strong>Spring DAO</strong>：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li><li><strong>Spring ORM</strong>：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li><li><strong>Spring Web 模块</strong>：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</li><li><strong>Spring MVC 框架</strong>：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</li></ul><h2 id="2-IOC理论推导"><a href="#2-IOC理论推导" class="headerlink" title="2. IOC理论推导"></a>2. IOC理论推导</h2><h3 id="2-1-推导"><a href="#2-1-推导" class="headerlink" title="2.1 推导"></a>2.1 推导</h3><p>考虑如下一种情形：</p><ol><li>UserDao.inteface</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>UserDaoImpl.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"获取用户数据"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>UserService.inteface</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>UserServiceImpl.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhuuu.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.zhuuu.dao.UserDaoImpl;</span><br><span class="line"><span class="keyword">import</span> com.zhuuu.dao.UserDaoMysqlImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">   UserService service = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">   service.getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>那么现在问题来了，如果用户想添加新的功能，那么我们只能从Service层Impl去修改代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> UserDao userDao = <span class="keyword">new</span> UserDaoMySqlImpl();</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       userDao.getUser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>假设如果我们还要新增一个功能的话，如</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoOracleImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Oracle获取数据"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>那么我们发现了一个很严重的问题，程序的耦合性太高了，牵一发而动全身。</li><li>假设我们的这种需求非常大 , 这种方式就根本不适用了</li></ul><p><strong>那么我们如何解决呢？</strong></p><h3 id="2-2-推导结果"><a href="#2-2-推导结果" class="headerlink" title="2.2 推导结果"></a>2.2 推导结果</h3><ul><li>我们可以在需要用到它的地方，不去实现它，而是留出一个接口</li><li>通过set方法区引用注入</li></ul><ol><li>修改过的UserServiceImpl.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"><span class="comment">//    private UserDao userDao = new UserDaoImpl();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 利用set实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>现在通过不一样的的方法去测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">   UserServiceImpl service = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">   service.setUserDao( <span class="keyword">new</span> UserDaoMySqlImpl() );</span><br><span class="line">   service.getUser();</span><br><span class="line">   <span class="comment">//那我们现在又想用Oracle去实现呢</span></span><br><span class="line">   service.setUserDao( <span class="keyword">new</span> UserDaoOracleImpl() );</span><br><span class="line">   service.getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：这里已经发生了根本性的变化</strong></p><ul><li><strong>以前所有的东西都是由程序去进行控制创建</strong></li><li><strong>而现在是由用户进行控制创建，把主动权交给了调用者，程序不要用管怎么创建对象。</strong></li><li><strong>这种思想 , 从本质上解决了问题 , 我们程序员不再去管理对象的创建了 , 更多的去关注业务的实现 . 耦合性大大降低 . 这也就是IOC的原型 !</strong></li></ul><h3 id="2-3-IOC本质"><a href="#2-3-IOC本质" class="headerlink" title="2.3 IOC本质"></a>2.3 IOC本质</h3><p><strong>控制反转IOC(Inversion Of Control)</strong></p><ul><li>一种设计思想，<strong>DI(依赖注入)是实现IoC的一种方法</strong>，也有人认为DI只是IoC的另一种说法</li><li>没有IoC的程序中 , 我们使用面向对象编程，对象的创建与对象间的依赖关系完全在硬编码的程序中</li><li>控制反转后将对象的创建交给第三方（可以说是获取依赖对象的方式反转了）</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200509/180313492.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200509/180325441.png" alt="mark"></p><p>以上就是IOC带来的改变。</p><p>同时，在Spring中：</p><ul><li><p><strong>IoC是Spring框架的核心内容</strong>，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。</p></li><li><p>Spring容器在初始化的时候先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再去从IOC容器中读取需要的对象。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200509/180605099.png" alt="mark"></p><p><strong>在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring-01-概述及IOC理论推导&quot;&gt;&lt;a href=&quot;#Spring-01-概述及IOC理论推导&quot; class=&quot;headerlink&quot; title=&quot;Spring-01-概述及IOC理论推导&quot;&gt;&lt;/a&gt;Spring-01-概述及IOC理论推导&lt;/h1&gt;&lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200508/203155619.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;2002年，Rod Jahnson首次推出了Spring框架雏形interface21框架。&lt;/p&gt;
&lt;p&gt;2004年3月24日，&lt;strong&gt;Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很难想象Rod Johnson的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。&lt;/p&gt;
&lt;p&gt;官网 : &lt;a href=&quot;http://spring.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://spring.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方下载地址 : &lt;a href=&quot;https://repo.spring.io/libs-release-local/org/springframework/spring/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://repo.spring.io/libs-release-local/org/springframework/spring/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GitHub : &lt;a href=&quot;https://github.com/spring-projects&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/spring-projects&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Spring" scheme="http://zhuuu.work/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>IO-02-流的分类</title>
    <link href="http://zhuuu.work/2020/05/01/FileIO/IO-02-%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB/"/>
    <id>http://zhuuu.work/2020/05/01/FileIO/IO-02-%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB/</id>
    <published>2020-05-01T06:38:38.000Z</published>
    <updated>2020-05-12T00:53:39.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO-流的分类"><a href="#IO-流的分类" class="headerlink" title="IO-流的分类"></a>IO-流的分类</h1><h2 id="1-输入流和输出流"><a href="#1-输入流和输出流" class="headerlink" title="1. 输入流和输出流"></a>1. 输入流和输出流</h2><ol><li>根据流向分为输入流和输出流</li></ol><p>注意输入流和输出流是相对于程序而言的。</p><ul><li>输出：把程序（内存）中的内容输出到磁盘等存储设备中。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200503/173003365.png" alt="mark"></p><ul><li>输入：读取外部数据（磁盘等存储设备）到程序（内存）中。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200503/173010277.png" alt="mark"></p><a id="more"></a><p>综合起来看：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200503/173123039.png" alt="mark"></p><h2 id="2-字节流和字符流"><a href="#2-字节流和字符流" class="headerlink" title="2. 字节流和字符流"></a>2. 字节流和字符流</h2><ol start="2"><li>根据传输单位分为字节流和字符流</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200503/173159639.png" alt="mark"></p><p><strong>上面的是Java IO流的四大基流。</strong></p><p><strong>这四大基流都是抽象类，其他流都是继承于这四大基流的。</strong></p><h2 id="3-节点流和包装流"><a href="#3-节点流和包装流" class="headerlink" title="3. 节点流和包装流"></a>3. 节点流和包装流</h2><p>节点流：可以从或向一个特定的地方（节点）读写数据。如FileReader.</p><p>处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader，处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p><strong>操作IO流的模板：</strong></p><ol><li>创建源或者目标对象<ul><li>输入：把文件中的数据流向到程序中，此时文件是 源，程序是目标</li><li>输出：把程序中的数据流向到文件中，此时文件是目标，程序是源</li></ul></li></ol><ol start="2"><li>创建IO流对象<ul><li>输入：创建输入流对象</li><li>输出：创建输出流对象</li></ul></li></ol><ol start="3"><li>具体的IO操作</li></ol><ol start="4"><li>关闭资源<ul><li>输入：输入流的 close()方法</li><li>输出：输出流的 close() 方法</li></ul></li></ol><p><strong>注意：</strong></p><ol><li>程序中打开的文件IO资源不属于内存里的资源，垃圾回收机制无法回收该资源。</li><li>如果不关闭这个资源，那么磁盘的文件将一直被程序引用着，那么文件即不能被删除也不能被修改。</li><li>所以应该手动关闭close()流资源。</li></ol><p>最后这是 Java IO 流的整体架构图，下面几篇博客将会详细讲解这些流：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200503/174049966.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IO-流的分类&quot;&gt;&lt;a href=&quot;#IO-流的分类&quot; class=&quot;headerlink&quot; title=&quot;IO-流的分类&quot;&gt;&lt;/a&gt;IO-流的分类&lt;/h1&gt;&lt;h2 id=&quot;1-输入流和输出流&quot;&gt;&lt;a href=&quot;#1-输入流和输出流&quot; class=&quot;headerlink&quot; title=&quot;1. 输入流和输出流&quot;&gt;&lt;/a&gt;1. 输入流和输出流&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;根据流向分为输入流和输出流&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意输入流和输出流是相对于程序而言的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输出：把程序（内存）中的内容输出到磁盘等存储设备中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200503/173003365.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入：读取外部数据（磁盘等存储设备）到程序（内存）中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200503/173010277.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-148</title>
    <link href="http://zhuuu.work/2020/05/01/Leetcode/Leetcode-148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://zhuuu.work/2020/05/01/Leetcode/Leetcode-148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2020-05-01T03:52:53.000Z</published>
    <updated>2020-05-01T03:36:48.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-148-Sort-List"><a href="#Leecode-148-Sort-List" class="headerlink" title="Leecode-148-Sort List"></a>Leecode-148-<a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">Sort List</a></h1><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p><strong>Solution：</strong></p><ul><li></li></ul><a id="more"></a><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><strong>Solution :</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><strong>Solution :</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-148-Sort-List&quot;&gt;&lt;a href=&quot;#Leecode-148-Sort-List&quot; class=&quot;headerlink&quot; title=&quot;Leecode-148-Sort List&quot;&gt;&lt;/a&gt;Leecode-148-&lt;a href=&quot;https://leetcode-cn.com/problems/sort-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sort List&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：&quot;&gt;&lt;a href=&quot;#思路：&quot; class=&quot;headerlink&quot; title=&quot;思路：&quot;&gt;&lt;/a&gt;思路：&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Solution：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>IO-01-File类</title>
    <link href="http://zhuuu.work/2020/05/01/FileIO/IO-01-File%E7%B1%BB/"/>
    <id>http://zhuuu.work/2020/05/01/FileIO/IO-01-File%E7%B1%BB/</id>
    <published>2020-05-01T03:38:38.000Z</published>
    <updated>2020-05-12T00:50:15.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO-File类"><a href="#IO-File类" class="headerlink" title="IO-File类"></a>IO-File类</h1><p><strong>File 类： 文件和目录路径名的抽象表示。</strong></p><p><strong>注意：File类只能操作文件的属性，文件的内容是不能操作的。</strong></p><a id="more"></a><h2 id="1-字段"><a href="#1-字段" class="headerlink" title="1. 字段"></a>1. 字段</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200503/162607006.png" alt="mark"></p><p>我们知道，各个平台之间的路径分隔符是不一样的。</p><ul><li>对于UNIX平台，绝对路径名的前缀始终是”/“。相对路径名没有前缀。表示跟目目录的抽象路径名具有前缀”/“和空名称序列。</li><li>对于Microsoft Windows平台，包含驱动器说明符的路径名的前缀由后面跟着<code>&quot;:&quot;</code>的驱动器号组成，如果路径名是绝对的，则可能后跟<code>&quot;\\&quot;</code> 。NC路径名的前缀为<code>&quot;\\\\&quot;</code> ; 主机名和共享名称是名称序列中的前两个名称。没有有指定驱动器的相对路径名没有前缀。</li></ul><p>那么为了屏蔽各个平台之间的分隔符差异，我们在构造File类的时候（如何构造，请看下面第二点），就可以使用上述Java为我们提供的字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(File.pathSeparator); <span class="comment">// 输出 ;</span></span><br><span class="line">System.out.println(File.separator);  <span class="comment">// 输出 \</span></span><br></pre></td></tr></table></figure><ul><li><strong>File.pathSeparator : 用来分割连续多个路径字符串的分隔符</strong></li><li><strong>File.separator: 用来分割同一个路径字符串中的目录</strong></li></ul><h2 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2. 构造方法"></a>2. 构造方法</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200503/163225396.png" alt="mark"></p><p>如何使用上述构造方法，请看如下例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不使用 Java 提供的分隔符字段，注意：这样写只能在 Windows 平台有效</span></span><br><span class="line">        File f1 = <span class="keyword">new</span> File(<span class="string">"D:\\IO\\a.txt"</span>);</span><br><span class="line">        <span class="comment">//使用 Java 提供的分隔符</span></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"D:"</span>+File.separator+<span class="string">"IO"</span>+File.separator+<span class="string">"a.txt"</span>);</span><br><span class="line">        System.out.println(f1);<span class="comment">//输出 D:\IO\a.txt  </span></span><br><span class="line">        System.out.println(f2);<span class="comment">//输出 D:\IO\a.txt</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//File(File parent, String child)</span></span><br><span class="line">        <span class="comment">//从父抽象路径名和子路径名字符串创建新的 File实例。</span></span><br><span class="line">        File f3 = <span class="keyword">new</span> File(<span class="string">"D:"</span>);</span><br><span class="line">        File f4 = <span class="keyword">new</span> File(f3,<span class="string">"IO"</span>);</span><br><span class="line">        System.out.println(f4); <span class="comment">//D:\IO</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//File(String pathname)</span></span><br><span class="line">        <span class="comment">//通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。</span></span><br><span class="line">        File f5 = <span class="keyword">new</span> File(<span class="string">"D:"</span>+File.separator+<span class="string">"IO"</span>+File.separator+<span class="string">"a.txt"</span>);</span><br><span class="line">        System.out.println(f5); <span class="comment">//D:\IO\a.txt</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//File(String parent, String child)</span></span><br><span class="line">        <span class="comment">//从父路径名字符串和子路径名字符串创建新的 File实例。</span></span><br><span class="line">        File f6 = <span class="keyword">new</span> File(<span class="string">"D:"</span>,<span class="string">"IO\\a.txt"</span>);</span><br><span class="line">        System.out.println(f6); <span class="comment">//D:\IO\a.txt</span></span><br></pre></td></tr></table></figure><h2 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3. 常用方法"></a>3. 常用方法</h2><h3 id="3-1-创建方法"><a href="#3-1-创建方法" class="headerlink" title="3.1 创建方法"></a>3.1 创建方法</h3><ul><li>boolean createNewFile()  ： 不存在返回true,存在返回false。</li><li>boolean mkdir() 创建目录，如果上一级目录不存在，则会创建失败</li><li>boolean mkdirs() 创建多级目录，如果上一级目录不存在也会自动创建</li></ul><h3 id="3-2-删除方法"><a href="#3-2-删除方法" class="headerlink" title="3.2 删除方法"></a>3.2 删除方法</h3><ul><li>boolean delete() 删除文件或目录，如果表示目录，则目录下必须为空才能删除</li><li>boolean deleteOnExit() 文件使用完成后删除</li></ul><h3 id="3-3-判断方法"><a href="#3-3-判断方法" class="headerlink" title="3.3 判断方法"></a>3.3 判断方法</h3><ul><li>boolean canExecute()判断文件是否可执行</li><li>boolean canRead()判断文件是否可读</li><li>boolean canWrite() 判断文件是否可写</li><li>boolean exists() 判断文件或目录是否存在</li><li>boolean isDirectory()  判断此路径是否为一个目录</li><li>boolean isFile()　　判断是否为一个文件</li><li>boolean isHidden()　　判断是否为隐藏文件</li><li>boolean isAbsolute()判断是否是绝对路径 文件不存在也能判断</li></ul><h3 id="3-4-获取方法"><a href="#3-4-获取方法" class="headerlink" title="3.4 获取方法"></a>3.4 获取方法</h3><ul><li>String getName() 获取此路径表示的文件或目录名称</li><li>String getPath() 将此路径名转换为路径名字符串</li><li>String getAbsolutePath() 返回此抽象路径名的绝对形式</li><li>String getParent()//如果没有父目录返回null</li><li>long lastModified()//获取最后一次修改的时间</li><li>long length() 返回由此抽象路径名表示的文件的长度。</li><li>boolean renameTo(File f) 重命名由此抽象路径名表示的文件。</li><li>File[] liseRoots()//获取机器盘符</li><li>String[] list()  返回一个字符串数组，命名由此抽象路径名表示的目录中的文件和目录。</li><li>String[] list(FilenameFilter filter) 返回一个字符串数组，命名由此抽象路径名表示的目录中满足指定过滤器的文件和目录。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//File(File parent, String child)</span></span><br><span class="line">    <span class="comment">//从父抽象路径名和子路径名字符串创建新的 File实例。</span></span><br><span class="line">    File dir = <span class="keyword">new</span> File(<span class="string">"D:"</span> + File.separator + <span class="string">"IO"</span>);</span><br><span class="line">    File file = <span class="keyword">new</span> File(dir, <span class="string">"a.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断dir是否存在且表示一个目录</span></span><br><span class="line">    <span class="keyword">if</span> (!(dir.exists()||dir.isDirectory()))&#123;</span><br><span class="line">        <span class="comment">//如果 dir 不存在，则创建这个目录</span></span><br><span class="line">        dir.mkdirs();</span><br><span class="line">        <span class="comment">//根据目录和文件名，创建 a.txt文件</span></span><br><span class="line">        file.createNewFile();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回由此抽象路径名表示的文件或目录的名称。</span></span><br><span class="line">    <span class="comment">// 这只是路径名称序列中的最后一个名字。</span></span><br><span class="line">    <span class="comment">// 如果路径名的名称序列为空，则返回空字符串。</span></span><br><span class="line">    System.out.println(file.getName());  <span class="comment">// a.txt</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回此抽象路径名的父路径名字符串，</span></span><br><span class="line">    <span class="comment">// 如果此路径名未命名为父目录，则返回null。</span></span><br><span class="line">    System.out.println(file.getParent()); <span class="comment">// D:\IO</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将此抽象路径名转换为路径名字符串。</span></span><br><span class="line">    <span class="comment">// 结果字符串使用default name-separator character以名称顺序分隔名称。</span></span><br><span class="line">    System.out.println(file.getPath());  <span class="comment">// D:\IO\a.txt</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-File-类的小技巧"><a href="#4-File-类的小技巧" class="headerlink" title="4. File 类的小技巧"></a>4. File 类的小技巧</h2><ul><li><strong>打印给定目录下的所有文件夹和文件夹里面的内容</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getFileList</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 第一级子目录</span></span><br><span class="line">    File[] files = file.listFiles();</span><br><span class="line">    <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">        <span class="comment">// 打印目录和文件</span></span><br><span class="line">        System.out.println(f);</span><br><span class="line">        <span class="comment">// 递归打印目录和文件名</span></span><br><span class="line">        <span class="keyword">if</span> (f.isDirectory())&#123;</span><br><span class="line">            getFileList(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IO-File类&quot;&gt;&lt;a href=&quot;#IO-File类&quot; class=&quot;headerlink&quot; title=&quot;IO-File类&quot;&gt;&lt;/a&gt;IO-File类&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;File 类： 文件和目录路径名的抽象表示。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：File类只能操作文件的属性，文件的内容是不能操作的。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>JUC-11-Stream流式计算</title>
    <link href="http://zhuuu.work/2020/04/30/JUC/JUC-11-%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97/"/>
    <id>http://zhuuu.work/2020/04/30/JUC/JUC-11-%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97/</id>
    <published>2020-04-30T13:02:24.000Z</published>
    <updated>2020-05-01T13:44:22.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC-11-Stream流式计算"><a href="#JUC-11-Stream流式计算" class="headerlink" title="JUC-11-Stream流式计算"></a>JUC-11-Stream流式计算</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>大数据时代：存储+计算、</p><ul><li>存储：集合，Mysql</li><li><strong>真正的计算都应该交给流去操作。（流计算实际上是链式编程）</strong></li><li>java.util.Stream接口</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200430/214757235.png" alt="mark"></p><a id="more"></a><h2 id="2-实际使用"><a href="#2-实际使用" class="headerlink" title="2. 实际使用"></a>2. 实际使用</h2><ol><li>新建一个User.java类(导入lombook)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>实际测试流计算</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">"a"</span>,<span class="number">21</span>);</span><br><span class="line">        User u2 = <span class="keyword">new</span> User(<span class="number">2</span>,<span class="string">"b"</span>,<span class="number">22</span>);</span><br><span class="line">        User u3 = <span class="keyword">new</span> User(<span class="number">3</span>,<span class="string">"c"</span>,<span class="number">23</span>);</span><br><span class="line">        User u4 = <span class="keyword">new</span> User(<span class="number">4</span>,<span class="string">"d"</span>,<span class="number">24</span>);</span><br><span class="line">        User u5 = <span class="keyword">new</span> User(<span class="number">5</span>,<span class="string">"e"</span>,<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 集合用来存储</span></span><br><span class="line">        <span class="comment">// 流计算实际上是链式编程</span></span><br><span class="line">        List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算交给流</span></span><br><span class="line">        <span class="comment">// 1. 过滤id为偶数的参数</span></span><br><span class="line">        list.stream()</span><br><span class="line">                .filter(u-&gt;&#123;<span class="keyword">return</span> u.getId()%<span class="number">2</span>==<span class="number">0</span>;&#125;)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 年龄大于23岁</span></span><br><span class="line">        list.stream()</span><br><span class="line">                .filter(u-&gt;&#123;<span class="keyword">return</span> u.getAge()&gt;<span class="number">23</span>;&#125;)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3 . 用户名转换成大写</span></span><br><span class="line">        list.stream()</span><br><span class="line">                .filter(u-&gt;&#123;<span class="keyword">return</span> u.getAge()&gt;<span class="number">23</span>;&#125;)</span><br><span class="line">                .map(u-&gt;&#123;<span class="keyword">return</span> u.getName().toUpperCase();&#125;)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 用户名倒着排序</span></span><br><span class="line">        list.stream()</span><br><span class="line">                .filter(u-&gt;&#123;<span class="keyword">return</span> u.getAge()&gt;<span class="number">23</span>;&#125;)</span><br><span class="line">                .map(u-&gt;&#123;<span class="keyword">return</span> u.getName().toUpperCase();&#125;)</span><br><span class="line">                .sorted((uu1,uu2)-&gt;&#123;<span class="keyword">return</span> uu2.compareTo(uu1);&#125;)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 只输出一个用户</span></span><br><span class="line">        list.stream()</span><br><span class="line">                .filter(u-&gt;&#123;<span class="keyword">return</span> u.getAge()&gt;<span class="number">23</span>;&#125;)</span><br><span class="line">                .map(u-&gt;&#123;<span class="keyword">return</span> u.getName().toUpperCase();&#125;)</span><br><span class="line">                .sorted((uu1,uu2)-&gt;&#123;<span class="keyword">return</span> uu2.compareTo(uu1);&#125;)</span><br><span class="line">                .limit(<span class="number">1</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JUC-11-Stream流式计算&quot;&gt;&lt;a href=&quot;#JUC-11-Stream流式计算&quot; class=&quot;headerlink&quot; title=&quot;JUC-11-Stream流式计算&quot;&gt;&lt;/a&gt;JUC-11-Stream流式计算&lt;/h1&gt;&lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h2&gt;&lt;p&gt;大数据时代：存储+计算、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储：集合，Mysql&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;真正的计算都应该交给流去操作。（流计算实际上是链式编程）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;java.util.Stream接口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200430/214757235.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JUC" scheme="http://zhuuu.work/tags/JUC/"/>
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JUC-10-四大函数式接口</title>
    <link href="http://zhuuu.work/2020/04/30/JUC/JUC-10-%E5%9B%9B%E5%A4%A7%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
    <id>http://zhuuu.work/2020/04/30/JUC/JUC-10-%E5%9B%9B%E5%A4%A7%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/</id>
    <published>2020-04-30T12:02:24.000Z</published>
    <updated>2020-05-01T13:33:35.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC-10-四大函数式接口"><a href="#JUC-10-四大函数式接口" class="headerlink" title="JUC-10-四大函数式接口"></a>JUC-10-四大函数式接口</h1><p>新时代程序猿：jdk8</p><ul><li>lambada表达式</li><li>链式编程</li><li>函数式接口</li><li>Stream流计算</li></ul><a id="more"></a><h2 id="1-函数式接口简介"><a href="#1-函数式接口简介" class="headerlink" title="1. 函数式接口简介"></a>1. 函数式接口简介</h2><p>向runnable接口这种典型的是函数式接口</p><p><strong>@FunctionalInterface</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> * <span class="meta">@author</span>  Arthur van Hoff</span><br><span class="line"> * <span class="meta">@see</span>     java.lang.Thread</span><br><span class="line"> * <span class="meta">@see</span>     java.util.concurrent.Callable</span><br><span class="line"> * <span class="meta">@since</span>   JDK1<span class="number">.0</span></span><br><span class="line"> */</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object's</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化编程模型</span></span><br></pre></td></tr></table></figure><p>另外可以查询JDK帮助文档：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200430/205043028.png" alt="mark"></p><h2 id="2-Function-函数式接口"><a href="#2-Function-函数式接口" class="headerlink" title="2.Function 函数式接口"></a>2.Function 函数式接口</h2><p>java.util.Function源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 传入参数t，返回R类型</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br></pre></td></tr></table></figure><p>测试用例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数型接口：</span></span><br><span class="line"><span class="comment">有一个输入参数</span></span><br><span class="line"><span class="comment">有一个输出类型</span></span><br><span class="line"><span class="comment">可以用lambada表达式简化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 工具类</span></span><br><span class="line">        <span class="comment">// 输出输入的值</span></span><br><span class="line">        <span class="comment">// 方式一：</span></span><br><span class="line"><span class="comment">//        Function&lt;String,String&gt; function = new Function&lt;String,String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public String apply(String str) &#123;</span></span><br><span class="line"><span class="comment">//                return str;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式二</span></span><br><span class="line">        Function&lt;String,String&gt; function = (str)-&gt;&#123;<span class="keyword">return</span> str;&#125;;</span><br><span class="line">        System.out.println(function.apply(<span class="string">"asdasd"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Predicate-断定型接口"><a href="#3-Predicate-断定型接口" class="headerlink" title="3. Predicate 断定型接口"></a>3. Predicate 断定型接口</h2><p>底层源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Evaluates this predicate on the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the input argument matches the predicate,</span></span><br><span class="line"><span class="comment">     * otherwise &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br></pre></td></tr></table></figure><p>举例分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.Function;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">断定型接口：</span></span><br><span class="line"><span class="comment">有一个输入参数</span></span><br><span class="line"><span class="comment">返回值只能是布尔值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断字符串是否为空</span></span><br><span class="line">        <span class="comment">// 方式一：</span></span><br><span class="line"><span class="comment">//        Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public boolean test(String str) &#123;</span></span><br><span class="line"><span class="comment">//                return str.isEmpty();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"><span class="comment">//        System.out.println(predicate.test("123"));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式二：lambada表达式</span></span><br><span class="line">        Predicate&lt;String&gt; predicate = (str)-&gt;&#123;<span class="keyword">return</span> str.isEmpty();&#125;;</span><br><span class="line">        System.out.println(predicate.test(<span class="string">"123"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Consumer-消费型接口"><a href="#4-Consumer-消费型接口" class="headerlink" title="4.  Consumer 消费型接口"></a>4.  Consumer 消费型接口</h2><p>源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs this operation on the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 只有输入 没有返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br></pre></td></tr></table></figure><p>举例分析；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Consumer 消费型接口：只有输入，没有返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方式一：</span></span><br><span class="line"><span class="comment">//        Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void accept(String str) &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(str);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"><span class="comment">//        consumer.accept("asd");</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式二：</span></span><br><span class="line">        Consumer&lt;String&gt; consumer = (str)-&gt;&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;;</span><br><span class="line">        consumer.accept(<span class="string">"asd"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Supplier-供给型接口"><a href="#5-Supplier-供给型接口" class="headerlink" title="5. Supplier 供给型接口"></a>5. Supplier 供给型接口</h2><p>底层源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Supplier&lt;T&gt;:没有参数，只有返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方式一：</span></span><br><span class="line"><span class="comment">//        Supplier&lt;String&gt; supplier = new Supplier&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public String get() &#123;</span></span><br><span class="line"><span class="comment">//                return "朱酱酱";</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"><span class="comment">//        System.out.println(supplier.get());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式二：</span></span><br><span class="line">        Supplier&lt;String&gt; supplier = ()-&gt;&#123;<span class="keyword">return</span> <span class="string">"朱酱酱"</span>;&#125;;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JUC-10-四大函数式接口&quot;&gt;&lt;a href=&quot;#JUC-10-四大函数式接口&quot; class=&quot;headerlink&quot; title=&quot;JUC-10-四大函数式接口&quot;&gt;&lt;/a&gt;JUC-10-四大函数式接口&lt;/h1&gt;&lt;p&gt;新时代程序猿：jdk8&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lambada表达式&lt;/li&gt;
&lt;li&gt;链式编程&lt;/li&gt;
&lt;li&gt;函数式接口&lt;/li&gt;
&lt;li&gt;Stream流计算&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="JUC" scheme="http://zhuuu.work/tags/JUC/"/>
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JUC-09-线程池</title>
    <link href="http://zhuuu.work/2020/04/30/JUC/JUC-09-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://zhuuu.work/2020/04/30/JUC/JUC-09-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-04-30T11:02:24.000Z</published>
    <updated>2020-05-01T13:17:43.210Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC-09-线程池"><a href="#JUC-09-线程池" class="headerlink" title="JUC-09-线程池"></a>JUC-09-线程池</h1><h2 id="1-池化技术"><a href="#1-池化技术" class="headerlink" title="1. 池化技术"></a>1. 池化技术</h2><ul><li>线程池</li><li>内存池</li><li>连接池</li><li>对象池</li></ul><p>以上池化技术都是优化系统资源</p><p><strong>池化技术：事先准备好一些资源，有人要用，就来我这里拿，用来之后还给我。</strong></p><a id="more"></a><p>线程池的好处:</p><ul><li>降低系统的消耗</li><li>方便管理</li><li><strong>可以复用，控制最大并发数</strong></li></ul><p><strong>线程池：三大方法，七大参数，四种拒绝策略</strong></p><h2 id="2-三大方法"><a href="#2-三大方法" class="headerlink" title="2. 三大方法"></a>2. 三大方法</h2><p>三大方法简单使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executors 工具类 ：三大方法</span></span><br><span class="line"><span class="comment">// 使用线程池之后是使用线程池来创建线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        ExecutorService threadPool = Executors.newSingleThreadExecutor();// 单个线程</span></span><br><span class="line"><span class="comment">//        ExecutorService threadPool = Executors.newCachedThreadPool();// 可伸缩的</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);<span class="comment">// 创建一个固定的线程池</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 使用了线程池之后，使用线程池来创建对象</span></span><br><span class="line">                threadPool.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"线程"</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 线程池用完，程序结束，关闭线程池</span></span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-七大参数"><a href="#3-七大参数" class="headerlink" title="3. 七大参数"></a>3. 七大参数</h2><p>底层源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本质：以上方法开启了ThreadPoolExecutor</span></span><br><span class="line"><span class="comment">// 七大参数：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,  // 核心线程池大小</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,  // 最大线程池大小</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,// 超时了没有人用就会释放</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,// 超时单位</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue, // 阻塞队列</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,// 线程工厂</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler  // 拒绝策略</span></span></span><br><span class="line"><span class="function"><span class="params">                         )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> :</span><br><span class="line">    AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在阿里巴巴开发手册中有这样一段描述：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200430/200542806.png" alt="mark"></p><p>7大参数形象比喻：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200430/200843933.png" alt="mark"></p><h2 id="3-四种拒绝策略"><a href="#3-四种拒绝策略" class="headerlink" title="3. 四种拒绝策略"></a>3. 四种拒绝策略</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200430/201345285.png" alt="mark"></p><p>自定义线程池：</p><ol><li>abortPolicy:抛出异常</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义线程池</span></span><br><span class="line">        ThreadPoolExecutor threadPool_1 = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                <span class="number">5</span>,</span><br><span class="line">                <span class="number">3</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy() <span class="comment">// 银行满了，但是还有人进来，就不处理这个人的，抛出异常</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 最大承载：deque + max</span></span><br><span class="line">            <span class="comment">// 超出最大承载抛出异常：java.util.concurrent.RejectedExecutionException</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 使用了线程池之后，使用线程池来创建对象</span></span><br><span class="line">                threadPool_1.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"线程"</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 线程池用完，程序结束，关闭线程池</span></span><br><span class="line">            threadPool_1.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>CallerRunsPolicy()</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy() <span class="comment">// 哪里来的去哪里：打发走</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main线程 <span class="comment">// main线程去执行</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>线程</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>线程</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>线程</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>线程</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>线程</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>线程</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>线程</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>线程</span><br></pre></td></tr></table></figure><ol start="3"><li>DiscardPolicy()</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy() <span class="comment">// 队列满了，丢掉任务不会抛出异常</span></span><br></pre></td></tr></table></figure><ol start="4"><li>DiscardOldestPolicy()</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy() <span class="comment">// 队列满了，尝试和最早的线程竞争，竞争失败就还是抛弃任务</span></span><br></pre></td></tr></table></figure><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p><strong>最大线程池到底该如何定义？</strong></p><ul><li><strong>CPU  密集型</strong>  ： 几核CPU就是几条线程，保持CPU效率最高</li><li><strong>IO      密集型</strong>  :   判断程序中十分耗IO的线程有多少个，只要大于这个数就可以</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 获取CPU的核心数</span></span><br><span class="line">System.out.println(Runtime.getRuntime().availableProcessors());s</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JUC-09-线程池&quot;&gt;&lt;a href=&quot;#JUC-09-线程池&quot; class=&quot;headerlink&quot; title=&quot;JUC-09-线程池&quot;&gt;&lt;/a&gt;JUC-09-线程池&lt;/h1&gt;&lt;h2 id=&quot;1-池化技术&quot;&gt;&lt;a href=&quot;#1-池化技术&quot; class=&quot;headerlink&quot; title=&quot;1. 池化技术&quot;&gt;&lt;/a&gt;1. 池化技术&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;线程池&lt;/li&gt;
&lt;li&gt;内存池&lt;/li&gt;
&lt;li&gt;连接池&lt;/li&gt;
&lt;li&gt;对象池&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上池化技术都是优化系统资源&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;池化技术：事先准备好一些资源，有人要用，就来我这里拿，用来之后还给我。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JUC" scheme="http://zhuuu.work/tags/JUC/"/>
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-198-打家劫舍</title>
    <link href="http://zhuuu.work/2020/04/28/Leetcode/Leetcode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <id>http://zhuuu.work/2020/04/28/Leetcode/Leetcode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</id>
    <published>2020-04-28T07:52:53.000Z</published>
    <updated>2020-04-30T03:01:29.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-198-House-Robber"><a href="#Leecode-198-House-Robber" class="headerlink" title="Leecode-198-House Robber"></a>Leecode-198-<a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">House Robber</a></h1><h2 id="思路：动态规划"><a href="#思路：动态规划" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</strong></p><p>简而言之：就是只能抢不相邻的两间屋子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,7,9,3,1]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Solution：动态规划</strong></p><ul><li>动态规划的方程：<code>dp[n] = MAX(dp[n-1],dp[n-2]+num[n-1])</code></li><li>因为不相邻的房间不可以闯入，所以当前位置<code>n</code>房屋可盗窃的最大值，要么就是<code>n-1</code>房屋可盗取的最大值，要么就是<code>n-2</code>房屋可盗窃的最大值加上当前房屋的值，二者之间取最大值</li><li>举例来说：1 号房间可盗窃最大值为 3 即为 dp[1]=3，2 号房间可盗窃最大值为 4 即为 dp[2]=4，3 号房间自身的值为 2 即为 num=2，那么 dp[3] = MAX( dp[2], dp[1] + num ) = MAX(4, 3+2) = 5，3 号房间可盗窃最大值为 5。</li></ul><p>看一个例子：</p><ol><li><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200430/104027120.png" alt="mark"></p></li><li><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200430/104119834.png" alt="mark"></p></li><li><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200430/104128589.png" alt="mark"></p></li></ol><ol start="4"><li><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200430/104143692.png" alt="mark"></li></ol><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><strong>Solution :</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp数组的长度是nums数组的长度加1</span></span><br><span class="line">        <span class="comment">// 因为dp[0] = 0</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp数组初始化</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>] + nums[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(dp));</span><br><span class="line">        <span class="comment">// 返回dp数组的最后一个元素即为结果</span></span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">    System.out.println(solution.rob(nums));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：O(n) -&gt; 遍历了一遍数组</strong></p><p><strong>空间复杂度：O(n) - &gt;额外使用了一个dp[n+1]长度的数组</strong> </p><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><strong>Solution :</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-198-House-Robber&quot;&gt;&lt;a href=&quot;#Leecode-198-House-Robber&quot; class=&quot;headerlink&quot; title=&quot;Leecode-198-House Robber&quot;&gt;&lt;/a&gt;Leecode-198-&lt;a href=&quot;https://leetcode-cn.com/problems/house-robber/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;House Robber&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：动态规划&quot;&gt;&lt;a href=&quot;#思路：动态规划&quot; class=&quot;headerlink&quot; title=&quot;思路：动态规划&quot;&gt;&lt;/a&gt;思路：动态规划&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，&lt;strong&gt;如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简而言之：就是只能抢不相邻的两间屋子。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,2,3,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     偷窃到的最高金额 = 1 + 3 = 4 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [2,7,9,3,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 偷窃 1 号房屋 (金额 &amp;#x3D; 2), 偷窃 3 号房屋 (金额 &amp;#x3D; 9)，接着偷窃 5 号房屋 (金额 &amp;#x3D; 1)。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     偷窃到的最高金额 &amp;#x3D; 2 + 9 + 1 &amp;#x3D; 12 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://zhuuu.work/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>JUC-08-队列</title>
    <link href="http://zhuuu.work/2020/04/26/JUC/JUC-08-%E9%98%9F%E5%88%97/"/>
    <id>http://zhuuu.work/2020/04/26/JUC/JUC-08-%E9%98%9F%E5%88%97/</id>
    <published>2020-04-26T14:02:24.000Z</published>
    <updated>2020-05-01T13:04:20.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC-08-队列"><a href="#JUC-08-队列" class="headerlink" title="JUC-08-队列"></a>JUC-08-队列</h1><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200427/195357297.png" alt="mark"></p><ul><li>队列：先入先出的数据结构</li><li>阻塞：写入阻塞和读取阻塞</li></ul><a id="more"></a><h2 id="1-阻塞队列"><a href="#1-阻塞队列" class="headerlink" title="1. 阻塞队列"></a>1. 阻塞队列</h2><ul><li><strong>jdk文档中的介绍</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200427/195542465.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200427/195517585.png" alt="mark"></p><ul><li><strong>BlockingQueue(一般用于线程池)</strong></li></ul><ul><li><strong>Queue的家族结构如图所示</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200427/200347169.png" alt="mark"></p><h2 id="2-阻塞队列-四组API"><a href="#2-阻塞队列-四组API" class="headerlink" title="2. 阻塞队列 四组API"></a>2. 阻塞队列 四组API</h2><ul><li>抛出异常</li><li>不会抛出异常</li><li>阻塞等待</li><li>超时等待</li></ul><table><thead><tr><th>方式</th><th>抛出异常</th><th>有返回值,不抛出异常</th><th>阻塞等待</th><th>超时等待</th></tr></thead><tbody><tr><td>添加</td><td>add()</td><td>offer()</td><td>put()</td><td>offer(“加入的内容”,seconds,TimeUnit.Seconds)</td></tr><tr><td>移除</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(seconds,TimeUnit.Seconds)</td></tr><tr><td>判断队列首</td><td>element()</td><td>peek()</td><td>-</td><td>-</td></tr></tbody></table><p><strong>1. 抛出异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBq</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        抛出异常</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        test1();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 队列的大小</span></span><br><span class="line">        ArrayBlockingQueue blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"a"</span>));</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"b"</span>));</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"c"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        // 抛出异常java.lang.IllegalStateException: Queue full</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.add("d"));</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"==============="</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除操作</span></span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列为空之后 报错 java.util.NoSuchElementException</span></span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 不抛出异常,有返回值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ArrayBlockingQueue blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.offer(<span class="string">"a"</span>));</span><br><span class="line">    System.out.println(blockingQueue.offer(<span class="string">"b"</span>));</span><br><span class="line">    System.out.println(blockingQueue.offer(<span class="string">"c"</span>));</span><br><span class="line">    System.out.println(blockingQueue.offer(<span class="string">"d"</span>)); <span class="comment">// 不抛出异常</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"==============="</span>);</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll());  <span class="comment">// null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不抛出异常</span></span><br><span class="line">    test2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 一直阻塞</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 等待阻塞</span></span><br><span class="line">    ArrayBlockingQueue blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 一直阻塞</span></span><br><span class="line">    blockingQueue.put(<span class="string">"a"</span>);</span><br><span class="line">    blockingQueue.put(<span class="string">"b"</span>);</span><br><span class="line">    blockingQueue.put(<span class="string">"c"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列没有位置，一直等待</span></span><br><span class="line">    blockingQueue.put(<span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"==============="</span>);</span><br><span class="line">    System.out.println(blockingQueue.take());</span><br><span class="line">    System.out.println(blockingQueue.take());</span><br><span class="line">    System.out.println(blockingQueue.take());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一直阻塞</span></span><br><span class="line">    test3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 超时退出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//超时等待</span></span><br><span class="line">    ArrayBlockingQueue blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    blockingQueue.offer(<span class="string">"a"</span>);</span><br><span class="line">    blockingQueue.offer(<span class="string">"b"</span>);</span><br><span class="line">    blockingQueue.offer(<span class="string">"c"</span>);</span><br><span class="line">    blockingQueue.offer(<span class="string">"d"</span>, <span class="number">2</span>,TimeUnit.SECONDS); <span class="comment">// 如果加d，只能2秒，超时就退出</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"==============="</span>);</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll(<span class="number">2</span>, TimeUnit.SECONDS));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//超时等待</span></span><br><span class="line">    test4();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-同步队列"><a href="#3-同步队列" class="headerlink" title="3. 同步队列"></a>3. 同步队列</h2><ul><li><p>阻塞队列：进去一个元素，必须等待取出来之后</p></li><li><p>同步队列：拿一个取一个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同步队列:和其他的阻塞队列是不一样的，</span><br><span class="line">SynchronousQueue是不存储元素的，</span><br><span class="line">只要put了一个元素，必须先take出来，否则不能继续put值</span><br></pre></td></tr></table></figure></li></ul><p>举例描述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronizedQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;(); <span class="comment">// 同步队列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一个线程在put</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"put 1"</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">"1"</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"put 2"</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">"1"</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"put 3"</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">"1"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一个线程在take</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"get "</span>+blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"get "</span>+blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"get "</span>+blockingQueue.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JUC-08-队列&quot;&gt;&lt;a href=&quot;#JUC-08-队列&quot; class=&quot;headerlink&quot; title=&quot;JUC-08-队列&quot;&gt;&lt;/a&gt;JUC-08-队列&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200427/195357297.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;队列：先入先出的数据结构&lt;/li&gt;
&lt;li&gt;阻塞：写入阻塞和读取阻塞&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="JUC" scheme="http://zhuuu.work/tags/JUC/"/>
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JUC-07-读写锁</title>
    <link href="http://zhuuu.work/2020/04/25/JUC/JUC-07-%E8%AF%BB%E5%86%99%E9%94%81/"/>
    <id>http://zhuuu.work/2020/04/25/JUC/JUC-07-%E8%AF%BB%E5%86%99%E9%94%81/</id>
    <published>2020-04-25T14:02:24.000Z</published>
    <updated>2020-04-27T11:50:24.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC-07-读写锁"><a href="#JUC-07-读写锁" class="headerlink" title="JUC-07-读写锁"></a>JUC-07-读写锁</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200424/212424251.png" alt="mark"></p><p><strong>读：可以被多个线程同时读</strong></p><p><strong>写：只能有一个线程去写</strong></p><a id="more"></a><h2 id="2-代码测试"><a href="#2-代码测试" class="headerlink" title="2. 代码测试"></a>2. 代码测试</h2><h3 id="2-1-未加锁"><a href="#2-1-未加锁" class="headerlink" title="2.1 未加锁"></a>2.1 未加锁</h3><ol><li>自定义缓存</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存 ： 写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"写入"</span>+key);</span><br><span class="line">        map.put(key,value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"写入OK"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取 : 写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"读取"</span>+key);</span><br><span class="line">        Object o = map.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"读取OK"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>多线程操作缓存</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    自定义缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                myCache.put(temp+<span class="string">""</span>,temp+<span class="string">""</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                myCache.get(temp+<span class="string">""</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况是有问题的：会有同时写入存在的情况</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200427/193954901.png" alt="mark"></p><h3 id="2-2-加锁"><a href="#2-2-加锁" class="headerlink" title="2.2 加锁"></a>2.2 加锁</h3><p>加入一把读写锁</p><ol><li>自定义缓存</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache2</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    <span class="comment">// 读写锁：更加细粒度的控制</span></span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存 ： 写（只希望一个线程 去写）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 写锁</span></span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"写入"</span>+key);</span><br><span class="line">            map.put(key,value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"写入OK"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取 : 写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读锁</span></span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"读取"</span>+key);</span><br><span class="line">            Object o = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"读取OK"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>多线程操作缓存</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    自定义缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCache2 myCache2 = <span class="keyword">new</span> MyCache2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                myCache2.put(temp+<span class="string">""</span>,temp+<span class="string">""</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                myCache2.get(temp+<span class="string">""</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：问题解决！！！</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200427/194718232.png" alt="mark"></p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><ul><li>读-读：可以共存</li><li>读-写： 不能共存</li><li>写-写： 不能共存</li></ul><p>独占锁：一次只能被一个线程占有（写锁）</p><p>共享锁：多个线程可以同时占有（读锁）</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JUC-07-读写锁&quot;&gt;&lt;a href=&quot;#JUC-07-读写锁&quot; class=&quot;headerlink&quot; title=&quot;JUC-07-读写锁&quot;&gt;&lt;/a&gt;JUC-07-读写锁&lt;/h1&gt;&lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200424/212424251.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读：可以被多个线程同时读&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写：只能有一个线程去写&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JUC" scheme="http://zhuuu.work/tags/JUC/"/>
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
