<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>朱酱酱的学习博客</title>
  <icon>https://www.gravatar.com/avatar/336d255f627c733c7a50883547bcec06</icon>
  <subtitle>From Zero to Hero</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhuuu.work/"/>
  <updated>2020-12-16T08:34:44.575Z</updated>
  <id>http://zhuuu.work/</id>
  
  <author>
    <name>Zhuuu</name>
    <email>353446503@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode-290-单词规律</title>
    <link href="http://zhuuu.work/2020/12/16/Leetcode/Leetcode-290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/"/>
    <id>http://zhuuu.work/2020/12/16/Leetcode/Leetcode-290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/</id>
    <published>2020-12-16T05:52:53.000Z</published>
    <updated>2020-12-16T08:34:44.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-290-单词规律"><a href="#Leetcode-290-单词规律" class="headerlink" title="Leetcode-290-单词规律"></a>Leetcode-290-<a href="https://leetcode-cn.com/problems/word-pattern/" target="_blank" rel="noopener">单词规律</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。</p></li><li><p>这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着<strong>双向连接的对应规律</strong>。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">示例1:</span><br><span class="line"></span><br><span class="line">输入: pattern &#x3D; &quot;abba&quot;, str &#x3D; &quot;dog cat cat dog&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入:pattern &#x3D; &quot;abba&quot;, str &#x3D; &quot;dog cat cat fish&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: pattern &#x3D; &quot;aaaa&quot;, str &#x3D; &quot;dog cat cat dog&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">输入: pattern &#x3D; &quot;abba&quot;, str &#x3D; &quot;dog dog dog dog&quot;</span><br><span class="line">输出: false</span><br><span class="line">说明:</span><br><span class="line">你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。</span><br></pre></td></tr></table></figure><p>​    </p><a id="more"></a><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ul><li><p>在本题中，我们需要判断字符与字符串之间是否恰好一一对应。即任意一个字符都对应着唯一的字符串，任意一个字符串也只被唯一的一个字符对应。<strong>在集合论中，这种关系被称为「双射」。</strong></p></li><li><p>想要解决本题，我们可以利用<strong>哈希表记录每一个字符对应的字符串</strong>，<strong>以及每一个字符串对应的字符。</strong></p></li><li><p>然后我们枚举每一对字符与字符串的配对过程，不断更新哈希表，如果发生了冲突，则说明给定的输入不满足双射关系。</p></li></ul><p><strong>在实际代码中，我们枚举 pattern 中的每一个字符，利用双指针来均摊线性地找到该字符在 str 中对应的字符串。</strong></p><p><strong>每次确定一个字符与字符串的组合，我们就检查是否出现冲突，最后我们再检查两字符串是否比较完毕即可。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordPattern</span><span class="params">(String pattern, String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,Character&gt; str2ch = <span class="keyword">new</span> HashMap&lt;&gt;();         <span class="comment">// 字符串映射字符</span></span><br><span class="line">        Map&lt;Character,String&gt; ch2str = <span class="keyword">new</span> HashMap&lt;&gt;();         <span class="comment">// 字符映射字符串</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m   = s.length();</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;                                            <span class="comment">// idx 用于记录每个单词的开头位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举pattern中的每一个字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">0</span>;p &lt; pattern.length();++p)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = pattern.charAt(p);                                <span class="comment">// 枚举pattern中的每一个字符</span></span><br><span class="line">            <span class="keyword">if</span>(idx &gt;= m)&#123;                                               <span class="comment">// 说明字符和对应字符串的数量不匹配，直接返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理空格之间的字符串单词</span></span><br><span class="line">            <span class="keyword">int</span> j = idx;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; m &amp;&amp; s.charAt(j) != <span class="string">' '</span>)&#123;                         <span class="comment">// j用于记录每个字符串单词的结束位置</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            String temp = s.substring(idx,j);                           <span class="comment">// 拿出空格之间的这个单词</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 离散数学：集合的双射匹配</span></span><br><span class="line">            <span class="keyword">if</span>(str2ch.containsKey(temp) &amp;&amp; str2ch.get(temp) != ch)&#123;     <span class="comment">// 字符串不匹配字符直接返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ch2str.containsKey(ch) &amp;&amp; !temp.equals(ch2str.get(ch)))&#123; <span class="comment">// 字符不匹配字符串直接返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 不在哈希表中 就加入到哈希表中 并且进入下一轮字符匹配</span></span><br><span class="line">            str2ch.put(temp,ch);</span><br><span class="line">            ch2str.put(ch,temp);</span><br><span class="line">            idx = j + <span class="number">1</span>;            <span class="comment">// 从下一个单词的开头进行匹配 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 匹配到结束都满足条件（idx = j + 1）</span></span><br><span class="line">        <span class="keyword">return</span> idx &gt; m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong> ： O(n + m)。 其中 n 是pattern的长度 , m是str 的长度。每个字符至多只被遍历一次，插入和查询哈希表的均摊时间复杂度为O(n + m)</li><li><strong>空间复杂度</strong> ： O(n + m) 。其中 n 是pattern的长度 , m是str 的长度。最坏情况下，我们需要存储pattern的每一个字符和str中的每一个字符串</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-290-单词规律&quot;&gt;&lt;a href=&quot;#Leetcode-290-单词规律&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-290-单词规律&quot;&gt;&lt;/a&gt;Leetcode-290-&lt;a href=&quot;https://leetcode-cn.com/problems/word-pattern/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;单词规律&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着&lt;strong&gt;双向连接的对应规律&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: pattern &amp;#x3D; &amp;quot;abba&amp;quot;, str &amp;#x3D; &amp;quot;dog cat cat dog&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入:pattern &amp;#x3D; &amp;quot;abba&amp;quot;, str &amp;#x3D; &amp;quot;dog cat cat fish&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: pattern &amp;#x3D; &amp;quot;aaaa&amp;quot;, str &amp;#x3D; &amp;quot;dog cat cat dog&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 4:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: pattern &amp;#x3D; &amp;quot;abba&amp;quot;, str &amp;#x3D; &amp;quot;dog dog dog dog&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;说明:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;​    &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="哈希表" scheme="http://zhuuu.work/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>排序-04-基数排序</title>
    <link href="http://zhuuu.work/2020/12/13/Sort/%E6%8E%92%E5%BA%8F-04-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhuuu.work/2020/12/13/Sort/%E6%8E%92%E5%BA%8F-04-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</id>
    <published>2020-12-13T10:33:24.000Z</published>
    <updated>2020-12-13T08:34:19.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序-04-基数排序"><a href="#排序-04-基数排序" class="headerlink" title="排序-04-基数排序"></a>排序-04-基数排序</h1><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;排序-04-基数排序&quot;&gt;&lt;a href=&quot;#排序-04-基数排序&quot; class=&quot;headerlink&quot; title=&quot;排序-04-基数排序&quot;&gt;&lt;/a&gt;排序-04-基数排序&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="排序算法" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-376-摆动序列</title>
    <link href="http://zhuuu.work/2020/12/12/Leetcode/Leetcode-376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/"/>
    <id>http://zhuuu.work/2020/12/12/Leetcode/Leetcode-376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/</id>
    <published>2020-12-12T01:52:53.000Z</published>
    <updated>2020-12-12T02:29:42.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-376-摆动序列"><a href="#Leetcode-376-摆动序列" class="headerlink" title="Leetcode-376-摆动序列"></a>Leetcode-376-<a href="https://leetcode-cn.com/problems/wiggle-subsequence/" target="_blank" rel="noopener">摆动序列</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p><strong>如果连续数字之间的差严格地在正数和负数之间交替</strong>，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p></li><li><p>例如， <code>[1,7,4,9,2,5]</code> 是一个摆动序列，因为差值 <code>(6,-3,5,-7,3)</code> 是正负交替出现的。相反,<code>[1,4,7,2,5]</code> 和 <code>[1,7,4,5,5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p></li><li><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 <strong>通过从原始序列中删除一些（也可以不删除）元素来获得子序列</strong>，剩下的元素保持其原始顺序。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [1,7,4,9,2,5]</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 整个序列均为摆动序列。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [1,17,5,10,13,15,10,5,16,8]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: [1,2,3,4,5,6,7,8,9]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong><br>你能否用 O(<em>n</em>) 时间复杂度完成此题?</p><a id="more"></a><h2 id="算法思路-：-贪心算法"><a href="#算法思路-：-贪心算法" class="headerlink" title="算法思路 ： 贪心算法"></a>算法思路 ： 贪心算法</h2><ul><li><p>本题要求通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p></li><li><p>来分析一下，要求删除元素使其达到最大摆动序列，应该删除什么元素呢？</p></li></ul><p>用示例二来举例，如图所示：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201212/092659036.png" alt="mark"></p><p><strong>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值</strong>。</p><p><strong>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列</strong>。</p><p>局部最优推出全局最优，并举不出反例，那么试试贪心！</p><p>（为方便表述，以下说的峰值都是指局部峰值）</p><p><strong>实际操作上，其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）</strong></p><p><strong>这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点</strong>。</p><ul><li>本题代码实现中，还有一些技巧，例如统计峰值的时候，数组最左面和最右面是最不好统计的。</li><li>例如序列[2,5]，它的峰值数量是2，如果靠统计差值来计算峰值个数就需要考虑数组最左面和最右面的特殊情况。</li><li>所以可以针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即<code>preDiff = 0</code>，如图：<ul><li>此时<code>curDiff &gt; 0 &amp;&amp; preDiff &lt;= 0</code>，那么<code>result++</code></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201212/092926932.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 长度为1的都是摆动序列</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 初始化</span></span><br><span class="line">        <span class="keyword">int</span> prevdiff = nums[<span class="number">1</span>] - nums[<span class="number">0</span>];        <span class="comment">// 记录相邻三个元素 x y z(x 和 y 的差是正还是负)</span></span><br><span class="line">        <span class="keyword">int</span> ret = prevdiff != <span class="number">0</span>?<span class="number">2</span>:<span class="number">1</span>;             <span class="comment">// 前两个元素是否有重复（产生了坡度）</span></span><br><span class="line">        <span class="comment">// 3. 贪心遍历数组:加入一个新元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> diff = nums[i] - nums[i - <span class="number">1</span>];   <span class="comment">// 记录相邻三个元素 x y z(y 和 z 的差是正还是负)</span></span><br><span class="line">            <span class="keyword">if</span>((diff &gt; <span class="number">0</span> &amp;&amp; prevdiff &lt;= <span class="number">0</span>) || (diff &lt; <span class="number">0</span> &amp;&amp; prevdiff &gt;= <span class="number">0</span>))&#123;  <span class="comment">// 如果出现了峰或者谷</span></span><br><span class="line">                ret++;                          <span class="comment">// 如果出现了「峰」或「谷」，答案加一</span></span><br><span class="line">                prevdiff = diff;                <span class="comment">// 更新当前序列的上升下降趋势</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret; <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-376-摆动序列&quot;&gt;&lt;a href=&quot;#Leetcode-376-摆动序列&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-376-摆动序列&quot;&gt;&lt;/a&gt;Leetcode-376-&lt;a href=&quot;https://leetcode-cn.com/problems/wiggle-subsequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;摆动序列&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;如果连续数字之间的差严格地在正数和负数之间交替&lt;/strong&gt;，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;例如， &lt;code&gt;[1,7,4,9,2,5]&lt;/code&gt; 是一个摆动序列，因为差值 &lt;code&gt;(6,-3,5,-7,3)&lt;/code&gt; 是正负交替出现的。相反,&lt;code&gt;[1,4,7,2,5]&lt;/code&gt; 和 &lt;code&gt;[1,7,4,5,5]&lt;/code&gt; 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;给定一个整数序列，返回作为摆动序列的最长子序列的长度。 &lt;strong&gt;通过从原始序列中删除一些（也可以不删除）元素来获得子序列&lt;/strong&gt;，剩下的元素保持其原始顺序。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,7,4,9,2,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 6 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 整个序列均为摆动序列。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,17,5,10,13,15,10,5,16,8]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,2,3,4,5,6,7,8,9]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;进阶:&lt;/strong&gt;&lt;br&gt;你能否用 O(&lt;em&gt;n&lt;/em&gt;) 时间复杂度完成此题?&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="贪心算法" scheme="http://zhuuu.work/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-649-Dota2参议院</title>
    <link href="http://zhuuu.work/2020/12/11/Leetcode/Leetcode-649-Dota2%E5%8F%82%E8%AE%AE%E9%99%A2/"/>
    <id>http://zhuuu.work/2020/12/11/Leetcode/Leetcode-649-Dota2%E5%8F%82%E8%AE%AE%E9%99%A2/</id>
    <published>2020-12-11T07:52:53.000Z</published>
    <updated>2020-12-11T02:12:43.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-649-Dota2-参议院"><a href="#Leetcode-649-Dota2-参议院" class="headerlink" title="Leetcode-649-Dota2 参议院"></a>Leetcode-649-<a href="https://leetcode-cn.com/problems/dota2-senate/" target="_blank" rel="noopener">Dota2 参议院</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Dota2 的世界里有两个阵营：Radiant(天辉)和 Dire(夜魇)</p><p>Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：</p><ul><li><p>禁止一名参议员的权利：</p></li><li><p>参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。</p></li></ul><p>宣布胜利：</p><pre><code>如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。</code></pre><p>给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。</p><p><strong>以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。</strong></p><p>假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 <code>Dota2</code>游戏中决定改变。输出应该是 <code>Radiant</code> 或 <code>Dire</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：&quot;RD&quot;</span><br><span class="line">输出：&quot;Radiant&quot;</span><br><span class="line">解释：第一个参议员来自 Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：&quot;RDD&quot;</span><br><span class="line">输出：&quot;Dire&quot;</span><br><span class="line">解释：</span><br><span class="line">第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利</span><br><span class="line">第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止</span><br><span class="line">第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利</span><br><span class="line">因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>给定字符串的长度在 <code>[1, 10,000]</code> 之间.</li></ul><a id="more"></a><h2 id="算法思路-循环队列"><a href="#算法思路-循环队列" class="headerlink" title="算法思路 : 循环队列"></a>算法思路 : 循环队列</h2><ul><li>我们以天辉方的议员为例。当一名天辉方的议员行使权利时：<ul><li>如果目前所有的议员都为天辉方，那么该议员可以直接宣布天辉方取得胜利；</li><li>如果目前仍然有夜魇方的议员，那么这名天辉方的议员只能行使「禁止一名参议员的权利」这一项权利。<ul><li>显然，该议员不会令一名同为天辉方的议员丧失权利，所以他一定会挑选一名夜魇方的议员。那么应该挑选哪一名议员呢？</li><li>容易想到的是，<strong>应该贪心地挑选按照投票顺序的下一名夜魇方的议员</strong>。</li><li>这也是很容易形象化证明的：既然只能挑选<strong>一名</strong>夜魇方的议员，那么就应该挑最早可以进行投票的那一名议员；</li><li>如果挑选了其它较晚投票的议员，那么等到最早可以进行投票的那一名议员行使权利时，一名天辉方议员就会丧失权利，这样就得不偿失了。</li></ul></li></ul></li></ul><p><strong>具体算法</strong></p><ul><li>由于我们总要挑选投票顺序最早的议员 ，因此我们可以使用两个队列<code>radiant</code> 和 <code>dire</code> 分别按照投票顺序存储天辉方和夜魇方每一名议员的投票时间</li><li>随后我们就可以开始模拟整个投票的过程：<ul><li><strong>如果此时 队列<code>radiant</code> 或者 <code>dire</code> 为空</strong>，那么就可以宣布另一方获得胜利；</li><li><strong>如果此时队列不为空</strong> ： 那么比较这两个队列的首元素，就可以确定当前行使权利的是哪一名议员<ul><li><strong>如果 <em>radiant</em> 的首元素较小，</strong>那说明轮到天辉方的议员行使权利，其会挑选 <em>dire</em> 的首元素对应的那一名议员</li><li><strong>因此，我们会将 <em>dire</em> 的首元素永久地弹出</strong></li><li><strong>并将 <em>radiant</em> 的首元素弹出，增加 <em>n</em> 之后再重新放回队列</strong></li><li>这里 n 是给给定字符串 senate 的长度,即表示该议员因为没有被ban掉所以参加了下一轮投票</li><li>同理 ： 如果dire 首元素较小,那么会永久的弹出 <code>radiant  的首元素，剩余的处理方法也是一样的</code></li></ul></li></ul></li></ul><blockquote><p>为什么这里是固定地增加 n，而不是增加与当前剩余议员数量相关的一个数？</p></blockquote><p>这样一来，我们就模拟了整个投票的过程，也就可以得到最终的答案了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">predictPartyVictory</span><span class="params">(String senate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = senate.length();</span><br><span class="line">        Queue&lt;Integer&gt; radiant = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; dire    = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 遍历数组 记录下每个阵营议员的下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(senate.charAt(i) == <span class="string">'R'</span>)&#123;</span><br><span class="line">                radiant.offer(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dire.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 如果两个队列都不空的情况下</span></span><br><span class="line">        <span class="keyword">while</span>(!radiant.isEmpty() &amp;&amp; !dire.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> radiantIndex = radiant.poll();      <span class="comment">// radiant的第一名议员 暂时弹出</span></span><br><span class="line">            <span class="keyword">int</span> direIndex    = dire.poll();         <span class="comment">// dire 的第一名议员   暂时弹出</span></span><br><span class="line">            <span class="keyword">if</span>(radiantIndex &lt; direIndex)&#123;           <span class="comment">// 如果radiant第一名议员首元素较小</span></span><br><span class="line">                radiant.offer(radiantIndex + n);    <span class="comment">// 暂时弹出 +n之后重新放回队列 对应dire第一名议员永久弹出</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                     <span class="comment">// 加上n后，可以保证这个议员只会参加下一轮，或者被上一轮的对手干掉。</span></span><br><span class="line">                dire.offer(direIndex + n);          <span class="comment">// 暂时弹出 +n之后重新放回队列 对应radiant第一名议员永久弹出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 宣布胜利</span></span><br><span class="line">        <span class="keyword">return</span> !radiant.isEmpty()?<span class="string">"Radiant"</span>:<span class="string">"Dire"</span>; <span class="comment">// 最后非空的队列宣布胜利</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度 ：</strong> O(n)   其中 <code>n</code> 是字符串<code>senate</code> 的长度。在模拟整个投票过程的每一步，我们进行的操作的时间复杂度均为<code>O(1)</code>，并且会弹出一名天辉方或夜魇方的议员。由于议员的数量为 n，因此模拟的步数不会超过 n，时间复杂度即为 O(n)。</li><li><strong>空间复杂度</strong> ： O(n)   队列所需要的复杂度</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-649-Dota2-参议院&quot;&gt;&lt;a href=&quot;#Leetcode-649-Dota2-参议院&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-649-Dota2 参议院&quot;&gt;&lt;/a&gt;Leetcode-649-&lt;a href=&quot;https://leetcode-cn.com/problems/dota2-senate/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dota2 参议院&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;Dota2 的世界里有两个阵营：Radiant(天辉)和 Dire(夜魇)&lt;/p&gt;
&lt;p&gt;Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;禁止一名参议员的权利：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;宣布胜利：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 &lt;code&gt;Dota2&lt;/code&gt;游戏中决定改变。输出应该是 &lt;code&gt;Radiant&lt;/code&gt; 或 &lt;code&gt;Dire&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&amp;quot;RD&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&amp;quot;Radiant&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：第一个参议员来自 Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&amp;quot;RDD&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&amp;quot;Dire&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定字符串的长度在 &lt;code&gt;[1, 10,000]&lt;/code&gt; 之间.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="贪心算法" scheme="http://zhuuu.work/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-860-柠檬水找零</title>
    <link href="http://zhuuu.work/2020/12/10/Leetcode/Leetcode-860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/"/>
    <id>http://zhuuu.work/2020/12/10/Leetcode/Leetcode-860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/</id>
    <published>2020-12-10T02:52:53.000Z</published>
    <updated>2020-12-10T01:27:30.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-860-柠檬水找零"><a href="#Leetcode-860-柠檬水找零" class="headerlink" title="Leetcode-860-柠檬水找零"></a>Leetcode-860-<a href="https://leetcode-cn.com/problems/lemonade-change/" target="_blank" rel="noopener">柠檬水找零</a></h1><h2 id="思路：贪心算法"><a href="#思路：贪心算法" class="headerlink" title="思路：贪心算法"></a>思路：贪心算法</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><ul><li><p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。</p></li><li><p>顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p></li><li><p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p></li></ul><p>  注意，一开始你手头没有任何零钱。</p><p>  如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">20</span>]</span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：</span><br><span class="line">前 <span class="number">3</span> 位顾客那里，我们按顺序收取 <span class="number">3</span> 张 <span class="number">5</span> 美元的钞票。</span><br><span class="line">第 <span class="number">4</span> 位顾客那里，我们收取一张 <span class="number">10</span> 美元的钞票，并返还 <span class="number">5</span> 美元。</span><br><span class="line">第 <span class="number">5</span> 位顾客那里，我们找还一张 <span class="number">10</span> 美元的钞票和一张 <span class="number">5</span> 美元的钞票。</span><br><span class="line">由于所有客户都得到了正确的找零，所以我们输出 <span class="keyword">true</span>。</span><br><span class="line">    </span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">5</span>,<span class="number">5</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">    </span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">10</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">    </span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">5</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">20</span>]</span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">解释：</span><br><span class="line">前 <span class="number">2</span> 位顾客那里，我们按顺序收取 <span class="number">2</span> 张 <span class="number">5</span> 美元的钞票。</span><br><span class="line">对于接下来的 <span class="number">2</span> 位顾客，我们收取一张 <span class="number">10</span> 美元的钞票，然后返还 <span class="number">5</span> 美元。</span><br><span class="line">对于最后一位顾客，我们无法退回 <span class="number">15</span> 美元，因为我们现在只有两张 <span class="number">10</span> 美元的钞票。</span><br><span class="line">由于不是每位顾客都得到了正确的找零，所以答案是 <span class="keyword">false</span>。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="算法思路：贪心-模拟（CRUD）"><a href="#算法思路：贪心-模拟（CRUD）" class="headerlink" title="算法思路：贪心 + 模拟（CRUD）"></a>算法思路：贪心 + 模拟（CRUD）</h2><p>由于顾客只可能给你三个面值的钞票，而且我们一开始没有任何钞票，因此我们拥有的钞票的面值只可能是 5 美元，10美元和 20 美元三种。基于此，我们可以进行如下的分类讨论。</p><ol><li><strong>5 美元</strong>，由于柠檬水的价格也为 5美元，因此我们直接收下即可</li><li><strong>10 美元，我们需要找回 5 美元</strong>，如果没有 5 美元面值的钞票，则无法正确找零。</li><li><strong>20 美元，我们需要找回 15 美元</strong>，此时有<strong>两种组合方式</strong><ul><li>一种是一张 10 美元和 5 美元的钞票</li><li>一种是 3 张  5 美元的钞票</li><li>如果两种组合方式都没有，则无法正确找零</li></ul></li></ol><ol start="4"><li><strong>对于情况三的找零方式 ：</strong> <ul><li>当可以正确找零时，两种找零的方式中我们更倾向于第一种</li><li>即如果存在5美元和10美元 我们就按照第一种方式找零</li><li>否则按照第二种情况找零，这样的目的是尽可以保留5美元的钞票</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lemonadeChange</span><span class="params">(<span class="keyword">int</span>[] bills)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> five = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ten  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  遍历所有的数组元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> bill:bills)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bill == <span class="number">5</span>)&#123;          <span class="comment">// 如果发现是五块钱，直接收了</span></span><br><span class="line">                five++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bill == <span class="number">10</span>)&#123;   <span class="comment">// 如果发现是10块钱</span></span><br><span class="line">                <span class="keyword">if</span>(five == <span class="number">0</span>)&#123;      <span class="comment">// 如果没有钱来找零了</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                five--;</span><br><span class="line">                ten++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                  <span class="comment">// 如果账单是20块钱</span></span><br><span class="line">                <span class="keyword">if</span>(ten &gt; <span class="number">0</span> &amp;&amp; five &gt; <span class="number">0</span>)&#123;    <span class="comment">// 1. 首先判断10块和5块的组合够不够找钱</span></span><br><span class="line">                    ten--;</span><br><span class="line">                    five--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(five &gt;= <span class="number">3</span>)&#123;        <span class="comment">// 2. 不够的话就用3张5块钱去找零</span></span><br><span class="line">                    five -= <span class="number">3</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;                      <span class="comment">// 3. 都没有零钱可找了</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可以找零的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong> ： O（N） 遍历一遍数组所需要的时间</li><li><strong>空间复杂度</strong>  ： O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-860-柠檬水找零&quot;&gt;&lt;a href=&quot;#Leetcode-860-柠檬水找零&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-860-柠檬水找零&quot;&gt;&lt;/a&gt;Leetcode-860-&lt;a href=&quot;https://leetcode-cn.com/problems/lemonade-change/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;柠檬水找零&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：贪心算法&quot;&gt;&lt;a href=&quot;#思路：贪心算法&quot; class=&quot;headerlink&quot; title=&quot;思路：贪心算法&quot;&gt;&lt;/a&gt;思路：贪心算法&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在柠檬水摊上，每一杯柠檬水的售价为 5 美元。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  注意，一开始你手头没有任何零钱。&lt;/p&gt;
&lt;p&gt;  如果你能给每位顾客正确找零，返回 true ，否则返回 false 。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;前 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; 位顾客那里，我们按顺序收取 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; 张 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 美元的钞票。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第 &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; 位顾客那里，我们收取一张 &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; 美元的钞票，并返还 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 美元。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 位顾客那里，我们找还一张 &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; 美元的钞票和一张 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 美元的钞票。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;由于所有客户都得到了正确的找零，所以我们输出 &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;前 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 位顾客那里，我们按顺序收取 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 张 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 美元的钞票。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;对于接下来的 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 位顾客，我们收取一张 &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; 美元的钞票，然后返还 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 美元。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;对于最后一位顾客，我们无法退回 &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt; 美元，因为我们现在只有两张 &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; 美元的钞票。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;由于不是每位顾客都得到了正确的找零，所以答案是 &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="贪心算法" scheme="http://zhuuu.work/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学-伽马修正</title>
    <link href="http://zhuuu.work/2020/12/09/cv/%E5%9B%BE%E5%83%8F%E5%AD%A6-%E4%BC%BD%E9%A9%AC%E4%BF%AE%E6%AD%A3/"/>
    <id>http://zhuuu.work/2020/12/09/cv/%E5%9B%BE%E5%83%8F%E5%AD%A6-%E4%BC%BD%E9%A9%AC%E4%BF%AE%E6%AD%A3/</id>
    <published>2020-12-09T09:38:38.000Z</published>
    <updated>2020-12-09T09:04:02.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图像学-伽马修正"><a href="#图像学-伽马修正" class="headerlink" title="图像学-伽马修正"></a>图像学-伽马修正</h1><h1 id="计算机图形学-伽马修正"><a href="#计算机图形学-伽马修正" class="headerlink" title="计算机图形学-伽马修正"></a>计算机图形学-伽马修正</h1><p><strong>起因：</strong> [][][一个伽马矫正的视频][<a href="https://v.youku.com/v_show/id_XMTQwMjg5NzM4OA==.html]" target="_blank" rel="noopener">https://v.youku.com/v_show/id_XMTQwMjg5NzM4OA==.html]</a></p><p><strong>答案 ：</strong> [一个知乎答案][<a href="https://www.zhihu.com/question/27467127]" target="_blank" rel="noopener">https://www.zhihu.com/question/27467127]</a></p><p><strong>参考博客 ：</strong> [博客地址][<a href="http://hanshilin.com/blog/gamma-and-linear-workflow/]" target="_blank" rel="noopener">http://hanshilin.com/blog/gamma-and-linear-workflow/]</a></p><a id="more"></a><h2 id="1-韦伯-费希纳定律"><a href="#1-韦伯-费希纳定律" class="headerlink" title="1. 韦伯-费希纳定律"></a>1. 韦伯-费希纳定律</h2><ul><li>最早见到韦伯定律的时候，以为就是个非常简单的式子：△I/I=K，△I是差别阈限；I是刺激强度；K是韦伯常数</li><li>根据刺激的不同，受试的不同，其值不同，但对于同一个被试在同等条件下进行同类型的刺激，该值为常数。</li><li>意思是，刺激强度I和在该刺激强度下引起最小可觉差所需要的刺激强度呈正比。例如，假设手里拿一个重量为10g的物体，若增加1g能让你恰好感觉到它的重量产生了变化（增加的重量低于1g你便不能感觉到重量发生了改变），那么如果手里拿一个重量为100g的物体，则需要增加其重量10g才能让你恰好感觉到重量发生了变化。</li></ul><p><strong>费希纳则在韦伯的基础上作出这样一个假设</strong>：</p><ul><li><strong>恰好引起感觉变化的刺激强度变化所引起的感觉变化是相等的。</strong>以上面那个例子为例，<ul><li>意思是，对于给10g物体增加1g所引起的你感觉变化与给100g物体增加10g所引起的你的感觉变化是一样的，都是1个单位的感觉变化。</li><li>换言之，你左手拿11g物体右手拿10g物体，你感觉左手比右手重”一些“；你左手拿110g物体右手拿100g物体，感觉左手比右手重”一些“，这两个”一些“的程度是一样的。 </li></ul></li></ul><ul><li>在这个假设的基础上，费希纳总结出公式：△P = k * △S/S         </li><li>根据该公式，若在某初始刺激为S的条件下，进行强度为10倍最小可觉差的刺激，则相应的感觉变化也应当变成10倍。比如给10g物体增加1g重量刚好能感觉到重量发生了改变，主观感觉变化量为△p；</li></ul><ul><li>虽然这个公式有一部分与韦伯定律的公式非常相似，但意义并不相同：<ul><li>在韦伯定律那里， △I/I=K指的是“当前刺激强度下的最小可觉差”与”当前刺激强度“的关系， △I与I均为变量。</li><li>而关系式△P = k * △S/S 则指示了在初始刺激强度为S时，刺激变化量△S与主观感觉变化量△P的关系。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">将上式改写成微分式，则有dP &#x3D; k * dS &#x2F; S</span><br><span class="line">   </span><br><span class="line">      对该式两侧同时进行积分：</span><br><span class="line">       ∫ dP  &#x3D; P &#x3D;  ∫ k&#x2F;S * dS  &#x3D;  k*lnS + C</span><br><span class="line">      </span><br><span class="line">      得到了主观感觉量P与刺激强度S的关系式：</span><br><span class="line">      P &#x3D; k*lnS + C</span><br><span class="line"></span><br><span class="line">      为消除积分常数C，令P&#x3D;0，有C &#x3D; -k*lns, s是绝对阈限。</span><br><span class="line"></span><br><span class="line">      可得：</span><br><span class="line">      P &#x3D; k * (lnS - lns)</span><br><span class="line">     </span><br><span class="line">     设绝对阈限为单位1，则lns &#x3D;0，</span><br><span class="line"></span><br><span class="line">     故可改写为P &#x3D;k *lnS &#x3D; k*(lgS&#x2F;lge) &#x3D; k&#x2F;lge * lgS  </span><br><span class="line">                         &#x3D; K * lgS</span><br><span class="line"></span><br><span class="line">     得到费希纳定律的公式。</span><br><span class="line"></span><br><span class="line">     若某振幅为10个单位的音波引起的声音的主观感觉量为1，如果把该音波的振幅扩大到100个单位，则声音的主观感觉量仅增加1。换言之，根据费希纳定律，若要感觉强度呈线性增长，则刺激强度需要呈几何倍数增长。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>[知乎另外一个答案][<a href="https://www.zhihu.com/question/314657948?sort=created]" target="_blank" rel="noopener">https://www.zhihu.com/question/314657948?sort=created]</a></p><p><strong>参考博客 ：</strong> </p><p><a href="https://www.douban.com/note/506270934/" target="_blank" rel="noopener">https://www.douban.com/note/506270934/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;图像学-伽马修正&quot;&gt;&lt;a href=&quot;#图像学-伽马修正&quot; class=&quot;headerlink&quot; title=&quot;图像学-伽马修正&quot;&gt;&lt;/a&gt;图像学-伽马修正&lt;/h1&gt;&lt;h1 id=&quot;计算机图形学-伽马修正&quot;&gt;&lt;a href=&quot;#计算机图形学-伽马修正&quot; class=&quot;headerlink&quot; title=&quot;计算机图形学-伽马修正&quot;&gt;&lt;/a&gt;计算机图形学-伽马修正&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;起因：&lt;/strong&gt; [][][一个伽马矫正的视频][&lt;a href=&quot;https://v.youku.com/v_show/id_XMTQwMjg5NzM4OA==.html]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://v.youku.com/v_show/id_XMTQwMjg5NzM4OA==.html]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答案 ：&lt;/strong&gt; [一个知乎答案][&lt;a href=&quot;https://www.zhihu.com/question/27467127]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.zhihu.com/question/27467127]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考博客 ：&lt;/strong&gt; [博客地址][&lt;a href=&quot;http://hanshilin.com/blog/gamma-and-linear-workflow/]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://hanshilin.com/blog/gamma-and-linear-workflow/]&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机图形学" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-897-递增顺序查找树</title>
    <link href="http://zhuuu.work/2020/12/07/Leetcode/Leetcode-897-%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    <id>http://zhuuu.work/2020/12/07/Leetcode/Leetcode-897-%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%A0%91/</id>
    <published>2020-12-07T07:52:53.000Z</published>
    <updated>2020-12-07T03:42:02.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-897-递增顺序查找树"><a href="#Leetcode-897-递增顺序查找树" class="headerlink" title="Leetcode-897-递增顺序查找树"></a>Leetcode-897-<a href="https://leetcode-cn.com/problems/increasing-order-search-tree/" target="_blank" rel="noopener">递增顺序查找树</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><p>给你一个树，请你 <strong>按中序遍历</strong> 重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。</p><pre><code>示例 ：输入：[5,3,6,2,4,null,8,1,null,null,null,7,9]      5      /     \    3    6   / \    \  2   4    8 /        / \ 1        7   9输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] 1  \   2    \     3      \       4        \         5          \           6            \             7              \               8                \                 9  </code></pre><a id="more"></a><h2 id="思路：中序遍历-构造新树"><a href="#思路：中序遍历-构造新树" class="headerlink" title="思路：中序遍历 + 构造新树"></a>思路：中序遍历 + 构造新树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; vals = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inorder(root,vals);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造新树</span></span><br><span class="line">        TreeNode ans = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        TreeNode cur = ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> val:vals)&#123;</span><br><span class="line">            cur.right = <span class="keyword">new</span> TreeNode(val);  <span class="comment">// 构造新的结点</span></span><br><span class="line">            cur = cur.right;    <span class="comment">// 方向只向右延伸</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode node,List&lt;Integer&gt; vals)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorder(node.left,vals);</span><br><span class="line">        vals.add(node.val);</span><br><span class="line">        inorder(node.right,vals);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：O(N)，其中 N 是树上的节点个数。</li><li><strong>空间复杂度</strong>：O(N)。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-897-递增顺序查找树&quot;&gt;&lt;a href=&quot;#Leetcode-897-递增顺序查找树&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-897-递增顺序查找树&quot;&gt;&lt;/a&gt;Leetcode-897-&lt;a href=&quot;https://leetcode-cn.com/problems/increasing-order-search-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;递增顺序查找树&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;给你一个树，请你 &lt;strong&gt;按中序遍历&lt;/strong&gt; 重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例 ：

输入：[5,3,6,2,4,null,8,1,null,null,null,7,9]

      5
      /     \
    3    6
   / \    \
  2   4    8
 /        / \ 
1        7   9

输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]

 1
  \
   2
    \
     3
      \
       4
        \
         5
          \
           6
            \
             7
              \
               8
                \
                 9  &lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="中序遍历" scheme="http://zhuuu.work/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-861-翻转矩阵后的得分</title>
    <link href="http://zhuuu.work/2020/12/07/Leetcode/Leetcode-861-%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5%E5%90%8E%E7%9A%84%E5%BE%97%E5%88%86/"/>
    <id>http://zhuuu.work/2020/12/07/Leetcode/Leetcode-861-%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5%E5%90%8E%E7%9A%84%E5%BE%97%E5%88%86/</id>
    <published>2020-12-07T02:52:53.000Z</published>
    <updated>2020-12-07T03:22:28.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-861-翻转矩阵后的得分"><a href="#Leetcode-861-翻转矩阵后的得分" class="headerlink" title="Leetcode-861-翻转矩阵后的得分"></a>Leetcode-861-<a href="https://leetcode-cn.com/problems/score-after-flipping-matrix/" target="_blank" rel="noopener">翻转矩阵后的得分</a></h1><h2 id="思路：贪心算法"><a href="#思路：贪心算法" class="headerlink" title="思路：贪心算法"></a>思路：贪心算法</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><ul><li><p>有一个二维矩阵 A 其中每个元素的值为 0 或 1 。</p></li><li><p><strong>移动是指选择任一行或列</strong>，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。</p></li><li><p>在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。</p></li><li><p>返回尽可能高的分数。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">39</span></span><br><span class="line">解释：</span><br><span class="line">转换为 [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line"><span class="number">0b1111</span> + <span class="number">0b1001</span> + <span class="number">0b1111</span> = <span class="number">15</span> + <span class="number">9</span> + <span class="number">15</span> = <span class="number">39</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ol><li>根据题意，能够知道一个重要的事实：给定一个翻转方案，则它们之间任意交换顺序后，得到的结果保持不变。<strong>因此，我们总可以先考虑所有的行翻转，再考虑所有的列翻转。</strong></li><li><strong>行翻转</strong> ：<strong>不难发现一点：为了得到最高的分数，矩阵的每一行的最左边的数都必须为1。为了做到这一点，我们可以翻转那些最左边的数不为 1 的那些行，而其他的行则保持不动。</strong></li><li><strong>列翻转</strong> ： 当将每一行的最左边的数都变为 1 之后，就只能进行列翻转了。<ul><li>为了使得总得分最大，我们要让每个列中 1 的数目尽可能多。</li><li>因此，我们扫描除了最左边的列以外的每一列，<strong>如果该列 0 的数目多于 1 的数目，就翻转该列，其他的列则保持不变。</strong></li></ul></li></ol><p><strong>对于实际编码的时候：我们无需要修改原来的矩阵</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201207/110943111.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此做法不必修改原来的矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">matrixScore</span><span class="params">(<span class="keyword">int</span>[][] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.length;</span><br><span class="line">        <span class="keyword">int</span> n = A[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 直接统计第一列的贡献（假设第一列全为1的结果）</span></span><br><span class="line">        <span class="keyword">int</span> ret = m * (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 统计从第二列开始 每一列的贡献</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> nOnes = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i][<span class="number">0</span>] == <span class="number">1</span>)&#123;           <span class="comment">// 说明这一行没有进行过行翻转</span></span><br><span class="line">                    nOnes += A[i][j];       <span class="comment">// 直接统计本列1的个数</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;                      <span class="comment">// 说明这一行开头是0,需要行翻转</span></span><br><span class="line">                    nOnes += (<span class="number">1</span> - A[i][j]); <span class="comment">// 如果这一行进行了翻转,则该元素的实际取值就是 1 - A[i][j]</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> k = Math.max(nOnes, m - nOnes);     <span class="comment">// k 是列翻转后1的数量 nOnes是1的数量 m - nOnes是0的数量</span></span><br><span class="line">            ret += k * (<span class="number">1</span> &lt;&lt; (n - j - <span class="number">1</span>));          <span class="comment">// 本列对于结果的贡献</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度 ： <code>O(mn)</code></strong></li><li><strong>空间复杂度：  <code>O(1)</code></strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-861-翻转矩阵后的得分&quot;&gt;&lt;a href=&quot;#Leetcode-861-翻转矩阵后的得分&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-861-翻转矩阵后的得分&quot;&gt;&lt;/a&gt;Leetcode-861-&lt;a href=&quot;https://leetcode-cn.com/problems/score-after-flipping-matrix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;翻转矩阵后的得分&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：贪心算法&quot;&gt;&lt;a href=&quot;#思路：贪心算法&quot; class=&quot;headerlink&quot; title=&quot;思路：贪心算法&quot;&gt;&lt;/a&gt;思路：贪心算法&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;有一个二维矩阵 A 其中每个元素的值为 0 或 1 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;移动是指选择任一行或列&lt;/strong&gt;，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;返回尽可能高的分数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;39&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;转换为 [[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0b1111&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;0b1001&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;0b1111&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;39&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="贪心算法" scheme="http://zhuuu.work/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-204-计数质数</title>
    <link href="http://zhuuu.work/2020/12/03/Leetcode/Leetcode-204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/"/>
    <id>http://zhuuu.work/2020/12/03/Leetcode/Leetcode-204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/</id>
    <published>2020-12-03T00:52:53.000Z</published>
    <updated>2020-12-03T01:44:43.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-204-计数质数"><a href="#Leetcode-204-计数质数" class="headerlink" title="Leetcode-204-计数质数"></a>Leetcode-204-<a href="https://leetcode-cn.com/problems/count-primes/" target="_blank" rel="noopener">计数质数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>统计所有小于非负整数 <em><code>n</code></em> 的质数的数量。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：n &#x3D; 10</span><br><span class="line">输出：4</span><br><span class="line">解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 0</span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt;&#x3D; n &lt;&#x3D; 5 * 106</span><br></pre></td></tr></table></figure><h2 id="方法一：枚举"><a href="#方法一：枚举" class="headerlink" title="方法一：枚举"></a>方法一：枚举</h2><ul><li><p>很直观的思路是我们枚举每个数判断其是不是质数。</p></li><li><p>考虑质数的定义：在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。</p></li><li><p>因此对于每个数 x，我们可以从小到大枚举<code>[2,x-1]</code>中的每个数 y，判断 y 是否为 x 的因数。但这样判断一个数是否为质数的时间复杂度最差情况下会到 <code>O(n)</code>，无法通过所有测试数据。</p></li></ul><p><strong>注意：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201203/091156606.png" alt="mark"></p><p>举例子 ： </p><ul><li><code>x = 6 y = 2 x/y =3</code></li><li><code>min(y,x/y)= 2</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化数据</span></span><br><span class="line">        String line;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((line = in.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> n = Integer.parseInt(line);</span><br><span class="line">            <span class="keyword">int</span> ret = <span class="keyword">new</span> Solution().countPrimes(n);</span><br><span class="line">            String out = String.valueOf(ret);</span><br><span class="line">            System.out.println(out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;++i)&#123;</span><br><span class="line">            ans += isPrime(i)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(sqrt(n))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i*i &lt;= x;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x % i == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201203/091257182.png" alt="mark"></p><a id="more"></a><h2 id="方法二-：-埃氏筛"><a href="#方法二-：-埃氏筛" class="headerlink" title="方法二 ： 埃氏筛"></a>方法二 ： 埃氏筛</h2><ul><li>枚举没有考虑到数与数的关联性，因此难以再继续优化时间复杂度。接下来我们介绍一个常见的算法，该算法由希腊数学家厄拉多塞（<code>Eratosthenes</code>）提出，称为厄拉多塞筛法，简称埃氏筛。</li></ul><p><strong>注意：</strong></p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201203/091731007.png" alt="mark" style="zoom:150%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 初始化质数数组</span></span><br><span class="line">        <span class="keyword">int</span>[] isPrime = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(isPrime,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 进行统计</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime[i] == <span class="number">1</span>)&#123;   <span class="comment">// 如果遇到的这个数是质数的话,开始判断,否则不会进循环</span></span><br><span class="line">                ans += <span class="number">1</span>;           <span class="comment">// 遍历数组,如果是质数的话,那么给结果加1</span></span><br><span class="line">                <span class="keyword">if</span>((<span class="keyword">long</span>)i*i &lt; n)&#123;  <span class="comment">// 如果i是质数 那么i*i就是合数 起始位置：需要标记为0</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = i*i;j &lt; n;j += i)&#123;  <span class="comment">// 同时,从i*i 位置开始标记,</span></span><br><span class="line">                        isPrime[j] = <span class="number">0</span>;             <span class="comment">// 标记i*i + i也同时为i的倍数，只要是i的倍数,那么就一定不是质数</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201203/094440295.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-204-计数质数&quot;&gt;&lt;a href=&quot;#Leetcode-204-计数质数&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-204-计数质数&quot;&gt;&lt;/a&gt;Leetcode-204-&lt;a href=&quot;https://leetcode-cn.com/problems/count-primes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;计数质数&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;统计所有小于非负整数 &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt; 的质数的数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：n &amp;#x3D; 10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：n &amp;#x3D; 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：n &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0 &amp;lt;&amp;#x3D; n &amp;lt;&amp;#x3D; 5 * 106&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;h2 id=&quot;方法一：枚举&quot;&gt;&lt;a href=&quot;#方法一：枚举&quot; class=&quot;headerlink&quot; title=&quot;方法一：枚举&quot;&gt;&lt;/a&gt;方法一：枚举&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;很直观的思路是我们枚举每个数判断其是不是质数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考虑质数的定义：在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;因此对于每个数 x，我们可以从小到大枚举&lt;code&gt;[2,x-1]&lt;/code&gt;中的每个数 y，判断 y 是否为 x 的因数。但这样判断一个数是否为质数的时间复杂度最差情况下会到 &lt;code&gt;O(n)&lt;/code&gt;，无法通过所有测试数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201203/091156606.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;举例子 ： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x = 6 y = 2 x/y =3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;min(y,x/y)= 2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainClass&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        BufferedReader in = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BufferedReader(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; InputStreamReader(System.in));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 初始化数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String line;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; ((line = in.readLine()) != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n = Integer.parseInt(line);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ret = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Solution().countPrimes(n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            String out = String.valueOf(ret);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(out);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;countPrimes&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ans = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// O(n)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;i &amp;lt; n;++i)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ans += isPrime(i)?&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// O(sqrt(n))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isPrime&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;i*i &amp;lt;= x;++i)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(x % i == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201203/091257182.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-134-加油站</title>
    <link href="http://zhuuu.work/2020/11/18/Leetcode/Leetcode-134-%E5%8A%A0%E6%B2%B9%E7%AB%99/"/>
    <id>http://zhuuu.work/2020/11/18/Leetcode/Leetcode-134-%E5%8A%A0%E6%B2%B9%E7%AB%99/</id>
    <published>2020-11-18T09:22:53.000Z</published>
    <updated>2020-11-18T04:56:06.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-134-加油站"><a href="#Leetcode-134-加油站" class="headerlink" title="Leetcode-134-加油站"></a>Leetcode-134-<a href="https://leetcode-cn.com/problems/gas-station/" target="_blank" rel="noopener">加油站</a></h1><h2 id="思路：一次遍历"><a href="#思路：一次遍历" class="headerlink" title="思路：一次遍历"></a>思路：一次遍历</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p>说明: </p><ul><li>如果题目有解，该答案即为唯一答案。</li><li>输入数组均为非空数组，且长度相同。</li><li>输入数组中的元素均为非负数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">gas  &#x3D; [1,2,3,4,5]</span><br><span class="line">cost &#x3D; [3,4,5,1,2]</span><br><span class="line"></span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 + 5 &#x3D; 8 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 8 - 2 + 1 &#x3D; 7 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 7 - 3 + 2 &#x3D; 6 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 6 - 4 + 3 &#x3D; 5 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">gas  &#x3D; [2,3,4]</span><br><span class="line">cost &#x3D; [3,4,3]</span><br><span class="line"></span><br><span class="line">输出: -1</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 4 - 3 + 2 &#x3D; 3 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 3 - 3 + 3 &#x3D; 3 升汽油</span><br><span class="line">你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法-：一次遍历"><a href="#方法-：一次遍历" class="headerlink" title="方法 ：一次遍历"></a>方法 ：一次遍历</h2><ul><li><p>最容易想到的解法是：从头到尾遍历每个加油站，并检查以该加油站为起点，最终能否行驶一周。我们可以通过减小被检查的加油站数目，来降低总的时间复杂度。</p></li><li><p>假设我们此前发现，从加油站 xx 出发，每经过一个加油站就加一次油，第一个无法到达的加油站是 y（不妨设 x&lt;y）。这就说明：</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201118/124732560.png" alt="mark"></p><ul><li>现在，考虑任意一个位于 x,y之间的加油站 z<em>，我们现在考察从该加油站出发，能否到达加油站 y</em></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201118/124851837.png" alt="mark"></p><p><strong>这也就是说明，从x,y 之间任何一个加油站出发,都无法到达加油站y(说明起点只能有一个,这个加油站不行的话，中间任何一个点作为起点都不可以，起点只能从下一次加油站 x + 1开始检查，故最后只遍历了一遍数组)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = gas.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从头到尾遍历每个加油站，并且检查以该加油站为起点，能否行驶一周</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            <span class="keyword">int</span> sumOfGas  = <span class="number">0</span>; <span class="comment">// 总共加的油</span></span><br><span class="line">            <span class="keyword">int</span> SumOfCost = <span class="number">0</span>; <span class="comment">// 总共消费的油</span></span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;     <span class="comment">// 记录能走过几个站点</span></span><br><span class="line">            <span class="keyword">while</span>(count &lt; n)&#123;  <span class="comment">// 退出循环的条件是走过所有的站点</span></span><br><span class="line">                <span class="keyword">int</span> j = (i + count) % n; <span class="comment">// 加油站是环形的</span></span><br><span class="line">                sumOfGas += gas[j];</span><br><span class="line">                SumOfCost += cost[j];</span><br><span class="line">                <span class="keyword">if</span>(SumOfCost &gt; sumOfGas)&#123; <span class="comment">// 如果这个站点发现油不够了</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count++; <span class="comment">// 这个站点满足情况</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(count == n)&#123;  <span class="comment">// 如果能环绕一圈</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 不行的话 从下一个站点开始 检查</span></span><br><span class="line">                i = i + count + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所有加油站作为起点都不满足</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(N)，其中 N为数组的长度。我们对数组进行了单次遍历。</li><li>空间复杂度：O(1)。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-134-加油站&quot;&gt;&lt;a href=&quot;#Leetcode-134-加油站&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-134-加油站&quot;&gt;&lt;/a&gt;Leetcode-134-&lt;a href=&quot;https://leetcode-cn.com/problems/gas-station/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;加油站&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：一次遍历&quot;&gt;&lt;a href=&quot;#思路：一次遍历&quot; class=&quot;headerlink&quot; title=&quot;思路：一次遍历&quot;&gt;&lt;/a&gt;思路：一次遍历&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。&lt;/p&gt;
&lt;p&gt;你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。&lt;/p&gt;
&lt;p&gt;如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。&lt;/p&gt;
&lt;p&gt;说明: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果题目有解，该答案即为唯一答案。&lt;/li&gt;
&lt;li&gt;输入数组均为非空数组，且长度相同。&lt;/li&gt;
&lt;li&gt;输入数组中的元素均为非负数。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;gas  &amp;#x3D; [1,2,3,4,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cost &amp;#x3D; [3,4,5,1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 &amp;#x3D; 0 + 4 &amp;#x3D; 4 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;开往 4 号加油站，此时油箱有 4 - 1 + 5 &amp;#x3D; 8 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;开往 0 号加油站，此时油箱有 8 - 2 + 1 &amp;#x3D; 7 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;开往 1 号加油站，此时油箱有 7 - 3 + 2 &amp;#x3D; 6 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;开往 2 号加油站，此时油箱有 6 - 4 + 3 &amp;#x3D; 5 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因此，3 可为起始索引。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;gas  &amp;#x3D; [2,3,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cost &amp;#x3D; [3,4,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: -1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 &amp;#x3D; 0 + 4 &amp;#x3D; 4 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;开往 0 号加油站，此时油箱有 4 - 3 + 2 &amp;#x3D; 3 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;开往 1 号加油站，此时油箱有 3 - 3 + 3 &amp;#x3D; 3 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因此，无论怎样，你都不可能绕环路行驶一周。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1030-距离顺序排列矩阵单元格</title>
    <link href="http://zhuuu.work/2020/11/17/Leetcode/Leetcode-1030-%E8%B7%9D%E7%A6%BB%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97%E7%9F%A9%E9%98%B5%E5%8D%95%E5%85%83%E6%A0%BC/"/>
    <id>http://zhuuu.work/2020/11/17/Leetcode/Leetcode-1030-%E8%B7%9D%E7%A6%BB%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97%E7%9F%A9%E9%98%B5%E5%8D%95%E5%85%83%E6%A0%BC/</id>
    <published>2020-11-17T07:52:53.000Z</published>
    <updated>2020-11-17T03:41:20.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-1030-距离顺序排列矩阵单元格"><a href="#Leetcode-1030-距离顺序排列矩阵单元格" class="headerlink" title="Leetcode-1030-距离顺序排列矩阵单元格"></a>Leetcode-1030-<a href="https://leetcode-cn.com/problems/matrix-cells-in-distance-order/" target="_blank" rel="noopener">距离顺序排列矩阵单元格</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>给出 R 行 C 列的矩阵，其中的单元格的整数坐标为<code>(r, c)</code>，满足 <code>0 &lt;= r &lt; R</code>且<code>0 &lt;= c &lt; C。</code></p><p>另外，我们在该矩阵中给出了一个坐标为<code>(r0, c0)</code> 的单元格。</p><p>返回矩阵中的所有单元格的坐标，并按到 <code>(r0, c0)</code> 的距离从最小到最大的顺序排，其中，两单元格<code>(r1, c1) 和 (r2, c2)</code> 之间的距离是曼哈顿距离，<code>|r1 - r2| + |c1 - c2|</code>。（你可以按任何满足此条件的顺序返回答案。）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：R &#x3D; 1, C &#x3D; 2, r0 &#x3D; 0, c0 &#x3D; 0</span><br><span class="line">输出：[[0,0],[0,1]]</span><br><span class="line">解释：从 (r0, c0) 到其他单元格的距离为：[0,1]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：R &#x3D; 2, C &#x3D; 2, r0 &#x3D; 0, c0 &#x3D; 1</span><br><span class="line">输出：[[0,1],[0,0],[1,1],[1,0]]</span><br><span class="line">解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2]</span><br><span class="line">[[0,1],[1,1],[0,0],[1,0]] 也会被视作正确答案。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：R &#x3D; 2, C &#x3D; 3, r0 &#x3D; 1, c0 &#x3D; 2</span><br><span class="line">输出：[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]</span><br><span class="line">解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2,2,3]</span><br><span class="line">其他满足题目要求的答案也会被视为正确，例如 [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法一-：-暴力排序"><a href="#方法一-：-暴力排序" class="headerlink" title="方法一 ： 暴力排序"></a>方法一 ： 暴力排序</h2><ul><li>最容易想到的方法是首先存储矩阵内所有的点，然后将其按照哈曼顿距离直接排序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] allCellsDistOrder(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] ret = <span class="keyword">new</span> <span class="keyword">int</span>[R * C][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">                ret[i * C + j] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(ret, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (Math.abs(a[<span class="number">0</span>] - r0) + Math.abs(a[<span class="number">1</span>] - c0)) - (Math.abs(b[<span class="number">0</span>] - r0) + Math.abs(b[<span class="number">1</span>] - c0));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201117/113741576.png" alt="mark"></p><h2 id="方法二-：桶排序"><a href="#方法二-：桶排序" class="headerlink" title="方法二 ：桶排序"></a>方法二 ：桶排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用桶排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] allCellsDistOrder(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) &#123;</span><br><span class="line">        <span class="comment">// 计算需要几个桶 并把创建相应数量的桶</span></span><br><span class="line">        <span class="keyword">int</span> maxDist = Math.max(r0,R - <span class="number">1</span> - r0) + Math.max(c0, C- <span class="number">1</span> - c0);</span><br><span class="line">        List&lt;List&lt;<span class="keyword">int</span>[]&gt;&gt; bucket = <span class="keyword">new</span> ArrayList&lt;List&lt;<span class="keyword">int</span>[]&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxDist;i++)&#123;</span><br><span class="line">            bucket.add(<span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算出哈曼顿距离 并结果加入到相应的桶里面(时间复杂度 O(RC))</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; R;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; C;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> d = dist(i,j,r0,c0);</span><br><span class="line">                bucket.get(d).add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建结果集，并把Arraylist&lt;List&lt;int[]&gt; 转换成int[][]</span></span><br><span class="line">        <span class="keyword">int</span>[][] ret = <span class="keyword">new</span> <span class="keyword">int</span>[R*C][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历每个桶,把桶中的元素加入到结果集中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= maxDist;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] it:bucket.get(i))&#123;</span><br><span class="line">                ret[idx++] = it;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算哈曼顿距离（排序方法）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> r1,<span class="keyword">int</span> c1,<span class="keyword">int</span> r2,<span class="keyword">int</span> c2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(r1 - r2) + Math.abs(c1 - c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201117/114113486.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-1030-距离顺序排列矩阵单元格&quot;&gt;&lt;a href=&quot;#Leetcode-1030-距离顺序排列矩阵单元格&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-1030-距离顺序排列矩阵单元格&quot;&gt;&lt;/a&gt;Leetcode-1030-&lt;a href=&quot;https://leetcode-cn.com/problems/matrix-cells-in-distance-order/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;距离顺序排列矩阵单元格&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;给出 R 行 C 列的矩阵，其中的单元格的整数坐标为&lt;code&gt;(r, c)&lt;/code&gt;，满足 &lt;code&gt;0 &amp;lt;= r &amp;lt; R&lt;/code&gt;且&lt;code&gt;0 &amp;lt;= c &amp;lt; C。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;另外，我们在该矩阵中给出了一个坐标为&lt;code&gt;(r0, c0)&lt;/code&gt; 的单元格。&lt;/p&gt;
&lt;p&gt;返回矩阵中的所有单元格的坐标，并按到 &lt;code&gt;(r0, c0)&lt;/code&gt; 的距离从最小到最大的顺序排，其中，两单元格&lt;code&gt;(r1, c1) 和 (r2, c2)&lt;/code&gt; 之间的距离是曼哈顿距离，&lt;code&gt;|r1 - r2| + |c1 - c2|&lt;/code&gt;。（你可以按任何满足此条件的顺序返回答案。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：R &amp;#x3D; 1, C &amp;#x3D; 2, r0 &amp;#x3D; 0, c0 &amp;#x3D; 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[[0,0],[0,1]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：从 (r0, c0) 到其他单元格的距离为：[0,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：R &amp;#x3D; 2, C &amp;#x3D; 2, r0 &amp;#x3D; 0, c0 &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[[0,1],[0,0],[1,1],[1,0]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[0,1],[1,1],[0,0],[1,0]] 也会被视作正确答案。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：R &amp;#x3D; 2, C &amp;#x3D; 3, r0 &amp;#x3D; 1, c0 &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2,2,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;其他满足题目要求的答案也会被视为正确，例如 [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="桶排序" scheme="http://zhuuu.work/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="BFS" scheme="http://zhuuu.work/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-402-移除K个数</title>
    <link href="http://zhuuu.work/2020/11/15/Leetcode/Leetcode-402-%E7%A7%BB%E9%99%A4K%E4%B8%AA%E6%95%B0/"/>
    <id>http://zhuuu.work/2020/11/15/Leetcode/Leetcode-402-%E7%A7%BB%E9%99%A4K%E4%B8%AA%E6%95%B0/</id>
    <published>2020-11-15T07:52:53.000Z</published>
    <updated>2020-11-15T01:32:21.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-409-移掉K位数字"><a href="#Leecode-409-移掉K位数字" class="headerlink" title="Leecode-409-移掉K位数字"></a>Leecode-409-<a href="https://leetcode-cn.com/problems/remove-k-digits/" target="_blank" rel="noopener">移掉K位数字</a></h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h2><ul><li>给定一个以字符串表示的非负整数 <em>num*，移除这个数中的 *k</em> 位数字，使得剩下的数字最小。</li></ul><p><strong>注意:</strong></p><ul><li><em>num</em> 的长度小于 10002 且 ≥ <em>k。</em></li><li><em>num</em> 不会包含任何前导零。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1 :</span><br><span class="line"></span><br><span class="line">输入: num &#x3D; &quot;1432219&quot;, k &#x3D; 3</span><br><span class="line">输出: &quot;1219&quot;</span><br><span class="line">解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。</span><br><span class="line"></span><br><span class="line">示例 2 :</span><br><span class="line"></span><br><span class="line">输入: num &#x3D; &quot;10200&quot;, k &#x3D; 1</span><br><span class="line">输出: &quot;200&quot;</span><br><span class="line">解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</span><br><span class="line"></span><br><span class="line">示例 3 :</span><br><span class="line"></span><br><span class="line">输入: num &#x3D; &quot;10&quot;, k &#x3D; 2</span><br><span class="line">输出: &quot;0&quot;</span><br><span class="line">解释: 从原数字移除所有的数字，剩余为空就是0。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法-：-贪心算法"><a href="#方法-：-贪心算法" class="headerlink" title="方法 ： 贪心算法"></a><strong>方法 ： 贪心算法</strong></h2><p><strong>官方很好的题解 ：</strong> <a href="https://leetcode-cn.com/problems/remove-k-digits/solution/yi-diao-kwei-shu-zi-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-k-digits/solution/yi-diao-kwei-shu-zi-by-leetcode-solution/</a></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201115/093033535.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeKdigits</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Character&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次丢弃一次，k 减去 1。当 k 减到 0 ，我们可以提前终止遍历。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> digit : num.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">while</span>(stack.size() &gt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span> &amp;&amp; stack.peekLast() &gt; digit)&#123;</span><br><span class="line">                stack.removeLast();</span><br><span class="line">                k -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.addLast(digit);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 而当遍历完成，如果 k 仍然大于 0。</span></span><br><span class="line">        <span class="comment">// 不妨假设最终还剩下 x 个需要丢弃，那么我们需要选择删除末尾 x 个元素。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">            stack.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder ret = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// 处理删除后的前导0，直接跳过即可</span></span><br><span class="line">        <span class="keyword">boolean</span> leadingZero = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> digit:stack)&#123;</span><br><span class="line">            <span class="keyword">if</span>(leadingZero &amp;&amp; digit == <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            leadingZero = <span class="keyword">false</span>;</span><br><span class="line">            ret.append(digit);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终数字序列为空的话,返回0</span></span><br><span class="line">        <span class="keyword">if</span>(ret.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度 ： O(n)，其中 n 为字符串的长度。尽管存在嵌套循环，但内部循环最多运行 k次。</strong>由于<code>0&lt;k≤n</code>，主循环的时间复杂度被限制在 <code>2n</code>以内。对于主循环之外的逻辑，它们的时间复杂度是 O(n)，因此总时间复杂度为 O(n)。</li><li><strong>空间复杂度 ： O(n) 栈所需要的空间大小</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-409-移掉K位数字&quot;&gt;&lt;a href=&quot;#Leecode-409-移掉K位数字&quot; class=&quot;headerlink&quot; title=&quot;Leecode-409-移掉K位数字&quot;&gt;&lt;/a&gt;Leecode-409-&lt;a href=&quot;https://leetcode-cn.com/problems/remove-k-digits/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;移掉K位数字&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给定一个以字符串表示的非负整数 &lt;em&gt;num*，移除这个数中的 *k&lt;/em&gt; 位数字，使得剩下的数字最小。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;num&lt;/em&gt; 的长度小于 10002 且 ≥ &lt;em&gt;k。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;num&lt;/em&gt; 不会包含任何前导零。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1 :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: num &amp;#x3D; &amp;quot;1432219&amp;quot;, k &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;1219&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2 :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: num &amp;#x3D; &amp;quot;10200&amp;quot;, k &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;200&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3 :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: num &amp;#x3D; &amp;quot;10&amp;quot;, k &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;0&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 从原数字移除所有的数字，剩余为空就是0。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="贪心算法" scheme="http://zhuuu.work/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1122-数组的相对排序</title>
    <link href="http://zhuuu.work/2020/11/14/Leetcode/Leetcode-1122-%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhuuu.work/2020/11/14/Leetcode/Leetcode-1122-%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/</id>
    <published>2020-11-14T07:52:53.000Z</published>
    <updated>2020-11-14T01:22:40.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-1122-数组的相对排序https-leetcode-cn-com-problems-maximum-nesting-depth-of-two-valid-parentheses-strings"><a href="#Leecode-1122-数组的相对排序https-leetcode-cn-com-problems-maximum-nesting-depth-of-two-valid-parentheses-strings" class="headerlink" title="Leecode-1122-数组的相对排序https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/)"></a>Leecode-1122-<a href="https://leetcode-cn.com/problems/relative-sort-array/" target="_blank" rel="noopener">数组的相对排序</a><a href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/</a>)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给你两个数组，arr1 和 arr2，</span><br><span class="line"></span><br><span class="line">arr2 中的元素各不相同</span><br><span class="line">arr2 中的每个元素都出现在 arr1 中</span><br><span class="line">对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：arr1 &#x3D; [2,3,1,3,2,4,6,7,9,2,19], arr2 &#x3D; [2,1,4,3,9,6]</span><br><span class="line">输出：[2,2,2,1,4,3,3,9,6,7,19]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">arr1.length, arr2.length &lt;&#x3D; 1000</span><br><span class="line">0 &lt;&#x3D; arr1[i], arr2[i] &lt;&#x3D; 1000</span><br><span class="line">arr2 中的元素 arr2[i] 各不相同</span><br><span class="line">arr2 中的每个元素 arr2[i] 都出现在 arr1 中</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法-：-计数排序"><a href="#方法-：-计数排序" class="headerlink" title="方法 ： 计数排序"></a>方法 ： 计数排序</h2><ul><li>注意到本题中元素的范围为 [0, 1000][0,1000]，这个范围不是很大，我们也可以考虑不基于比较的排序，例如「计数排序」。</li></ul><p><strong>具体算法</strong></p><ol><li><p>使用长度为1001【下标0 - 1000】 的数组<code>frequency</code> 记录每一个元素在<code>arr1</code> 中出现的次数 </p></li><li><p>随后遍历数组<code>arr2</code>,当遍历到元素x的时候。将<code>frequency[x]</code> 放入到结果集中，并将<code>frequency[x]</code>清0</p></li><li><p>此时还剩下没有在<code>arr2</code> 中出现过的元素，因此我们还需要对整个数组<code>frequency</code> 进行一次遍历。当遍历到x时，如果<code>frequency[x]!=0</code> ，说明这个元素没有在arr2中出现，那么将这个元素添加到答案的最后。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] relativeSortArray(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2) &#123;</span><br><span class="line">        <span class="comment">// 本题中元素的范围是[0,1000] 这个范围不是很大，可以不考虑比较排序，例如【计数排序】</span></span><br><span class="line">        <span class="comment">// 对空间的优化，使用比数组arr1中最大值upper 使用长度upper + 1;</span></span><br><span class="line">        <span class="keyword">int</span> upper = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:arr1)&#123;</span><br><span class="line">            upper = Math.max(upper,x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录每个数出现的次数</span></span><br><span class="line">        <span class="keyword">int</span>[] frequency = <span class="keyword">new</span> <span class="keyword">int</span>[upper + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:arr1)&#123;</span><br><span class="line">            ++frequency[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组arr2，当遍历到元素x的时候</span></span><br><span class="line">        <span class="comment">// 将frequency[x] 放入到结果集中，并将frequency[x]清0</span></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[arr1.length];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:arr2)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; frequency[x];i++)&#123;</span><br><span class="line">                ans[idx++] = x;</span><br><span class="line">            &#125;</span><br><span class="line">            frequency[x] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将frequency[x]中剩余的数字放入到结果集中</span></span><br><span class="line">        <span class="comment">// 按照frequency中的升序放入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>;x &lt;= upper;++x)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; frequency[x];++i)&#123;</span><br><span class="line">                ans[idx++] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(<code>m + n + upper</code>)</li><li>空间复杂度 :   O(<code>upper</code>),即为<code>frequency</code>数组使用的空间</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-1122-数组的相对排序https-leetcode-cn-com-problems-maximum-nesting-depth-of-two-valid-parentheses-strings&quot;&gt;&lt;a href=&quot;#Leecode-1122-数组的相对排序https-leetcode-cn-com-problems-maximum-nesting-depth-of-two-valid-parentheses-strings&quot; class=&quot;headerlink&quot; title=&quot;Leecode-1122-数组的相对排序https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/)&quot;&gt;&lt;/a&gt;Leecode-1122-&lt;a href=&quot;https://leetcode-cn.com/problems/relative-sort-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数组的相对排序&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/&lt;/a&gt;)&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给你两个数组，arr1 和 arr2，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr2 中的元素各不相同&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr2 中的每个元素都出现在 arr1 中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：arr1 &amp;#x3D; [2,3,1,3,2,4,6,7,9,2,19], arr2 &amp;#x3D; [2,1,4,3,9,6]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[2,2,2,1,4,3,3,9,6,7,19]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr1.length, arr2.length &amp;lt;&amp;#x3D; 1000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0 &amp;lt;&amp;#x3D; arr1[i], arr2[i] &amp;lt;&amp;#x3D; 1000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr2 中的元素 arr2[i] 各不相同&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr2 中的每个元素 arr2[i] 都出现在 arr1 中&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="计数排序" scheme="http://zhuuu.work/tags/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-观察者模式</title>
    <link href="http://zhuuu.work/2020/11/13/GoF23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zhuuu.work/2020/11/13/GoF23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-11-13T07:02:24.000Z</published>
    <updated>2020-11-16T09:50:42.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式-观察者模式"><a href="#设计模式-观察者模式" class="headerlink" title="设计模式-观察者模式"></a>设计模式-观察者模式</h1><h4 id="观察者模式（Obersver）"><a href="#观察者模式（Obersver）" class="headerlink" title="观察者模式（Obersver）"></a>观察者模式（Obersver）</h4><ul><li><strong>观察者模式是使用频率非常高的模式了，它定义了对象间一种一对多的关系，使得每当一个对象改变状态，则所有依赖它的对象都会收到通知，并且自动更新。</strong></li><li><strong>例如：<code>Java</code>中的监听器<code>Listener</code>用的就是观察者模式。</strong></li></ul><p><strong>UML类图：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200624/094333516.png" alt="mark"></p><ul><li><strong><code>Subject:</code> 具有注册和移除观察者，并且通知观察者的功能，主体是通过某种数据结构（可能是列表）来维护一张观察者列表实现这些操作的。</strong></li><li><strong>观察者（<code>Observer</code>）的注册功能需要调用主体的<code>registerObserver()</code>方法。</strong></li></ul><a id="more"></a><p><strong>实现：</strong></p><ul><li>开发<strong>技术周报</strong>，每周会更新一些内容，但是不知道具体的更新时间，又想第一时间阅读更新内容。</li><li>难道要一直按住<code>F5</code>等它更新么？那估计<code>F5</code>烂了可能都没有更新。其实我们只需要简单的订阅一下就好，当有新的内容更新的时候，会发邮件到你订阅的邮箱中。</li></ul><p>上述例子中：</p><ul><li>订阅者就是观察者，技术周报就是被观察者</li></ul><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"><span class="keyword">import</span> java.util.Observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者：程序员</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coder</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Coder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"收到的更新内容为"</span> + o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 被观察者：主体（开发周报）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weekly</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一对多的通知</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加一个观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除一个观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        observers.forEach(observer -&gt; observer.update(<span class="string">"数据更新了"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK中自带的观察者模式的类</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200624/103921192.png" alt="mark"></p><ul><li><strong>在<code>java.util</code> 包中内置了<code>Observer</code> 和 <code>observable</code>类,同时<code>Observable</code>类实现了注册和反注册等方法，使用起来方便很多。可见观察者模式是非常重要的。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Vector&lt;java.util.Observer&gt; obs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Observable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obs = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (!obs.contains(o)) &#123;</span><br><span class="line">            obs.addElement(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反注册</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        obs.removeElement(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反注册所有观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obs.removeAllElements();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知更新</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        notifyObservers(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知更新</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        Object[] arrLocal;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!changed)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            arrLocal = obs.toArray();</span><br><span class="line">            clearChanged();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arrLocal.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">            ((Observer)arrLocal[i]).update(<span class="keyword">this</span>, arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        changed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clearChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        changed = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">hasChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> changed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">countObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obs.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>Observer</code>接口则是比较简单的代码</strong>，<code>update()</code>的参数中除了可以传递数据意外，还提供了被观察者的引用对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is called whenever the observed object is changed. An</span></span><br><span class="line"><span class="comment">     * application calls an &lt;tt&gt;Observable&lt;/tt&gt; object's</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;notifyObservers&lt;/code&gt; method to have all the object's</span></span><br><span class="line"><span class="comment">     * observers notified of the change.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   o     the observable object.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   arg   an argument passed to the &lt;code&gt;notifyObservers&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     *                 method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK中的实现：</strong></p><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Observer.html" target="_blank" rel="noopener">java.util.Observer</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/EventListener.html" target="_blank" rel="noopener">java.util.EventListener</a></li><li><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionBindingListener.html" target="_blank" rel="noopener">javax.servlet.http.HttpSessionBindingListener</a></li><li><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;设计模式-观察者模式&quot;&gt;&lt;a href=&quot;#设计模式-观察者模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式-观察者模式&quot;&gt;&lt;/a&gt;设计模式-观察者模式&lt;/h1&gt;&lt;h4 id=&quot;观察者模式（Obersver）&quot;&gt;&lt;a href=&quot;#观察者模式（Obersver）&quot; class=&quot;headerlink&quot; title=&quot;观察者模式（Obersver）&quot;&gt;&lt;/a&gt;观察者模式（Obersver）&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;观察者模式是使用频率非常高的模式了，它定义了对象间一种一对多的关系，使得每当一个对象改变状态，则所有依赖它的对象都会收到通知，并且自动更新。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;例如：&lt;code&gt;Java&lt;/code&gt;中的监听器&lt;code&gt;Listener&lt;/code&gt;用的就是观察者模式。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;UML类图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200624/094333516.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Subject:&lt;/code&gt; 具有注册和移除观察者，并且通知观察者的功能，主体是通过某种数据结构（可能是列表）来维护一张观察者列表实现这些操作的。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;观察者（&lt;code&gt;Observer&lt;/code&gt;）的注册功能需要调用主体的&lt;code&gt;registerObserver()&lt;/code&gt;方法。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="设计模式" scheme="http://zhuuu.work/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-模板方法模式</title>
    <link href="http://zhuuu.work/2020/11/13/GoF23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zhuuu.work/2020/11/13/GoF23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-11-13T07:02:24.000Z</published>
    <updated>2020-11-19T11:12:26.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式-模板方法模式"><a href="#设计模式-模板方法模式" class="headerlink" title="设计模式-模板方法模式"></a>设计模式-模板方法模式</h1><h2 id="模板方法模式（Template-Method）"><a href="#模板方法模式（Template-Method）" class="headerlink" title="模板方法模式（Template Method）"></a>模板方法模式（Template Method）</h2><ul><li>动机：对于一项任务，常常有<strong>稳定的整体操作结构</strong>，但各个子步骤却又很多改变的需求，或者需要子步骤的晚期实现（<strong>延迟到子类去实现</strong>）。</li><li><strong><code>Template Method</code>使得子类可以复用一个算法的结构</strong>（<code>Override</code> 重写）该算法的某些特定步骤。</li><li><strong>不要调用我，让我来调用你，实现晚绑定机制</strong>，<strong>这也就是控制反转的思想。</strong></li><li><strong>声明成 <code>protected</code> ,因为具体步骤在流程中才有意义。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200615/161657528.png" alt="mark"></p><ul><li><strong>AbstractClass : 稳定的骨架（里面有具体的方法和需要被重写的方法）</strong></li><li><strong>ContreteClass : 具体的重写方法</strong></li></ul><p><strong>模板方法模式定义</strong>（特别的常用）：</p><ul><li><strong>定义一个操作中的算法的骨架（稳定） ,而将一些步骤（变化）延迟到子类中。</strong></li><li><strong>Template Method 使得子类可以不改变（复用）一个算法的结构即可（Override 重写）该算法某些特定的步骤</strong></li></ul><a id="more"></a><ul><li>具体实现（举例）</li></ul><p>冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200615/162632540.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 骨架流程</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepareRecipe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        boilWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourIncoup();</span><br><span class="line">        addCondiments();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待重写的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待重写的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pourIncoup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"倒进杯子"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">boilWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"倒水"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"倒咖啡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"加入咖啡粉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tea</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"倒茶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"加入茶叶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractClass coffee = <span class="keyword">new</span> Coffee();</span><br><span class="line">        coffee.prepareRecipe();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"========"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        AbstractClass tea = <span class="keyword">new</span> Tea();</span><br><span class="line">        tea.prepareRecipe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果显示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">倒水</span><br><span class="line">倒咖啡</span><br><span class="line">倒进杯子</span><br><span class="line">加入咖啡粉</span><br><span class="line">========</span><br><span class="line">倒水</span><br><span class="line">倒茶</span><br><span class="line">倒进杯子</span><br><span class="line">加入茶叶</span><br></pre></td></tr></table></figure><p><strong>JDK中实现：</strong></p><ul><li><code>java.util.Collections#sort()</code></li><li><code>java.io.InputStream#skip()</code></li><li><code>java.io.InputStream#read()</code></li><li><code>java.util.AbstractList#indexOf()</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;设计模式-模板方法模式&quot;&gt;&lt;a href=&quot;#设计模式-模板方法模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式-模板方法模式&quot;&gt;&lt;/a&gt;设计模式-模板方法模式&lt;/h1&gt;&lt;h2 id=&quot;模板方法模式（Template-Method）&quot;&gt;&lt;a href=&quot;#模板方法模式（Template-Method）&quot; class=&quot;headerlink&quot; title=&quot;模板方法模式（Template Method）&quot;&gt;&lt;/a&gt;模板方法模式（Template Method）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;动机：对于一项任务，常常有&lt;strong&gt;稳定的整体操作结构&lt;/strong&gt;，但各个子步骤却又很多改变的需求，或者需要子步骤的晚期实现（&lt;strong&gt;延迟到子类去实现&lt;/strong&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Template Method&lt;/code&gt;使得子类可以复用一个算法的结构&lt;/strong&gt;（&lt;code&gt;Override&lt;/code&gt; 重写）该算法的某些特定步骤。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要调用我，让我来调用你，实现晚绑定机制&lt;/strong&gt;，&lt;strong&gt;这也就是控制反转的思想。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;声明成 &lt;code&gt;protected&lt;/code&gt; ,因为具体步骤在流程中才有意义。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200615/161657528.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;AbstractClass : 稳定的骨架（里面有具体的方法和需要被重写的方法）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ContreteClass : 具体的重写方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;模板方法模式定义&lt;/strong&gt;（特别的常用）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义一个操作中的算法的骨架（稳定） ,而将一些步骤（变化）延迟到子类中。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Template Method 使得子类可以不改变（复用）一个算法的结构即可（Override 重写）该算法某些特定的步骤&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="设计模式" scheme="http://zhuuu.work/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-031-下一个排列</title>
    <link href="http://zhuuu.work/2020/11/10/Leetcode/Leetcode-031-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <id>http://zhuuu.work/2020/11/10/Leetcode/Leetcode-031-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</id>
    <published>2020-11-10T02:52:53.000Z</published>
    <updated>2020-11-10T01:20:54.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-031-下一个排列"><a href="#Leecode-031-下一个排列" class="headerlink" title="Leecode-031-下一个排列"></a>Leecode-031-<a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">下一个排列</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>实现获取<strong>下一个排列的函数</strong>，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p></li><li><p>如果<strong>不存在下一个更大的排列</strong>，则将<strong>数字重新排列成最小的排列（即升序排列）。</strong></p></li><li><p>必须<strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地</a></strong>修改，只允许使用额外常数空间。</p></li></ul><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br><code>1,2,3</code> → <code>1,3,2</code><br><code>3,2,1</code> → <code>1,2,3</code><br><code>1,1,5</code> → <code>1,5,1</code></p><a id="more"></a><h2 id="字典序"><a href="#字典序" class="headerlink" title="字典序"></a>字典序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">本题要求我们实现一个算法，将给定数字序列重新排列成字典序中下一个更大的排列。</span><br><span class="line"></span><br><span class="line">以数字序列 [1,2,3][1,2,3] 为例，其排列按照字典序依次为：</span><br><span class="line">[1,2,3]\\ [1,3,2]\\ [2,1,3]\\ [2,3,1]\\ [3,1,2]\\ [3,2,1]</span><br><span class="line"></span><br><span class="line">这样，排列 [2,3,1] 的下一个排列即为 [3,1,2]。特别的，最大的排列 [3,2,1] 的下一个排列为最小的排列 [1,2,3]。</span><br></pre></td></tr></table></figure><h2 id="方法：两边扫描"><a href="#方法：两边扫描" class="headerlink" title="方法：两边扫描"></a>方法：两边扫描</h2><p>注意到下一个排列总是比当前排列要大，除非该排列已经是最大的排列。我们希望找到一种方法，<strong>能够找到一个大于当前序列的新序列，且变大的幅度尽可能小</strong>。具体地：</p><ol><li>我们需要将一个<strong>左边的「较小数」与一个右边的「较大数」交换</strong>，以能够让当前排列变大，从而得到下一个排列。</li><li>同时我们要让这个「<strong>较小数」尽量靠右，而「较大数」尽可能小</strong>。</li><li><strong>当交换完成后，「较大数」右边的数需要按照升序重新排列</strong>。这样可以在保证新排列大于原来排列的情况下，使变大的幅</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以排列 [4,5,2,6,3,1] 为例：</span><br><span class="line"></span><br><span class="line">我们能找到的符合条件的一对「较小数」与「较大数」的组合为 2 与 3，满足「较小数」尽量靠右，而「较大数」尽可能小。</span><br><span class="line"></span><br><span class="line">当我们完成交换后排列变为 [4,5,3,6,2,1]，此时我们可以重排「较小数」右边的序列，序列变为 [4,5,3,1,2,6]。</span><br></pre></td></tr></table></figure><p><strong>具体地，我们这样描述该算法，对于长度为 n的排列 a：</strong></p><ol><li><p>首先从后向前查找第一个顺序对 <code>(i,i+1)</code>，满足 <code>a[i] &lt; a[i+1]</code>。这样「较小数」即为 <code>a[i]</code>。此时 <code>[i+1,n)</code>必然是下降序列。</p></li><li><p>如果找到了顺序对，那么在区间<code>[i+1,n)</code>中从后向前查找第一个元素 <code>j</code> 满足 <code>a[i] &lt; a[j]a[i]&lt;a[j]</code>。这样「较大数」即为 <code>a[j]</code>。</p></li><li><p>交换<code>a[i] 与 a[j]</code>，此时可以证明区间<code>[i+1,n)</code>必为降序。我们可以直接使用双指针反转区间 <code>[i+1,n)</code>使其变为升序，而无需对该区间进行排序。</p></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201110/090035559.gif" alt="mark"></p><p><strong>注意</strong></p><p><strong>如果在步骤 1 找不到顺序对，说明当前序列已经是一个降序序列，即最大的序列，我们直接跳过步骤 2 执行步骤 3，即可得到最小的升序序列。</strong></p><p><strong>该方法支持序列中存在重复元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = nums.length - <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从后向前扫描 找到较小数</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>])&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时(i + 1,n] 一定是下降序列</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)&#123; <span class="comment">// 如果这个条件不满足，说明当前序列已经是一个降序序列，即最大的序列 ，所以直接进行翻转reverser即可</span></span><br><span class="line">            <span class="comment">// 从[i + 1,n)从后往前查找</span></span><br><span class="line">            <span class="comment">// 找到丢一个元素j 满足 a[i] &lt; a[j] </span></span><br><span class="line">            <span class="comment">// 较大数即为 a[j]</span></span><br><span class="line">            <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j])&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 交换a[i] 和 a[j]</span></span><br><span class="line">            swap(nums,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时[i + 1,n) 一定是降序序列</span></span><br><span class="line">        reverse(nums,i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i]  = nums[j];</span><br><span class="line">        nums[j]  = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用双指针翻转区间[i + 1,n)</span></span><br><span class="line">    <span class="comment">// 使得该区间变成升序序列，而无需对区间进行排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left  = start;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            swap(nums,left,right);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：O(N)，其中 N为给定序列的长度。我们至多只需要扫描两次序列，以及进行一次反转操作。</li><li><strong>空间复杂度</strong>：O(1)，只需要常数的空间存放若干变量。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-031-下一个排列&quot;&gt;&lt;a href=&quot;#Leecode-031-下一个排列&quot; class=&quot;headerlink&quot; title=&quot;Leecode-031-下一个排列&quot;&gt;&lt;/a&gt;Leecode-031-&lt;a href=&quot;https://leetcode-cn.com/problems/next-permutation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;下一个排列&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;实现获取&lt;strong&gt;下一个排列的函数&lt;/strong&gt;，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果&lt;strong&gt;不存在下一个更大的排列&lt;/strong&gt;，则将&lt;strong&gt;数字重新排列成最小的排列（即升序排列）。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;必须&lt;strong&gt;&lt;a href=&quot;https://baike.baidu.com/item/原地算法&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原地&lt;/a&gt;&lt;/strong&gt;修改，只允许使用额外常数空间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是一些例子，输入位于左侧列，其相应输出位于右侧列。&lt;br&gt;&lt;code&gt;1,2,3&lt;/code&gt; → &lt;code&gt;1,3,2&lt;/code&gt;&lt;br&gt;&lt;code&gt;3,2,1&lt;/code&gt; → &lt;code&gt;1,2,3&lt;/code&gt;&lt;br&gt;&lt;code&gt;1,1,5&lt;/code&gt; → &lt;code&gt;1,5,1&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Netty-13-TCP粘包和拆包</title>
    <link href="http://zhuuu.work/2020/11/08/Netty/Netty-13-TCP%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/"/>
    <id>http://zhuuu.work/2020/11/08/Netty/Netty-13-TCP%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/</id>
    <published>2020-11-08T02:05:24.000Z</published>
    <updated>2020-11-09T02:34:46.880Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-13-TCP粘包和拆包"><a href="#Netty-13-TCP粘包和拆包" class="headerlink" title="Netty-13-TCP粘包和拆包"></a>Netty-13-TCP粘包和拆包</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>TCP是面向连接的，面向流的，提供高可靠性服务。</li><li>收发两端（<strong>客户端和服务器端）</strong>都要有一一成对的socket，因此，发送端为了将多个发给接收端的包，更有效的发给对方，<strong>使用了优化方法（Nagle算法</strong>），将多次<strong>间隔较小且数据量小</strong>的数据，合并成一个大的数据块，然后进行封包。</li><li>这样做虽然提高了效率，但是<strong>接收端就难于分辨出完整的数据包</strong>了，因为<strong>面向流的通信是无消息保护边界</strong>的</li></ul><p><strong>通常的解决方案</strong></p><ol><li><p><strong>发送端</strong>每发送一次消息，就需要在消息的内容之前<strong>携带消息的长度</strong></p></li><li><p>这样，<strong>接收方</strong>每次先接受消息的长度，再<strong>根据长度去读取消息剩余的元素</strong></p></li><li><p>如果 <code>socket</code> 中还有没有读取的内容，也只能放在下一次读取事件中读取</p></li></ol><a id="more"></a><h2 id="1-拆包、粘包的图解"><a href="#1-拆包、粘包的图解" class="headerlink" title="1. 拆包、粘包的图解"></a>1. 拆包、粘包的图解</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201109/091157126.png" alt="mark"></p><p>假设客户端同时发送了两个数据包D1和D2给服务端，由于服务端一次读取到字节数是不确定的，固可能存在以下四种情况：</p><ol><li><p>服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包</p></li><li><p>服务端一次接受到了两个数据包，D1和D2粘合在一起，<strong>称之为TCP粘包</strong></p></li><li><p>服务端分两次读取到了数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这<strong>称之为TCP拆包</strong></p></li><li><p>服务端分两次读取到了数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余部分内容D1_2和完整的D2包。</p></li></ol><h2 id="2-TCP-拆包、粘包"><a href="#2-TCP-拆包、粘包" class="headerlink" title="2. TCP  拆包、粘包"></a>2. TCP  拆包、粘包</h2><p> 本实例主要演示出现拆包和粘包的场景。</p><p><strong>客户端：</strong></p><p> 我们将使用循环连续发送10个<code>String</code>类型的字符串。这里相当于发送了10次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//使用客户端发送10条数据，hello，server</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        String msg = <span class="string">"server"</span> + i + <span class="string">"  "</span>;</span><br><span class="line">        System.out.println(<span class="string">"发送消息 "</span> + msg);</span><br><span class="line">        ByteBuf byteBuf = Unpooled.copiedBuffer(msg, CharsetUtil.UTF_8);</span><br><span class="line">        ctx.writeAndFlush(byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>服务端：</strong></p><p> 我们接受客户端发过来的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[msg.readableBytes()];</span><br><span class="line">    msg.readBytes(bytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将buffer转成字符串</span></span><br><span class="line">    String message = <span class="keyword">new</span> String(bytes, CharsetUtil.UTF_8);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"服务器接收到数据 "</span> + message);</span><br><span class="line">    System.out.println(<span class="string">"服务器接收到消息量 = "</span> + (++<span class="keyword">this</span>.count));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器回送数据到客户端，回送一个随机Id</span></span><br><span class="line">    ByteBuf response = Unpooled.copiedBuffer(UUID.randomUUID().toString() + <span class="string">"--"</span>, CharsetUtil.UTF_8);</span><br><span class="line">    ctx.writeAndFlush(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端输出结果如下：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201109/091543240.png" alt="mark"></p><ul><li>可以看到，服务端直接一次就把我们客户端10次发送的内容读取完成了。</li><li>这里也印证了我们开篇所说的，当<strong>数据量小且发送间隔短</strong>，如果我们客户端每次发送的都是不同的结果，这种情况下我们就不知道客户端返回了多少次结果以及每次结果究竟是什么。这就是我们本篇需要解决的问题。</li></ul><h2 id="3-TCP-问题解决方案"><a href="#3-TCP-问题解决方案" class="headerlink" title="3. TCP 问题解决方案"></a>3. TCP 问题解决方案</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201109/091255970.png" alt="mark"></p><ul><li><strong>在数据包的前面加上一个固定字节数的数据长度</strong>，如加上一个 <code>int</code> (固定四个字节）类型的数据内容长度</li><li>就算客户端同时发送两个数据包到服务端，当服务端接收时，也可以先读取四个字节的长度，然后根据长度获取相应消息的内容，这样就不会出现多读取或者少读取的情况了。</li></ul><h3 id="3-1-解决方案代码演示"><a href="#3-1-解决方案代码演示" class="headerlink" title="3.1 解决方案代码演示"></a>3.1 解决方案代码演示</h3><ul><li><p><strong>使用自定义协议 + 编解码器 来解决</strong></p></li><li><p>关键就是要解决 <strong>服务器端每次读取数据长度的问题</strong></p></li><li><p>这个问题解决，就不会出现服务器多读或少读数据的问题，从而避免的TCP 粘包、拆包 。</p></li></ul><ol><li><strong>自定义协议(重要)</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义协议</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len; <span class="comment">//关键</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLen</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLen</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.len = len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getContent()&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(<span class="keyword">byte</span>[] content)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>客户端引导器</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">MyClientInitializer</span>())</span>; <span class="comment">// 自定义初始化类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">"localhost"</span>, <span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync(); <span class="comment">// 监听关闭端口事件</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭连接</span></span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>客户端pipeline</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加入多个handler</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyMessageEncoder()); <span class="comment">// 加入编码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyMessageDecoder()); <span class="comment">// 加入解码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyClientHandler());  <span class="comment">// 加入自定义处理器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>客户端Handler(重要)</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 记录发送了几条消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 客户端发送5条数据 "今天天气冷，吃火锅" 编号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            String msg = <span class="string">"今天天气冷，吃火锅"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 封装数据对象</span></span><br><span class="line">            <span class="keyword">byte</span>[] content = msg.getBytes(Charset.forName(<span class="string">"utf-8"</span>));     <span class="comment">// 数据内容转换成字节数组</span></span><br><span class="line">            <span class="keyword">int</span> length = msg.getBytes(Charset.forName(<span class="string">"utf-8"</span>)).length;  <span class="comment">// 数据长度</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 封装成自定义数据包对象</span></span><br><span class="line">            Message message = <span class="keyword">new</span> Message();</span><br><span class="line">            message.setLen(length);</span><br><span class="line">            message.setContent(content);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送</span></span><br><span class="line">            ctx.writeAndFlush(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, Message message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>服务端引导器</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">MyServerInitializer</span>())</span>;</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>服务端pipeline</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加入自定义处理器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyMessageDecoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyMessageEncoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li><strong>服务端handler(重要)</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 统计接收的次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, Message message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收到数据进行处理</span></span><br><span class="line">        <span class="keyword">int</span> len = message.getLen();</span><br><span class="line">        <span class="keyword">byte</span>[] content = message.getContent();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"服务器接收到信息如下"</span>);</span><br><span class="line">        System.out.println(<span class="string">"长度="</span> + len);</span><br><span class="line">        System.out.println(<span class="string">"内容="</span> + <span class="keyword">new</span> String(content, Charset.forName(<span class="string">"utf-8"</span>)));</span><br><span class="line">        System.out.println(<span class="string">"服务器接收到消息包数量="</span> + (++<span class="keyword">this</span>.count));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回复客户端消息</span></span><br><span class="line">        String response = UUID.randomUUID().toString();</span><br><span class="line">        <span class="keyword">int</span> resLen = response.getBytes(<span class="string">"utf-8"</span>).length;</span><br><span class="line">        <span class="keyword">byte</span>[] rescontent = response.getBytes(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把回复的消息封装成一个message对象</span></span><br><span class="line">        Message message1 = <span class="keyword">new</span> Message();</span><br><span class="line">        message1.setContent(rescontent);</span><br><span class="line">        message1.setLen(resLen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送给客户端</span></span><br><span class="line">        channelHandlerContext.writeAndFlush(message1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li><strong>自定义协议编码器</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.MessageToByteEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, Message message, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyMessageEncoder encode 方法被调用"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将编码数据写入ByteBuf中</span></span><br><span class="line">        byteBuf.writeInt(message.getLen());</span><br><span class="line">        byteBuf.writeBytes(message.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="9"><li><strong>自定义协议解码器</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ReplayingDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyMessageDecoder decode 被调用"</span>);</span><br><span class="line">        <span class="comment">//需要将得到二进制字节码-&gt; MessageProtocol 数据包(对象)</span></span><br><span class="line">        <span class="keyword">int</span> length = in.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] content = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.readBytes(content);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//封装成 MessageProtocol 对象，放入 out， 传递下一个handler业务处理</span></span><br><span class="line">        Message messageProtocol = <span class="keyword">new</span> Message();</span><br><span class="line">        messageProtocol.setLen(length);</span><br><span class="line">        messageProtocol.setContent(content);</span><br><span class="line"></span><br><span class="line">        out.add(messageProtocol);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 本文档整理自 尚硅谷韩顺平Netty 相关课程。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-13-TCP粘包和拆包&quot;&gt;&lt;a href=&quot;#Netty-13-TCP粘包和拆包&quot; class=&quot;headerlink&quot; title=&quot;Netty-13-TCP粘包和拆包&quot;&gt;&lt;/a&gt;Netty-13-TCP粘包和拆包&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;TCP是面向连接的，面向流的，提供高可靠性服务。&lt;/li&gt;
&lt;li&gt;收发两端（&lt;strong&gt;客户端和服务器端）&lt;/strong&gt;都要有一一成对的socket，因此，发送端为了将多个发给接收端的包，更有效的发给对方，&lt;strong&gt;使用了优化方法（Nagle算法&lt;/strong&gt;），将多次&lt;strong&gt;间隔较小且数据量小&lt;/strong&gt;的数据，合并成一个大的数据块，然后进行封包。&lt;/li&gt;
&lt;li&gt;这样做虽然提高了效率，但是&lt;strong&gt;接收端就难于分辨出完整的数据包&lt;/strong&gt;了，因为&lt;strong&gt;面向流的通信是无消息保护边界&lt;/strong&gt;的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;通常的解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;发送端&lt;/strong&gt;每发送一次消息，就需要在消息的内容之前&lt;strong&gt;携带消息的长度&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这样，&lt;strong&gt;接收方&lt;/strong&gt;每次先接受消息的长度，再&lt;strong&gt;根据长度去读取消息剩余的元素&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果 &lt;code&gt;socket&lt;/code&gt; 中还有没有读取的内容，也只能放在下一次读取事件中读取&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="TCP" scheme="http://zhuuu.work/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-127-单词接龙</title>
    <link href="http://zhuuu.work/2020/11/05/Leetcode/Leetcode-127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/"/>
    <id>http://zhuuu.work/2020/11/05/Leetcode/Leetcode-127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/</id>
    <published>2020-11-05T07:22:53.000Z</published>
    <updated>2020-11-05T06:06:39.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-127-单词接龙"><a href="#Leecode-127-单词接龙" class="headerlink" title="Leecode-127-单词接龙"></a>Leecode-127-<a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener">单词接龙</a></h1><h2 id="思路：BFS-双向BFS"><a href="#思路：BFS-双向BFS" class="headerlink" title="思路：BFS/双向BFS"></a>思路：BFS/双向BFS</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：</span><br><span class="line"></span><br><span class="line">每次转换只能改变一个字母。</span><br><span class="line">转换过程中的中间单词必须是字典中的单词。</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">如果不存在这样的转换序列，返回 0。</span><br><span class="line">所有单词具有相同的长度。</span><br><span class="line">所有单词只由小写字母组成。</span><br><span class="line">字典中不存在重复的单词。</span><br><span class="line">你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">beginWord &#x3D; &quot;hit&quot;,</span><br><span class="line">endWord &#x3D; &quot;cog&quot;,</span><br><span class="line">wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">输出: 5</span><br><span class="line"></span><br><span class="line">解释: 一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class="line">     返回它的长度 5。</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">beginWord &#x3D; &quot;hit&quot;</span><br><span class="line">endWord &#x3D; &quot;cog&quot;</span><br><span class="line">wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">解释: endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul><li>无向图中两个顶点之间的最短路径的长度，可以通过广度优先遍历得到；</li><li>为什么 BFS 得到的路径最短？<strong>可以把起点和终点所在的路径拉直来看，两点之间线段最短</strong>；</li><li>已知目标顶点的情况下，可以<strong>分别从起点和目标顶点（终点）执行广度优先遍历</strong>，直到遍历的部分有交集，这是<strong>双向广度优先遍历的思想。</strong></li></ul><p><strong>分析题意：</strong></p><p>「转换」意即：两个单词对应位置只有一个字符不同，例如 “hit” 与 “hot”，这种转换是可以逆向的，因此，根据题目给出的单词列表，可以<strong>构建出一个无向（无权）图</strong>；</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201105/140134859.png" alt="mark"></p><ul><li>如果一开始就构建图，每一个单词都需要和除它以外的另外的单词进行比较，<strong>复杂度是 O(N O(NwordLen)</strong>，这里 N 是单词列表的长度；</li><li>为此，我们在遍历的一开始，把所有单词放入一个哈希表中，然后在遍历的过程中构件图，每一次得到在单词列表里可以转换的单词，<strong>复杂度是O(26×wordLen)，借助哈希表</strong>，找到邻居与 N 无关；</li><li>使用BFS ： 所需要的辅助数据结构是<ul><li>队列</li><li><code>visited</code> 集合<ul><li>说明：可以直接在 <code>wordSet</code> (由 <code>wordList</code> 放进集合中得到)里做删除</li><li>但更好的做法是新开一个哈希表，遍历过的字符串放进哈希表里。</li><li>这种做法具有普遍意义。绝大多数在线测评系统和应用场景都不会在意空间开销。</li></ul></li></ul></li></ul><h2 id="方法一-：-广度优先遍历"><a href="#方法一-：-广度优先遍历" class="headerlink" title="方法一 ： 广度优先遍历"></a>方法一 ： 广度优先遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第 1 步：先将 wordList 放到哈希表里，便于判断某个单词是否在 wordList 里</span></span><br><span class="line">        Set&lt;String&gt; wordSet = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">        <span class="keyword">if</span> (wordSet.size() == <span class="number">0</span> || !wordSet.contains(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        wordSet.remove(beginWord);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二步 ： 图的广度优先遍历,必须使用队列和表示访问过的visited 访问过数据的哈希表</span></span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(beginWord);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        visited.add(beginWord);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三步： 开始进行广度优先遍历，包含起点，因此起点的初始化步数为1</span></span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curSize = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; curSize;i++)&#123;</span><br><span class="line">                <span class="comment">// 依次遍历当前队列中的单词</span></span><br><span class="line">                String currWord = queue.poll();</span><br><span class="line">                <span class="comment">// 如果currWord 能够修改依次字符便和 endWord 相同，那么立即返回step + 1即可</span></span><br><span class="line">                <span class="keyword">if</span>(changeWordEveryOneLetter(currWord,endWord,queue,visited,wordSet))&#123;</span><br><span class="line">                    <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找不到的话返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">changeWordEveryOneLetter</span><span class="params">(String currentWord, String endWord,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             Queue&lt;String&gt; queue, Set&lt;String&gt; visited, Set&lt;String&gt; wordSet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] charArray = currentWord.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; endWord.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 先保存，然后恢复</span></span><br><span class="line">            <span class="keyword">char</span> originChar = charArray[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> k = <span class="string">'a'</span>; k &lt;= <span class="string">'z'</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k == originChar) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                charArray[i] = k;</span><br><span class="line">                String nextWord = String.valueOf(charArray);</span><br><span class="line">                <span class="keyword">if</span> (wordSet.contains(nextWord)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nextWord.equals(endWord)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(nextWord)) &#123;</span><br><span class="line">                        queue.add(nextWord);</span><br><span class="line">                        <span class="comment">// 注意：添加到队列以后，必须马上标记为已经访问</span></span><br><span class="line">                        visited.add(nextWord);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 恢复</span></span><br><span class="line">            charArray[i] = originChar;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二：-双向广度优先遍历"><a href="#方法二：-双向广度优先遍历" class="headerlink" title="方法二： 双向广度优先遍历"></a>方法二： 双向广度优先遍历</h2><p><strong>参考题解 ：</strong> <a href="https://leetcode-cn.com/problems/word-ladder/solution/yan-du-you-xian-bian-li-shuang-xiang-yan-du-you-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-ladder/solution/yan-du-you-xian-bian-li-shuang-xiang-yan-du-you-2/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-127-单词接龙&quot;&gt;&lt;a href=&quot;#Leecode-127-单词接龙&quot; class=&quot;headerlink&quot; title=&quot;Leecode-127-单词接龙&quot;&gt;&lt;/a&gt;Leecode-127-&lt;a href=&quot;https://leetcode-cn.com/problems/word-ladder/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;单词接龙&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：BFS-双向BFS&quot;&gt;&lt;a href=&quot;#思路：BFS-双向BFS&quot; class=&quot;headerlink&quot; title=&quot;思路：BFS/双向BFS&quot;&gt;&lt;/a&gt;思路：BFS/双向BFS&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;每次转换只能改变一个字母。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;转换过程中的中间单词必须是字典中的单词。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;说明:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果不存在这样的转换序列，返回 0。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;所有单词具有相同的长度。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;所有单词只由小写字母组成。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;字典中不存在重复的单词。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;你可以假设 beginWord 和 endWord 是非空的，且二者不相同。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;beginWord &amp;#x3D; &amp;quot;hit&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;endWord &amp;#x3D; &amp;quot;cog&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wordList &amp;#x3D; [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;,&amp;quot;cog&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 一个最短转换序列是 &amp;quot;hit&amp;quot; -&amp;gt; &amp;quot;hot&amp;quot; -&amp;gt; &amp;quot;dot&amp;quot; -&amp;gt; &amp;quot;dog&amp;quot; -&amp;gt; &amp;quot;cog&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     返回它的长度 5。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;beginWord &amp;#x3D; &amp;quot;hit&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;endWord &amp;#x3D; &amp;quot;cog&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wordList &amp;#x3D; [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: endWord &amp;quot;cog&amp;quot; 不在字典中，所以无法进行转换。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双向BFS" scheme="http://zhuuu.work/tags/%E5%8F%8C%E5%90%91BFS/"/>
    
  </entry>
  
  <entry>
    <title>Netty-12-handler调用机制</title>
    <link href="http://zhuuu.work/2020/11/05/Netty/Netty-12-handler%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/"/>
    <id>http://zhuuu.work/2020/11/05/Netty/Netty-12-handler%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/</id>
    <published>2020-11-05T05:05:24.000Z</published>
    <updated>2020-11-06T09:34:59.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-12-handler调用机制"><a href="#Netty-12-handler调用机制" class="headerlink" title="Netty-12-handler调用机制"></a>Netty-12-handler调用机制</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>netty的组件设计：Netty的主要组件有<code>Channel、EventLoop、ChannelFuture、ChannelHandler、ChannelPipe</code>等</li><li>我们先来复习一下<code>ChannelHandler</code>和<code>ChannelPipeline</code>的关系。示例图如下：我们可以将<code>pipeline</code>理解为一个双向链表，<code>ChannelHandlerContext</code>看作链表中的一个节点，<code>ChannelHandler</code>则为每个节点中保存的一个属性对象。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/123220946.png" alt="mark"></p><a id="more"></a><ul><li><strong><code>ChannelHandler</code>充当了处理入站和出站数据的应用程序逻辑的容器。</strong><ul><li>例如，实现<code>ChannelInboundHandler</code>接口（或<code>ChannelInboundHandlerAdapter</code>），你就可以接收入站事件和数据，这些数据会被业务逻辑处理。</li><li>当<strong>要给客户端发送响应</strong>时，也可以从<code>ChannelInboundHandler</code>冲刷数据。业务逻辑通常写在一个或者多个<code>ChannelInboundHandler</code>中。</li></ul></li><li><strong><code>ChannelPipeline</code>提供了<code>ChannelHandler</code>链的容器。</strong><ul><li>如果事件的运动方向是从<strong>客户端到服务端的，那么我们称这些事件为出站的，即客户端发送给服务端的数据会通过<code>pipeline</code>中的一系列<code>ChannelOutboundHandler</code>,被这些<code>Handler</code>处理</strong></li><li>反之则称为入站的</li></ul></li></ul><p><strong>下面，来看看我们常用的<code>Handler</code>的关系图：<code>Inbound</code>处理入站，<code>Outbound</code>处理出站</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201106/160524576.png" alt="mark"></p><p>一般来说，在我们接收数据时将数据解码后，就进行业务的相关处理，所以上图的<strong>入站的常用类更多(服务端到客户端)</strong>。<strong>在数据出站时（客户端到服务端）</strong>，一般我们只需要将数据编码后直接发出。</p><h2 id="1-Handler-链式调用"><a href="#1-Handler-链式调用" class="headerlink" title="1. Handler 链式调用"></a>1. Handler 链式调用</h2><ul><li><p><code>Pipeline</code>中的<code>Handler</code>可以当作一个双向链表。</p></li><li><p>但是<code>Handler</code>却又存在着入站和出站之分。那么<code>Netty</code>是如何将两种类型的<code>Handler</code>保存在一个链表中，却又能够入站的时候调用<code>InboundHandler</code>，出栈的时候调用<code>OutBoundHandler</code>呢</p></li><li><p>看下图，黄色的表示入站，以及入站的<code>Handler</code>，绿色的表示出站，以及出站的<code>Handler</code>。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201106/162411613.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> LongToByteEncoder()); <span class="comment">//out</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> ByteToLongDecoder()); <span class="comment">//in</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> OutBoundHandler()); <span class="comment">//out</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> InBoundHandler()); <span class="comment">//in</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>请求处理流程</strong></p><ul><li>当一个请求来了的时候，首先会将请求发给<code>pipeline</code>中位于链表首部的<code>Handler</code>。</li><li>首先由队列第一个handler 进行处理，如果接受类型不匹配，那么跳过，直接转发给下一个handler 进行处理</li><li>如果需要返回数据，我们就调用<code>writeAndFlush</code>方法，这个方法可不简单，当他一被调用，就会触发出站请求，然后就由当前所在的<code>handler</code> 节点往回调用</li></ul><p><strong>通过上面的描述，我们可以总结添加<code>Handler</code>的以下节点总结：</strong></p><ul><li><strong>调用<code>InboundHandler</code>的顺序和添加的顺序是一致的。</strong></li><li><strong>调用<code>OutboundHandler</code>的顺序和添加它的顺序是相反的。</strong></li><li><strong>链表的末尾不能有 <code>OutHandler</code>，因为如果最后是 <code>OutHandler</code>的话，当他前面的 <code>Inhandler</code> 处理完数据返回消息调用<code>writeAndflush</code> 方法后，它就直接在前面进行反向调用了。那么就无法调用到这个 <code>OutHandler</code></strong></li><li><strong>所以，平常会把 <code>OutHandler</code>写在前面，<code>InHandler</code> 一般放在链表的末尾</strong></li><li><strong><code>InHandler</code> 一旦进行了 <code>writeAndFlush</code> ，那么只有这个<code>Inhandler</code> 之前添加的 <code>Outhandler</code> 才能正确的处理数据</strong></li></ul><h2 id="2-Handler-编解码器"><a href="#2-Handler-编解码器" class="headerlink" title="2. Handler 编解码器"></a>2. Handler 编解码器</h2><ul><li><p>当<code>Netty</code>发送或者接受一个消息的时候，就将会发生一次数据转换。入站消息会被解码：从字节转换为另一种格式（比如<code>java</code>对象）；如果是出站消息，它会被编码成字节。</p></li><li><p>Netty提供一系列<strong>实用的编解码器</strong>，他们都实现了<code>ChannelInboundHadnler</code>或者<code>ChannelOutboundHandler</code>接口。在这些类中，<code>channelRead</code>方法已经被重写了</p></li><li><p><strong>以入站为例</strong>，对于每个从入站<code>Channel</code>读取的消息，这个方法会被调用。随后，它将调用由解码器所提供的<code>decode()</code>方法进行解码，并将已经解码的字节转发给<code>ChannelPipeline</code>中的下一个<code>ChannelInboundHandler</code>。</p></li></ul><h3 id="2-1-解码器-ByteToMessageDecoder"><a href="#2-1-解码器-ByteToMessageDecoder" class="headerlink" title="2.1 解码器-ByteToMessageDecoder"></a>2.1 解码器-ByteToMessageDecoder</h3><ul><li>由于<strong>不可能知道远程节点是否会一次性发送一个完整的信息，tcp有可能出现粘包拆包的问题，这个类会对入站数据进行缓冲，直到它准备好被处理。</strong></li></ul><p><strong>下面是段示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToIntegerDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (in.readableBytes() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">            out.add(in.readInt());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个例子中</strong></p><ol><li>每次入站从<code>ByteBuf</code>中读取4字节，将其解码为一个<code>int</code>，</li><li>然后将它添加到下一个<code>List</code>中。当没有更多元素可以被添加到该<code>List</code>中时，它的内容将会被发送给下一个<code>ChannelInboundHandler</code>。</li><li><code>int</code>在被添加到<code>List</code>中时，会被自动装箱为<code>Integer</code>。</li></ol><p>在调用<code>readInt()</code>方法前必须验证所输入的<code>ByteBuf</code>是否具有足够的数据</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201106/163527996.png" alt="mark"></p><h3 id="2-2-解码器-ReplayingDecoder"><a href="#2-2-解码器-ReplayingDecoder" class="headerlink" title="2.2 解码器 - ReplayingDecoder"></a>2.2 <strong>解码器 - ReplayingDecoder</strong></h3><ul><li><code>public abstract class ReplayingDecoder&lt;S&gt; extends ByteToMessageDecoder{ }</code></li><li><code>ReplayingDecoder</code>扩展了<code>ByteToMessageDecoder</code>类，使用这个类，我们不必调用<code>readableBytes()</code>方法。参数S指定了用户状态管理的类型，<strong>其中Void代表不需要状态管理</strong></li><li>下面是代码示例：这段代码起到了上面<code>ByteToMessageDecoder</code>一样的作用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteToLongDecoder2</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.add(in.readLong());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>ReplayingDecoder</code>使用方便，但它也有一些局限性：<ul><li><strong>并不是所有的 <code>ByteBuf</code> 操作都被支持</strong>，如果调用了一个不被支持的方法，将会抛出一个 <code>UnsupportedOperationException</code>。</li><li><code>ReplayingDecoder</code> 在某些情况下可能稍慢于 <code>ByteToMessageDecoder</code>，例如网络缓慢并且消息格式复杂时，消息会被拆成了多个碎片，速度变慢</li></ul></li></ul><p><strong>其他的解码器</strong></p><ul><li><code>LineBasedFrameDecoder</code>：这个类在Netty内部也有使用，它使用行尾控制字符（\n或者\r\n）作为分隔符来解析数据。</li><li><code>DelimiterBasedFrameDecoder</code>：使用自定义的特殊字符作为消息的分隔符。</li><li><code>HttpObjectDecoder</code>：一个HTTP数据的解码器</li><li><code>LengthFieldBasedFrameDecoder</code>：通过指定长度来标识整包消息，这样就可以自动的处理黏包和半包消息。</li></ul><h2 id="3-简单实例"><a href="#3-简单实例" class="headerlink" title="3. 简单实例"></a>3. 简单实例</h2><p><strong>实例要求：</strong></p><ul><li>使用自定义的编码器和解码器来说明Netty的<code>handler</code> 调用机制</li><li>客户端发送<code>long</code> -&gt; 服务器</li><li>服务端发送<code>long</code>-&gt; 客户端</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201106/172833866.png" alt="mark"></p><p>注意 ：  这里只展示，<code>Handler</code>相应的代码和添加<code>Handler</code>的关键代码。</p><ol><li><strong>Decoder</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteToLongDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * decode 方法会根据接收到的数据，被调用多次，知道确定没有新的元素被添加到list，或者是ByteBuf 没有更多的可读字节为止</span></span><br><span class="line"><span class="comment">     * 如果 list out不为空，就会将list的内容传递给下一个 Handler 进行处理，该处理器的方法也会被调用多次。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 入栈的 ByteBuf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out list集合，将解码后的数据传给下一个Handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//因为long为8个字节，所以需要8个字节才能读取成一个long类型的数据</span></span><br><span class="line">        System.out.println(<span class="string">"ByteToLongDecoder：入栈数据被解码"</span>);</span><br><span class="line">        <span class="keyword">if</span> (in.readableBytes() &gt;= <span class="number">8</span>)&#123;</span><br><span class="line">            out.add(in.readLong());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>Encoder</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongToByteEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Long msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"LongToByteEncoder: 出栈数据，msg = "</span> + msg);</span><br><span class="line">        out.writeLong(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>服务器端添加Handler</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> LongToByteEncoder()); <span class="comment">//编码器，出站</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> ByteToLongDecoder()); <span class="comment">//解码器，入站</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> ServerInBoundHandler()); <span class="comment">//业务处理，入站</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>客户端添加Handler</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> LongToByteEncoder()); <span class="comment">//编码器，出站</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> ByteToLongDecoder()); <span class="comment">//解码器，入站</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> ClientInBoundHandler()); <span class="comment">//业务处理，入站。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>这里当客户端和服务端接收消息的时候<ul><li>首先会调用入站的解码器，然后进行业务的处理</li><li>然后在调用出站的解码解码器再返回消息</li></ul></li><li>后面可以在业务处理类中，增加发送消息的代码，此处省略。</li></ul><h2 id="4-Netty整合-log4j"><a href="#4-Netty整合-log4j" class="headerlink" title="4. Netty整合 log4j"></a>4. Netty整合 log4j</h2><ol><li><strong>添加依赖</strong></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.7.25&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.7.25&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.7.25&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>添加配置文件</strong></li></ol><p>在<code>resource</code>目录下新建<code>log4j.properties</code>即可</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">log5j.rootLogger</span>=<span class="string">DEBUG, stdout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">[%p] %C&#123;1&#125; - %m%n</span></span><br></pre></td></tr></table></figure><blockquote><p> 本文档整理自 尚硅谷韩顺平Netty 相关课程。</p></blockquote><p><strong>参考博客 ：</strong> <a href="https://dongzl.github.io/netty-handbook/#/README" target="_blank" rel="noopener">https://dongzl.github.io/netty-handbook/#/README</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-12-handler调用机制&quot;&gt;&lt;a href=&quot;#Netty-12-handler调用机制&quot; class=&quot;headerlink&quot; title=&quot;Netty-12-handler调用机制&quot;&gt;&lt;/a&gt;Netty-12-handler调用机制&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;netty的组件设计：Netty的主要组件有&lt;code&gt;Channel、EventLoop、ChannelFuture、ChannelHandler、ChannelPipe&lt;/code&gt;等&lt;/li&gt;
&lt;li&gt;我们先来复习一下&lt;code&gt;ChannelHandler&lt;/code&gt;和&lt;code&gt;ChannelPipeline&lt;/code&gt;的关系。示例图如下：我们可以将&lt;code&gt;pipeline&lt;/code&gt;理解为一个双向链表，&lt;code&gt;ChannelHandlerContext&lt;/code&gt;看作链表中的一个节点，&lt;code&gt;ChannelHandler&lt;/code&gt;则为每个节点中保存的一个属性对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/123220946.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="handler" scheme="http://zhuuu.work/tags/handler/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-057-插入区间</title>
    <link href="http://zhuuu.work/2020/11/04/Leetcode/Leetcode-057-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/"/>
    <id>http://zhuuu.work/2020/11/04/Leetcode/Leetcode-057-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/</id>
    <published>2020-11-04T03:52:53.000Z</published>
    <updated>2020-11-04T06:06:05.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-057-插入区间"><a href="#Leetcode-057-插入区间" class="headerlink" title="Leetcode-057-插入区间"></a>Leetcode-057-<a href="https://leetcode-cn.com/problems/insert-interval/" target="_blank" rel="noopener">插入区间</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个<em>无重叠的 ，</em>按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：intervals &#x3D; [[1,3],[6,9]], newInterval &#x3D; [2,5]</span><br><span class="line">输出：[[1,5],[6,9]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：intervals &#x3D; [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval &#x3D; [4,8]</span><br><span class="line">输出：[[1,2],[3,10],[12,16]]</span><br><span class="line">解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-：模拟"><a href="#思路-：模拟" class="headerlink" title="思路 ：模拟"></a><strong>思路 ：模拟</strong></h2><ol><li><strong>是否有交集的探讨</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201104/135246852.png" alt="mark"></p><ol start="2"><li><strong>思路与算法</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201104/135519588.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201104/135533962.png" alt="mark"></p><ul><li><p>这样做的正确性在于，给定的区间<strong>集合中任意两个区间都是没有交集</strong>的，因此所有需要合并的区间，就是所有与区间 S 重叠的区间。</p></li><li><p>并且，在给定的区间集合已经按照左端点排序的前提下，所有与区间 S 重叠的区间在数组 <strong>intervals</strong> 中下标范围是连续的，因此我们<strong>可以对所有的区间进行一次遍历</strong>，就可以找到这个连续的下标范围。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201104/135816063.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = newInterval[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> right = newInterval[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">boolean</span> placed = <span class="keyword">false</span>; <span class="comment">// 保证新插入的集合只被插入一次</span></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; ansList = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">0</span>] &gt; right) &#123;</span><br><span class="line">                <span class="comment">// 在插入区间的右侧且无交集</span></span><br><span class="line">                <span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">                    ansList.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left, right&#125;);</span><br><span class="line">                    placed = <span class="keyword">true</span>;                    </span><br><span class="line">                &#125;</span><br><span class="line">                ansList.add(interval);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interval[<span class="number">1</span>] &lt; left) &#123;</span><br><span class="line">                <span class="comment">// 在插入区间的左侧且无交集</span></span><br><span class="line">                ansList.add(interval);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 与插入区间有交集，计算它们的并集（扩大区间）</span></span><br><span class="line">                left = Math.min(left, interval[<span class="number">0</span>]);</span><br><span class="line">                right = Math.max(right, interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果走完发现 ： 新插入的集合还未加入到结果集中</span></span><br><span class="line">        <span class="comment">// 说明新插入的集合在 所有区间的最后</span></span><br><span class="line">        <span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">            ansList.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left, right&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将ArrayList转化成 int[ansList.size()][2]</span></span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[ansList.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ansList.size(); ++i) &#123;</span><br><span class="line">            ans[i] = ansList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)，其中 n 是数组 intervals 的长度，即给定的区间个数。</li><li>空间复杂度:   O(1) 除了存储返回答案的空间以外，我们只需要额外的常数空间即可。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-057-插入区间&quot;&gt;&lt;a href=&quot;#Leetcode-057-插入区间&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-057-插入区间&quot;&gt;&lt;/a&gt;Leetcode-057-&lt;a href=&quot;https://leetcode-cn.com/problems/insert-interval/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;插入区间&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给出一个&lt;em&gt;无重叠的 ，&lt;/em&gt;按照区间起始端点排序的区间列表。&lt;/p&gt;
&lt;p&gt;在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：intervals &amp;#x3D; [[1,3],[6,9]], newInterval &amp;#x3D; [2,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[[1,5],[6,9]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：intervals &amp;#x3D; [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval &amp;#x3D; [4,8]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[[1,2],[3,10],[12,16]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-24-IO核心子系统</title>
    <link href="http://zhuuu.work/2020/11/03/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-24-IO%E6%A0%B8%E5%BF%83%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <id>http://zhuuu.work/2020/11/03/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-24-IO%E6%A0%B8%E5%BF%83%E5%AD%90%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-11-03T03:00:53.000Z</published>
    <updated>2020-11-02T03:39:29.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-24-IO核心子系统"><a href="#操作系统-24-IO核心子系统" class="headerlink" title="操作系统-24-IO核心子系统"></a>操作系统-24-IO核心子系统</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/111350794.png" alt="mark"></p><p><strong>IO 核心子系统</strong></p><ul><li>设备独立性软件</li><li>设备驱动程序</li><li>中断处理程序</li></ul><h2 id="1-假脱机技术-SPOOLing"><a href="#1-假脱机技术-SPOOLing" class="headerlink" title="1. 假脱机技术(SPOOLing)"></a>1. 假脱机技术(SPOOLing)</h2><ul><li>在<strong>用户层软件</strong>实现，但是408大纲将其归入I/O核心子系统</li></ul><h3 id="1-1-什么是脱机技术？"><a href="#1-1-什么是脱机技术？" class="headerlink" title="1.1 什么是脱机技术？"></a>1.1 什么是脱机技术？</h3><p><strong>这里温习一下手工操作阶段：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/111631459.png" alt="mark"></p><p>因为手工阶段的速度慢问题，引入了脱机技术</p><a id="more"></a><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/111700059.png" alt="mark"></p><h3 id="1-2-假脱机技术"><a href="#1-2-假脱机技术" class="headerlink" title="1.2 假脱机技术"></a>1.2 假脱机技术</h3><ul><li>在脱机技术的基础上人们发明了更好的假脱机技术</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/111730874.png" alt="mark"></p><p><strong>输入井和输出井</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/111923725.png" alt="mark"></p><p><strong>输入进程和输出进程</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/111948908.png" alt="mark"></p><p><strong>输入和输出缓冲区</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112015684.png" alt="mark"></p><h3 id="1-3-共享打印机"><a href="#1-3-共享打印机" class="headerlink" title="1.3 共享打印机"></a>1.3 共享打印机</h3><p><strong>先了解一下独占和共享设备，以此引出假脱机技术如何实现对独占设备的共享：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112058454.png" alt="mark"></p><ul><li><strong>共享打印机原理</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112156732.png" alt="mark"></p><p>打印请求完成后，请求表从打印队列删除，执行后续队列的打印任务</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112316764.png" alt="mark"></p><h2 id="2-IO-设备的分配和回收"><a href="#2-IO-设备的分配和回收" class="headerlink" title="2. IO 设备的分配和回收"></a>2. IO 设备的分配和回收</h2><p><strong>设备分配时应该考虑的因素</strong></p><ul><li><strong>设备的固有属性</strong><br>独占设备、共享设备、虚拟设备(SPOOLing技术将独占设备改造成虚拟的共享设备)</li><li><strong>设备分配算法</strong><br>先来先服务、优先级高者优先、短任务优先等等</li><li><strong>设备分配的安全性</strong><br><strong>安全分配方式</strong>：串行使用设备，为进程分配一个设备后将进程阻塞，I/O完成再唤醒。不会产生死锁<br><strong>不安全分配方式</strong>：进程请求I/O，操作系统负责分配设备，进程可以继续执行或者请求新的I/O，直到某个I/O无法满足才阻塞进程。可能产生死锁</li></ul><p><strong>静态分配和动态分配</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112601713.png" alt="mark"></p><h3 id="2-1-设备分配数据结构"><a href="#2-1-设备分配数据结构" class="headerlink" title="2.1 设备分配数据结构"></a>2.1 设备分配数据结构</h3><p><strong>设备、控制器、通道之间的关系：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112633304.png" alt="mark"></p><p><strong>设备控制表-DCT</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112655363.png" alt="mark"></p><p><strong>控制器控制表-COCT</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112713381.png" alt="mark"></p><p><strong>通道控制表-CHCT</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112740089.png" alt="mark"></p><p><strong>系统设备表-SDT</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112751658.png" alt="mark"></p><h3 id="2-2-设备分配的步骤"><a href="#2-2-设备分配的步骤" class="headerlink" title="2.2 设备分配的步骤"></a>2.2 设备分配的步骤</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112815959.png" alt="mark"></p><h3 id="2-3-设备分配改进步骤"><a href="#2-3-设备分配改进步骤" class="headerlink" title="2.3 设备分配改进步骤"></a>2.3 设备分配改进步骤</h3><ul><li><strong>缺点</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112905248.png" alt="mark"></p><ul><li><strong>改进方法 ： 逻辑设备名</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112948310.png" alt="mark"></p><ul><li><strong>逻辑设备表</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113006948.png" alt="mark"></p><h2 id="3-缓冲区管理"><a href="#3-缓冲区管理" class="headerlink" title="3. 缓冲区管理"></a>3. 缓冲区管理</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113120359.png" alt="mark"></p><h3 id="3-1-缓冲区的作用"><a href="#3-1-缓冲区的作用" class="headerlink" title="3.1 缓冲区的作用"></a>3.1 缓冲区的作用</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113306353.png" alt="mark"></p><h3 id="3-2-单缓冲"><a href="#3-2-单缓冲" class="headerlink" title="3.2 单缓冲"></a><strong>3.2 单缓冲</strong></h3><p><strong>单缓冲的原则</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113336039.png" alt="mark"></p><ol><li><strong>T &gt; C</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113423300.png" alt="mark"></p><ol start="2"><li><strong>T &lt; C</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113434600.png" alt="mark"></p><h3 id="3-3-双缓冲"><a href="#3-3-双缓冲" class="headerlink" title="3.3 双缓冲"></a>3.3 双缓冲</h3><ol><li><strong>T  &gt; C+ M</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113506440.png" alt="mark"></p><ol start="2"><li><strong>T &lt; C + M</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113540130.png" alt="mark"></p><h3 id="3-4-循环缓冲"><a href="#3-4-循环缓冲" class="headerlink" title="3.4 循环缓冲"></a>3.4 循环缓冲</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113606985.png" alt="mark"></p><h3 id="3-5-缓冲池"><a href="#3-5-缓冲池" class="headerlink" title="3.5 缓冲池"></a>3.5 缓冲池</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113853966.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考笔记 ：</strong> <a href="https://blog.csdn.net/weixin_43914604/article/details/104415990" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43914604/article/details/104415990</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-24-IO核心子系统&quot;&gt;&lt;a href=&quot;#操作系统-24-IO核心子系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统-24-IO核心子系统&quot;&gt;&lt;/a&gt;操作系统-24-IO核心子系统&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/111350794.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IO 核心子系统&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设备独立性软件&lt;/li&gt;
&lt;li&gt;设备驱动程序&lt;/li&gt;
&lt;li&gt;中断处理程序&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-假脱机技术-SPOOLing&quot;&gt;&lt;a href=&quot;#1-假脱机技术-SPOOLing&quot; class=&quot;headerlink&quot; title=&quot;1. 假脱机技术(SPOOLing)&quot;&gt;&lt;/a&gt;1. 假脱机技术(SPOOLing)&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在&lt;strong&gt;用户层软件&lt;/strong&gt;实现，但是408大纲将其归入I/O核心子系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-1-什么是脱机技术？&quot;&gt;&lt;a href=&quot;#1-1-什么是脱机技术？&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是脱机技术？&quot;&gt;&lt;/a&gt;1.1 什么是脱机技术？&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;这里温习一下手工操作阶段：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/111631459.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;因为手工阶段的速度慢问题，引入了脱机技术&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-941-有效的山脉数组</title>
    <link href="http://zhuuu.work/2020/11/03/Leetcode/Leetcode-941-%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84/"/>
    <id>http://zhuuu.work/2020/11/03/Leetcode/Leetcode-941-%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84/</id>
    <published>2020-11-02T23:52:53.000Z</published>
    <updated>2020-11-03T00:50:59.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-941-有效的山脉数组"><a href="#Leetcode-941-有效的山脉数组" class="headerlink" title="Leetcode-941-有效的山脉数组"></a>Leetcode-941-<a href="https://leetcode-cn.com/problems/valid-mountain-array/" target="_blank" rel="noopener">有效的山脉数组</a></h1><h2 id="思路：线性扫描"><a href="#思路：线性扫描" class="headerlink" title="思路：线性扫描"></a>思路：线性扫描</h2><p><strong>题目描述</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。</span><br><span class="line"></span><br><span class="line">让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：</span><br><span class="line"></span><br><span class="line">A.length &gt;&#x3D; 3</span><br><span class="line">在 0 &lt; i &lt; A.length - 1 条件下，存在 i 使得：</span><br><span class="line">A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</span><br><span class="line">A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201103/084745146.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：[2,1]</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：[3,5,5]</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：[0,3,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>思路：线性扫描</strong></p><ul><li>按照题目模拟即可，我们从数组最左侧开始向右扫描</li><li>直到找到第一个不满足<em>A</em>[<em>i</em>]&lt;<em>A</em>[<em>i</em>+1]  的下标 i ,那么 i 就是这个数组的最高点下标</li><li>如果 i = 0 或者不存在这样的 i (即整个数组单调递增)，那么就返回false</li><li>否则 从 i 开始继续向右扫描，判断接下来的下标 j 是否都满足 <em>A</em>[<em>j</em>]&gt;<em>A</em>[<em>j</em>+1] ，若都满足返回true ,不满足返回false.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validMountainArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查最高点左半部分</span></span><br><span class="line">        <span class="keyword">while</span>(i + <span class="number">1</span> &lt; n &amp;&amp; A[i] &lt; A[i + <span class="number">1</span>])&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最高点不能是数组的第一个位置或者最后一个位置</span></span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> || i == n - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查最高点后半部分</span></span><br><span class="line">        <span class="keyword">while</span>(i + <span class="number">1</span> &lt; n &amp;&amp; A[i] &gt; A[i + <span class="number">1</span>])&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否正确走到了数组最后</span></span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span> == i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n) 扫描一遍数组所需要的时间</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-941-有效的山脉数组&quot;&gt;&lt;a href=&quot;#Leetcode-941-有效的山脉数组&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-941-有效的山脉数组&quot;&gt;&lt;/a&gt;Leetcode-941-&lt;a href=&quot;https://leetcode-cn.com/problems/valid-mountain-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;有效的山脉数组&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：线性扫描&quot;&gt;&lt;a href=&quot;#思路：线性扫描&quot; class=&quot;headerlink&quot; title=&quot;思路：线性扫描&quot;&gt;&lt;/a&gt;思路：线性扫描&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A.length &amp;gt;&amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在 0 &amp;lt; i &amp;lt; A.length - 1 条件下，存在 i 使得：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A[0] &amp;lt; A[1] &amp;lt; ... A[i-1] &amp;lt; A[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A[i] &amp;gt; A[i+1] &amp;gt; ... &amp;gt; A[A.length - 1]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201103/084745146.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[2,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[3,5,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[0,3,2,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Netty-10-WebSocket</title>
    <link href="http://zhuuu.work/2020/11/02/Netty/Netty-10-WebSocket/"/>
    <id>http://zhuuu.work/2020/11/02/Netty/Netty-10-WebSocket/</id>
    <published>2020-11-02T05:05:24.000Z</published>
    <updated>2020-11-02T06:13:44.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-10-WebSocket"><a href="#Netty-10-WebSocket" class="headerlink" title="Netty-10-WebSocket"></a>Netty-10-WebSocket</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>实例要求</strong></p><ul><li>Http 协议是无状态的，浏览器和服务器之间的请求只响应一次，下一次会重新创建连接</li><li>要求  ： 实现基于webSocket 的长连接全双工的交互</li><li>改变Http 协议多次请求的约束，实现长连接，服务器可以发送消息给浏览器</li><li>客户端浏览器和服务器端会相互感知，比如服务器关闭了，浏览器会感知，同样浏览器关闭了，服务器会感知</li></ul><a id="more"></a><h2 id="1-启动器代码"><a href="#1-启动器代码" class="headerlink" title="1. 启动器代码"></a>1. 启动器代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">    NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">            .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">handler</span>(<span class="title">new</span> <span class="title">LoggingHandler</span>(<span class="title">LogLevel</span>.<span class="title">INFO</span>))</span></span><br><span class="line"><span class="class">            .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                    <span class="comment">//因为是基于Http协议，所以要使用Http的编码和解码器</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">                    <span class="comment">//是以块方式写，添加ChunkedWriter处理器</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ChunkedWriteHandler());</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    * 1、http数据在传输过程中是分裂的,HttpObjectAggregator就可以将多个段聚合</span></span><br><span class="line"><span class="comment">                    * 2、这就是为什么，当浏览器发送大量数据时，就会发出多次http请求</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">8192</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    * 1、对于websocket，它的数据是以帧的形式传递的</span></span><br><span class="line"><span class="comment">                    * 2、可以看到 WebsocketFrame 下面有六个子类</span></span><br><span class="line"><span class="comment">                    * 3、浏览器请求时：ws://localhost:7000/hello 表示请求的uri</span></span><br><span class="line"><span class="comment">                    * 4、WebSocketServerProtocolHandler 核心功能是将 http 协议升级为 ws 协议，保持长连接</span></span><br><span class="line"><span class="comment">                    * 5、从Http协议升级到Websocket协议，是通过StatusCode 101（Switching Protocols）来切换的。</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> WebSocketServerProtocolHandler(<span class="string">"/hello"</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//自定义Handler，处理业务逻辑</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> MyTextWebSocketFrameHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        ChannelFuture sync = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">        sync.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        bossGroup.shutdownGracefully();</span><br><span class="line">        workerGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-案例总结"><a href="#2-案例总结" class="headerlink" title="2 . 案例总结"></a>2 . 案例总结</h2><ol><li><strong>创建启动类</strong></li></ol><ul><li>首先初始化两个NioEventLoopGroup。其中BossGroup一般设置线程为1</li><li>初始化一个ServerBootStrap类。并调用它设置很多参数。<ul><li><code>group()</code>：服务端设置两个Group，客户端设置一个Group</li><li><code>channel()</code>：服务端传入<code>NioServerSocketChannel</code>，客户端传入<code>NioSocketChannel</code></li><li><code>option()</code>：服务端给BossGroup设置<code>SO_BACKLOG</code>任务队列大小</li><li><code>childOption()</code>：服务端给WorkerGroup设置连接<code>SO_KEEPALIVE</code>保持连接状态</li><li><code>handler()</code>：服务端给BossGroup设置Handler，客户端设置Handler</li><li><code>childHandler()</code>：服务端给WorkerGroup设置Handler。</li></ul></li><li>通过BootStrap去绑定端口，监听关闭事件。设置为异步拿到ChannelFuture对象</li></ul><ol start="2"><li><strong>Handler 处理逻辑</strong></li></ol><ul><li><code>SimpleChannelInboundHandler</code><ul><li>可以继承它来处理很多通信。经过上面几个案例推敲，一般写自己的Handler继承它就可以了</li></ul></li><li><code>ChannelInboundHandlerAdapter</code><ul><li>这个是上一个的父类，我们在心跳检测的时候通过继承它的<code>userEventTriggered</code>去判断连接状态</li><li>其实通过上面那个<code>simple</code>也可以继承这个<code>trigger</code></li></ul></li><li><code>IdleStateHandler</code><ul><li>在心跳检测时我们要通过这个Handler去触发上面的<code>trigger</code></li></ul></li><li><code>HttpServerCodec</code><ul><li>提供好的用于Http编码解码，一般用于Http请求</li></ul></li><li><code>ChunkedWriteHandler</code><ul><li>提供好的Handler，以块方式写，添加ChunkedWriter处理器</li><li>我搜了一下，它一般用于发送大文件。这个东西使我们在Websocket的时候用的。</li></ul></li><li><code>HttpObjectAggregator</code><ul><li>它会将http数据聚合在一起发送</li></ul></li><li><code>WebSocketServerProtocolHandler</code><ul><li>传入ws路径，将Http协议升级成为ws协议</li></ul></li></ul><ol start="3"><li><strong>netty 中通信数据实体</strong></li></ol><ul><li><code>TextWebSocketFrame</code><ul><li>这是我们在websocket连接的时候用的，它表示一个文本帧，是websocket进行通信的数据形式</li></ul></li><li><code>HttpObject</code><ul><li>这是我们在建立Http连接的时候用到的，可以将它转换成一个<code>HttpRequest</code></li></ul></li></ul><ol start="4"><li><strong>Handler 常用方法</strong></li></ol><table><thead><tr><th>方法名</th><th>介绍</th></tr></thead><tbody><tr><td><code>channelRead0(ChannelHandlerContext channelHandlerContext, T t)</code></td><td>读取数据，并进行消息转发</td></tr><tr><td><code>handlerAdded(ChannelHandlerContext ctx)</code></td><td>连接建立，一旦建立连接，就第一个被执行</td></tr><tr><td><code>channelActive(ChannelHandlerContext ctx)</code></td><td>表示 channel 处于活动状态，提示 xxx 上线</td></tr><tr><td><code>channelInactive(ChannelHandlerContext ctx)</code></td><td>表示 channel 处于不活动状态，提示 xxx 离线</td></tr><tr><td><code>handlerRemoved(ChannelHandlerContext ctx)</code></td><td>表示 channel 断开连接，将xx客户离开信息推送给当前在线客户</td></tr><tr><td><code>exceptionCaught(ChannelHandlerContext ctx, Throwable cause)</code></td><td>出现错误如何进行处理</td></tr><tr><td><code>userEventTriggered(ChannelHandlerContext ctx, Object evt)</code></td><td>事件触发器，通过判断evt的类型去判断发生了什么事件，再通过里面的属性判断事件发生的类型。我们在<code>IdleStateHandler</code>后面加上一个触发器，可以检测心跳。</td></tr></tbody></table><blockquote><p> 本文档整理自 尚硅谷韩顺平Netty 相关课程。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-10-WebSocket&quot;&gt;&lt;a href=&quot;#Netty-10-WebSocket&quot; class=&quot;headerlink&quot; title=&quot;Netty-10-WebSocket&quot;&gt;&lt;/a&gt;Netty-10-WebSocket&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;实例要求&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Http 协议是无状态的，浏览器和服务器之间的请求只响应一次，下一次会重新创建连接&lt;/li&gt;
&lt;li&gt;要求  ： 实现基于webSocket 的长连接全双工的交互&lt;/li&gt;
&lt;li&gt;改变Http 协议多次请求的约束，实现长连接，服务器可以发送消息给浏览器&lt;/li&gt;
&lt;li&gt;客户端浏览器和服务器端会相互感知，比如服务器关闭了，浏览器会感知，同样浏览器关闭了，服务器会感知&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="NIO" scheme="http://zhuuu.work/tags/NIO/"/>
    
      <category term="WebSocket" scheme="http://zhuuu.work/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>Netty-11-ProtoBuf</title>
    <link href="http://zhuuu.work/2020/11/02/Netty/Netty-11-ProtoBuf/"/>
    <id>http://zhuuu.work/2020/11/02/Netty/Netty-11-ProtoBuf/</id>
    <published>2020-11-02T05:05:24.000Z</published>
    <updated>2020-11-04T05:51:08.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-11-ProtoBuf"><a href="#Netty-11-ProtoBuf" class="headerlink" title="Netty-11-ProtoBuf"></a>Netty-11-ProtoBuf</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>编写网络应用程序时，因为<strong>数据在网络中传输的都是二进制字节码数据</strong>，在发送数据的时候就需要编码，接收数据时候就需要解码</li><li><strong>codec(编解码器)的组成部分有两个</strong><ul><li><code>decoder</code>(解码器) ： 负责把字节码数据转换成业务逻辑</li><li><code>encoder</code>(编码器) ： 负责把业务数据转换成字节码数据</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201104/084813142.png" alt="mark"></p><a id="more"></a><h2 id="1-Netty-提供的编解码机制"><a href="#1-Netty-提供的编解码机制" class="headerlink" title="1. Netty 提供的编解码机制"></a>1. Netty 提供的编解码机制</h2><ul><li>Netty 本身的编解码器的机制和问题分析（为什么要引入<code>protobuf</code> ?）</li><li><code>Netty</code> 自身提供了一些 <code>codec</code>(编解码器)<ul><li><code>Netty</code> 提供的编码器 <code>StringEncoder</code>，对字符串数据进行编码 <code>ObjectEncoder</code>，对Java对象进行编码…</li><li><code>Netty</code> 提供的解码器 <code>StringDecoder</code>,对字符串数据进行解码 <code>ObjectDecoder</code>，对 <code>Java</code> 对象进行解码…</li></ul></li><li><strong><code>Netty</code> 本身自带的 <code>ObjectDecoder</code> 和 <code>ObjectEncoder</code> 可以用来实现 <code>POJO</code> 对象或各种业务对象的编码和解码，底层使用的仍是Java序列化技术,而Java序列化技术本身效率就不高，</strong>存在如下问题<ul><li>无法跨语言</li><li>序列化后的体积太大，是二进制编码的5倍多</li><li>序列化性能太低</li></ul></li></ul><p><strong>于是引出了新的解决方案（Google Protobuf）</strong></p><h2 id="2-ProtoBuf-简介"><a href="#2-ProtoBuf-简介" class="headerlink" title="2. ProtoBuf 简介"></a>2. ProtoBuf 简介</h2><p><strong>1. Google ProtoBuf 参考文档</strong>：</p><ul><li><a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/proto</a> <strong>语言指南</strong></li></ul><p><strong>2. 简介概述</strong></p><ul><li>首先，<strong>ProtoBuf 是用来将对象进行序列化的</strong>，相类似的技术还有<code>Json</code> 序列化等等，它是一种高效的结构化数据存储格式，</li><li>可以用于结构化数据串行化（序列化）。它很适合做数据存储或者<strong>RPC(远程工程调用)数据交换格式</strong> （目前很多公司 <code>http + json || tcp + protobuf</code>）</li><li><strong>ProtoBuf 是以 message的方式来管理数据的</strong></li></ul><p><strong>3. 优点：</strong></p><ul><li><strong>支持跨平台跨语言</strong> 【即客户端可以使用不同的语言编写】<ul><li>支持目前绝大多数语言，例如 C++、C#、Java、python 等</li></ul></li><li><strong>使用 protobuf 编译器能自动生成代码</strong></li><li><code>protobuf</code> 是将 类的定义使用<code>.proto</code> 文件进行描述<ul><li>说明，在<code>idea</code> 中编写 <code>.proto</code> 文件时，会自动提示是否下载 <code>.proto</code> 编写插件，可以让语法高亮</li><li><strong>然后通过 <code>proto.exe</code> 编译器根据 <code>.proto</code> 自动的生成java 文件</strong></li></ul></li></ul><p><strong>使用示意图 ：</strong> </p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201104/085943886.png" alt="mark"></p><h2 id="3-Proto-文件格式"><a href="#3-Proto-文件格式" class="headerlink" title="3. Proto 文件格式"></a>3. Proto 文件格式</h2><ul><li><strong>首先我们需要在<code>.proto</code>文件中定义好实体及他们的属性，再进行编译成<code>java</code>对象为我们所用。下面将介绍<code>proto</code>文件的写法。</strong></li></ul><ol><li><strong>文件头</strong></li></ol><ul><li>像写<code>java</code>需要写<code>package</code>包名一样，<code>.proto</code>文件也要写一些文件的全局属性，主要用于将<code>.proto</code>文件编译成<code>Java</code>文件。</li></ul><table><thead><tr><th><code>实例</code></th><th><code>介绍</code></th></tr></thead><tbody><tr><td><code>syntax=&quot;proto3&quot;;</code></td><td>声明使用到的protobuf的版本</td></tr><tr><td><code>optimize_for=SPEED;</code></td><td>表示</td></tr><tr><td><code>java_package=&quot;com.mical.netty.pojo&quot;;</code></td><td>表示生成Java对象所在包名</td></tr><tr><td><code>java_outer_classname=&quot;MyWorker&quot;;</code></td><td>表示生成的Java对象的外部类名</td></tr></tbody></table><ul><li>我们一般将这些代码写在<code>proto</code>文件的开头，以表明生成<code>Java</code>对象的相关文件属性。</li></ul><ol start="2"><li><strong>定义类和属性</strong></li></ol><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>; <span class="comment">//版本</span></span><br><span class="line"><span class="keyword">option</span> optimize_for = SPEED; <span class="comment">//加快解析</span></span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">"MyDataInfo"</span>; <span class="comment">//生成的外部类名，同时也是文件名</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Student</span> </span>&#123; <span class="comment">//会在StudentPojo 外部类生成一个内部类Student，他是真正发送的pojo对象</span></span><br><span class="line">    <span class="built_in">int32</span> id = <span class="number">1</span>; <span class="comment">//Student类中有一个属性名字为ID，类型为int32（protobuf类型），1表示序号，不是值</span></span><br><span class="line">    <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DateType</span> </span>&#123;</span><br><span class="line">    StudentType = <span class="number">0</span>; <span class="comment">//在proto3中，要求enum的编号从0开始</span></span><br><span class="line">    WorkerType = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如上图所示，我们在文件中不但声明了<code>protobuf</code>的版本，还声明了生成java对象的类名。当生成java对象后，<code>MyDataInfo</code>将是对象的类名，同时，它使用<code>message</code>声明了<code>Student</code>这个内部类，使用<code>enum</code>声明了<code>DataType</code>这个内部枚举类。就像下面这个样子</p></li><li><p><code>messag</code>：声明类。</p></li><li><p><code>enum</code>：声明枚举类。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDataInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> DataType &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后需要注意的是，protobuf中的变量类型和其他语言的声明有所不同。下面是<strong>类型的对照表</strong>。</p><table><thead><tr><th>.proto类型</th><th>java类型</th><th>C++类型</th><th>备注</th></tr></thead><tbody><tr><td><strong>double</strong></td><td><strong>double</strong></td><td><strong>double</strong></td><td></td></tr><tr><td><strong>float</strong></td><td><strong>float</strong></td><td><strong>float</strong></td><td></td></tr><tr><td><strong>int32</strong></td><td><strong>int</strong></td><td><strong>int32</strong></td><td><strong>使用可变长编码方式。编码负数时不够高效——如果你的字段可能含有负数，那么请使用sint32。</strong></td></tr><tr><td><strong>int64</strong></td><td><strong>long</strong></td><td><strong>int64</strong></td><td><strong>使用可变长编码方式。编码负数时不够高效——如果你的字段可能含有负数，那么请使用sint64。</strong></td></tr><tr><td>unit32</td><td>int[1]</td><td>unit32</td><td>总是4个字节。如果数值总是比总是比228大的话，这个类型会比uint32高效。</td></tr><tr><td>unit64</td><td>long[1]</td><td>unit64</td><td>总是8个字节。如果数值总是比总是比256大的话，这个类型会比uint64高效。</td></tr><tr><td>sint32</td><td>int</td><td>int32</td><td>使用可变长编码方式。有符号的整型值。编码时比通常的int32高效。</td></tr><tr><td>sint64</td><td>long</td><td>int64</td><td>使用可变长编码方式。有符号的整型值。编码时比通常的int64高效。</td></tr><tr><td>fixed32</td><td>int[1]</td><td>unit32</td><td></td></tr><tr><td>fixed64</td><td>long[1]</td><td>unit64</td><td>总是8个字节。如果数值总是比总是比256大的话，这个类型会比uint64高效。</td></tr><tr><td>sfixed32</td><td>int</td><td>int32</td><td>总是4个字节。</td></tr><tr><td>sfixed64</td><td>long</td><td>int64</td><td>总是8个字节。</td></tr><tr><td><strong>bool</strong></td><td><strong>boolean</strong></td><td><strong>bool</strong></td><td></td></tr><tr><td><strong>string</strong></td><td><strong>String</strong></td><td><strong>string</strong></td><td><strong>一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本。</strong></td></tr><tr><td>bytes</td><td>ByteString</td><td>string</td><td>可能包含任意顺序的字节数据</td></tr></tbody></table><ul><li>类型关注之后,我们看到代码中<code>string name = 2</code>，它并不是给name这个变量赋值，而是给它标号。每个类都需要给其中的变量标号，且需要注意的是类的标号是从1开始的，枚举的标号是从0开始的。</li></ul><ol start="3"><li><strong>复杂对象</strong></li></ol><ul><li>当我们<strong>需要统一发送对象和接受对象时，就需要使用一个对象将其他所有对象进行包装</strong>，再获取里面的某一类对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>; <span class="comment">//版本</span></span><br><span class="line">option optimize_for = SPEED; <span class="comment">//加快解析</span></span><br><span class="line">option java_outer_classname = <span class="string">"MyDataInfo"</span>; <span class="comment">//生成的外部类名，同时也是文件名</span></span><br><span class="line"></span><br><span class="line">message MyMessage &#123;</span><br><span class="line">    <span class="comment">//定义一个枚举类型</span></span><br><span class="line">    <span class="keyword">enum</span> DateType &#123;</span><br><span class="line">        StudentType = <span class="number">0</span>; <span class="comment">//在proto3中，要求enum的编号从0开始</span></span><br><span class="line">        WorkerType = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用data_type来标识传的是哪一个枚举类型</span></span><br><span class="line">    DateType data_type = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标识每次枚举类型最多只能出现其中的一个类型，节省空间</span></span><br><span class="line">    oneof dataBody &#123;</span><br><span class="line">        Student stuent = <span class="number">2</span>;</span><br><span class="line">        Worker worker = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Student &#123; <span class="comment">//会在StudentPojo 外部类生成一个内部类Student，他是真正发送的pojo对象</span></span><br><span class="line">    int32 id = <span class="number">1</span>; <span class="comment">//Student类中有一个属性名字为ID，类型为int32（protobuf类型），1表示序号，不是值</span></span><br><span class="line">    string name = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">message Worker &#123;</span><br><span class="line">    string name = <span class="number">1</span>;</span><br><span class="line">    int32 age = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里面我们定义了<code>MyMessage</code>、<code>Student</code>、<code>Worker</code>三个对象</li><li><code>MyMessage</code>里面持有了一个枚举类<code>DataType</code>和，<code>Student</code>、<code>Worker</code>这两个类对象中的其中一个。</li><li>这样设计的目的是什么呢？当我们在发送对象时，设置<code>MyMessage</code>里面的对象的同时就可以给枚举赋值，这样当我们接收对象时，就可以根据枚举判断我们接受到哪个实例类了。</li></ul><h2 id="4-Netty-ProtoBuf编解码器"><a href="#4-Netty-ProtoBuf编解码器" class="headerlink" title="4. Netty ProtoBuf编解码器"></a>4. Netty ProtoBuf编解码器</h2><h3 id="4-1-发送端"><a href="#4-1-发送端" class="headerlink" title="4.1 发送端"></a>4.1 发送端</h3><ol><li>需要给发送端的<code>pipeline</code>添加编码器：<code>ProtobufEncoder</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.group(group)</span><br><span class="line">    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> ProtobufEncoder());</span><br><span class="line">            pipeline.addLast(<span class="keyword">new</span> ProtoClientHandler());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>在发送时，如何<strong>构造一个具体对象</strong>呢？以上面复杂对象为例，我们主要构造的是<code>MyMessage</code>对象，设置里面的枚举属性，和对应的对象。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyDataInfo.MyMessage build = MyDataInfo.MyMessage.</span><br><span class="line">    newBuilder().</span><br><span class="line">    setDataType(MyDataInfo.MyMessage.DateType.StudentType)</span><br><span class="line">    .setStuent(MyDataInfo.Student</span><br><span class="line">                        .newBuilder()</span><br><span class="line">               .setId(<span class="number">5</span>)</span><br><span class="line">               .setName(<span class="string">"王五"</span>)</span><br><span class="line">               .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h3 id="4-2-接收端"><a href="#4-2-接收端" class="headerlink" title="4.2 接收端"></a>4.2 接收端</h3><ol><li>需要在接收端添加解码器：<code>ProtobufDecoder</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">LoggingHandler</span>())</span></span><br><span class="line"><span class="class">    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 128)</span></span><br><span class="line"><span class="class">    .<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            <span class="comment">//需要指定对哪种对象进行解码</span></span><br><span class="line">            pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> ProtobufDecoder(MyDataInfo.MyMessage.getDefaultInstance()));</span><br><span class="line">            pipeline.addLast(<span class="keyword">new</span> ProtoServerHandler());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li>在接收对象时，我们就可以根据枚举变量去获取实例对象了。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MyDataInfo.MyMessage message = (MyDataInfo.MyMessage) msg;</span><br><span class="line">MyDataInfo.MyMessage.DateType dataType = message.getDataType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (dataType) &#123;</span><br><span class="line">    <span class="keyword">case</span> StudentType:</span><br><span class="line">        MyDataInfo.Student student = message.getStuent();</span><br><span class="line">        System.out.println(<span class="string">"学生Id = "</span> + student.getId() + student.getName());</span><br><span class="line">    <span class="keyword">case</span> WorkerType:</span><br><span class="line">        MyDataInfo.Worker worker = message.getWorker();</span><br><span class="line">        System.out.println(<span class="string">"工人：name = "</span> + worker.getName() + worker.getAge());</span><br><span class="line">    <span class="keyword">case</span> UNRECOGNIZED:</span><br><span class="line">        System.out.println(<span class="string">"输入的类型不正确"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 本文档整理自 尚硅谷韩顺平Netty 相关课程。</p></blockquote><p><strong>参考博客 ：</strong> <a href="https://dongzl.github.io/netty-handbook/#/README" target="_blank" rel="noopener">https://dongzl.github.io/netty-handbook/#/README</a></p><p><strong>idea 使用 protobuf 问题 ：</strong> <a href="https://www.cnblogs.com/liugh/p/7505533.html" target="_blank" rel="noopener">https://www.cnblogs.com/liugh/p/7505533.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-11-ProtoBuf&quot;&gt;&lt;a href=&quot;#Netty-11-ProtoBuf&quot; class=&quot;headerlink&quot; title=&quot;Netty-11-ProtoBuf&quot;&gt;&lt;/a&gt;Netty-11-ProtoBuf&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;编写网络应用程序时，因为&lt;strong&gt;数据在网络中传输的都是二进制字节码数据&lt;/strong&gt;，在发送数据的时候就需要编码，接收数据时候就需要解码&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;codec(编解码器)的组成部分有两个&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;decoder&lt;/code&gt;(解码器) ： 负责把字节码数据转换成业务逻辑&lt;/li&gt;
&lt;li&gt;&lt;code&gt;encoder&lt;/code&gt;(编码器) ： 负责把业务数据转换成字节码数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201104/084813142.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="ProtoBuf" scheme="http://zhuuu.work/tags/ProtoBuf/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-059-螺旋矩阵II</title>
    <link href="http://zhuuu.work/2020/11/02/Leetcode/Leetcode-059-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/"/>
    <id>http://zhuuu.work/2020/11/02/Leetcode/Leetcode-059-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/</id>
    <published>2020-11-02T03:52:53.000Z</published>
    <updated>2020-11-05T06:15:36.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-059-螺旋矩阵-II"><a href="#Leetcode-059-螺旋矩阵-II" class="headerlink" title="Leetcode-059-螺旋矩阵 II"></a>Leetcode-059-<a href="https://leetcode-cn.com/problems/spiral-matrix-ii/" target="_blank" rel="noopener">螺旋矩阵 II</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个正整数 <em>n</em>，生成一个包含 1 到 <em>n</em> 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 8, 9, 4 ],</span><br><span class="line"> [ 7, 6, 5 ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-：模拟"><a href="#思路-：模拟" class="headerlink" title="思路 ：模拟"></a><strong>思路 ：模拟</strong></h2><ul><li>定义当前左右上下边界 <code>l,r,t,b</code>，初始值 <code>num = 1</code>，迭代终止值 <code>tar = n * n</code>；</li><li>当 <code>num &lt;= tar</code> 时，始终按照 <code>从左到右</code> <code>从上到下</code> <code>从右到左</code> <code>从下到上</code> 填入顺序循环，每次填入后：<ul><li>执行 <code>num += 1</code>：得到下一个需要填入的数字；</li><li>更新边界：例如从左到右填完后，上边界<code>t += 1</code>，相当于上边界向内缩 1。</li></ul></li><li><strong>使用<code>num &lt;= tar</code>而不是<code>l &lt; r || t &lt; b</code>作为迭代条件，是为了解决当<code>n</code>为奇数时，矩阵中心数字无法在迭代过程中被填充的问题。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  矩阵初始化 边界初始化</span></span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = matrix.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 起始数字和终止数字</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> target = n * n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环打印</span></span><br><span class="line">        <span class="keyword">while</span> (num &lt;= target)&#123;</span><br><span class="line">            <span class="comment">// 从左到右</span></span><br><span class="line">            <span class="comment">// 打印数字</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r ; i++) &#123;</span><br><span class="line">                matrix[t][i] = num;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 边界收缩</span></span><br><span class="line">            t++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从上到下</span></span><br><span class="line">            <span class="comment">// 打印数字</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt;= b ; i++) &#123;</span><br><span class="line">                matrix[i][r] = num;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 边界收缩</span></span><br><span class="line">            r--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从右到左</span></span><br><span class="line">            <span class="comment">// 打印数字</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt;= l ; i--) &#123;</span><br><span class="line">                matrix[b][i] = num;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 边界收缩</span></span><br><span class="line">            b--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从下到上</span></span><br><span class="line">            <span class="comment">// 打印数字</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &gt;= t ; i--) &#123;</span><br><span class="line">                matrix[i][l] = num;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 边界收缩</span></span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n^2) 矩阵元素的个数</li><li>空间复杂度:   O(1) 除了存储返回答案的空间以外，我们只需要额外的常数空间即可。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-059-螺旋矩阵-II&quot;&gt;&lt;a href=&quot;#Leetcode-059-螺旋矩阵-II&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-059-螺旋矩阵 II&quot;&gt;&lt;/a&gt;Leetcode-059-&lt;a href=&quot;https://leetcode-cn.com/problems/spiral-matrix-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;螺旋矩阵 II&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个正整数 &lt;em&gt;n&lt;/em&gt;，生成一个包含 1 到 &lt;em&gt;n&lt;/em&gt; 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [ 1, 2, 3 ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [ 8, 9, 4 ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [ 7, 6, 5 ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Netty-09-心跳检测机制</title>
    <link href="http://zhuuu.work/2020/11/02/Netty/Netty-09-%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6/"/>
    <id>http://zhuuu.work/2020/11/02/Netty/Netty-09-%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6/</id>
    <published>2020-11-02T02:05:24.000Z</published>
    <updated>2020-11-02T02:48:09.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-09-心跳检测机制"><a href="#Netty-09-心跳检测机制" class="headerlink" title="Netty-09-心跳检测机制"></a>Netty-09-心跳检测机制</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>实例要求</strong></p><ul><li>编写一个 Netty心跳检测机制案例, 当服务器超过3秒没有读时，就提示读空闲</li><li>当服务器超过5秒没有写操作时，就提示写空闲</li><li>实现当服务器超过7秒没有读或者写操作时，就提示读写空闲</li></ul><a id="more"></a><h2 id="1-服务端代码"><a href="#1-服务端代码" class="headerlink" title="1. 服务端代码"></a>1. 服务端代码</h2><h3 id="1-1-启动类"><a href="#1-1-启动类" class="headerlink" title="1.1 启动类"></a>1.1 启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">LoggingHandler</span>(<span class="title">LogLevel</span>.<span class="title">INFO</span>)) // 为<span class="title">bossGroup</span>请求日志处理<span class="title">handler</span></span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 加入一个netty提供的IdleStateHandler</span></span><br><span class="line">                            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                             * 1. IdleStateHandler 是netty提供的检测空闲状态的处理器</span></span><br><span class="line"><span class="comment">                             * 2. long readerIdleTime 表示多长事件没有读，就会发送一个心跳检测包检测是否还是连接状态</span></span><br><span class="line"><span class="comment">                             * 3、long writerIdleTime：表示多长时间没有写，就会发送一个心跳检测包检测是否还是连接的状态</span></span><br><span class="line"><span class="comment">                             * 4、long allIdleTime：表示多长时间没有读写，就会发送一个心跳检测包检测是否还是连接的状态</span></span><br><span class="line"><span class="comment">                             * 5、当 IdleStateEvent 触发后，就会传递给管道的下一个 Handler，通过调用（触发）下一个Handler的 userEventTriggered，在该方法区处理这个事件。</span></span><br><span class="line"><span class="comment">                             *</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line"></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 加入一个对空闲检测进一步处理的Handler(自定义)</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">//启动服务器，设置为同步模式。</span></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-Handler"><a href="#1-2-Handler" class="headerlink" title="1.2 Handler"></a>1.2 Handler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateEvent;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.EventExecutorGroup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evt 事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent)&#123;</span><br><span class="line">            <span class="comment">// 将evt向下转型成IdleStateEvent</span></span><br><span class="line">            IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断空闲事件类型</span></span><br><span class="line">            String eventType = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">switch</span> (event.state())&#123;</span><br><span class="line">                <span class="keyword">case</span> READER_IDLE:</span><br><span class="line">                    eventType = <span class="string">"读空闲"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WRITER_IDLE:</span><br><span class="line">                    eventType = <span class="string">"写空闲"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ALL_IDLE:</span><br><span class="line">                    eventType = <span class="string">"读写空闲"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ctx.channel().remoteAddress() +<span class="string">"---超时时间--"</span> + eventType);</span><br><span class="line">            System.out.println(<span class="string">"服务器做相应处理....."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-客户端代码"><a href="#2-客户端代码" class="headerlink" title="2. 客户端代码"></a>2. 客户端代码</h2><h3 id="2-1-客户端代码"><a href="#2-1-客户端代码" class="headerlink" title="2.1 客户端代码"></a>2.1 客户端代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        NioEventLoopGroup eventExecutors = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                    .group(eventExecutors)</span><br><span class="line">                    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//加入Handler</span></span><br><span class="line">                            pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> GroupChatClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// connect 事件</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(host, port).sync();</span><br><span class="line">            <span class="comment">// 得到channel,打印本地地址</span></span><br><span class="line">            Channel channel = channelFuture.channel();</span><br><span class="line">            System.out.println(<span class="string">"--------"</span> + channel.localAddress() + <span class="string">"---------"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 客户端需要输入信息</span></span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNextLine())&#123;</span><br><span class="line">                String msg = scanner.nextLine();</span><br><span class="line">                <span class="comment">// 通过channel 发送到服务器端</span></span><br><span class="line">                channel.writeAndFlush(msg + <span class="string">"\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            eventExecutors.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GroupChatClient(<span class="string">"127.0.0.1"</span>,<span class="number">7000</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-Handler"><a href="#2-2-Handler" class="headerlink" title="2.2  Handler"></a>2.2  Handler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(msg.trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-09-心跳检测机制&quot;&gt;&lt;a href=&quot;#Netty-09-心跳检测机制&quot; class=&quot;headerlink&quot; title=&quot;Netty-09-心跳检测机制&quot;&gt;&lt;/a&gt;Netty-09-心跳检测机制&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;实例要求&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编写一个 Netty心跳检测机制案例, 当服务器超过3秒没有读时，就提示读空闲&lt;/li&gt;
&lt;li&gt;当服务器超过5秒没有写操作时，就提示写空闲&lt;/li&gt;
&lt;li&gt;实现当服务器超过7秒没有读或者写操作时，就提示读写空闲&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="NIO" scheme="http://zhuuu.work/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-23-IO管理</title>
    <link href="http://zhuuu.work/2020/11/01/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-23-IO%E7%AE%A1%E7%90%86/"/>
    <id>http://zhuuu.work/2020/11/01/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-23-IO%E7%AE%A1%E7%90%86/</id>
    <published>2020-11-01T03:00:53.000Z</published>
    <updated>2020-11-02T03:04:15.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-23-IO管理"><a href="#操作系统-23-IO管理" class="headerlink" title="操作系统-23-IO管理"></a>操作系统-23-IO管理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>首先了解一下什么是IO 设备</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/112638277.png" alt="mark"></p><a id="more"></a><h2 id="1-IO-控制器"><a href="#1-IO-控制器" class="headerlink" title="1. IO 控制器"></a>1. IO 控制器</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/112847048.png" alt="mark"></p><ol><li><strong>机械部件</strong></li></ol><ul><li>执行具体的I/O操作，比如鼠标键盘的按钮，显示器的屏幕，移动硬盘的磁臂</li></ul><ol start="2"><li><strong>电子部件</strong></li></ol><ul><li><strong>CPU和机械部件的中介</strong>，通常是插入主板的电路板</li><li><strong>又叫I/O控制器，设备控制器</strong></li></ul><ol start="3"><li><strong>IO 控制器的组成</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/113021745.png" alt="mark"></p><ol start="4"><li><strong>IO 控制器两种寄存器编址方式</strong></li></ol><ul><li>内存映像</li><li>独立编址</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/113207976.png" alt="mark"></p><h2 id="2-IO-控制方式"><a href="#2-IO-控制方式" class="headerlink" title="2. IO 控制方式"></a>2. IO 控制方式</h2><ul><li><strong>有以下四种IO 控制方式</strong><ul><li><strong>程序直接控制</strong></li><li><strong>中断驱动方式</strong></li><li><strong>直接存储器存取DMA 方式</strong></li><li><strong>通道控制方式</strong></li></ul></li></ul><h3 id="2-1-程序直接控制"><a href="#2-1-程序直接控制" class="headerlink" title="2.1 程序直接控制"></a>2.1 程序直接控制</h3><ul><li>流程图如下</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/151737147.png" alt="mark"></p><h3 id="2-2-中断驱动方式"><a href="#2-2-中断驱动方式" class="headerlink" title="2.2 中断驱动方式"></a>2.2 中断驱动方式</h3><ul><li>流程图如下</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/152102370.png" alt="mark"></p><h3 id="2-3-DMA-方式"><a href="#2-3-DMA-方式" class="headerlink" title="2.3 DMA 方式"></a><strong>2.3 DMA 方式</strong></h3><ol><li><strong>DMA 控制器图</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/152156189.png" alt="mark"></p><ol start="2"><li><strong>流程图如下</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/152438653.png" alt="mark"></p><h3 id="2-4-通道处理方式"><a href="#2-4-通道处理方式" class="headerlink" title="2.4 通道处理方式"></a>2.4 通道处理方式</h3><ol><li><strong>通道的概念</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/152751952.png" alt="mark"></p><ol start="2"><li><strong>流程图</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/153050863.png" alt="mark"></p><h3 id="2-5-小结对比"><a href="#2-5-小结对比" class="headerlink" title="2.5 小结对比"></a>2.5 小结对比</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/153109627.png" alt="mark"></p><h2 id="3-IO-软件层次"><a href="#3-IO-软件层次" class="headerlink" title="3. IO 软件层次"></a>3. IO 软件层次</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/105845878.png" alt="mark"></p><h3 id="3-1-用户层软件"><a href="#3-1-用户层软件" class="headerlink" title="3.1 用户层软件"></a>3.1 用户层软件</h3><ul><li>向下提供系统调用</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/105904327.png" alt="mark"></p><h3 id="3-2-设备独立性软件"><a href="#3-2-设备独立性软件" class="headerlink" title="3.2 设备独立性软件"></a>3.2 设备独立性软件</h3><p><strong>功能</strong></p><ul><li>提供调用接口(read/write系统调用) </li><li>设备保护 </li><li>差错处理 </li><li><strong>设备分配与回收</strong> </li><li><strong>数据缓冲区管理</strong> </li><li><strong>建立逻辑设备名到物理设备名的映射关系</strong> </li><li>根据设备类型调用相应的驱动程序</li></ul><p><strong>逻辑设备表 LUT</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/110032068.png" alt="mark"></p><h3 id="3-3-设备驱动程序"><a href="#3-3-设备驱动程序" class="headerlink" title="3.3 设备驱动程序"></a>3.3 设备驱动程序</h3><ul><li>设置设备的寄存器</li><li>检测设备状态</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/110122761.png" alt="mark"></p><h3 id="3-4-中断处理程序"><a href="#3-4-中断处理程序" class="headerlink" title="3.4 中断处理程序"></a>3.4 中断处理程序</h3><ul><li><strong>一次IO 请求的流程</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/110157329.png" alt="mark"></p><ul><li><strong>中断处理逻辑</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/110412976.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考笔记 ：</strong> <a href="https://blog.csdn.net/weixin_43914604/article/details/104415990" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43914604/article/details/104415990</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-23-IO管理&quot;&gt;&lt;a href=&quot;#操作系统-23-IO管理&quot; class=&quot;headerlink&quot; title=&quot;操作系统-23-IO管理&quot;&gt;&lt;/a&gt;操作系统-23-IO管理&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;首先了解一下什么是IO 设备&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/112638277.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-22-磁盘调度算法</title>
    <link href="http://zhuuu.work/2020/11/01/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-22-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <id>http://zhuuu.work/2020/11/01/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-22-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</id>
    <published>2020-11-01T02:00:53.000Z</published>
    <updated>2020-11-01T03:24:21.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-22-磁盘调度算法"><a href="#操作系统-22-磁盘调度算法" class="headerlink" title="操作系统-22-磁盘调度算法"></a>操作系统-22-磁盘调度算法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111815980.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg" alt="mark"></p><a id="more"></a><h2 id="1-一次读磁盘所需要的时间"><a href="#1-一次读磁盘所需要的时间" class="headerlink" title="1. 一次读磁盘所需要的时间"></a>1. 一次读磁盘所需要的时间</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111926789.png" alt="mark"></p><h2 id="2-磁盘调度算法"><a href="#2-磁盘调度算法" class="headerlink" title="2. 磁盘调度算法"></a>2. 磁盘调度算法</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg" alt="mark"></p><p>磁盘调度算法的目的很简单，就是为了提高磁盘的访问性能，一般是通过优化磁盘的访问请求顺序来做到的。</p><p>寻道的时间是磁盘访问最耗时的部分，如果请求顺序优化的得当，必然可以节省一些不必要的寻道时间，从而提高磁盘的访问性能。</p><h3 id="2-1-先来先服务"><a href="#2-1-先来先服务" class="headerlink" title="2.1 先来先服务"></a>2.1 先来先服务</h3><ul><li><p>先来先服务（<em>First-Come，First-Served，FCFS</em>），顾名思义，先到来的请求，先被服务。</p></li><li><p>那按照这个序列的话：</p><p><code>98，183，37，122，14，124，65，67</code></p><p>那么，磁盘的写入顺序是从左到右，如下图：</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/144809106.png" alt="mark"></p><ul><li>先来先服务算法总共移动了 <code>640</code> 个磁道的距离，这么一看这种算法，比较简单粗暴，但是如果大量进程竞争使用磁盘，请求访问的磁道可能会很分散，那先来先服务算法在性能上就会显得很差，因为寻道时间过长。</li></ul><h3 id="2-2-最短寻道时间优先"><a href="#2-2-最短寻道时间优先" class="headerlink" title="2.2 最短寻道时间优先"></a>2.2 最短寻道时间优先</h3><ul><li>最短寻道时间优先（<em>Shortest Seek First，SSF</em>）算法的工作方式是，优先选择从当前磁头位置所需寻道时间最短的请求，还是以这个序列为例子：</li></ul><p><code>98，183，37，122，14，124，65，67</code></p><ul><li>那么，那么根据距离磁头（ 53 位置）最近的请求的算法，具体的请求则会是下列从左到右的顺序：</li></ul><p><code>65，67，37，14，98，122，124，183</code></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/144946962.png" alt="mark"></p><ul><li>磁头移动的总距离是 <code>236</code> 磁道，相比先来先服务性能提高了不少。<ul><li>但这个算法可能存在某些请求的<strong>饥饿</strong>，因为本次例子我们是静态的序列，看不出问题，</li><li>假设是一个动态的请求，如果后续来的请求都是小于 183 磁道的，那么 183 磁道可能永远不会被响应，于是就产生了饥饿现象，这里<strong>产生饥饿的原因是磁头在一小块区域来回移动</strong>。</li></ul></li></ul><h3 id="2-3-扫描算法"><a href="#2-3-扫描算法" class="headerlink" title="2.3 扫描算法"></a>2.3 扫描算法</h3><ul><li>最短寻道时间优先算法会产生饥饿的原因在于：磁头有可能再一个小区域内来回得移动。</li><li>为了防止这个问题，可以规定：<strong>磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后的磁道，才调换方向，这就是扫描（Scan）算法</strong>。</li><li>这种算法也叫做<strong>电梯算法</strong>，比如电梯保持按一个方向移动，直到在那个方向上没有请求为止，然后改变方向。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">还是以这个序列为例子，磁头的初始位置是 53：</span><br><span class="line"></span><br><span class="line">98，183，37，122，14，124，65，67</span><br><span class="line"></span><br><span class="line">那么，假设扫描调度算先朝磁道号减少的方向移动，具体请求则会是下列从左到右的顺序：</span><br><span class="line"></span><br><span class="line">37，14，0，65，67，98，122，124，183</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/145111421.png" alt="mark"></p><ul><li>磁头先响应左边的请求，直到到达最左端（ 0 磁道）后，才开始反向移动，响应右边的请求。</li><li>扫描调度算法性能较好，不会产生饥饿现象，但是存在这样的问题<ul><li><strong>中间部分的磁道会比较占便宜</strong>，中间部分相比其他部分<strong>响应的频率会比较多</strong>，也就是说每个磁道的响应频率存在差异。</li></ul></li></ul><h3 id="2-4-循环扫描算法"><a href="#2-4-循环扫描算法" class="headerlink" title="2.4 循环扫描算法"></a>2.4 循环扫描算法</h3><ul><li>扫描算法使得每个磁道响应的频率存在差异，那么<strong>要优化这个问题的话，可以总是按相同的方向进行扫描，使得每个磁道的响应频率基本一致。</strong></li></ul><ul><li>循环扫描（<em>Circular Scan, CSCAN</em> ）规定：只有磁头朝某个特定方向移动时，才处理磁道访问请求，而<strong>返回时直接快速移动至最靠边缘的磁道，也就是复位磁头</strong>，这个过程是很快的，并且<strong>返回中途不处理任何请求</strong>，该算法的特点，就是<strong>磁道只响应一个方向上的请求</strong>。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">还是以这个序列为例子，磁头的初始位置是 53：</span><br><span class="line"></span><br><span class="line">98，183，37，122，14，124，65，67</span><br><span class="line"></span><br><span class="line">那么，假设循环扫描调度算先朝磁道增加的方向移动，具体请求会是下列从左到右的顺序：</span><br><span class="line"></span><br><span class="line">65，67，98，122，124，183，199，0，14，37</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/145234782.png" alt="mark"></p><ul><li>磁头先响应了右边的请求，直到碰到了最右端的磁道 199，就立即回到磁盘的开始处（磁道 0），但这个返回的途中是不响应任何请求的，直到到达最开始的磁道后，才继续顺序响应右边的请求。</li><li>循环扫描算法相比于扫描算法，对于<strong>各个位置磁道响应频率相对比较平均。</strong></li></ul><h3 id="2-5-LOOK-与-C-LOOK算法"><a href="#2-5-LOOK-与-C-LOOK算法" class="headerlink" title="2.5 LOOK 与 C-LOOK算法"></a>2.5 LOOK 与 C-LOOK算法</h3><ul><li>我们前面说到的扫描算法和循环扫描算法，都是磁头移动到磁盘「最始端或最末端」才开始调换方向。</li><li>那这其实是可以优化的，优化的思路就是<strong>磁头在移动到「最远的请求」位置，然后立即反向移动。</strong></li><li>那<strong>针对 SCAN 算法的优化则叫 LOOK 算法</strong>，它的工作方式，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，<strong>反向移动的途中会响应请求</strong>。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/145437467.png" alt="mark"></p><ul><li>而针 <strong>C-SCAN 算法的优化则叫 C-LOOK</strong>，它的工作方式，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，<strong>反向移动的途中不会响应请求</strong>。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/145453441.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-22-磁盘调度算法&quot;&gt;&lt;a href=&quot;#操作系统-22-磁盘调度算法&quot; class=&quot;headerlink&quot; title=&quot;操作系统-22-磁盘调度算法&quot;&gt;&lt;/a&gt;操作系统-22-磁盘调度算法&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111815980.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="磁盘管理" scheme="http://zhuuu.work/tags/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket理解</title>
    <link href="http://zhuuu.work/2020/11/01/NetworkCoding/WebSocket%E7%90%86%E8%A7%A3/"/>
    <id>http://zhuuu.work/2020/11/01/NetworkCoding/WebSocket%E7%90%86%E8%A7%A3/</id>
    <published>2020-11-01T01:02:24.000Z</published>
    <updated>2020-11-01T01:56:34.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebSocket理解"><a href="#WebSocket理解" class="headerlink" title="WebSocket理解"></a>WebSocket理解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><strong>WebSocket是HTML5出的东西（协议），也就是说HTTP协议没有变化，或者说没关系，但HTTP是不支持持久连接的（长连接，循环连接的不算）</strong></li><li>首先HTTP有<code>1.1</code>和<code>1.0</code>之说，也就是所谓的<code>keep-alive</code>，把多个HTTP请求合并为一个，但是<strong><code>Websocket</code>其实是一个新协议，跟HTTP协议基本没有关系</strong>，只是为了兼容现有浏览器的握手规范而已，也就是说它是HTTP协议上的一种补充可以通过这样一张图理解</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/093305644.png" alt="mark"></p><p>有交集，但是并不是全部。</p><ul><li>另外Html5是指的一系列新的API，或者说新规范，新技术。Http协议本身只有1.0和1.1，而且跟Html本身没有直接关系。</li><li>通俗来说，你可以用HTTP<strong>协议</strong>传输非Html<strong>数据</strong>，就是这样=。=</li><li>再简单来说，<strong>层级不一样</strong>。</li></ul><a id="more"></a><h2 id="1-WebSocket概念"><a href="#1-WebSocket概念" class="headerlink" title="1. WebSocket概念"></a>1. WebSocket概念</h2><ul><li>首先，Websocket是一个<strong>持久化</strong>的协议，相对于HTTP这种<strong>非持久</strong>的协议来说。</li></ul><p>简单的举个例子吧，用目前应用比较广泛的PHP生命周期来解释。</p><ol><li>HTTP的生命周期通过Request来界定，也就是一个Request 一个Response，那么<strong>在</strong>HTTP1.0<strong>中</strong>，这次HTTP请求就结束了。</li><li>在HTTP1.1中进行了改进，使得有一个keep-alive，也就是说，在一个HTTP连接中，可以发送多个Request，接收多个Response。</li><li>但是请记住 Request = Response ， <strong>在HTTP中永远是这样，也就是说一个request只能有一个response</strong>。而且这个response也是<strong>被动</strong>的，不能主动发起。</li></ol><p><strong>HTTP 和 WebSocket 的关系</strong></p><ul><li><p>首先Websocket是基于HTTP协议的，或者说<strong>借用</strong>了HTTP的协议来完成一部分握手。</p></li><li><p>在握手阶段是一样的</p></li><li><p>然后我们来看个典型的WebSocket 握手</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http://example.com</span><br></pre></td></tr></table></figure><p>熟悉HTTP的童鞋可能发现了，这段类似HTTP协议的握手请求中，多了几个东西。<br>我会顺便讲解下作用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure><p>这个就是Websocket的核心了，告诉Apache、Nginx等服务器：<strong>注意啦，窝发起的是Websocket协议，快点帮我找到对应的助理处理~不是那个老土的HTTP。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li><p>首先，Sec-WebSocket-Key 是一个Base64 encode的值，这个是浏览器随机生成的，告诉服务器：<strong>泥煤，不要忽悠窝，我要验证尼是不是真的是Websocket助理。</strong></p></li><li><p>然后，Sec_WebSocket-Protocol 是一个用户定义的字符串，用来区分同URL下，不同的服务所需要的协议。简单理解：<strong>今晚我要服务A，别搞错啦~</strong></p></li><li><p>最后，Sec-WebSocket-Version 是告诉服务器所使用的Websocket Draft（协议版本），在最初的时候，Websocket协议还在 Draft 阶段，各种奇奇怪怪的协议都有，而且还有很多期奇奇怪怪不同的东西，什么Firefox和Chrome用的不是一个版本之类的，当初Websocket协议太多可是一个大难题。。不过现在还好，已经定下来啦<del>大家都使用的一个东西</del> 脱水：<strong>服务员，我要的是13岁的噢→_→</strong></p></li></ol><ul><li>然后服务器会返回下列东西，表示已经接受到请求， 成功建立Websocket啦！</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure><p>这里开始就是HTTP最后负责的区域了，告诉客户，我已经成功切换协议啦~</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure><p>依然是固定的，告诉客户端即将升级的是Websocket协议，而不是mozillasocket，lurnarsocket或者shitsocket。</p><p>然后，Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key。服务器：<strong>好啦好啦，知道啦，给你看我的ID CARD来证明行了吧。。</strong><br>后面的，Sec-WebSocket-Protocol 则是表示最终使用的协议。</p><p><strong>至此，HTTP已经完成它所有工作了，接下来就是完全按照Websocket协议进行了。</strong></p><h2 id="2-WebSocket的作用"><a href="#2-WebSocket的作用" class="headerlink" title="2. WebSocket的作用"></a>2. WebSocket的作用</h2><p>在讲Websocket之前，我就<strong>顺带着讲下 long poll 和 ajax轮询 的原理</strong>。</p><ol><li><strong>首先是 ajax轮询 ，ajax轮询 的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">场景再现：</span><br><span class="line">客户端：啦啦啦，有没有新信息(Request)</span><br><span class="line">服务端：没有（Response）</span><br><span class="line">客户端：啦啦啦，有没有新信息(Request)</span><br><span class="line">服务端：没有。。（Response）</span><br><span class="line">客户端：啦啦啦，有没有新信息(Request)</span><br><span class="line">服务端：你好烦啊，没有啊。。（Response）</span><br><span class="line">客户端：啦啦啦，有没有新消息（Request）</span><br><span class="line">服务端：好啦好啦，有啦给你。（Response）</span><br><span class="line">客户端：啦啦啦，有没有新消息（Request）</span><br><span class="line">服务端：。。。。。没。。。。没。。。没有（Response） ---- loop</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>long poll</strong></li></ol><ul><li>long poll 其实原理跟 ajax轮询 差不多，都是采用轮询的方式，</li><li>不过采取的是<strong>阻塞模型</strong>（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。</li><li>直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request）</span><br><span class="line">服务端：额。。 等待到有消息的时候。。来 给你（Response）</span><br><span class="line">客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request） -loop</span><br></pre></td></tr></table></figure><p><strong>注意 ： 上面的共性</strong></p><ul><li><p>从上面可以看出其实这两种方式，都是在不断地建立HTTP连接，然后等待服务端处理</p></li><li><p>可以体现HTTP协议的另外一个特点，<strong>被动性</strong>。</p><ul><li>何为被动性呢，其实就是，<strong>服务端不能主动联系客户端，只能有客户端发起。</strong></li></ul></li><li><p>缺点：</p><ul><li>很容易看出来，不管怎么样，上面这两种都是非常消耗资源的。</li><li><strong>ajax轮询 需要服务器有很快的处理速度和资源。（速度）</strong></li><li><strong>long poll 需要有很高的并发，也就是说同时接待客户的能力。（场地大小）</strong></li></ul></li></ul><p><strong>所以ajax轮询 和long poll 都有可能发生这种情况。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">客户端：啦啦啦啦，有新信息么？</span><br><span class="line">服务端：月线正忙，请稍后再试（503 Server Unavailable）</span><br><span class="line">客户端：。。。。好吧，啦啦啦，有新信息么？</span><br><span class="line">服务端：月线正忙，请稍后再试（503 Server Unavailable）</span><br></pre></td></tr></table></figure><ul><li>通过上面这个例子，我们可以看出，这两种方式都不是最好的方式，需要很多资源。</li><li>HTTP还是一个<strong>无状态协议</strong>。<ul><li>通俗的说就是，服务器因为每天要接待太多客户了，是个<strong>健忘鬼</strong>，你一挂电话，他就把你的东西全忘光了，把你的东西全丢掉了。你第二次还得再告诉服务器一遍。</li></ul></li></ul><h3 id="2-1-WebSocket-的诞生"><a href="#2-1-WebSocket-的诞生" class="headerlink" title="2.1 WebSocket 的诞生"></a>2.1 WebSocket 的诞生</h3><ul><li>所以在这种情况下出现了，Websocket出现了。</li><li>他解决了HTTP的这几个难题。<ul><li>首先，<strong>被动性</strong>，当服务器完成协议升级后（HTTP-&gt;Websocket），服务端就可以主动推送信息给客户端啦。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">所以上面的情景可以做如下修改。</span><br><span class="line">客户端：啦啦啦，我要建立Websocket协议，需要的服务：chat，Websocket协议版本：17（HTTP Request）</span><br><span class="line">服务端：ok，确认，已升级为Websocket协议（HTTP Protocols Switched）</span><br><span class="line">客户端：麻烦你有信息的时候推送给我噢。。</span><br><span class="line">服务端：ok，有的时候会告诉你的。</span><br><span class="line">服务端：balabalabalabala服务端：balabalabalabala</span><br><span class="line">服务端：哈哈哈哈哈啊哈哈哈哈服务端：笑死我了哈哈哈哈哈哈哈</span><br></pre></td></tr></table></figure><ul><li><p>只需要经过<strong>一次HTTP请求</strong>，就可以做到源源不断的信息传送了。（在程序设计中，这种设计叫做<strong>回调</strong>，即：你有信息了再来通知我，而不是我傻乎乎的每次跑来问你）</p></li><li><p>那么为什么他会<strong>解决服务器上消耗资源</strong>的问题呢？</p><ul><li>其实我们所用的程序是要经过两层代理的，即<strong>HTTP协议在Nginx等服务器的解析下</strong>，然后再传送给相应的<strong>Handler（PHP等）</strong>来处理。</li><li>简单地说，我们有一个非常快速的接<strong>线员（Nginx）</strong>，他负责把问题转交给相应的<strong>客服（Handler）</strong>。</li><li>本身<strong>接线员基本上速度是足够的</strong>，但是每次都卡在<strong>客服（Handler）</strong>了，老有<strong>客服</strong>处理速度太慢。，导致客服不够。</li><li>Websocket就解决了这样一个难题，建立后，可以直接跟接线员建立持<strong>久连接</strong>，有信息的时候客服想办法通知接线员，然后<strong>接线员</strong>在统一转交给客户。</li></ul></li></ul><ul><li><p>同时，在传统的方式上，要不断的建立，关闭HTTP协议</p><ul><li>由于HTTP是非状态性的，每次都要<strong>重新传输identity info（鉴别信息）</strong>，来告诉服务端你是谁。</li><li>虽然接线员很快速，但是每次都要听这么一堆，效率也会有所下降的，同时还得不断把这些信息转交给客服，不但浪费客服的<strong>处理时间</strong>，而且还会在网路传输中消耗<strong>过多的流量/时间。</strong></li><li>但是Websocket只需要<strong>一次HTTP握手，所以说整个通讯过程是建立在一次连接/状态中</strong>，</li><li>也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议，还要查看identity info的信息。</li></ul></li><li><p>同时由<strong>客户主动询问</strong>，转换为<strong>服务器（推送）有信息的时候就发送（当然客户端还是等主动发送信息过来的。。）</strong></p><ul><li>没有信息的时候就交给接线员（Nginx），不需要占用本身速度就慢的<strong>客服（Handler）</strong>了</li></ul></li></ul><p><strong>PS  :</strong></p><p><strong>至于怎么在不支持Websocket的客户端上使用Websocket。。答案是：不能</strong></p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.  总结"></a>3.  总结</h2><ul><li>可以把 WebSocket 看成是 HTTP 协议为了支持长连接所打的一个大补丁，它和 HTTP 有一些共性，是为了解决 HTTP 本身无法解决的某些问题而做出的一个改良设计。</li><li>在以前 HTTP 协议中所谓的 keep-alive connection 是指在一次 TCP 连接中完成多个 HTTP 请求，但是对每个请求仍然要单独发 header；所谓的 polling 是指从客户端（一般就是浏览器）不断主动的向服务器发 HTTP 请求查询是否有新数据。</li><li>这两种模式有一个共同的缺点，<strong>就是除了真正的数据部分外，服务器和客户端还要大量交换 HTTP header</strong>，信息交换效率很低。<strong>它们建立的“长连接”都是伪.长连接</strong>，只不过好处是不需要对现有的 HTTP server 和浏览器架构做修改就能实现。</li></ul><p><strong>WebSocket 解决的第一个问题是，通过第一个 HTTP request 建立了 TCP 连接之后，之后的交换数据都不需要再发 HTTP request了</strong></p><ul><li>使得这个长连接变成了一个<strong>真.长连接</strong></li><li>但是不需要发送 HTTP header就能交换数据显然和原有的 HTTP 协议是有区别的，所以它需要对服务器和客户端都进行升级才能实现。</li><li>在此基础上 WebSocket 还是一个双通道的连接，在同一个 TCP 连接上既可以发也可以收信息。</li><li>另外外还有 multiplexing 功能，几个不同的 URI 可以复用同一个 WebSocket 连接。这些都是原来的 HTTP 不能做到的。</li></ul><p><strong>另外说一点技术细节，因为看到有人提问 WebSocket 可能进入某种半死不活的状态。这实际上也是原有网络世界的一些缺陷性设计</strong></p><ul><li>上面所说的 WebSocket 真.长连接虽然解决了服务器和客户端两边的问题，但坑爹的是网络应用除了服务器和客户端之外，另一个巨大的存在是中间的网络链路。</li><li>一个 HTTP/WebSocket 连接往往要经过无数的路由，防火墙。你以为你的数据是在一个“连接”中发送的，实际上它要跨越千山万水，经过无数次转发，过滤，才能最终抵达终点。在这过程中，中间节点的处理方法很可能会让你意想不到。</li><li>比如说，这些坑爹的中间节点可能会认为一份连接在一段时间内没有数据发送就等于失效，它们会自作主张的切断这些连接。</li><li>在这种情况下，不论服务器还是客户端都不会收到任何提示，它们只会一厢情愿的以为彼此间的红线还在，徒劳地一边又一边地发送抵达不了彼岸的信息。而计算机网络协议栈的实现中又会有一层套一层的缓存，除非填满这些缓存，你的程序根本不会发现任何错误</li></ul><p><strong>这样，本来一个美好的 WebSocket 长连接，就可能在毫不知情的情况下进入了半死不活状态。</strong></p><p><strong>而解决方案，WebSocket 的设计者们也早已想过。就是让服务器和客户端能够发送 Ping/Pong Frame</strong>（<a href="https://link.zhihu.com/?target=https%3A//tools.ietf.org/html/rfc6455%23section-5.5.2">RFC 6455 - The WebSocket Protocol</a>）。<strong>（心跳包）</strong></p><p><strong>这种 Frame 是一种特殊的数据包，它只包含一些元数据而不需要真正的 Data Payload，可以在不影响 Application 的情况下维持住中间网络的连接状态。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;WebSocket理解&quot;&gt;&lt;a href=&quot;#WebSocket理解&quot; class=&quot;headerlink&quot; title=&quot;WebSocket理解&quot;&gt;&lt;/a&gt;WebSocket理解&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;WebSocket是HTML5出的东西（协议），也就是说HTTP协议没有变化，或者说没关系，但HTTP是不支持持久连接的（长连接，循环连接的不算）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;首先HTTP有&lt;code&gt;1.1&lt;/code&gt;和&lt;code&gt;1.0&lt;/code&gt;之说，也就是所谓的&lt;code&gt;keep-alive&lt;/code&gt;，把多个HTTP请求合并为一个，但是&lt;strong&gt;&lt;code&gt;Websocket&lt;/code&gt;其实是一个新协议，跟HTTP协议基本没有关系&lt;/strong&gt;，只是为了兼容现有浏览器的握手规范而已，也就是说它是HTTP协议上的一种补充可以通过这样一张图理解&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/093305644.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;有交集，但是并不是全部。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;另外Html5是指的一系列新的API，或者说新规范，新技术。Http协议本身只有1.0和1.1，而且跟Html本身没有直接关系。&lt;/li&gt;
&lt;li&gt;通俗来说，你可以用HTTP&lt;strong&gt;协议&lt;/strong&gt;传输非Html&lt;strong&gt;数据&lt;/strong&gt;，就是这样=。=&lt;/li&gt;
&lt;li&gt;再简单来说，&lt;strong&gt;层级不一样&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="WebSocket" scheme="http://zhuuu.work/tags/WebSocket/"/>
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-21-磁盘管理</title>
    <link href="http://zhuuu.work/2020/10/31/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-21-%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    <id>http://zhuuu.work/2020/10/31/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-21-%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-10-31T02:00:53.000Z</published>
    <updated>2020-11-01T07:41:05.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-21-磁盘管理"><a href="#操作系统-21-磁盘管理" class="headerlink" title="操作系统-21-磁盘管理"></a>操作系统-21-磁盘管理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111136067.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/144348215.png" alt="mark"></p><a id="more"></a><h2 id="1-磁盘的结构"><a href="#1-磁盘的结构" class="headerlink" title="1. 磁盘的结构"></a>1. 磁盘的结构</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111241257.png" alt="mark"></p><ol><li><strong>如何在磁盘中读写数据？</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111310259.png" alt="mark"></p><ol start="2"><li><strong>柱面盘面扇区号 = 磁盘地址</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111349961.png" alt="mark"></p><ol start="3"><li><strong>磁盘的分类</strong></li></ol><ul><li>按盘面分类</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111429132.png" alt="mark"></p><ul><li>按磁头分类</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111434376.png" alt="mark"></p><h2 id="2-磁盘管理"><a href="#2-磁盘管理" class="headerlink" title="2. 磁盘管理"></a>2. 磁盘管理</h2><h3 id="2-1-磁盘初始化"><a href="#2-1-磁盘初始化" class="headerlink" title="2.1 磁盘初始化"></a>2.1 磁盘初始化</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111623596.png" alt="mark"></p><h3 id="2-2-引导块"><a href="#2-2-引导块" class="headerlink" title="2.2 引导块"></a>2.2 引导块</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111648466.png" alt="mark"></p><h3 id="2-3-坏道管理（坏块）"><a href="#2-3-坏道管理（坏块）" class="headerlink" title="2.3 坏道管理（坏块）"></a>2.3 坏道管理（坏块）</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111715011.png" alt="mark"></p><h2 id="3-减少磁盘延迟"><a href="#3-减少磁盘延迟" class="headerlink" title="3. 减少磁盘延迟"></a>3. 减少磁盘延迟</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/153257581.png" alt="mark"></p><p><strong>需要减少磁盘延迟的原因 ： 无法连续的读取数据</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/153315306.png" alt="mark"></p><h3 id="3-1-交替编号"><a href="#3-1-交替编号" class="headerlink" title="3.1 交替编号"></a>3.1 交替编号</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/153406299.png" alt="mark"></p><h3 id="3-2-磁盘地址结构的设计"><a href="#3-2-磁盘地址结构的设计" class="headerlink" title="3.2 磁盘地址结构的设计"></a>3.2 磁盘地址结构的设计</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/153423711.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/153509150.png" alt="mark"></p><h3 id="3-3-错位命名"><a href="#3-3-错位命名" class="headerlink" title="3.3 错位命名"></a>3.3 错位命名</h3><ul><li>不使用错位命名</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/154002106.png" alt="mark"></p><ul><li>使用错位命名</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/154100860.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-21-磁盘管理&quot;&gt;&lt;a href=&quot;#操作系统-21-磁盘管理&quot; class=&quot;headerlink&quot; title=&quot;操作系统-21-磁盘管理&quot;&gt;&lt;/a&gt;操作系统-21-磁盘管理&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111136067.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/144348215.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="磁盘管理" scheme="http://zhuuu.work/tags/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-381-O(1) 时间插入、删除和获取随机元素 - 允许重复</title>
    <link href="http://zhuuu.work/2020/10/31/Leetcode/Leetcode-381-O(1)%20%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0%20-%20%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D/"/>
    <id>http://zhuuu.work/2020/10/31/Leetcode/Leetcode-381-O(1)%20%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0%20-%20%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D/</id>
    <published>2020-10-31T00:52:53.000Z</published>
    <updated>2020-10-31T02:06:35.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-381-O-1-时间插入、删除和获取随机元素-允许重复"><a href="#Leetcode-381-O-1-时间插入、删除和获取随机元素-允许重复" class="headerlink" title="Leetcode-381-O(1) 时间插入、删除和获取随机元素 - 允许重复"></a>Leetcode-381-<a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed/" target="_blank" rel="noopener">O(1) 时间插入、删除和获取随机元素 - 允许重复</a></h1><h2 id="思路：哈希表"><a href="#思路：哈希表" class="headerlink" title="思路：哈希表"></a>思路：哈希表</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>设计一个支持在平均 时间复杂度 O(1) 下， 执行以下操作的数据结构。</p><p>注意: 允许出现重复元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert(val)：向集合中插入元素 val。</span><br><span class="line">remove(val)：当 val 存在时，从集合中移除一个 val。</span><br><span class="line">getRandom：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 初始化一个空的集合。</span><br><span class="line">RandomizedCollection collection &#x3D; new RandomizedCollection();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向集合中插入 1 。返回 true 表示集合不包含 1 。</span><br><span class="line">collection.insert(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。</span><br><span class="line">collection.insert(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。</span><br><span class="line">collection.insert(2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; getRandom 应当有 2&#x2F;3 的概率返回 1 ，1&#x2F;3 的概率返回 2 。</span><br><span class="line">collection.getRandom();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。</span><br><span class="line">collection.remove(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; getRandom 应有相同概率返回 1 和 2 。</span><br><span class="line">collection.getRandom();</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法-哈希表"><a href="#方法-哈希表" class="headerlink" title="方法 : 哈希表"></a>方法 : 哈希表</h2><ul><li><strong>对于get() 方法</strong><ul><li>为了使得 <strong>O(1) 时间内能够随机获取一个元素</strong>，我们将<strong>每个数值（可以重复）存储在一个列表nums 中</strong>。</li><li>这样，获取随机元素时，只需要随机生成一个列表中的索引，就能够得到一个随机元素。</li></ul></li></ul><ul><li><strong>对于 remove() 方法</strong><ul><li>这样做的问题在于：<strong>列表中的随机删除并不是 O(1) 的。</strong></li><li>然而我们可以发现，<strong>列表中元素的顺序是无关紧要的</strong>，只要它们正确地存在于列表中即可。</li><li><strong>因此，在删除元素时，我们可以将被删的元素与列表中最后一个元素交换位置，随后便可以在 O(1)时间内，从列表中去除该元素。</strong></li><li>这需要我们<strong>额外维护数值在列表中每一次出现的下标集合</strong>。对于数值 val 而言，记其下标集合为 S<strong>i</strong>dx。</li></ul></li></ul><p><strong>具体删除操作</strong></p><ul><li><strong>在删除时，我们找出 val出现的其中一个下标 i</strong></li><li><strong>并将 <code>nums[i]</code> 和<code>nums[nums.length - 1]</code> 交换。</strong></li><li><strong>随后，将 i 从 Sval 中删除，并将<code>Snums[nums.length - 1]</code> 中原有的 <code>nums[nums.length - 1]</code> 替换成 i 。</strong></li><li><strong>由于每个操作都是O(1)的 那么平均时间复杂度也是 O（1）</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedCollection</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer,Set&lt;Integer&gt;&gt; idx; <span class="comment">// Map 用于维护数值在列表中每次出现的下标集合       Set 用于作为下标集合</span></span><br><span class="line">    List&lt;Integer&gt; nums; <span class="comment">// 用于随机获取元素 get() 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedCollection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        idx  = <span class="keyword">new</span> HashMap&lt;Integer,Set&lt;Integer&gt;&gt;();</span><br><span class="line">        nums = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 插入操作</span></span><br><span class="line">        nums.add(val); <span class="comment">// 加入到列表中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录出现的下标集合</span></span><br><span class="line">        <span class="comment">// key 是 出现的数字</span></span><br><span class="line">        <span class="comment">// val 是 出现数字所对应的下标</span></span><br><span class="line">        <span class="comment">// 比如插入[1,1,1,2,2,2]</span></span><br><span class="line">        <span class="comment">// 对应idx 即为 [1,[0,1,2]] [2,[3,4,5]]</span></span><br><span class="line">        Set&lt;Integer&gt; set = idx.getOrDefault(val,<span class="keyword">new</span> HashSet&lt;Integer&gt;()); </span><br><span class="line">        set.add(nums.size() - <span class="number">1</span>); </span><br><span class="line">        idx.put(val,set); <span class="comment">// set记录每个数字每一次出现的下标</span></span><br><span class="line">        <span class="keyword">return</span> set.size() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes a value from the collection. Returns true if the collection contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 删除操作</span></span><br><span class="line">        <span class="keyword">if</span>(!idx.containsKey(val))&#123; <span class="comment">// 如果根本没有这个数字的话，直接返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在删除时 找到val出现的其中一个下标i</span></span><br><span class="line">        <span class="comment">// 并将其和 最后一个元素进行交换</span></span><br><span class="line">        Iterator&lt;Integer&gt; it = idx.get(val).iterator();</span><br><span class="line">        <span class="keyword">int</span> i = it.next();</span><br><span class="line">        <span class="keyword">int</span> lastNum = nums.get(nums.size() - <span class="number">1</span>);</span><br><span class="line">        nums.set(i,lastNum);</span><br><span class="line"></span><br><span class="line">        idx.get(val).remove(i);</span><br><span class="line">        idx.get(lastNum).remove(nums.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &lt; nums.size() - <span class="number">1</span>)&#123;</span><br><span class="line">            idx.get(lastNum).add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(idx.get(val).size() == <span class="number">0</span>)&#123;</span><br><span class="line">            idx.remove(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the collection. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.get((<span class="keyword">int</span>) (Math.random() * nums.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedCollection object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RandomizedCollection obj = new RandomizedCollection();</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.insert(val);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.remove(val);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 O(1)</li><li>空间复杂度 O(n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-381-O-1-时间插入、删除和获取随机元素-允许重复&quot;&gt;&lt;a href=&quot;#Leetcode-381-O-1-时间插入、删除和获取随机元素-允许重复&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-381-O(1) 时间插入、删除和获取随机元素 - 允许重复&quot;&gt;&lt;/a&gt;Leetcode-381-&lt;a href=&quot;https://leetcode-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;O(1) 时间插入、删除和获取随机元素 - 允许重复&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：哈希表&quot;&gt;&lt;a href=&quot;#思路：哈希表&quot; class=&quot;headerlink&quot; title=&quot;思路：哈希表&quot;&gt;&lt;/a&gt;思路：哈希表&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;设计一个支持在平均 时间复杂度 O(1) 下， 执行以下操作的数据结构。&lt;/p&gt;
&lt;p&gt;注意: 允许出现重复元素。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;insert(val)：向集合中插入元素 val。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remove(val)：当 val 存在时，从集合中移除一个 val。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getRandom：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; 初始化一个空的集合。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RandomizedCollection collection &amp;#x3D; new RandomizedCollection();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; 向集合中插入 1 。返回 true 表示集合不包含 1 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;collection.insert(1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;collection.insert(1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;collection.insert(2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; getRandom 应当有 2&amp;#x2F;3 的概率返回 1 ，1&amp;#x2F;3 的概率返回 2 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;collection.getRandom();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;collection.remove(1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; getRandom 应有相同概率返回 1 和 2 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;collection.getRandom();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="哈希表" scheme="http://zhuuu.work/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-463-岛屿的周长</title>
    <link href="http://zhuuu.work/2020/10/30/Leetcode/Leetcode-463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/"/>
    <id>http://zhuuu.work/2020/10/30/Leetcode/Leetcode-463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/</id>
    <published>2020-10-30T08:35:53.000Z</published>
    <updated>2020-10-30T07:50:13.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-463-岛屿的周长"><a href="#Leetcode-463-岛屿的周长" class="headerlink" title="Leetcode-463-岛屿的周长"></a>Leetcode-463-<a href="https://leetcode-cn.com/problems/island-perimeter/" target="_blank" rel="noopener">岛屿的周长</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。</p><p>网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p><p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。<strong>计算这个岛屿的周长。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/154731661.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 :</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[[0,1,0,0],</span><br><span class="line"> [1,1,1,0],</span><br><span class="line"> [0,1,0,0],</span><br><span class="line"> [1,1,0,0]]</span><br><span class="line"></span><br><span class="line">输出: 16</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-迭代"><a href="#思路-迭代" class="headerlink" title="思路:  迭代"></a>思路:  迭代</h2><ul><li>对于一个陆地格子的每条边，它被算作岛屿的周长当且仅当这条边为网格的边界或者相邻的另一个格子为水域。</li><li>因此，我们可以遍历每个陆地格子，看其四个方向是否为边界或者水域，如果是，将这条边的贡献（即 1）加入答案<em>ans</em> 中即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dx = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dy = &#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.length; <span class="comment">// 行</span></span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].length; <span class="comment">// 列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个陆地格子，看其四个方向是否是边界或者水域</span></span><br><span class="line">        <span class="comment">// 如果是边界 或者 是水域 那么将这条边的贡献加1到ans中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)&#123;</span><br><span class="line">                <span class="comment">// 遍历每一个陆地格子</span></span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">// 遍历每个格子四条边4条边</span></span><br><span class="line">                    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">4</span>;k++)&#123;</span><br><span class="line">                        <span class="keyword">int</span> tx = i + dx[k];</span><br><span class="line">                        <span class="keyword">int</span> ty = j + dy[k];</span><br><span class="line">                        <span class="keyword">if</span>(tx &lt; <span class="number">0</span> || tx &gt;= n || ty &lt; <span class="number">0</span> || ty &gt;= m || grid[tx][ty] == <span class="number">0</span>)&#123;</span><br><span class="line">                            count += <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 计算完一个格子之后</span></span><br><span class="line">                    ans += count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：O(nm)，其中 n 为网格的高度，m 为网格的宽度。我们需要遍历每个格子，每个格子要看其周围 4 个格子是否为岛屿，因此总时间复杂度为 O(nm)。</li><li><strong>空间复杂度</strong>：<em>O</em>(1)。只需要常数空间存放若干变量。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-463-岛屿的周长&quot;&gt;&lt;a href=&quot;#Leetcode-463-岛屿的周长&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-463-岛屿的周长&quot;&gt;&lt;/a&gt;Leetcode-463-&lt;a href=&quot;https://leetcode-cn.com/problems/island-perimeter/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;岛屿的周长&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。&lt;/p&gt;
&lt;p&gt;网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。&lt;/p&gt;
&lt;p&gt;岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。&lt;strong&gt;计算这个岛屿的周长。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/154731661.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[0,1,0,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [1,1,1,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [0,1,0,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [1,1,0,0]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-20-文件的存储空间管理</title>
    <link href="http://zhuuu.work/2020/10/30/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-20-%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    <id>http://zhuuu.work/2020/10/30/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-20-%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/</id>
    <published>2020-10-30T02:00:53.000Z</published>
    <updated>2020-10-31T08:44:44.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-20-文件的存储空间管理"><a href="#操作系统-20-文件的存储空间管理" class="headerlink" title="操作系统-20-文件的存储空间管理"></a>操作系统-20-文件的存储空间管理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>操作系统对磁盘进行管理</strong></p><ul><li>对<strong>非空闲磁盘</strong>的管理（文件的分配方式）</li><li>对<strong>空闲磁盘</strong>的管理（文件的存储空间）</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/100452907.png" alt="mark"></p><a id="more"></a><h2 id="文件的存储空间管理"><a href="#文件的存储空间管理" class="headerlink" title="文件的存储空间管理"></a>文件的存储空间管理</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/100830136.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/100846144.png" alt="mark"></p><p><strong>接下来将一一介绍这些知识点</strong></p><h2 id="1-存储空间的划分和初始化"><a href="#1-存储空间的划分和初始化" class="headerlink" title="1. 存储空间的划分和初始化"></a>1. 存储空间的划分和初始化</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/162611539.png" alt="mark"></p><h2 id="2-文件空闲分配空间分配算法"><a href="#2-文件空闲分配空间分配算法" class="headerlink" title="2. 文件空闲分配空间分配算法"></a>2. 文件空闲分配空间分配算法</h2><ul><li><strong>文件存储设备管理实质上是对空闲块的组织和管理</strong></li></ul><h3 id="2-1-空闲表法"><a href="#2-1-空闲表法" class="headerlink" title="2.1 空闲表法"></a>2.1 空闲表法</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/162811554.png" alt="mark"></p><h3 id="2-2-空闲链表法"><a href="#2-2-空闲链表法" class="headerlink" title="2.2 空闲链表法"></a>2.2 空闲链表法</h3><p><strong>空闲链表法是将磁盘上的所有空闲空间以盘块位单位拉成一条链</strong></p><h4 id="2-2-1-空闲盘块链"><a href="#2-2-1-空闲盘块链" class="headerlink" title="2.2.1 空闲盘块链"></a>2.2.1 空闲盘块链</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/162946825.png" alt="mark"></p><h4 id="2-2-2-空闲盘区链"><a href="#2-2-2-空闲盘区链" class="headerlink" title="2.2.2 空闲盘区链"></a>2.2.2 空闲盘区链</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/163024433.png" alt="mark"></p><h3 id="2-3-位示图法"><a href="#2-3-位示图法" class="headerlink" title="2.3 位示图法"></a>2.3 位示图法</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/163116309.png" alt="mark"></p><p><strong>如何进行分配和回收？</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/163235928.png" alt="mark"></p><h3 id="2-4-成组链接法"><a href="#2-4-成组链接法" class="headerlink" title="2.4 成组链接法"></a>2.4 成组链接法</h3><ul><li><strong>Unix 采用成组链接法对磁盘空闲块进行管理</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/163702699.png" alt="mark"></p><h4 id="2-4-1-超级块"><a href="#2-4-1-超级块" class="headerlink" title="2.4.1 超级块"></a>2.4.1 超级块</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/163822214.png" alt="mark"></p><h4 id="2-4-2-分配策略"><a href="#2-4-2-分配策略" class="headerlink" title="2.4.2 分配策略"></a>2.4.2 分配策略</h4><ul><li><strong>需要1个空闲磁盘块</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/164120779.png" alt="mark"></p><ul><li><strong>需要分配100个空心块</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/164209348.png" alt="mark"></p><h4 id="2-4-3-回收策略"><a href="#2-4-3-回收策略" class="headerlink" title="2.4.3 回收策略"></a>2.4.3 回收策略</h4><ul><li><strong>回收区域未满</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/164258244.png" alt="mark"></p><ul><li><strong>回收区域已满</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/164404090.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-20-文件的存储空间管理&quot;&gt;&lt;a href=&quot;#操作系统-20-文件的存储空间管理&quot; class=&quot;headerlink&quot; title=&quot;操作系统-20-文件的存储空间管理&quot;&gt;&lt;/a&gt;操作系统-20-文件的存储空间管理&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;操作系统对磁盘进行管理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对&lt;strong&gt;非空闲磁盘&lt;/strong&gt;的管理（文件的分配方式）&lt;/li&gt;
&lt;li&gt;对&lt;strong&gt;空闲磁盘&lt;/strong&gt;的管理（文件的存储空间）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/100452907.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="文件管理" scheme="http://zhuuu.work/tags/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-19-文件的物理结构</title>
    <link href="http://zhuuu.work/2020/10/30/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-19-%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84/"/>
    <id>http://zhuuu.work/2020/10/30/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-19-%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84/</id>
    <published>2020-10-30T00:00:53.000Z</published>
    <updated>2020-10-30T01:28:55.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-19-文件的物理结构"><a href="#操作系统-19-文件的物理结构" class="headerlink" title="操作系统-19-文件的物理结构"></a>操作系统-19-文件的物理结构</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/085837475.png" alt="mark"></p><a id="more"></a><h2 id="1-文件块，磁盘块"><a href="#1-文件块，磁盘块" class="headerlink" title="1. 文件块，磁盘块"></a>1. 文件块，磁盘块</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/090314126.png" alt="mark"></p><h2 id="2-文件的实现（文件的分配方式）"><a href="#2-文件的实现（文件的分配方式）" class="headerlink" title="2. 文件的实现（文件的分配方式）"></a>2. 文件的实现（文件的分配方式）</h2><h3 id="2-1-连续分配方式"><a href="#2-1-连续分配方式" class="headerlink" title="2.1 连续分配方式"></a>2.1 连续分配方式</h3><ul><li><strong>优点</strong>：支持随机访问；顺序访问时速度最快（移动磁头所需的时间短） </li><li><strong>缺点</strong>：不方便文件扩展，每次扩展都得迁移到一段连续的空间，代价大；存储空间利用率低，产生磁盘碎片</li></ul><h3 id="2-2-链接分配方式"><a href="#2-2-链接分配方式" class="headerlink" title="2.2 链接分配方式"></a>2.2 链接分配方式</h3><p>链接分配采用离散分配的方式，消除了外部碎片</p><ul><li><strong>链接分配又分为</strong><ul><li><strong>显式链接</strong></li><li><strong>隐式链接</strong></li></ul></li></ul><h4 id="2-2-1-隐式链接"><a href="#2-2-1-隐式链接" class="headerlink" title="2.2.1 隐式链接"></a>2.2.1 隐式链接</h4><ul><li>不支持随机访问，查找效率低</li><li>方便拓展，磁盘利用率高</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/091949038.png" alt="mark"></p><h4 id="2-2-2-显示链接"><a href="#2-2-2-显示链接" class="headerlink" title="2.2.2 显示链接"></a>2.2.2 显示链接</h4><ul><li>逻辑块号转物理块号不需要访问磁盘，因此支持随机访问；扩展方便且不会有磁盘碎片</li><li>缺点是FAT要占用一定的存储空间</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/092112596.png" alt="mark"></p><h4 id="2-2-3-链式分配小结"><a href="#2-2-3-链式分配小结" class="headerlink" title="2.2.3 链式分配小结"></a>2.2.3 链式分配小结</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/092156870.png" alt="mark"></p><h3 id="2-3-索引分配"><a href="#2-3-索引分配" class="headerlink" title="2.3 索引分配"></a>2.3 索引分配</h3><ul><li>每一个文件建立一张索引表，其中记录文件的逻辑块对应的物理块。</li><li>存放索引表的磁盘块叫<strong>索引块</strong>，存放文件数据的磁盘块叫<strong>数据块</strong>。</li></ul><p><strong>索引分配支持直接访问，且没有外部碎片的问题。</strong></p><p><strong>但是每个文件都必须有一个索引块，因此索引块要尽可能的小。</strong></p><p>有如下几种方案减少索引块所占的空间：</p><ol><li><strong>链接方案</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/092725382.png" alt="mark"></p><ol start="2"><li><strong>多层索引</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/092811877.png" alt="mark"></p><ol start="3"><li><strong>混合索引</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/092832505.png" alt="mark"></p><p><strong>索引分配小结</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/092853080.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-19-文件的物理结构&quot;&gt;&lt;a href=&quot;#操作系统-19-文件的物理结构&quot; class=&quot;headerlink&quot; title=&quot;操作系统-19-文件的物理结构&quot;&gt;&lt;/a&gt;操作系统-19-文件的物理结构&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/085837475.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="文件管理" scheme="http://zhuuu.work/tags/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-129-求根到叶子节点数字之和</title>
    <link href="http://zhuuu.work/2020/10/29/Leetcode/Leetcode-129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"/>
    <id>http://zhuuu.work/2020/10/29/Leetcode/Leetcode-129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</id>
    <published>2020-10-29T07:22:53.000Z</published>
    <updated>2020-10-29T00:49:17.202Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-129-求根到叶子节点数字之和"><a href="#Leetcode-129-求根到叶子节点数字之和" class="headerlink" title="Leetcode-129-求根到叶子节点数字之和"></a><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">Leetcode-129-求根到叶子节点数字之和</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。</p><p>例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。</p><p>计算从根到叶子节点生成的所有数字之和。</p><p>说明: 叶子节点是指没有子节点的节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line">输出: 25</span><br><span class="line">解释:</span><br><span class="line">从根到叶子节点路径 1-&gt;2 代表数字 12.</span><br><span class="line">从根到叶子节点路径 1-&gt;3 代表数字 13.</span><br><span class="line">因此，数字总和 &#x3D; 12 + 13 &#x3D; 25.</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;sum-root-to-leaf-numbers</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br><span class="line"></span><br><span class="line">输入: [4,9,0,5,1]</span><br><span class="line">    4</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9   0</span><br><span class="line"> &#x2F; \</span><br><span class="line">5   1</span><br><span class="line">输出: 1026</span><br><span class="line">解释:</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.</span><br><span class="line">从根到叶子节点路径 4-&gt;0 代表数字 40.</span><br><span class="line">因此，数字总和 &#x3D; 495 + 491 + 40 &#x3D; 1026.</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;sum-root-to-leaf-numbers</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法-：-DFS"><a href="#方法-：-DFS" class="headerlink" title="方法 ： DFS"></a>方法 ： DFS</h2><ul><li>深度优先搜索是很直观的做法。从根节点开始，遍历每个节点，如果遇到叶子节点，则将叶子节点对应的数字加到数字之和</li><li>如果<strong>当前节点不是叶子节点，则计算其子节点对应的数字，然后对子节点递归遍历。</strong></li><li>如果<strong>当前节点是叶子节点，直接返回sum即可</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201029/084301292.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root,<span class="keyword">int</span> prevSum)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1. 递归结束的条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 对叶子节点或者不是叶子节点的处理</span></span><br><span class="line">        <span class="keyword">int</span> sum = prevSum*<span class="number">10</span> + root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123; <span class="comment">//如果是叶子节点</span></span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(root.left,sum) + dfs(root.right,sum); <span class="comment">// 如果是根节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>： <em>O</em>(<em>n</em>)，其中<em>n</em> 是二叉树的节点个数。对每个节点访问一次。</li><li><strong>空间复杂度</strong>： <em>O</em>(<em>n</em>)，其中n 是二叉树节点的个数。空间复杂度主要取决于递归调用的栈空间，递归栈的深度等于二叉树的高度。（最坏情况下，空间复杂度为<em>O</em>(<em>n</em>)）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-129-求根到叶子节点数字之和&quot;&gt;&lt;a href=&quot;#Leetcode-129-求根到叶子节点数字之和&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-129-求根到叶子节点数字之和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/valid-palindrome/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode-129-求根到叶子节点数字之和&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。&lt;/p&gt;
&lt;p&gt;例如，从根到叶子节点路径 1-&amp;gt;2-&amp;gt;3 代表数字 123。&lt;/p&gt;
&lt;p&gt;计算从根到叶子节点生成的所有数字之和。&lt;/p&gt;
&lt;p&gt;说明: 叶子节点是指没有子节点的节点。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,2,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2   3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从根到叶子节点路径 1-&amp;gt;2 代表数字 12.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从根到叶子节点路径 1-&amp;gt;3 代表数字 13.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因此，数字总和 &amp;#x3D; 12 + 13 &amp;#x3D; 25.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;来源：力扣（LeetCode）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;链接：https:&amp;#x2F;&amp;#x2F;leetcode-cn.com&amp;#x2F;problems&amp;#x2F;sum-root-to-leaf-numbers&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [4,9,0,5,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  9   0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#x2F; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5   1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 1026&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从根到叶子节点路径 4-&amp;gt;9-&amp;gt;5 代表数字 495.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从根到叶子节点路径 4-&amp;gt;9-&amp;gt;1 代表数字 491.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从根到叶子节点路径 4-&amp;gt;0 代表数字 40.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因此，数字总和 &amp;#x3D; 495 + 491 + 40 &amp;#x3D; 1026.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;来源：力扣（LeetCode）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;链接：https:&amp;#x2F;&amp;#x2F;leetcode-cn.com&amp;#x2F;problems&amp;#x2F;sum-root-to-leaf-numbers&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Netty-07-群聊系统实现</title>
    <link href="http://zhuuu.work/2020/10/28/Netty/Netty-07-%E7%BE%A4%E8%81%8A%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/"/>
    <id>http://zhuuu.work/2020/10/28/Netty/Netty-07-%E7%BE%A4%E8%81%8A%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-10-28T10:05:24.000Z</published>
    <updated>2020-11-02T01:59:19.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-07-群聊系统实现"><a href="#Netty-07-群聊系统实现" class="headerlink" title="Netty-07-群聊系统实现"></a>Netty-07-群聊系统实现</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>实例要求</strong></p><ul><li>编写一个Netty 群聊系统，实现客户端和服务端之间的数据简单通信（非阻塞）</li><li>实现多人群聊</li><li>服务器端： 可以检测用户上线，离线，并实现消息的转发</li><li>客户端：通过channel 可以无阻塞发送消息给其他用户，同时可以接受其他用户发送来的消息（由）服务器转发得到</li><li>目的 ： 进一步理解Netty 非阻塞网络编程机制</li></ul><a id="more"></a><h2 id="1-服务端代码"><a href="#1-服务端代码" class="headerlink" title="1. 服务端代码"></a>1. 服务端代码</h2><h3 id="1-1-启动类"><a href="#1-1-启动类" class="headerlink" title="1.1 启动类"></a>1.1 启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编写run 方法，处理客户端请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="comment">// 创建两个线程组</span></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>,128)</span></span><br><span class="line"><span class="class">                    .<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>,<span class="title">true</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="string">"decoder"</span>,<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            pipeline.addLast(<span class="string">"encoder"</span>,<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> GroupChatHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"----- netty 服务端启动 -----"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 绑定端口</span></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(port).sync();</span><br><span class="line">            <span class="comment">// 监听关闭事件</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主方法启动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        GroupChatServer groupChatServer = <span class="keyword">new</span> GroupChatServer(<span class="number">7000</span>);</span><br><span class="line">        groupChatServer.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-Handler"><a href="#1-2-Handler" class="headerlink" title="1.2 Handler"></a>1.2 Handler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.ChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.DefaultChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.GlobalEventExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个channel组，管理所有的channel</span></span><br><span class="line">    <span class="comment">// GlobalEventExecutor.INSTANCE 是全局事件执行器，是一个单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ChannelGroup channelGroup = <span class="keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此方法表示连接建立，一旦建立连接就第一个被执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        <span class="comment">// 该方法会将channelGroup 中所有的channel 遍历，并发送消息而不需要我们自己去遍历</span></span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">"[客户端]"</span> + channel.remoteAddress() + sdf.format(<span class="keyword">new</span> Date()) + <span class="string">"加入了聊天"</span>);</span><br><span class="line">        <span class="comment">// 将当前的Channel 加入到 channelGroup</span></span><br><span class="line">        channelGroup.add(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示channel 处于活动状态，提示XXX已经上线</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">" "</span> + sdf.format(<span class="keyword">new</span> Date()) + <span class="string">"上线了~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示channel 断开连接，将xx客户端离开信息推送给当前在线用户</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">" "</span> + sdf.format(<span class="keyword">new</span> Date()) + <span class="string">"离线了~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// channel 关闭后会自动remove掉</span></span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">"[客户端]"</span> + channel.remoteAddress() +<span class="string">" "</span>+ sdf.format(<span class="keyword">new</span> Date()) + <span class="string">"离开了\n"</span>);</span><br><span class="line">        System.out.println(<span class="string">"当前channelGroup大小 ："</span> + channelGroup.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据进行消息的转发</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前的channel</span></span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历channelGroup 根据不同的情况回显不同的消息</span></span><br><span class="line">        channelGroup.forEach(item -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (item != channel)&#123;</span><br><span class="line">                item.writeAndFlush(<span class="string">"[客户]"</span> + channel.remoteAddress() + <span class="string">"发送了消息："</span> + msg + <span class="string">"\n"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                item.writeAndFlush(<span class="string">"[自己]发送了消息："</span> + msg + <span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-客户端代码"><a href="#2-客户端代码" class="headerlink" title="2. 客户端代码"></a>2. 客户端代码</h2><h3 id="2-1-客户端代码"><a href="#2-1-客户端代码" class="headerlink" title="2.1 客户端代码"></a>2.1 客户端代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        NioEventLoopGroup eventExecutors = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                    .group(eventExecutors)</span><br><span class="line">                    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//加入Handler</span></span><br><span class="line">                            pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> GroupChatClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// connect 事件</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(host, port).sync();</span><br><span class="line">            <span class="comment">// 得到channel,打印本地地址</span></span><br><span class="line">            Channel channel = channelFuture.channel();</span><br><span class="line">            System.out.println(<span class="string">"--------"</span> + channel.localAddress() + <span class="string">"---------"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 客户端需要输入信息</span></span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNextLine())&#123;</span><br><span class="line">                String msg = scanner.nextLine();</span><br><span class="line">                <span class="comment">// 通过channel 发送到服务器端</span></span><br><span class="line">                channel.writeAndFlush(msg + <span class="string">"\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            eventExecutors.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GroupChatClient(<span class="string">"127.0.0.1"</span>,<span class="number">7000</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-Handler"><a href="#2-2-Handler" class="headerlink" title="2.2  Handler"></a>2.2  Handler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(msg.trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-07-群聊系统实现&quot;&gt;&lt;a href=&quot;#Netty-07-群聊系统实现&quot; class=&quot;headerlink&quot; title=&quot;Netty-07-群聊系统实现&quot;&gt;&lt;/a&gt;Netty-07-群聊系统实现&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;实例要求&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编写一个Netty 群聊系统，实现客户端和服务端之间的数据简单通信（非阻塞）&lt;/li&gt;
&lt;li&gt;实现多人群聊&lt;/li&gt;
&lt;li&gt;服务器端： 可以检测用户上线，离线，并实现消息的转发&lt;/li&gt;
&lt;li&gt;客户端：通过channel 可以无阻塞发送消息给其他用户，同时可以接受其他用户发送来的消息（由）服务器转发得到&lt;/li&gt;
&lt;li&gt;目的 ： 进一步理解Netty 非阻塞网络编程机制&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="NIO" scheme="http://zhuuu.work/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Netty-06-核心组件</title>
    <link href="http://zhuuu.work/2020/10/28/Netty/Netty-06-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    <id>http://zhuuu.work/2020/10/28/Netty/Netty-06-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</id>
    <published>2020-10-28T10:05:24.000Z</published>
    <updated>2020-10-29T01:35:15.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-06-核心组件"><a href="#Netty-06-核心组件" class="headerlink" title="Netty-06-核心组件"></a>Netty-06-核心组件</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><strong>本文注重讲解Netty的核心组成</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/085701217.png" alt="mark"></p><h2 id="1-Bootstrap、ServerBootstrap"><a href="#1-Bootstrap、ServerBootstrap" class="headerlink" title="1. Bootstrap、ServerBootstrap"></a>1. Bootstrap、ServerBootstrap</h2><ul><li><code>Bootstrap</code> 意思是引导，一个 <code>Netty</code> 应用通常由一个 <code>Bootstrap</code> 开始，主要作用是配置整个 <code>Netty</code> 程序，串联各个组件，<code>Netty</code> 中 <code>Bootstrap</code> 类是客户端程序的启动引导类，<code>ServerBootstrap</code> 是服务端启动引导类</li></ul><p><strong>常见方法：</strong></p><table><thead><tr><th>方法名称</th><th>方法介绍</th></tr></thead><tbody><tr><td><code>public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)</code></td><td>该方法用于服务器端，用来设置两个EventLoop</td></tr><tr><td><code>public B group(EventLoopGroup group)</code></td><td>该方法用于客户端，用来设置一个EventLoop</td></tr><tr><td><code>public B channel(Class&lt;? extends C&gt; channelClass)</code></td><td>该方法用来设置一个服务器端的通道实现</td></tr><tr><td><code>public &lt;T&gt; B option(ChannelOption&lt;T&gt; option, T value)</code></td><td>用来给 ServerChannel 添加配置</td></tr><tr><td><code>public &lt;T&gt; ServerBootstrap childOption(ChannelOption&lt;T&gt; childOption, T value)</code></td><td>用来给接收到的通道添加配置</td></tr><tr><td><code>public ServerBootstrap childHandler(ChannelHandler childHandler)</code></td><td>该方法用来设置业务处理类（自定义的 handler）</td></tr><tr><td><code>public ChannelFuture bind(int inetPort)</code></td><td>该方法用于服务器端，用来设置占用的端口号</td></tr><tr><td><code>public ChannelFuture connect(String inetHost, int inetPort)</code></td><td>该方法用于客户端，用来连接服务器</td></tr></tbody></table><a id="more"></a><h2 id="2-Future、ChannelFuture"><a href="#2-Future、ChannelFuture" class="headerlink" title="2. Future、ChannelFuture"></a>2. Future、ChannelFuture</h2><ul><li><code>Netty</code> 中所有的 <code>IO</code> 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 <code>Future</code> 和 <code>ChannelFuture</code>，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件</li></ul><p><strong>常见的方法有</strong></p><table><thead><tr><th>方法名</th><th>方法介绍</th></tr></thead><tbody><tr><td><code>Channel channel()</code></td><td>返回当前正在进行 IO 操作的通道</td></tr><tr><td><code>ChannelFuture sync()</code></td><td>等待异步操作执行完毕，相当于将阻塞在当前。</td></tr></tbody></table><h2 id="3-Channel"><a href="#3-Channel" class="headerlink" title="3. Channel"></a>3. Channel</h2><ul><li><p><code>Netty</code> 网络通信的组件，能够用于执行网络 <code>I/O</code> 操作。</p></li><li><p>通过<code>Channel</code> 可获得当前网络连接的通道的状态</p></li><li><p>通过<code>Channel</code> 可获得 网络连接的配置参数 （例如接收缓冲区大小）</p></li><li><p><code>Channel</code> 提供异步的网络 <code>I/O</code> 操作(如建立连接，读写，绑定端口)，<strong>异步调用意味着任何 <code>I/O</code> 调用都将立即返回，并且不保证在调用结束时所请求的 <code>I/O</code> 操作已完成</strong></p></li><li><p><strong>调用立即返回一个 <code>ChannelFuture</code> 实例，通过注册监听器到 <code>ChannelFuture</code> 上，可以 <code>I/O</code> 操作成功、失败或取消时回调通知调用方</strong></p></li><li><p><strong>不同协议、不同的阻塞类型的连接都有不同的 <code>Channel</code> 类型与之对应</strong></p></li></ul><p><strong>常用的 <code>Channel</code> 类型</strong></p><table><thead><tr><th>名称</th><th>介绍</th></tr></thead><tbody><tr><td><code>NioSocketChannel</code></td><td>异步的客户端 TCP Socket 连接。</td></tr><tr><td><code>NioServerSocketChannel</code></td><td>异步的服务器端 TCP Socket 连接</td></tr><tr><td><code>NioDatagramChannel</code></td><td>异步的 UDP 连接。</td></tr><tr><td><code>NioSctpChannel</code></td><td>异步的客户端 Sctp 连接。</td></tr><tr><td><code>NioSctpServerChannel</code></td><td>异步的 Sctp 服务器端连接，这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO。</td></tr></tbody></table><h2 id="4-Seletor"><a href="#4-Seletor" class="headerlink" title="4. Seletor"></a>4. Seletor</h2><ul><li><p><strong><code>Netty</code> 基于 <code>Selector</code> 对象实现 <code>I/O</code> 多路复用，通过 <code>Selector</code> 一个线程可以监听多个连接的 <code>Channel</code> 事件。</strong></p></li><li><p>当向一个 <code>Selector</code> 中注册 <code>Channel</code> 后，<code>Selector</code> 内部的机制就可以自动不断地查询(<code>Select</code>) 这些注册的 <code>Channel</code> 是否有已就绪的 <code>I/O</code> 事件（例如可读，可写，网络连接完成等），这样程序就可以<strong>很简单地使用一个线程高效地管理多个 <code>Channel</code></strong></p></li><li><p>同时，<code>Netty</code>中对<code>selector</code>中的<code>selectedKey</code>集合进行了替换，它替换成了一个它自己实现的一个<code>set</code>集合，这样效率更高。</p></li></ul><h2 id="5-ChannelHandler"><a href="#5-ChannelHandler" class="headerlink" title="5. ChannelHandler"></a>5. ChannelHandler</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/123220946.png" alt="mark"></p><ul><li><strong><code>ChannelHandler</code> 是一个接口，处理 <code>I/O</code> 事件或拦截 <code>I/O</code> 操作，并将其转发到其 <code>ChannelPipeline</code>(业务处理链)中的下一个处理程序。</strong></li><li><strong><code>ChannelHandler</code> 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类</strong></li><li>我们经常需要<strong>自定义一个<code>Handler</code> 类去继承<code>ChannelInboundHandlerAdapter</code> ，然后通过相应方法实现业务逻辑，来看看有哪些方法需要重写</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201028/224217480.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelInboundHandlerAdapter</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">ChannelInboundHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通道注册事件</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelRegistered();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通道取消注册事件</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelUnregistered();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通道就绪事件</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#fireChannelInactive()&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelInboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelInactive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通道读取数据事件</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelRead(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通道数据读取完毕事件</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelReadComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#fireUserEventTriggered(Object)&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelInboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireUserEventTriggered(evt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#fireChannelWritabilityChanged()&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelInboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelWritabilityChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通道发生异常事件</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireExceptionCaught(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>再来回顾一下类图</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201028/224217480.png" alt="mark"></p><ul><li><code>ChannelInboundHandler</code> 用于处理入站 I/O 事件。</li><li><code>ChannelOutboundHandler</code> 用于处理出站 I/O 操作。</li></ul><p><strong>适配器</strong></p><ul><li><code>ChannelInboundHandlerAdapter</code> 用于处理入站 I/O 事件。</li><li><code>ChannelOutboundHandlerAdapter</code> 用于处理出站 I/O 操作。</li><li><code>ChannelDuplexHandler</code> 用于处理入站和出站事件。</li></ul><h2 id="7-Pipeline-和-ChannelPipeline"><a href="#7-Pipeline-和-ChannelPipeline" class="headerlink" title="7. Pipeline 和 ChannelPipeline"></a>7. Pipeline 和 ChannelPipeline</h2><ul><li><code>ChannelPipeline</code> 是一个 <code>Handler</code> 的集合，它负责处理和拦截 <code>inbound</code> 或者 <code>outbound</code> 的事件和操作，相当于一个贯穿 <code>Netty</code> 的链。(也可以这样理解：<code>ChannelPipeline</code> 是 保存 <code>ChannelHandler</code> 的 <code>List</code>，用于处理或拦截 <code>Channel</code> 的入站事件和出站操作)</li><li><code>ChannelPipeline</code> 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 <code>Channel</code> 中各个的 <code>ChannelHandler</code> 如何相互交互</li><li>在 <code>Netty</code> 中每个 <code>Channel</code> 都有且仅有一个 <code>ChannelPipeline</code> 与之对应，它们的组成关系如下</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/123220946.png" alt="mark"></p><p><strong>组成关系</strong></p><ul><li>一个 <code>Channel</code> 包含了一个 <code>ChannelPipeline</code>，而 <code>ChannelPipeline</code> 中又维护了一个由 <code>ChannelHandlerContext</code> 组成的<strong>双向链表</strong>，并且每个 <code>ChannelHandlerContext</code> 中又关联着一个 <code>ChannelHandler</code></li><li><strong>入站事件和出站事件在一个双向链表中</strong>，入站事件会从链表 <code>head</code> 往后传递到最后一个入站的 <code>handler</code>，出站事件会从链表 <code>tail</code> 往前传递到最前一个出站的 <code>handler</code>，两种类型的 <code>handler</code> 互不干扰</li></ul><p><strong>常用方法：</strong></p><table><thead><tr><th>方法名</th><th>介绍</th></tr></thead><tbody><tr><td><code>ChannelPipeline addFirst(ChannelHandler... handlers)</code></td><td>把一个业务处理类（handler）添加到链中的第一个位置</td></tr><tr><td>ChannelPipeline addLast(ChannelHandler… handlers)</td><td>把一个业务处理类（handler）添加到链中的最后一个位置</td></tr></tbody></table><h2 id="8-ChannelOption"><a href="#8-ChannelOption" class="headerlink" title="8. ChannelOption"></a>8. ChannelOption</h2><ul><li><code>Netty</code> 在创建 <code>Channel</code> 实例后,一般都需要设置 <code>ChannelOption</code> 参数。</li></ul><p><strong>ChannelOption 参数如下</strong></p><p><code>ChannelOption.SO_BACKLOG</code></p><ul><li><strong>对应 TCP/IP 协议 listen 函数中的 backlog 参数，用来初始化服务器可连接队列大小。</strong></li><li>服务端处理客户端连接请求是顺序处理的，所以同一时间只能处理一个客户端连接。多个客户端来的时候，<strong>服务端将不能处理的客户端连接请求放在队列中等待处理，backlog 参数指定了队列的大小。</strong></li></ul><p><code>ChannelOption.SO_KEEPALIVE</code></p><ul><li><strong>一直保持TCP连接活动的状态</strong></li></ul><h2 id="9-EventLoopGroup-和-NioEventLoopGroup"><a href="#9-EventLoopGroup-和-NioEventLoopGroup" class="headerlink" title="9. EventLoopGroup 和 NioEventLoopGroup"></a>9. EventLoopGroup 和 NioEventLoopGroup</h2><ul><li><code>EventLoopGroup</code> 是一组 <code>EventLoop</code> 的抽象，Netty为了更好的利用多核CPU资源，一般会有多个<code>EventLoop</code> 同时工作，每个<code>EventLoop</code>维护着一个Selector 实例</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201029/092123789.png" alt="mark"></p><ul><li><code>EventLoopGroup</code> 提供 next 接口，可以从组里面按照一定规则获取其中一个 <code>EventLoop</code>来处理任务。<ul><li>在 Netty 服务器端编程中，我们一般都需要提供两个 <code>EventLoopGroup</code>，例如：<code>BossEventLoopGroup</code> 和<code>WorkerEventLoopGroup</code>。</li></ul></li><li>通常一个服务端口即一个<code>ServerSocketChannel</code> 对应一个 <code>Selector</code> 和 一个<code>EventLoop</code> 线程。<ul><li>BossEventLoop 负责接收客户端的连接并将 SocketChannel 交给 WorkerEventLoopGroup 来进行 IO 处理</li></ul></li><li>BossEventLoopGroup 通常是一个单线程的 EventLoop，EventLoop 维护者一个注册了ServerSocketChannel 的Selector 实例BossEventLoop 不断轮询 Selector 将连接事件分离出来<ul><li>通常是 OP_ACCEPT 事件，然后将接收到的 SocketChannel 交给 WorkerEventLoopGroup</li><li>WorkerEventLoopGroup 会由 next 选择其中一个EventLoop 来讲这个SocketChannel 注册到其维护的Selector 并对和后续的IO事件进行处理</li></ul></li></ul><p><strong>常用方法：</strong></p><table><thead><tr><th>方法名</th><th>介绍</th></tr></thead><tbody><tr><td><code>public NioEventLoopGroup()</code></td><td>构造方法</td></tr><tr><td><code>public Future&lt;?&gt; shutdownGracefully()</code></td><td>断开连接，关闭线程</td></tr></tbody></table><h2 id="10-ByteBuf"><a href="#10-ByteBuf" class="headerlink" title="10. ByteBuf"></a>10. ByteBuf</h2><ul><li><strong>Netty 提供一个专门用来操作缓冲区(即Netty的数据容器)的工具类</strong></li></ul><p><strong>常用方法</strong></p><table><thead><tr><th>方法名</th><th>介绍</th></tr></thead><tbody><tr><td><code>public static ByteBuf copiedBuffer(CharSequence string, Charset charset)</code></td><td>通过给定的数据和字符编码返回一个 ByteBuf 对象（类似于 NIO 中的 ByteBuffer 但有区别）</td></tr></tbody></table><ul><li><strong>使用举例</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个ByteBuf</span></span><br><span class="line"><span class="comment">//1、创建对象，该对象包含一个数组，是一个byte[10]</span></span><br><span class="line"><span class="comment">//2、在netty的buffer中，写入数据后再读取数据不需要使用 flip 进行反转</span></span><br><span class="line"><span class="comment">// 底层维护了 readerIndex 和 writeIndex</span></span><br><span class="line"><span class="comment">//往buffer中写的范围为 [writeIndex, capacity)</span></span><br><span class="line"><span class="comment">//往buffer中可读的范围为 [readerIndex, writeIndex)。使用 buf.readByte() 会往后移动 readerIndex 指针，使用 buf.getByte(i) 通过索引获取就不会移动该指针</span></span><br><span class="line">ByteBuf byteBuf = Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    byteBuf.writeByte(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取该buf的大小</span></span><br><span class="line"><span class="keyword">int</span> capacity = byteBuf.capacity();</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; byteBuf.capacity(); i++) &#123;</span><br><span class="line">    System.out.println(byteBuf.getByte(i));</span><br><span class="line">    System.out.println(byteBuf.readByte());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">byte</span>[] content = byteBuf.array();</span><br><span class="line"><span class="comment">//将content转成字符串</span></span><br><span class="line">String c = <span class="keyword">new</span> String(content, StandardCharsets.UTF_8);</span><br><span class="line"><span class="comment">//数组偏移量</span></span><br><span class="line"><span class="keyword">int</span> offset = byteBuf.arrayOffset();</span><br><span class="line"><span class="comment">//获取读取偏移量</span></span><br><span class="line"><span class="keyword">int</span> readerIndex = byteBuf.readerIndex();</span><br><span class="line"><span class="comment">//获取写偏移量</span></span><br><span class="line"><span class="keyword">int</span> writerIndex = byteBuf.writerIndex();</span><br><span class="line"><span class="comment">//获取容量</span></span><br><span class="line"><span class="keyword">int</span> capacity = byteBuf.capacity();</span><br><span class="line"><span class="comment">//获取可读取的字节数</span></span><br><span class="line"><span class="keyword">int</span> readableBytes = byteBuf.readableBytes();</span><br><span class="line"><span class="comment">//通过索引获取某个位置的字节</span></span><br><span class="line"><span class="keyword">byte</span> aByte = byteBuf.getByte(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//获取Buf中某个范围的字符序列</span></span><br><span class="line">CharSequence charSequence = byteBuf.getCharSequence(<span class="number">0</span>, <span class="number">4</span>, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-06-核心组件&quot;&gt;&lt;a href=&quot;#Netty-06-核心组件&quot; class=&quot;headerlink&quot; title=&quot;Netty-06-核心组件&quot;&gt;&lt;/a&gt;Netty-06-核心组件&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;本文注重讲解Netty的核心组成&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/085701217.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-Bootstrap、ServerBootstrap&quot;&gt;&lt;a href=&quot;#1-Bootstrap、ServerBootstrap&quot; class=&quot;headerlink&quot; title=&quot;1. Bootstrap、ServerBootstrap&quot;&gt;&lt;/a&gt;1. Bootstrap、ServerBootstrap&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Bootstrap&lt;/code&gt; 意思是引导，一个 &lt;code&gt;Netty&lt;/code&gt; 应用通常由一个 &lt;code&gt;Bootstrap&lt;/code&gt; 开始，主要作用是配置整个 &lt;code&gt;Netty&lt;/code&gt; 程序，串联各个组件，&lt;code&gt;Netty&lt;/code&gt; 中 &lt;code&gt;Bootstrap&lt;/code&gt; 类是客户端程序的启动引导类，&lt;code&gt;ServerBootstrap&lt;/code&gt; 是服务端启动引导类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;常见方法：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法名称&lt;/th&gt;
&lt;th&gt;方法介绍&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;该方法用于服务器端，用来设置两个EventLoop&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;public B group(EventLoopGroup group)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;该方法用于客户端，用来设置一个EventLoop&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;public B channel(Class&amp;lt;? extends C&amp;gt; channelClass)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;该方法用来设置一个服务器端的通道实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;public &amp;lt;T&amp;gt; B option(ChannelOption&amp;lt;T&amp;gt; option, T value)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用来给 ServerChannel 添加配置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;public &amp;lt;T&amp;gt; ServerBootstrap childOption(ChannelOption&amp;lt;T&amp;gt; childOption, T value)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用来给接收到的通道添加配置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;public ServerBootstrap childHandler(ChannelHandler childHandler)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;该方法用来设置业务处理类（自定义的 handler）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;public ChannelFuture bind(int inetPort)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;该方法用于服务器端，用来设置占用的端口号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;public ChannelFuture connect(String inetHost, int inetPort)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;该方法用于客户端，用来连接服务器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="NIO" scheme="http://zhuuu.work/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-18-文件基础</title>
    <link href="http://zhuuu.work/2020/10/24/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-18-%E6%96%87%E4%BB%B6%E5%9F%BA%E7%A1%80/"/>
    <id>http://zhuuu.work/2020/10/24/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-18-%E6%96%87%E4%BB%B6%E5%9F%BA%E7%A1%80/</id>
    <published>2020-10-24T02:00:53.000Z</published>
    <updated>2020-10-30T02:03:25.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-18-文件基础"><a href="#操作系统-18-文件基础" class="headerlink" title="操作系统-18-文件基础"></a>操作系统-18-文件基础</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/092059126.png" alt="mark"></p><a id="more"></a><h2 id="1-文件的属性"><a href="#1-文件的属性" class="headerlink" title="1. 文件的属性"></a>1. 文件的属性</h2><ul><li><strong>文件名</strong><br>主要是给用户看，同一个目录下不允许重名文件</li><li><strong>标识符</strong><br>一个系统内各文件标识符唯一，对用户毫无可读性，给操作系统看的</li><li><strong>类型</strong><br>文件扩展名</li><li><strong>位置</strong><br>文件存放路径，给用户看的，在外存中的地址用户是看不到的</li><li><strong>大小</strong></li><li><strong>创建时间</strong></li><li><strong>上次修改/访问时间</strong></li><li><strong>所有者信息</strong></li><li><strong>保护信息</strong></li></ul><h2 id="2-文件的逻辑结构"><a href="#2-文件的逻辑结构" class="headerlink" title="2. 文件的逻辑结构"></a>2. 文件的逻辑结构</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/092304381.png" alt="mark"></p><h3 id="2-1-无结构文件"><a href="#2-1-无结构文件" class="headerlink" title="2.1 无结构文件"></a>2.1 无结构文件</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/092424194.png" alt="mark"></p><h3 id="2-2-有结构文件"><a href="#2-2-有结构文件" class="headerlink" title="2.2 有结构文件"></a>2.2 有结构文件</h3><ul><li><p>又叫做 记录式 文件，<strong>比如数据库表，由一组相似的记录组成</strong></p></li><li><p>记录是一组相关的数据线的集合，<strong>每条记录有一个数据项可作为关键字</strong></p></li><li><p>根据记录的长度是否相等，可以分为</p><ul><li><strong>定长记录</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/092629157.png" alt="mark"></p><ul><li><strong>可变长记录</strong></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/092639472.png" alt="mark">****</p><p><strong>有结构文件的逻辑结构</strong></p><h4 id="2-2-1-顺序文件"><a href="#2-2-1-顺序文件" class="headerlink" title="2.2.1 顺序文件"></a>2.2.1 顺序文件</h4><ul><li><p><strong>链式存储</strong><br>逻辑上相邻的记录，<strong>在物理上离散存储</strong>。<br>​无论是定长/可变长记录，都无法实现随机存取，只能从链头开始遍历</p></li><li><p><strong>顺序存储</strong></p><p>逻辑上相邻的记录，在物理上也相邻。<br>没有说明的情况下，顺序文件指采用顺序存储的顺序文件</p><ul><li><p><strong>可变长记录</strong><br>无法实现随机存取</p></li><li><p><strong>定长记录</strong><br>可以实现随机存储。如果采用串结构(记录顺序与关键字无关)，无法快速找到某个关键字对应的记录，如果采用顺序结构(记录按关键字排序的)，可以使用折半查找快速找到记录</p></li></ul></li></ul><h4 id="2-2-2-索引文件"><a href="#2-2-2-索引文件" class="headerlink" title="2.2.2 索引文件"></a>2.2.2 索引文件</h4><ul><li><strong>索引表本身是定长记录的顺序文件</strong>，</li><li>索引表项包含索引号，长度，指针，<strong>真正的记录可以在物理上离散存储</strong>。</li><li><strong>索引号可以是关键字</strong>，这样就能折半查找加快检索速度，用于对信息处理及时性要求高的场合，解决了顺序文件增删不便的问题 可以用不同的数据项建立多个索引表</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/092917082.png" alt="mark"></p><h4 id="2-2-3-索引顺序文件"><a href="#2-2-3-索引顺序文件" class="headerlink" title="2.2.3 索引顺序文件"></a>2.2.3 索引顺序文件</h4><ul><li><strong>将记录分组，每一个组对应一个索引表项</strong> </li><li><strong>检索记录时先检索索引表，找到分组，再顺序查找分组</strong> </li><li>记录过多时，可以建立多级索引表 记录N的表，平均查找次数是N/2</li></ul><ol><li><strong>索引文件的缺点</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/093155169.png" alt="mark"></p><p><strong>索引顺序文件的效率分析：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/093318355.png" alt="mark"></p><ul><li><strong>多级索引顺序文件</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/093407395.png" alt="mark"></p><h2 id="3-文件的目录结构"><a href="#3-文件的目录结构" class="headerlink" title="3. 文件的目录结构"></a>3. 文件的目录结构</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/093521886.png" alt="mark"></p><h3 id="3-1-文件控制块"><a href="#3-1-文件控制块" class="headerlink" title="3.1 文件控制块"></a>3.1 文件控制块</h3><ul><li><strong>一个FCB 对应一个文件，一个FCB就是一个目录项</strong>，</li><li><strong>FCB的有序集合叫“文件目录”</strong> </li><li>FCB包含了文件的基本信息，存取控制信息，使用信息等等，最重要的是文件名、文件存放的物理地址 对目录的操作:搜索、创建文件、删除文件、显示文件、修改文件</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/093627660.png" alt="mark"></p><ul><li><strong>对目录的操作分类</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/093700128.png" alt="mark"></p><h3 id="3-2-目录结构"><a href="#3-2-目录结构" class="headerlink" title="3.2 目录结构"></a>3.2 目录结构</h3><h4 id="3-2-1-单级目录结构"><a href="#3-2-1-单级目录结构" class="headerlink" title="3.2.1 单级目录结构"></a>3.2.1 单级目录结构</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/093735243.png" alt="mark"></p><h4 id="3-2-2-两级目录结构"><a href="#3-2-2-两级目录结构" class="headerlink" title="3.2.2 两级目录结构"></a>3.2.2 两级目录结构</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/093830141.png" alt="mark"></p><h4 id="3-2-3-多级目录结构-树形目录结构"><a href="#3-2-3-多级目录结构-树形目录结构" class="headerlink" title="3.2.3 多级目录结构(树形目录结构)"></a>3.2.3 多级目录结构(树形目录结构)</h4><ul><li><p>共享不方便</p></li><li><p>从根目录出发的路径叫做<strong>绝对路径</strong></p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/094017394.png" alt="mark"></p><ul><li>从当前目录出发的路径叫做<strong>相对路径</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/094026527.png" alt="mark"></p><h4 id="3-2-4-无环图目录结构"><a href="#3-2-4-无环图目录结构" class="headerlink" title="3.2.4 无环图目录结构"></a>3.2.4 无环图目录结构</h4><ul><li>树形目录结构能够便于实现文件分类，但是不利于文件共享</li><li><strong>为此在树形目录结构的基础上增加一些指向同一节点的有向边</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/094101496.png" alt="mark"></p><h3 id="3-3-索引节点"><a href="#3-3-索引节点" class="headerlink" title="3.3 索引节点"></a>3.3 索引节点</h3><ul><li><strong>FCB  的问题</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/094317250.png" alt="mark"></p><ul><li>存放在磁盘上的索引节点叫做<strong>磁盘索引节点</strong></li><li>当文件被打开的时候，磁盘索引节点复制到<strong>内存索引节点</strong>中</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/094516179.png" alt="mark"></p><h2 id="4-文件的基本操作"><a href="#4-文件的基本操作" class="headerlink" title="4. 文件的基本操作"></a>4. 文件的基本操作</h2><ul><li><strong>创建文件(creat)</strong><ul><li>在外存中找到文件所需的<strong>空间</strong></li><li>根据<strong>文件路径找到对应的目录</strong>，创建文件对应的目录项</li></ul></li></ul><ul><li><strong>删除文件(delete)</strong><ul><li>根据文件路径找到对应的目录文件，找到文件名对应的目录项</li><li>回收文件占用的磁盘块</li><li>删除目录项</li></ul></li></ul><ul><li><strong>打开文件(open)</strong><ul><li>根据路径找到目录文件，找到文件名对应的目录项，检测用户的权限</li><li>将目录项复制到该进程在内存中的<strong>打开文件表</strong>中，返回<strong>表目编号</strong>(<strong>索引号/文件描述符FD</strong>)</li></ul></li></ul><ul><li><strong>关闭文件(close)</strong><ul><li>删除进程的打开文件表的对应项</li><li>回收分配给该文件的内存空间等资源</li><li>系统打开文件表的打开计数器count -= 1 (归零时删除该项)</li></ul></li></ul><ul><li><strong>读文件(read)</strong><ul><li>需要提供进程<strong>打开文件表中的索引号</strong>，读入的数据量，数据在内存中存放的位置</li><li>从读指针指向的外存位置读取指定大小的数据到指定的内存区域</li></ul></li></ul><ul><li><strong>写文件(write)</strong><ul><li>需要提供打开文件表中的索引号，写出的数据量，写回外存的数据位置(写指针指向)</li></ul></li></ul><h2 id="5-文件共享"><a href="#5-文件共享" class="headerlink" title="5. 文件共享"></a>5. 文件共享</h2><h3 id="5-1-基于索引节点的共享（硬链接）"><a href="#5-1-基于索引节点的共享（硬链接）" class="headerlink" title="5.1 基于索引节点的共享（硬链接）"></a>5.1 基于索引节点的共享（硬链接）</h3><ul><li>索引节点里面放了一个链接计数器 count </li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/094159031.png" alt="mark"></p><h3 id="5-2-基于符号链的共享（软链接）"><a href="#5-2-基于符号链的共享（软链接）" class="headerlink" title="5.2 基于符号链的共享（软链接）"></a>5.2 基于符号链的共享（软链接）</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/094226319.png" alt="mark"></p><ul><li>系统会创建一个<strong>Link 类型的新文件</strong><ul><li><strong>新文件的路径名</strong>只被视为是符号链</li><li>在利用符号链实现文件共享时候<ul><li><strong>只有文件的拥有</strong>者才拥有指向其索引节点的指针</li><li><strong>共享该文件的其他用户</strong>只有该为文件的路径名</li></ul></li></ul></li></ul><h2 id="6-文件保护"><a href="#6-文件保护" class="headerlink" title="6. 文件保护"></a>6. 文件保护</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/094509107.png" alt="mark"></p><ol><li><strong>口令保护</strong></li><li><strong>加密保护</strong></li><li><strong>访问控制</strong></li></ol><h2 id="7-文件的系统层次结构"><a href="#7-文件的系统层次结构" class="headerlink" title="7. 文件的系统层次结构"></a>7. 文件的系统层次结构</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/094625764.png" alt="mark"></p><p><strong>举个例子：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/094641719.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-18-文件基础&quot;&gt;&lt;a href=&quot;#操作系统-18-文件基础&quot; class=&quot;headerlink&quot; title=&quot;操作系统-18-文件基础&quot;&gt;&lt;/a&gt;操作系统-18-文件基础&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/092059126.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="文件管理" scheme="http://zhuuu.work/tags/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Netty-05-异步模型</title>
    <link href="http://zhuuu.work/2020/10/24/Netty/Netty-05-%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B/"/>
    <id>http://zhuuu.work/2020/10/24/Netty/Netty-05-%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-10-24T00:05:24.000Z</published>
    <updated>2020-10-28T14:23:00.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-05-异步模型"><a href="#Netty-05-异步模型" class="headerlink" title="Netty-05-异步模型"></a>Netty-05-异步模型</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本文注重讲解Netty的<strong>异步模型</strong> 和 <strong>任务的队列</strong></li></ul><h2 id="1-任务队列"><a href="#1-任务队列" class="headerlink" title="1. 任务队列"></a>1. 任务队列</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/085701217.png" alt="mark"></p><ul><li>任务队列由<code>NioEventLoop</code> 维护并且不断执行，当我们收到请求之后，在当前的 <code>channel</code> 中对应的 <code>pipeline</code>中的各个 <code>Hanlder</code>进行业务的处理和请求的过滤。</li><li>当某些业务需要消费大量事件的时候，我们可以将这些任务提交到由 <code>NioEventLoop</code> 维护的 <code>taskQueue</code> 或者 <code>ScheduleTaskQueue</code>中， 让当前的 NioEventLoop 线程在空闲的时候去执行这些任务。</li><li><strong>下面将介绍提交任务的三种方式:</strong></li></ul><a id="more"></a><h3 id="1-1-用户程序自定义的普通任务"><a href="#1-1-用户程序自定义的普通任务" class="headerlink" title="1.1 用户程序自定义的普通任务"></a>1.1 用户程序自定义的普通任务</h3><ul><li>该方式会将任务提交到<code>taskQueue</code>队列中。提交到该队列中的任务会按照提交顺序依次执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">channelHandlerContext.channel().eventLoop().execute(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="1-2-用户自定的定时任务"><a href="#1-2-用户自定的定时任务" class="headerlink" title="1.2 用户自定的定时任务"></a>1.2 用户自定的定时任务</h3><ul><li>该方式会将任务提交到<code>scheduleTaskQueue</code>定时任务队列中。该队列是底层是优先队列<code>PriorityQueue</code>实现的，固该队列中的任务会按照时间的先后顺序定时执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">channelHandlerContext.channel().eventLoop().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">60</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><h3 id="1-3-为其他的-EventLoop-线程对应的-Channel添加任务"><a href="#1-3-为其他的-EventLoop-线程对应的-Channel添加任务" class="headerlink" title="1.3 为其他的 EventLoop 线程对应的 Channel添加任务"></a>1.3 为其他的 EventLoop 线程对应的 Channel添加任务</h3><ul><li><strong>可以在<code>ChannelInitializer</code>中，将刚创建的各个<code>Channel</code>以及对应的标识加入到统一的集合中去</strong></li><li>然后可以根据表示获取 Channel 对应的 NioEventLoop,然后就可以调用<code>execute()</code>或者<code>schedule()</code>方法。</li></ul><h2 id="2-异步模型"><a href="#2-异步模型" class="headerlink" title="2. 异步模型"></a>2. 异步模型</h2><h3 id="2-1-异步的概念"><a href="#2-1-异步的概念" class="headerlink" title="2.1 异步的概念"></a>2.1 异步的概念</h3><ul><li>异步的概念和同步是相对的，当一个异步过程调用发出后，调用者不能立即的得到结果。实际处理这个调用的组件在完成后，<strong>通过状态，通知和回调来通知调用者</strong></li><li><code>Netty</code> 中的 <code>I/O</code> 操作是异步的，包括 <code>Bind</code>、<code>Write</code>、<code>Connect</code> 等操作会简单的返回一个 <code>ChannelFuture</code>。</li><li>调用者并不能立即获得结果，而是通过 <code>Future-Listener</code> 机制，用户可以方便的主动获取或者通过通知机构获取IO 的操作结果。</li></ul><p><strong>机制描述</strong></p><ul><li><code>Netty</code> 的异步模型是建立在 <code>future</code> 和 <code>callback</code> 的之上的。<code>callback</code> 就是回调。重点说 <code>Future</code>，它的核心思想是：假设一个方法 <code>fun</code>，计算过程可能非常耗时，等待 <code>fun</code>返回显然不合适。那么可以在调用 <code>fun</code> 的时候，立马返回一个 <code>Future</code>，后续可以通过 <code>Future</code>去监控方法 <code>fun</code> 的处理过程(即 ： <code>Future-Listener</code> 机制)</li></ul><p><strong>关于 Future 的说明</strong></p><ul><li>表示异步的执行结果, 可以通过它提供的方法来检测执行是否完成，比如检索计算等等.</li><li><code>ChannelFuture</code> 是一个接口 ： <code>public interface ChannelFuture extends Future&lt;Void&gt;</code>。我们可以添加监听器，当监听的事件发生时，就会通知到监听器</li></ul><p><strong>工作原理示意图</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201028/215425984.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201028/215442367.png" alt="mark"></p><ul><li>在使用 <code>Netty</code> 进行编程时，拦截操作和转换出入站数据只需要您提供 <code>callback</code> 或利用<code>future</code> 即可。这使得链式操作简单、高效, 并有利于编写可重用的、通用的代码。</li><li><code>Netty</code> 框架的目标就是让你的业务逻辑从网络基础应用编码中分离出来、解脱出来</li></ul><h3 id="2-2-Future-Listener-机制"><a href="#2-2-Future-Listener-机制" class="headerlink" title="2.2 Future-Listener 机制"></a>2.2 Future-Listener 机制</h3><ul><li>当 <code>Future</code> 对象刚刚创建时，处于非完成状态，调用者可以通过返回的 <code>ChannelFuture</code> 来获取操作执行的状态，注册监听函数来执行完成后的操作。</li></ul><p><strong>常用方法如下：</strong></p><table><thead><tr><th>方法名称</th><th>方法作用</th></tr></thead><tbody><tr><td>isDone()</td><td>判断当前操作是否完成</td></tr><tr><td>isSuccess()</td><td>判断已完成的当前操作是否成功</td></tr><tr><td>getCause()</td><td>获取已完成当前操作失败的原因</td></tr><tr><td>isCancelled()</td><td>判断已完成的当前操作是否被取消</td></tr><tr><td>addListener()</td><td>注册监听器，当前操作（Future）已完成，将会通知指定的监听器</td></tr></tbody></table><p><strong>举例说明</strong></p><ul><li>绑定端口操作时异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.bind(port).addListener(future -&gt; &#123;</span><br><span class="line">       <span class="keyword">if</span>(future.isSuccess()) &#123;</span><br><span class="line">           System.out.println(newDate() + <span class="string">": 端口["</span>+ port + <span class="string">"]绑定成功!"</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">           System.err.println(<span class="string">"端口["</span>+ port + <span class="string">"]绑定失败!"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><h3 id="2-3-HTTP-实战入门"><a href="#2-3-HTTP-实战入门" class="headerlink" title="2.3 HTTP 实战入门"></a>2.3 HTTP 实战入门</h3><p><strong>目标 ：  浏览器访问<code>Netty</code>服务器后，返回<code>HelloWorld</code></strong></p><ol><li><strong>启动器</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">TestServerInitializer</span>())</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 绑定端口号操作</span></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭线程池</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>自定义ChannelInitializer</strong></p><p><strong>用于给<code>Channel</code>对应的<code>pipeline</code>添加<code>handler</code></strong>。该<code>ChannelInitializer</code>中的代码在<code>SocketChannel</code>被创建时都会执行</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向管道加入处理器</span></span><br><span class="line">        <span class="comment">// 首先得到管道</span></span><br><span class="line">        ChannelPipeline pipeline = channel.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 加入一个netty提供的HttpServerCodec</span></span><br><span class="line">        <span class="comment">// netty自带的http编码解码器</span></span><br><span class="line">        pipeline.addLast(<span class="string">"MyHttpServerCodec"</span>,<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 增加自定义handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">"MyTestHttpServerHandler"</span>,<span class="keyword">new</span> TestHttpServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>自定义Handler</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHttpServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">HttpObject</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取客户端的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channelHandlerContext</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> httpObject 客户端和服务端互相通讯所使用的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, HttpObject httpObject)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 判断msg 是不是 HttpRequest请求</span></span><br><span class="line">        <span class="keyword">if</span>(httpObject <span class="keyword">instanceof</span> HttpRequest)&#123;</span><br><span class="line">            System.out.println(<span class="string">"msg 类型 = "</span> + httpObject.getClass());</span><br><span class="line">            System.out.println(<span class="string">"客户端地址："</span> + channelHandlerContext.channel().remoteAddress());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取http请求</span></span><br><span class="line">            HttpRequest request = (HttpRequest) httpObject;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从http请求中获取uri</span></span><br><span class="line">            URI uri = <span class="keyword">new</span> URI(request.uri());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 过滤http中的请求</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"/favicon.ico"</span>.equals(uri.getPath()))&#123;</span><br><span class="line">                System.out.println(<span class="string">"请求了 favicon.ico，不做响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回复信息给浏览器[http协议]</span></span><br><span class="line">            ByteBuf content = Unpooled.copiedBuffer(<span class="string">"helloWorld"</span>, CharsetUtil.UTF_8);</span><br><span class="line">            <span class="comment">// 构造一个http响应回复给浏览器</span></span><br><span class="line">            DefaultFullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_TYPE,<span class="string">"text/plain"</span>);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_LENGTH,content.readableBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将构建好的response返回给客户端</span></span><br><span class="line">            channelHandlerContext.writeAndFlush(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-05-异步模型&quot;&gt;&lt;a href=&quot;#Netty-05-异步模型&quot; class=&quot;headerlink&quot; title=&quot;Netty-05-异步模型&quot;&gt;&lt;/a&gt;Netty-05-异步模型&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本文注重讲解Netty的&lt;strong&gt;异步模型&lt;/strong&gt; 和 &lt;strong&gt;任务的队列&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-任务队列&quot;&gt;&lt;a href=&quot;#1-任务队列&quot; class=&quot;headerlink&quot; title=&quot;1. 任务队列&quot;&gt;&lt;/a&gt;1. 任务队列&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/085701217.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任务队列由&lt;code&gt;NioEventLoop&lt;/code&gt; 维护并且不断执行，当我们收到请求之后，在当前的 &lt;code&gt;channel&lt;/code&gt; 中对应的 &lt;code&gt;pipeline&lt;/code&gt;中的各个 &lt;code&gt;Hanlder&lt;/code&gt;进行业务的处理和请求的过滤。&lt;/li&gt;
&lt;li&gt;当某些业务需要消费大量事件的时候，我们可以将这些任务提交到由 &lt;code&gt;NioEventLoop&lt;/code&gt; 维护的 &lt;code&gt;taskQueue&lt;/code&gt; 或者 &lt;code&gt;ScheduleTaskQueue&lt;/code&gt;中， 让当前的 NioEventLoop 线程在空闲的时候去执行这些任务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;下面将介绍提交任务的三种方式:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="NIO" scheme="http://zhuuu.work/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Linux-10-内存页面置换算法</title>
    <link href="http://zhuuu.work/2020/10/22/Linux/Linux-10-%E5%86%85%E5%AD%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/"/>
    <id>http://zhuuu.work/2020/10/22/Linux/Linux-10-%E5%86%85%E5%AD%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/</id>
    <published>2020-10-22T03:22:53.000Z</published>
    <updated>2020-10-22T12:06:03.995Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-10-内存页面置换算法"><a href="#Linux-10-内存页面置换算法" class="headerlink" title="Linux-10-内存页面置换算法"></a>Linux-10-内存页面置换算法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg" alt="mark"></p><a id="more"></a><h2 id="1-缺页异常"><a href="#1-缺页异常" class="headerlink" title="1. 缺页异常"></a>1. 缺页异常</h2><p>在了解内存页面置换算法前，我们得先谈一下<strong>缺页异常（缺页中断）</strong>。</p><p>当 CPU 访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存。那它与一般中断的主要区别在于：</p><ul><li>缺页中断在指令执行「期间」产生和处理中断信号，而一般中断在一条指令执行「完成」后检查和处理中断信号。</li><li>缺页中断返回到该指令的开始重新执行「该指令」，而一般中断返回回到该指令的「下一个指令」执行。</li></ul><p>我们来看一下缺页中断的处理流程，如下图：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/142400418.png" alt="mark"></p><ol><li>在 CPU 里访问一条 <code>Load M</code> 指令，然后 <code>CPU</code> 会去找 M 所对应的页表项。</li><li>如果该页表项的状态位是「有效的」，那 CPU 就可以直接去访问物理内存了，如果状态位是「无效的」，则 CPU 则会发送缺页中断请求。</li><li>操作系统收到了缺页中断，则会执行缺页中断处理函数，先会查找该页面在磁盘中的页面的位置。</li><li>找到磁盘中对应的页面后，需要把该页面换入到物理内存中，但是在换入前，需要在物理内存中找空闲页，如果找到空闲页，就把页面换入到物理内存中。</li><li>页面从磁盘换入到物理内存完成后，则把页表项中的状态位修改为「有效的」。</li><li>最后，CPU 重新执行导致缺页异常的指令。</li></ol><p>上面所说的过程，第 4 步是能在物理内存找到空闲页的情况，那如果找不到呢？</p><ul><li>找不到空闲页的话，就说明此时内存已满了，这时候，就需要「页面置换算法」选择一个物理页<ul><li>如果该物理页有被修改过（脏页），则把它换出到磁盘</li><li>然后把该被置换出去的页表项的状态改成「无效的」，最后把正在访问的页面装入到这个物理页中。</li></ul></li></ul><p>这里提一下，<strong>页表项</strong>通常有如下图的字段：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/142756318.png" alt="mark"></p><ul><li><em>状态位</em>：用于表示该页是否有效，也就是说是否在物理内存中，供程序访问时参考。</li><li><em>访问字段</em>：用于记录该页在一段时间被访问的次数，供页面置换算法选择出页面时参考。</li><li><em>修改位</em>：表示该页在调入内存后是否有被修改过，由于内存中的每一页都在磁盘上保留一份副本，因此，如果没有修改，在置换该页时就不需要将该页写回到磁盘上，以减少系统的开销；如果已经被修改，则将该页重写到磁盘上，以保证磁盘中所保留的始终是最新的副本。</li><li><em>硬盘地址</em>：用于指出该页在硬盘上的地址，通常是物理块号，供调入该页时使用。</li></ul><h2 id="2-虚拟内存管理"><a href="#2-虚拟内存管理" class="headerlink" title="2. 虚拟内存管理"></a>2. 虚拟内存管理</h2><p>这里整理了虚拟内存的管理整个流程，你可以从下面这张图看到：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/142914008.jpg" alt="mark"></p><ul><li><p>所以，页面置换算法的功能是，<strong>当出现缺页异常，需调入新页面而内存已满时，选择被置换的物理页面</strong></p></li><li><p>也就是说选择一个物理页面换出到磁盘，然后把需要访问的页面换入到物理页。</p></li></ul><h2 id="3-常见的页面置换算法"><a href="#3-常见的页面置换算法" class="headerlink" title="3. 常见的页面置换算法"></a>3. 常见的页面置换算法</h2><p>那其算法目标则是，尽可能减少页面的换入换出的次数，常见的页面置换算法有如下几种：</p><ul><li>最佳页面置换算法（<em>OPT</em>）</li><li>先进先出置换算法（<em>FIFO</em>）</li><li>最近最久未使用的置换算法（<em>LRU</em>）</li><li>时钟页面置换算法（<em>Lock</em>）</li><li>最不常用置换算法（<em>LFU</em>）</li></ul><h3 id="3-1-最佳页面置换算法"><a href="#3-1-最佳页面置换算法" class="headerlink" title="3.1 最佳页面置换算法"></a>3.1 最佳页面置换算法</h3><ul><li>最佳页面置换算法基本思路是，<strong>置换在「未来」最长时间不访问的页面</strong>。</li><li>所以，该算法实现需要计算内存中每个逻辑页面的「下一次」访问时间，然后比较，选择未来最长时间不访问的页面。</li><li>我们举个例子，假设一开始有 3 个空闲的物理页，然后有请求的页面序列，那它的置换过程如下图：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/143450166.png" alt="mark"></p><ul><li>在这个请求的页面序列中，缺页共发生了 <code>7</code> 次（空闲页换入 3 次 + 最优页面置换 4 次），页面置换共发生了 <code>4</code> 次。</li><li>这很理想，但是实际系统中无法实现，因为程序访问页面时是动态的，我们是无法预知每个页面在「下一次」访问前的等待时间。</li><li>所以，最佳页面置换算法作用是为了衡量你的算法的效率，你的算法效率越接近该算法的效率，那么说明你的算法是高效的。</li></ul><h3 id="3-2-先进先出置换算法"><a href="#3-2-先进先出置换算法" class="headerlink" title="3.2 先进先出置换算法"></a>3.2 先进先出置换算法</h3><ul><li>既然我们无法预知页面在下一次访问前所需的等待时间，那我们可以<strong>选择在内存驻留时间很长的页面进行中置换</strong>，这个就是「先进先出置换」算法的思想。</li><li>还是以前面的请求的页面序列作为例子，假设使用先进先出置换算法，则过程如下图：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/143610965.png" alt="mark"></p><ul><li>在这个请求的页面序列中，缺页共发生了 <code>10</code> 次，页面置换共发生了 <code>7</code> 次，跟最佳页面置换算法比较起来，性能明显差了很多。</li></ul><h3 id="3-3-最近最久未使用置换算法（LRU）"><a href="#3-3-最近最久未使用置换算法（LRU）" class="headerlink" title="3.3 最近最久未使用置换算法（LRU）"></a>3.3 最近最久未使用置换算法（LRU）</h3><ul><li><p>最近最久未使用（<em>LRU</em>）的置换算法的基本思路是，发生缺页时，<strong>选择最长时间没有被访问的页面进行置换</strong>，也就是说，该算法假设已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用。</p></li><li><p>这种算法近似最优置换算法，最优置换算法是通过「未来」的使用情况来推测要淘汰的页面，而 LRU 则是通过「历史」的使用情况来推测要淘汰的页面。</p></li><li><p>还是以前面的请求的页面序列作为例子，假设使用最近最久未使用的置换算法，则过程如下图：</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/143749910.png" alt="mark"></p><ul><li>在这个请求的页面序列中，缺页共发生了 <code>9</code> 次，页面置换共发生了 <code>6</code> 次，跟先进先出置换算法比较起来，性能提高了一些。</li><li>虽然 LRU 在理论上是可以实现的，但代价很高。为了完全实现 LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。</li><li>困难的是，在每次访问内存时都必须要更新「整个链表」。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常费时的操作。</li><li>所以，LRU 虽然看上去不错，但是由于开销比较大，实际应用中比较少使用。</li></ul><h3 id="3-4-时钟页面置换算法"><a href="#3-4-时钟页面置换算法" class="headerlink" title="3.4 时钟页面置换算法"></a>3.4 时钟页面置换算法</h3><ul><li><p>那有没有一种即能优化置换的次数，也能方便实现的算法呢？</p></li><li><p>时钟页面置换算法就可以两者兼得，它跟 LRU 近似，又是对 FIFO 的一种改进。</p></li></ul><p>该算法的思路是，<strong>把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。</strong></p><ul><li>如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；</li><li>如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/144000359.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/144016734.png" alt="mark"></p><p>了解了这个算法的工作方式，就明白为什么它被称为时钟（<em>Clock</em>）算法了</p><h3 id="3-5-最不常用算法（LFU）"><a href="#3-5-最不常用算法（LFU）" class="headerlink" title="3.5 最不常用算法（LFU）"></a>3.5 最不常用算法（LFU）</h3><ul><li>最不常用（<em>LFU</em>）算法，这名字听起来很调皮，但是它的意思不是指这个算法不常用，而是<strong>当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰</strong>。</li><li>它的实现方式是，对每个页面设置一个「访问计数器」，每当一个页面被访问时，该页面的访问计数器就累加 1。在发生缺页中断时，淘汰计数器值最小的那个页面。</li></ul><p><strong>缺点</strong></p><ul><li>看起来很简单，每个页面加一个计数器就可以实现了，但是在操作系统中实现的时候，我们需要考虑效率和硬件成本的。</li><li>要增加一个计数器来实现，这个硬件成本是比较高的，另外如果要对这个计数器查找哪个页面访问次数最小，查找链表本身，如果<strong>链表长度很大，是非常耗时</strong>的，效率不高。</li><li>LFU 算法<strong>只考虑了频率问题，没考虑时间的问题</strong>，比如有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。<ul><li>那这个问题的解决的办法还是有的，可以定期减少访问的次数，比如当发生时间中断时，把过去时间访问的页面的访问次数除以 2</li><li>也就说，随着时间的流失，以前的高访问次数的页面会慢慢减少，相当于加大了被置换的概率。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-10-内存页面置换算法&quot;&gt;&lt;a href=&quot;#Linux-10-内存页面置换算法&quot; class=&quot;headerlink&quot; title=&quot;Linux-10-内存页面置换算法&quot;&gt;&lt;/a&gt;Linux-10-内存页面置换算法&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="内存页面置换" scheme="http://zhuuu.work/tags/%E5%86%85%E5%AD%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Netty-04-线程模型</title>
    <link href="http://zhuuu.work/2020/10/19/Netty/Netty-04-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>http://zhuuu.work/2020/10/19/Netty/Netty-04-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-10-19T03:05:24.000Z</published>
    <updated>2020-10-24T00:52:11.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-04-线程模型"><a href="#Netty-04-线程模型" class="headerlink" title="Netty-04-线程模型"></a>Netty-04-线程模型</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="原生NIO存在的问题"><a href="#原生NIO存在的问题" class="headerlink" title="原生NIO存在的问题"></a>原生NIO存在的问题</h3><ul><li>NIO 的类库和 API 繁杂，使用麻烦：需要熟练掌握 <code>Selector</code>、<code>ServerSocketChannel</code>、<code>SocketChannel</code>、<code>ByteBuffer</code> 等。</li><li>需要具备其他的额外技能：要熟悉 <code>Java</code> 多线程编程，因为 <code>NIO</code> 编程涉及到 <code>Reactor</code> 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 NIO 程序。</li><li>开发工作量和难度都非常大：例如客户端面临<strong>断连重连</strong>、<strong>网络闪断</strong>、<strong>半包读写</strong>、<strong>失败缓存</strong>、<strong>网络拥塞和异常流的处理</strong>等等。</li><li>JDK NIO 的 Bug : 例如臭名昭著的 <code>Epoll Bug</code>，它会导致 <code>Selector</code> 空轮询，最终导致 <code>CPU</code> 100%。直到 JDK 1.7 版本该问题仍旧存在，没有被根本解决。</li></ul><h3 id="Netty优点"><a href="#Netty优点" class="headerlink" title="Netty优点"></a>Netty优点</h3><ul><li><strong><code>Netty</code>对<code>JDK</code>自带的<code>NIO</code>的<code>API</code>进行了封装，解决了上述问题。</strong><ul><li>设计优雅：适用于各种传输类型的统一 <code>API</code> 阻塞和非阻塞 <code>Socket</code>；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型 - 单线程，一个或多个线程池.</li><li>安全：完整的 <code>SSL/TLS</code> 和 <code>StartTLS</code> 支持</li><li>高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。</li></ul></li></ul><a id="more"></a><h2 id="1-I-O线程模型"><a href="#1-I-O线程模型" class="headerlink" title="1. I/O线程模型"></a>1. I/O线程模型</h2><p>目前存在的线程模型主要有：</p><ul><li><strong>传统阻塞I/O服务模型</strong></li><li><strong>Reactor模式</strong></li></ul><p>根据<code>Reactor</code>的数量和处理资源池线程的数量不同，有<strong>如下<code>3</code>种典型的实现</strong></p><ul><li>单<code>Reactor</code>单线程</li><li>单<code>Reactor</code>多线程</li><li>主从<code>Reactor</code>多线程</li></ul><ul><li><code>Netty</code>线程模型主要基于<strong>主从Reactor多线程模型</strong>做了一定的改进，其中主从<code>Reactor</code>多线程模型有多个<code>Reactor</code>。</li></ul><h3 id="1-1-传统阻塞I-O服务模型"><a href="#1-1-传统阻塞I-O服务模型" class="headerlink" title="1.1 传统阻塞I/O服务模型"></a>1.1 传统阻塞I/O服务模型</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201018/110137563.png" alt="mark"></p><p><strong>图解说明：黄色的框表示对象，蓝色的框表示线程、白色的框表示方法（API）。之后的图相同。</strong></p><h4 id="1-1-1-模型分析"><a href="#1-1-1-模型分析" class="headerlink" title="1.1.1 模型分析"></a>1.1.1 模型分析</h4><p><strong>模型特点：</strong></p><ul><li>采用阻塞<code>IO</code>模式获取输入的数据</li><li>每个链接都需要独立的线程完成数据的输入，业务处理、数据返回。</li></ul><p><strong>问题分析：</strong></p><ul><li>当并发数很大，就会创建大量的线程，占用很大系统资源</li><li>连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在<code>read</code>操作，造成线程资源浪费。</li></ul><h4 id="1-1-2-代码实现"><a href="#1-1-2-代码实现" class="headerlink" title="1.1.2 代码实现"></a>1.1.2 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个线程池</span></span><br><span class="line">        <span class="comment">// 2. 如果有客户端前来链接，就创建一个线程与之通信（单独的一个方法）</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        System.out.println(<span class="string">"服务器启动了"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 监听等待客户端的连接</span></span><br><span class="line">            <span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">"连接到一个客户端请求"</span>);</span><br><span class="line">            <span class="comment">// 创建一个线程与之通信</span></span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="comment">// 重写Runnable 方法，与客户端进行同i性能</span></span><br><span class="line">                handler(socket);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编写一个handler方法，和客户端通讯，主要进行数据的读取和业务的处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过socket获取输入流</span></span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            <span class="comment">// 循环的读取客户端发送来的数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> read = inputStream.read(bytes);</span><br><span class="line">                <span class="keyword">if</span> (read != -<span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, read)); <span class="comment">// 输出客户端发送的数据</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"关闭和client的链接"</span>);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-Reactor-模型概述"><a href="#1-2-Reactor-模型概述" class="headerlink" title="1.2 Reactor 模型概述"></a>1.2 Reactor 模型概述</h3><p><strong>针对传统阻塞I/O服务模型的2个缺点，解决方案如下：</strong></p><ul><li>基于 <code>I/O</code> 复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。<code>Reactor</code> 对应的叫法: 1. 反应器模式 2. 分发者模式(<code>Dispatcher</code>) 3. 通知者模式(<code>notifier</code>)</li><li>基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务。</li></ul><p><strong>I/O复用结合线程池，就是Reactor模式基本设计思想，如图所示：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201018/112628506.png" alt="mark"></p><ul><li><code>Reactor</code> 模式，通过一个或者多个输入同时传递给服务处理器模式（基于事件驱动） </li><li>服务端端程序处理传入的多个请求，并将它们同步分派到相应的处理线程，因此<code>Reactor</code>模式也叫做<code>Dispatcher</code> 模式</li><li><code>Reactor</code>模式使用的IO多路复用监听事件，收到事件后，分发到某个线程或者进程，这点就是网络服务高并发处理的关键。</li></ul><p><strong>Reactor模式中的核心组成部分：</strong></p><ul><li><code>Reactor</code>：<code>Reactor</code>在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对<code>IO</code>事件作出反应。</li><li><code>Handlers</code>：处理程序执行<code>I/O</code>事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。<code>Reactor</code>通过调度适当的处理程序来响应<code>I/O</code>事件，处理程序执行非阻塞操作。</li></ul><h3 id="1-3-单Reactor-单线程模式"><a href="#1-3-单Reactor-单线程模式" class="headerlink" title="1.3 单Reactor 单线程模式"></a>1.3 单Reactor 单线程模式</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201018/113023202.png" alt="mark"></p><p><strong>方案说明：</strong></p><ul><li><code>Select</code> 是前面 <code>I/O</code> 复用模型介绍的标准网络编程 API，可以实现应用程序通过一个阻塞对象监听多路连接请求</li><li><code>Reactor</code> 对象通过 <code>Select</code> 监控客户端请求事件，收到事件后通过 <code>Dispatch</code> 进行分发</li><li>如果是建立连接请求事件，则由 <code>Acceptor</code> 通过 <code>Accept</code> 处理连接请求，然后创建一个 <code>Handler</code> 对象处理连接完成后的后续业务处理</li><li>如果不是建立连接事件，则 <code>Reactor</code> 会分发调用连接对应的 Handler 来响应<ul><li><code>Handler</code> 会完成 <code>Read</code>→业务处理→<code>Send</code> 的完整业务流程</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/094751253.png" alt="mark"></p><h4 id="1-3-1-模型分析"><a href="#1-3-1-模型分析" class="headerlink" title="1.3.1 模型分析"></a>1.3.1 <strong>模型分析</strong></h4><ul><li><strong>优点</strong>：模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成</li><li><strong>缺点</strong>：<ul><li>性能问题，只有一个线程，无法完全发挥多核 <code>CPU</code> 的性能。<code>Handler</code> 在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈</li><li>可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障</li></ul></li><li><strong>使用场景</strong>：客户端的数量有限，业务处理非常快速，比如 <code>Redis</code>在业务处理的时间复杂度 <code>O(1)</code> 的情况</li></ul><h4 id="1-3-2-代码实现"><a href="#1-3-2-代码实现" class="headerlink" title="1.3.2 代码实现"></a>1.3.2 代码实现</h4><blockquote><p>这里面我为了简便，我将Reactor和Acceptor和Handler三个对象搞成了方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel serverSocketChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> PORT = <span class="number">6666</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">            serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对客户端进行监听事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> count = selector.select();</span><br><span class="line">                <span class="comment">// 返回值大于0表示有客户端产生事件</span></span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 取出产生事件的channel</span></span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                    <span class="comment">// 对事件遍历</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                        SelectionKey next = iterator.next();</span><br><span class="line">                        <span class="comment">// 将key进行分发</span></span><br><span class="line">                        dispatch(next);</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分发</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(SelectionKey key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">            <span class="comment">// 如果是连接事件</span></span><br><span class="line">            accept(key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 其他事件</span></span><br><span class="line">            handler(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立新的连接</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(SelectionKey key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            socketChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对请求进行处理，接收消息--业务处理--返回消息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(SelectionKey key)</span></span>&#123;</span><br><span class="line">        SocketChannel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            channel = (SocketChannel) key.channel();</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">            StringBuilder msg = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (channel.read(buffer) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                msg.append(<span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"接收到消息："</span> + msg.toString());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            String ok = <span class="string">"OK"</span>;</span><br><span class="line">            buffer.put(ok.getBytes());</span><br><span class="line">            <span class="comment">//这个flip非常重要哦，是将position置0，limit置于position的位置，</span></span><br><span class="line">            <span class="comment">// 以便下面代码进行写入操作能够正确写入buffer中的所有数据</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            channel.write(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(channel.getRemoteAddress() + <span class="string">"离线了"</span>);</span><br><span class="line">                <span class="comment">//取消该通道的注册并关闭通道，这里非常重要，没有这一步的话当客户端断开连接就会不断抛出IOException</span></span><br><span class="line">                <span class="comment">//是因为，select会一直产生该事件。</span></span><br><span class="line">                key.cancel();</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException ex)&#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test test = <span class="keyword">new</span> test();</span><br><span class="line">        test.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里有更牛逼更完整的<code>Reactor</code>单线程模型的代码案例：</strong><a href="https://www.cnblogs.com/hama1993/p/10611229.html" target="_blank" rel="noopener">https://www.cnblogs.com/hama1993/p/10611229.html</a></p><h3 id="1-4-单Reactor-多线程模式"><a href="#1-4-单Reactor-多线程模式" class="headerlink" title="1.4 单Reactor 多线程模式"></a>1.4 单Reactor 多线程模式</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/095400913.png" alt="mark"></p><p><strong>方案说明：</strong></p><ul><li><code>Reactor</code> 对象通过<code>select</code> 监控客户端请求事件, 收到事件后，通过<code>dispatch</code>进行分发</li><li>如果建立连接请求, 则右<code>Acceptor</code> 通过accept 处理连接请求, 然后创建一个<code>Handler</code>对象处理完成连接后的各种事件</li><li>如果不是连接请求，则由<code>reactor</code>分发调用连接对应的<code>handler</code> 来处理</li><li>handler 只负责响应事件，不做具体的业务处理, 通过<code>read</code> 读取数据后，会分发给后面的<code>worker</code>线程池的某个线程处理业务</li><li><code>worker</code> 线程池会分配独立线程完成真正的业务，并将结果返回给<code>handler</code></li><li><code>handler</code>收到响应后，通过<code>send</code> 将结果返回给<code>client</code></li></ul><h4 id="1-4-1-模型分析"><a href="#1-4-1-模型分析" class="headerlink" title="1.4.1 模型分析"></a>1.4.1 模型分析</h4><ul><li><strong>优点</strong>：可以充分的利用多核<code>cpu</code> 的处理能力</li><li><strong>缺点</strong>：多线程数据共享和访问比较复杂， <code>reactor</code> 处理所有的事件的监听和响应，在单线程运行， 在高并发场景容易出现性能瓶颈.</li></ul><h4 id="1-4-2-代码实现"><a href="#1-4-2-代码实现" class="headerlink" title="1.4.2 代码实现"></a>1.4.2 代码实现</h4><ul><li><code>ReadHandler</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SelectionKey selectionKey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadHandler</span><span class="params">(SelectionKey selectionKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.selectionKey = selectionKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SocketChannel sc = (SocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="comment">//处理读请求</span></span><br><span class="line">            doRead(sc);</span><br><span class="line">            <span class="comment">//处理完读请求，将通道注册为写</span></span><br><span class="line">            Selector selector = selectionKey.selector();</span><br><span class="line">            SelectionKey sk = sc.register(selector, SelectionKey.OP_WRITE);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRead</span><span class="params">(SocketChannel ssc)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"读取数据，然后做一些数据处理"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在ReadHandler中，doRead(sc)，方法是同步的，而一般读到一个请求要经历解析请求信息，然后交到对应的service处理业务等等操作，非常耗时，此时将doRead进行异步处理，将能提高服务器资源的使用，提高性能。</li><li>所以单Reactor单线程模型的实现，就是将单线程模型中的Handler中的数据处理异步处理，并引入线程池管理这些线程，这样dispatch将专注于事件分发，而各自handler专注于各自的事件处理。</li></ul><ul><li><strong>单Reactor多线程</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单Reactor多线程模型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneReactorMultiThreadMode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化一个线程池，然后启动MultiReacor</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ThreadPool.getPool().init(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">new</span> MultiReactor(<span class="number">8089</span>).run();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>MultiReactor</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiReactor</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel servChannel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiReactor</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            servChannel = ServerSocketChannel.open();</span><br><span class="line">            servChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            servChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(port), <span class="number">1024</span>);</span><br><span class="line">            SelectionKey sk = servChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            stop=<span class="keyword">false</span>;</span><br><span class="line">            System.out.println(<span class="string">"The time server is start in port : "</span> + port);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                selector.select(<span class="number">1000</span>);</span><br><span class="line">                Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; it = selectedKeys.iterator();</span><br><span class="line">                SelectionKey key = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                    key = it.next();</span><br><span class="line">                    it.remove();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        disptach(key);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            key.cancel();</span><br><span class="line">                            <span class="keyword">if</span> (key.channel() != <span class="keyword">null</span>)</span><br><span class="line">                                key.channel().close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                t.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">disptach</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(key.isValid())&#123;</span><br><span class="line">            <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                <span class="keyword">new</span> MultiAcceptor(key).run();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                <span class="keyword">new</span> MultiReadHandler(key).run();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(key.isWritable())&#123;</span><br><span class="line">                <span class="keyword">new</span> MultiWriteHandler(key).run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>MultiAcceptor</strong> </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiAcceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SelectionKey selectionKey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiAcceptor</span><span class="params">(SelectionKey selectionKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.selectionKey = selectionKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocketChannel ssc = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">            SocketChannel sc = ssc.accept();</span><br><span class="line">            sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            Selector selector = selectionKey.selector();</span><br><span class="line">            SelectionKey sk = sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>MultiReadHandler</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiReadHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SelectionKey selectionKey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiReadHandler</span><span class="params">(SelectionKey selectionKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.selectionKey = selectionKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> SocketChannel sc = (SocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="comment">//使用线程池，异步处理读请求</span></span><br><span class="line">            ThreadPool.getPool().submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    doRead(sc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理完读请求，将通道注册为写</span></span><br><span class="line">            Selector selector = selectionKey.selector();</span><br><span class="line">            SelectionKey sk = sc.register(selector, SelectionKey.OP_WRITE);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRead</span><span class="params">(SocketChannel ssc)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"读取数据，然后做一些数据处理"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>线程池</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 示例-线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadPool pool = <span class="keyword">new</span> ThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> init=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadPool</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!init)&#123;</span><br><span class="line">            executorService=Executors.newFixedThreadPool(size);</span><br><span class="line">            init=<span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"the thread pool had inited"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadPool <span class="title">getPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> pool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">submit</span><span class="params">(Runnable runnable)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(init)&#123;</span><br><span class="line">            executorService.submit(runnable);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"the thread pool is not inited"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-主从Reactor模式"><a href="#1-5-主从Reactor模式" class="headerlink" title="1.5 主从Reactor模式"></a>1.5 主从Reactor模式</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/094348642.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/094725334.png" alt="mark"></p><p><strong>方案说明</strong></p><ul><li><code>Reactor</code>主线程 <code>MainReactor</code> 对象就只注册一个用于监听连接请求的<code>ServerSocketChannel</code>，通过<code>select</code> 监听连接事件, 收到事件后，通过<code>Acceptor</code> 处理连接事件</li><li>当 <code>Acceptor</code> 处理连接事件后，<code>MainReactor</code> 通过<code>accept</code>获取新的连接，并将连接注册到<code>SubReactor</code></li><li><code>subreactor</code> 将连接加入到连接队列进行监听,并创建<code>handler</code>进行各种事件处理</li><li>当有新事件发生时， <code>subreactor</code> 就会调用对应的<code>handler</code>处理</li><li><code>handler</code> 通过<code>read</code> 读取数据，分发给后面的<code>worker</code> 线程处理</li><li><code>worker</code> 线程池分配独立的<code>worker</code> 线程进行业务处理，并返回结果</li><li>handler<code>收到响应的结果后，再通过</code>send<code>将结果返回给</code>client</li><li>Reactor<code>主线程可以对应多个</code>Reactor<code>子线程, 即</code>MainRecator<code>可以关联多个</code>SubReactor</li></ul><h4 id="1-5-1-模型分析"><a href="#1-5-1-模型分析" class="headerlink" title="1.5.1 模型分析"></a>1.5.1 模型分析</h4><ul><li><strong>优点</strong>：父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。</li><li><strong>优点</strong>：父线程与子线程的数据交互简单，<code>Reactor</code> 主线程只需要把新连接传给子线程，子线程无需返回数据</li><li><strong>缺点</strong>：编程复杂度较高</li><li><strong>结合实例</strong>：这种模型在许多项目中广泛使用，包括 <code>Nginx</code> 主从 <code>Reactor</code> 多进程模型，<code>Memcached</code> 主从多线程，<code>Netty</code> 主从多线程模型的支持</li></ul><h4 id="1-5-2-代码实现"><a href="#1-5-2-代码实现" class="headerlink" title="1.5.2 代码实现"></a>1.5.2 代码实现</h4><ul><li>主从Reactor多线程模型，将使用两个selector，一个主selector专门维护accept事件，当接收到accept事件，将该连接交给从selector，从selector维护该连接的read和write事件。</li><li>主从selector的方式，将连接和数据处理完全分开维护，将大大提高并发量。</li><li>[参考博客][<a href="https://www.cnblogs.com/eason-ou/p/11912010.html]" target="_blank" rel="noopener">https://www.cnblogs.com/eason-ou/p/11912010.html]</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主从Reactor多线程模型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAndSubReactorMultiThreadMode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化一个线程池，然后创建一个主Reactor，并加入一个从Reactor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ThreadPool.getPool().init(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">new</span> MainReactor(<span class="number">8089</span>).addSub(<span class="keyword">new</span> SubReactor()).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>主Reactor</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主Reactor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainReactor</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 维护一个从Reactor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> SubReactor subReactor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel servChannel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainReactor</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            servChannel = ServerSocketChannel.open();</span><br><span class="line">            servChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            servChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(port), <span class="number">1024</span>);</span><br><span class="line">            SelectionKey sk = servChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            stop=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.port=port;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加子Reactor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subReactor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MainReactor <span class="title">addSub</span><span class="params">(SubReactor subReactor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subReactor=subReactor;</span><br><span class="line">        <span class="keyword">this</span>.subReactor.run();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"主reactor开始启动了,监听端口："</span>+port+<span class="string">"......."</span>);</span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                selector.select(<span class="number">1000</span>);</span><br><span class="line">                Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; it = selectedKeys.iterator();</span><br><span class="line">                SelectionKey key = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                    key = it.next();</span><br><span class="line">                    it.remove();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        disptach(key);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            key.cancel();</span><br><span class="line">                            <span class="keyword">if</span> (key.channel() != <span class="keyword">null</span>)</span><br><span class="line">                                key.channel().close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                t.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">disptach</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(key.isValid())&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 主Reactor只关心Accept事件</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                <span class="keyword">new</span> MultiAcceptor(key).addSub(<span class="keyword">this</span>.subReactor).run();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果未使用了从Reactor</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.subReactor==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                <span class="keyword">new</span> MultiReadHandler(key).run();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(key.isWritable())&#123;</span><br><span class="line">                <span class="keyword">new</span> MultiWriteHandler(key).run();</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>从Reactor</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从Reactor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubReactor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubReactor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selector = SelectorProvider.provider().openSelector();</span><br><span class="line">            stop=<span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将主Reactor中的Channel注册到从Reactor中的selector</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sc</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(SocketChannel sc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sc.register(selector,SelectionKey.OP_READ|SelectionKey.OP_WRITE);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPool.getPool().submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"从reactor开始启动了。。。。。"</span>);</span><br><span class="line">                <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        selector.select(<span class="number">1000</span>);</span><br><span class="line">                        Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">                        Iterator&lt;SelectionKey&gt; it = selectedKeys.iterator();</span><br><span class="line">                        SelectionKey key = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                            key = it.next();</span><br><span class="line">                            it.remove();</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                disptach(key);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    key.cancel();</span><br><span class="line">                                    <span class="keyword">if</span> (key.channel() != <span class="keyword">null</span>)</span><br><span class="line">                                        key.channel().close();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        t.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">disptach</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 从Reactor只关心读和写事件</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(key.isValid())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                <span class="keyword">new</span> MultiReadHandler(key).run();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(key.isWritable())&#123;</span><br><span class="line">                <span class="keyword">new</span> MultiWriteHandler(key).run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>acceptor</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiAcceptor</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SubReactor subReactor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SelectionKey selectionKey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiAcceptor</span><span class="params">(SelectionKey selectionKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.selectionKey = selectionKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MultiAcceptor <span class="title">addSub</span><span class="params">(SubReactor subReactor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subReactor=subReactor;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocketChannel ssc = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">            SocketChannel sc = ssc.accept();</span><br><span class="line">            sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span>(subReactor==<span class="keyword">null</span>)&#123;</span><br><span class="line">                Selector selector = selectionKey.selector();</span><br><span class="line">                SelectionKey sk = sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"accept"</span>);</span><br><span class="line">                subReactor.register(sc);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>ReadHandler</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiReadHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SelectionKey selectionKey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiReadHandler</span><span class="params">(SelectionKey selectionKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.selectionKey = selectionKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> SocketChannel sc = (SocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="comment">//使用线程池，异步处理读请求</span></span><br><span class="line">            ThreadPool.getPool().submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    doRead(sc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理完读请求，将通道注册为写</span></span><br><span class="line">            Selector selector = selectionKey.selector();</span><br><span class="line">            SelectionKey sk = sc.register(selector, SelectionKey.OP_WRITE);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRead</span><span class="params">(SocketChannel ssc)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"读取数据，然后做一些数据处理"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>WriteHandler</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiWriteHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SelectionKey selectionKey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiWriteHandler</span><span class="params">(SelectionKey selectionKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.selectionKey = selectionKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(SocketChannel sc)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"处理写。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> SocketChannel sc = (SocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="comment">//使用线程池，异步处理写请求</span></span><br><span class="line">            ThreadPool.getPool().submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    doWrite(sc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//写完后，将通道注册为读</span></span><br><span class="line">            Selector selector = selectionKey.selector();</span><br><span class="line">            SelectionKey sk = sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>线程池</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 示例-线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadPool pool = <span class="keyword">new</span> ThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> init=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadPool</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!init)&#123;</span><br><span class="line">            executorService=Executors.newFixedThreadPool(size);</span><br><span class="line">            init=<span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"the thread pool had inited"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadPool <span class="title">getPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> pool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">submit</span><span class="params">(Runnable runnable)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(init)&#123;</span><br><span class="line">            executorService.submit(runnable);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"the thread pool is not inited"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Netty-线程模型"><a href="#2-Netty-线程模型" class="headerlink" title="2. Netty 线程模型"></a>2. Netty 线程模型</h2><h3 id="2-1-主从Reactor进阶"><a href="#2-1-主从Reactor进阶" class="headerlink" title="2.1 主从Reactor进阶"></a>2.1 主从Reactor进阶</h3><ul><li><code>Netty</code>主要是基于主从<code>Reactor</code>多线程模式做了一定的改进，其中主从<code>Reactor</code>都有单一的一个变成了多个。下面是简单的改进图。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/095946610.png" alt="mark"></p><ul><li>如图所示，增加了<code>BossGroup</code>来维护多个主<code>Reactor</code>，主<code>Reactor</code>还是只关注连接的<code>Accept</code>；增加了<code>WorkGroup</code>来维护多个从<code>Reactor</code>，从<code>Reactor</code>将接收到的请求交给<code>Handler</code>进行处理。</li><li>在主<code>Reactor</code>中接收到<code>Accept</code>事件，获取到对应的<code>SocketChannel</code>，<code>Netty</code>会将它进一步封装成<code>NIOSocketChannel</code>对象，这个封装后的对象还包含了该<code>Channel</code>对应的<code>SelectionKey</code>、通信地址等详细信息</li><li><code>Netty</code>会将装个封装后的<code>Channel</code>对象注册到<code>WorkerGroup</code>中的从<code>Reactor</code>中。</li><li>当<code>WorkerGroup</code>中的从<code>Reactor</code>监听到事件后，就会将之交给与此<code>Reactor</code>对应的<code>Handler</code>进行处理。</li></ul><p><strong>稍微详细图如下</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/100035114.png" alt="mark"></p><ul><li><p><code>Netty</code>将<code>Selector</code>以及<code>Selector</code>相关的事件及任务封装了<code>NioEventLoop</code>，这样<code>BossGroup</code>就可以通过管理<code>NioEventLoop</code>去管理各个<code>Selector</code>。</p></li><li><p>同时，<code>Netty</code>模型中主要存在两个大的线程池组<code>BossGroup</code>和<code>WorkerGroup</code>，用于管理主<code>Reactor</code>线程和从<code>Reactor</code>线程。</p></li></ul><h3 id="2-2-Netty-模型"><a href="#2-2-Netty-模型" class="headerlink" title="2.2 Netty 模型"></a>2.2 Netty 模型</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/122455038.png" alt="mark"></p><p><strong>图中详细解释</strong></p><ul><li><p><code>Netty</code>抽象出两组线程池，</p><ul><li><code>BossGroup</code>专门负责接收客户端的连接，</li><li><code>WorkerGroup</code>专门负责网络的读写</li></ul></li><li><p><code>BossGroup</code>和<code>WorkerGroup</code>类型的本质都是<code>NioEventLoopGroup</code>类型。</p></li><li><p><code>NioEventLoopGroup</code>相当于一个线程管理器（类似于<code>ExecutorServevice</code>），它下面维护很多个<code>NioEventLoop</code>线程。</p><ul><li>在初始化这两个线程组的时候，默认会在每个<code>Group</code>中生成<code>CPU*2</code>个<code>NioEventLoop</code>线程</li><li>当<code>n</code>个连接来了，<code>Group</code>默认会按照连接请求的顺序分别将这些连接分给各个<code>NioEventLoop</code>去处理。</li><li>同时<code>Group</code>还负责管理<code>EventLoop</code>的生命周期。</li></ul></li><li><p><code>NioEventLoop</code>表示一个不断循环的执行处理任务的线程</p><ul><li><strong>它维护了一个线程和任务队列</strong></li><li>每个<code>NioEventLoop</code>都包含一个<code>Selector</code>，用于监听绑定在它上面的<code>socket</code>通讯。</li><li>每个<code>NioEventLoop</code>相当于<code>Selector</code>，负责处理多个<code>Channel</code>上的事件</li><li>每增加一个请求连接，<code>NioEventLoopGroup</code>就将这个请求依次分发给它下面的</li><li><code>NioEventLoop</code>处理。</li></ul></li><li><p><strong>每个<code>Boss NioEventLoop</code>循环执行的步骤有3步：</strong></p><ul><li>轮询<code>accept</code>事件</li><li>处理<code>accept</code>事件，与<code>client</code>建立连接，生成<code>NioSocketChannel</code>，并将其注册到某个<code>Worker NioEventLoop</code>的<code>selector</code>上。</li><li>处理任务队列到任务，即<code>runAllTasks</code></li></ul></li><li><p><strong>每个<code>Worker NioEventLoop</code>循环执行的步骤：</strong></p><ul><li>轮询<code>read</code>，<code>write</code>事件</li><li>处理<code>I/O</code>事件，即<code>read</code>，<code>write</code>事件，在对应的<code>NioSocketChannel</code>中进行处理</li><li>处理任务队列的任务，即<code>runAllTasks</code></li></ul></li><li><p><strong>每个 <code>Worker NioEventLoop</code>处理业务时，会使用<code>pipeline</code>（管道）</strong></p><ul><li><code>pipeline</code>中维护了一个<code>ChannelHandlerContext</code>链表</li><li><code>ChannelHandlerContext</code>则保存了<code>Channel</code>相关的所有上下文信息，同时关联一个<code>ChannelHandler</code>对象。</li><li>如图所示，<code>Channel</code>和<code>pipeline</code>一一对应，<code>ChannelHandler</code>和<code>ChannelHandlerContext</code>一一对应。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/123220946.png" alt="mark"></p><h3 id="2-3-ChannelHandler"><a href="#2-3-ChannelHandler" class="headerlink" title="2.3 ChannelHandler"></a>2.3 ChannelHandler</h3><ul><li><code>ChannelHandler</code>是一个接口，负责处理或拦截<code>I/O</code>操作，并将其转发到<code>Pipeline</code>中的下一个处理<code>Handler</code>进行处理。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">                                               I&#x2F;O Request</span><br><span class="line">                                          via Channel or</span><br><span class="line">                                      ChannelHandlerContext</span><br><span class="line">                                                    |</span><br><span class="line">+---------------------------------------------------+---------------+</span><br><span class="line">|                           ChannelPipeline         |               |</span><br><span class="line">|                                                  \|&#x2F;              |</span><br><span class="line">|    +---------------------+            +-----------+----------+    |</span><br><span class="line">|    | Inbound Handler  N  |            | Outbound Handler  1  |    |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|              &#x2F;|\                                  |               |</span><br><span class="line">|               |                                  \|&#x2F;              |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|    | Inbound Handler N-1 |            | Outbound Handler  2  |    |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|              &#x2F;|\                                  .               |</span><br><span class="line">|               .                                   .               |</span><br><span class="line">| ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|</span><br><span class="line">|        [ method call]                       [method call]         |</span><br><span class="line">|               .                                   .               |</span><br><span class="line">|               .                                  \|&#x2F;              |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|    | Inbound Handler  2  |            | Outbound Handler M-1 |    |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|              &#x2F;|\                                  |               |</span><br><span class="line">|               |                                  \|&#x2F;              |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|    | Inbound Handler  1  |            | Outbound Handler  M  |    |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|              &#x2F;|\                                  |               |</span><br><span class="line">+---------------+-----------------------------------+---------------+</span><br><span class="line">                |                                  \|&#x2F;</span><br><span class="line">+---------------+-----------------------------------+---------------+</span><br><span class="line">|               |                                   |               |</span><br><span class="line">|       [ Socket.read() ]                    [ Socket.write() ]     |</span><br><span class="line">|                                                                   |</span><br><span class="line">|  Netty Internal I&#x2F;O Threads (Transport Implementation)            |</span><br><span class="line">+-------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><h2 id="3-Netty-入门代码实例"><a href="#3-Netty-入门代码实例" class="headerlink" title="3. Netty 入门代码实例"></a>3. Netty 入门代码实例</h2><ol><li><strong>服务器端</strong></li></ol><ul><li><strong>服务端启动器代码</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> NettyPro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//创建BossGroup 和 WorkerGroup</span></span><br><span class="line">        <span class="comment">//1、创建两个线程组，bossGroup 和 workerGroup</span></span><br><span class="line">        <span class="comment">//2、bossGroup 只是处理连接请求，真正的和客户端业务处理，会交给 workerGroup 完成</span></span><br><span class="line">        <span class="comment">//3、两个都是无限循环</span></span><br><span class="line">        <span class="comment">//4、bossGroup 和 workerGroup 含有的子线程（NioEventLoop）个数为实际 cpu 核数 * 2</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup worderGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务器端的启动对象，配置参数</span></span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用链式编程来进行设置，配置</span></span><br><span class="line">            bootstrap.group(bossGroup, worderGroup) <span class="comment">//设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>) //使用 <span class="title">NioServerSocketChannel</span> 作为服务器的通道实现</span></span><br><span class="line"><span class="class">                    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 128) //设置线程队列得到连接个数</span></span><br><span class="line"><span class="class">                    .<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>, <span class="title">true</span>) //设置保持活动连接状态</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123; <span class="comment">//为accept channel的pipeline预添加的handler</span></span><br><span class="line">                        <span class="comment">//给 pipeline 添加处理器，每当有连接accept时，就会运行到此处。</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;); <span class="comment">//给我们的 workerGroup 的 EventLoop 对应的管道设置处理器</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"........服务器 is ready......"</span>);</span><br><span class="line">            <span class="comment">//绑定一个端口并且同步，生成了一个ChannelFuture 对象</span></span><br><span class="line">            <span class="comment">//启动服务器（并绑定端口）</span></span><br><span class="line">            ChannelFuture future = bootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            worderGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>服务器端处理器代码</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> NettyPro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *读取客户端发送过来的消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文对象，含有 管道pipeline，通道channel，地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 就是客户端发送的数据，默认Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器读取线程："</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">"server ctx = "</span> + ctx);</span><br><span class="line">        <span class="comment">// 看看Channel 和 PipelLine的瓜西</span></span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        ChannelPipeline pipeline = ctx.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将msg 转换成一个ByteBuf ，比较NIO的ByteBuffer 性能的提高</span></span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">"客户端发来的消息是 + "</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">"客户端的地址是 + "</span> + ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据读取完毕</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 它是 write + flush ，将数据写入到缓存buffer，并将buffer中的数据flush进入通道</span></span><br><span class="line">        <span class="comment">// 一般来讲，我们对这个发送的数据进行编码</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"hello 客户端！"</span>,CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理异常，一般是关闭通道</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>客户端</strong></li></ol><ul><li><strong>客户端的启动器代码</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> NettyPro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 客户端需要一个事件循环组</span></span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建启动器</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建客户端启动对象</span></span><br><span class="line">            <span class="comment">// 注意： 客户端使用的不是ServerBootStrap 而是 Bootstrap</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置相关参数</span></span><br><span class="line">            bootstrap.group(group) <span class="comment">// 设置线程组</span></span><br><span class="line">                    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>) // 设置客户端通道的是实现类(使用反射实现)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyClientHandler()); <span class="comment">// 加入自己的处理器</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"----- 客户端 is Ready----"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动客户端去连接服务器端</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">"127.0.0.1"</span>, <span class="number">6668</span>).sync();</span><br><span class="line">            <span class="comment">// 给监听的通道关闭</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>客户端的处理器代码</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> NettyPro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道就绪就会触发</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"client is + "</span> + ctx);</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"hello Server ~！ "</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道有读取的事件的时候，就会触发</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">"服务器回复的消息是："</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">"服务器的地址是 + "</span> + ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发生异常的关闭处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考博客</strong> ： <a href="https://www.cnblogs.com/eason-ou/p/11912010.html" target="_blank" rel="noopener">https://www.cnblogs.com/eason-ou/p/11912010.html</a></p><p>​                    <a href="https://blog.csdn.net/Danny_idea/article/details/89286195" target="_blank" rel="noopener">https://blog.csdn.net/Danny_idea/article/details/89286195</a>    </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-04-线程模型&quot;&gt;&lt;a href=&quot;#Netty-04-线程模型&quot; class=&quot;headerlink&quot; title=&quot;Netty-04-线程模型&quot;&gt;&lt;/a&gt;Netty-04-线程模型&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h3 id=&quot;原生NIO存在的问题&quot;&gt;&lt;a href=&quot;#原生NIO存在的问题&quot; class=&quot;headerlink&quot; title=&quot;原生NIO存在的问题&quot;&gt;&lt;/a&gt;原生NIO存在的问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;NIO 的类库和 API 繁杂，使用麻烦：需要熟练掌握 &lt;code&gt;Selector&lt;/code&gt;、&lt;code&gt;ServerSocketChannel&lt;/code&gt;、&lt;code&gt;SocketChannel&lt;/code&gt;、&lt;code&gt;ByteBuffer&lt;/code&gt; 等。&lt;/li&gt;
&lt;li&gt;需要具备其他的额外技能：要熟悉 &lt;code&gt;Java&lt;/code&gt; 多线程编程，因为 &lt;code&gt;NIO&lt;/code&gt; 编程涉及到 &lt;code&gt;Reactor&lt;/code&gt; 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 NIO 程序。&lt;/li&gt;
&lt;li&gt;开发工作量和难度都非常大：例如客户端面临&lt;strong&gt;断连重连&lt;/strong&gt;、&lt;strong&gt;网络闪断&lt;/strong&gt;、&lt;strong&gt;半包读写&lt;/strong&gt;、&lt;strong&gt;失败缓存&lt;/strong&gt;、&lt;strong&gt;网络拥塞和异常流的处理&lt;/strong&gt;等等。&lt;/li&gt;
&lt;li&gt;JDK NIO 的 Bug : 例如臭名昭著的 &lt;code&gt;Epoll Bug&lt;/code&gt;，它会导致 &lt;code&gt;Selector&lt;/code&gt; 空轮询，最终导致 &lt;code&gt;CPU&lt;/code&gt; 100%。直到 JDK 1.7 版本该问题仍旧存在，没有被根本解决。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Netty优点&quot;&gt;&lt;a href=&quot;#Netty优点&quot; class=&quot;headerlink&quot; title=&quot;Netty优点&quot;&gt;&lt;/a&gt;Netty优点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Netty&lt;/code&gt;对&lt;code&gt;JDK&lt;/code&gt;自带的&lt;code&gt;NIO&lt;/code&gt;的&lt;code&gt;API&lt;/code&gt;进行了封装，解决了上述问题。&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;设计优雅：适用于各种传输类型的统一 &lt;code&gt;API&lt;/code&gt; 阻塞和非阻塞 &lt;code&gt;Socket&lt;/code&gt;；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型 - 单线程，一个或多个线程池.&lt;/li&gt;
&lt;li&gt;安全：完整的 &lt;code&gt;SSL/TLS&lt;/code&gt; 和 &lt;code&gt;StartTLS&lt;/code&gt; 支持&lt;/li&gt;
&lt;li&gt;高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="NIO" scheme="http://zhuuu.work/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-16-内存扩充</title>
    <link href="http://zhuuu.work/2020/10/19/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-16-%E5%86%85%E5%AD%98%E6%89%A9%E5%85%85/"/>
    <id>http://zhuuu.work/2020/10/19/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-16-%E5%86%85%E5%AD%98%E6%89%A9%E5%85%85/</id>
    <published>2020-10-19T03:00:53.000Z</published>
    <updated>2020-10-23T01:20:10.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-16-内存扩充"><a href="#操作系统-16-内存扩充" class="headerlink" title="操作系统-16-内存扩充"></a>操作系统-16-内存扩充</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/113853923.png" alt="mark"></p><a id="more"></a><h2 id="1-覆盖技术"><a href="#1-覆盖技术" class="headerlink" title="1. 覆盖技术"></a>1. 覆盖技术</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/113907728.png" alt="mark"></p><ol><li><strong>概念</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/113936749.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/114009295.png" alt="mark"></p><h2 id="2-交换技术"><a href="#2-交换技术" class="headerlink" title="2. 交换技术"></a>2. 交换技术</h2><ol><li><strong>概念</strong></li></ol><ul><li>内存紧张时，把进程暂时换出到外存 </li><li>见：进程的<strong>中级调度(内存调度)</strong>，挂起态，七状态模型 磁盘分为对换区(swap)和文件区，前者连续分配追求<code>I/O</code>速度，后者离散分配追求存储空间利用率 </li><li>优先换出阻塞进程、低优先级进程（可能导致饥饿）、还要考虑进程在内存的驻留时间，</li><li><code>PCB</code>不会换出</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/114115334.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/115956949.png" alt="mark"></p><h2 id="3-虚拟内存"><a href="#3-虚拟内存" class="headerlink" title="3. 虚拟内存"></a>3. 虚拟内存</h2><ul><li><p><strong>传统存储方式的缺点</strong></p><p><strong>连续分配/非连续分配</strong></p><ul><li><p><strong>一次性</strong><br>作业必须一次性全部装入内存后才能开始运行。大作业无法运行,多道程序并发度下降。</p></li><li><p><strong>驻留性</strong><br>作业在运行期间一直驻留在内存，内存中驻留大量的暂时用不到的数据，浪费了宝贵的内存资源。</p></li></ul></li></ul><ul><li><strong>局部性原理</strong><ul><li>时间局部性<br>现在访问的指令、数据在不久后很可能再次访问</li><li>空间局部性<br>现在访问的内存单元周围的内存空间很可能在不久之后访问</li><li>高速缓存<br>频繁访问的数据放到更高速的储存器中</li></ul></li></ul><ul><li><p><strong>虚拟内存的定义和特征</strong></p><p>程序不需要全部装入内存即可运行，运行时根据需要动态调入数据，内存不够时，换出一些数据到外存</p><ul><li><p><strong>多次性</strong><br>作业无需在运行时一次装入内存，而是允许分多次调用</p></li><li><p><strong>对换性</strong><br>作业无需在运行时常驻内存，允许作业换入、换出</p></li><li><p><strong>虚拟性</strong><br>从逻辑上扩充了内存容量，用户看到的容量，远大于实际容量</p></li></ul></li></ul><h3 id="3-1-请求分页"><a href="#3-1-请求分页" class="headerlink" title="3.1 请求分页"></a>3.1 请求分页</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201023/085952774.png" alt="mark"></p><ul><li><strong>请求分页</strong><br>访问的信息不存在时，操作系统负责将需要的信息从外存调入内存</li></ul><ul><li><strong>页表机制</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/170504815.png" alt="mark"></p><p><strong>页面置换概念</strong></p><ul><li>内存空间不足时，将内存中暂时不用的信息换到外存 页面的换入换出需要磁盘I/O，时间开销是很大的，<strong>缺页率越小越好</strong></li></ul><ul><li><strong>缺页中断</strong><ul><li>访问的页面不存在时，产生缺页中断(属于<strong>内中断的故障</strong> fault)，</li><li>操作系统缺页中断处理程序中断，进程<strong>放到阻塞队列</strong>，待调页完成后将进程唤醒，放到就绪队列 </li><li>如果<strong>内存有空闲块</strong>，则为进程分配一个空闲块，将缺页装入其中，并修改页表相应页表项 </li><li>如果<strong>内存没有空闲块，由页面置换算法</strong>选择一个页面淘汰(若该页面在内存期间被修改过，则需要先将其写回外存)，腾出一个空间再装入缺页 一条指令执行期间，可能产生多次缺页中断</li></ul></li></ul><p><strong>地址变换机构</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/170623996.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201023/090606347.png" alt="mark"></p><p><strong>页面置换算法（具体内容请看下一篇博客）</strong></p><ul><li><strong>最佳置换算法(OPT)</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/170419565.png" alt="mark"></p><ul><li><strong>先进先出置换算法(FIFO)</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/170426988.png" alt="mark"></p><ul><li><strong>最近最久未使用算法(LRU)</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/170331530.png" alt="mark"></p><ul><li><strong>时钟置换算法(CLOCK)</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/170432349.png" alt="mark"></p><ul><li><strong>改进型时钟置换算法</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/170438711.png" alt="mark"></p><ul><li><strong>小结：</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/170312379.png" alt="mark"></p><p><strong>页面分配策略</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201023/091112009.png" alt="mark"></p><ol><li><strong>驻留集</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201023/091352567.png" alt="mark"></p><ul><li>固定分配局部置换</li><li>可变分配局部置换</li><li>可变分配全局置换</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201023/091451976.png" alt="mark"></p><ol start="2"><li><strong>何时调入页面</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201023/091518574.png" alt="mark"></p><ol start="3"><li><strong>何处调入页面</strong></li></ol><ul><li>系统拥有足够的兑换区空间</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201023/091646646.png" alt="mark"></p><ul><li>系统缺少足够的兑换区空间</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201023/091655387.png" alt="mark"></p><ul><li>UNIX方式</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201023/091825055.png" alt="mark"></p><ol start="4"><li><strong>抖动现象</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201023/091858809.png" alt="mark"></p><ol start="5"><li><strong>工作集</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201023/091925610.png" alt="mark"></p><p><strong>页面分配策略小结</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201023/091255298.png" alt="mark"></p><h3 id="3-2-请求分段"><a href="#3-2-请求分段" class="headerlink" title="3.2 请求分段"></a>3.2 请求分段</h3><ul><li>书上无具体详解</li></ul><h3 id="3-3-请求段页式"><a href="#3-3-请求段页式" class="headerlink" title="3.3 请求段页式"></a>3.3 请求段页式</h3><ul><li>书上无具体说明</li></ul><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-16-内存扩充&quot;&gt;&lt;a href=&quot;#操作系统-16-内存扩充&quot; class=&quot;headerlink&quot; title=&quot;操作系统-16-内存扩充&quot;&gt;&lt;/a&gt;操作系统-16-内存扩充&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/113853923.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="内存管理" scheme="http://zhuuu.work/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-15-内存的分配和回收</title>
    <link href="http://zhuuu.work/2020/10/19/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-15-%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6/"/>
    <id>http://zhuuu.work/2020/10/19/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-15-%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6/</id>
    <published>2020-10-19T03:00:53.000Z</published>
    <updated>2020-10-21T03:16:54.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-15-内存的分配和回收"><a href="#操作系统-15-内存的分配和回收" class="headerlink" title="操作系统-15-内存的分配和回收"></a>操作系统-15-内存的分配和回收</h1><h2 id="1-连续分配管理方式"><a href="#1-连续分配管理方式" class="headerlink" title="1. 连续分配管理方式"></a>1. 连续分配管理方式</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/111935038.png" alt="mark"></p><a id="more"></a><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/111947265.png" alt="mark"></p><h3 id="1-1-单一连续分配"><a href="#1-1-单一连续分配" class="headerlink" title="1.1 单一连续分配"></a>1.1 单一连续分配</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/112300340.png" alt="mark"></p><h3 id="1-2-固定分区分配"><a href="#1-2-固定分区分配" class="headerlink" title="1.2 固定分区分配"></a>1.2 固定分区分配</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/112340583.png" alt="mark"></p><p><strong>数据结构</strong></p><ol><li><strong>分区说明表</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/112436485.png" alt="mark"></p><h3 id="1-3-动态分区分配"><a href="#1-3-动态分区分配" class="headerlink" title="1.3 动态分区分配"></a>1.3 动态分区分配</h3><ol><li><strong>概念</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/112628598.png" alt="mark"></p><ol start="2"><li><strong>动态分区遇到的问题</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/112739289.png" alt="mark"></p><p><strong>（1）系统要用怎样的数据结构记录内存的使用情况呢？</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/112823281.png" alt="mark"></p><p><strong>（2）当多个空闲分区都能满足要求时，应该选择哪个分区进行分配？</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/112900513.png" alt="mark"></p><h4 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/112930125.png" alt="mark"></p><p><strong>1.首次适应算法</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/112948127.png" alt="mark"></p><p><strong>2.最佳适应算法</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/113116950.png" alt="mark"></p><p><strong>3.最坏（大）适应算法</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/113107332.png" alt="mark"></p><p><strong>4.邻近适应算法</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/113156318.png" alt="mark"></p><p><strong>小结：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/113226216.png" alt="mark"></p><h4 id="内部碎片和外部碎片"><a href="#内部碎片和外部碎片" class="headerlink" title="内部碎片和外部碎片"></a>内部碎片和外部碎片</h4><ol><li><strong>概念</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/113333983.png" alt="mark"></p><ol start="2"><li><strong>解决方式 ： 紧凑技术</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/113359367.png" alt="mark"></p><h2 id="2-非连续分配管理方式"><a href="#2-非连续分配管理方式" class="headerlink" title="2. 非连续分配管理方式"></a>2. 非连续分配管理方式</h2><h3 id="2-1-基本分页存储管理"><a href="#2-1-基本分页存储管理" class="headerlink" title="2.1 基本分页存储管理"></a>2.1 基本分页存储管理</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201020/094401416.png" alt="mark"></p><ol><li><strong>概念</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201020/094436003.png" alt="mark"></p><ol start="2"><li><strong>地址结构</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201020/094758265.png" alt="mark"></p><ul><li><strong>为什么页面大小一般设为2的整数次幂？</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201020/094747360.png" alt="mark"></p><ol start="3"><li><strong>基本地址转换</strong></li></ol><p><strong>两个基本要素</strong></p><ul><li><strong>页面的起始地址</strong></li><li><strong>页面的偏移量</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201020/095459685.png" alt="mark"></p><ul><li>首先需要建立一张<strong>页表</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201020/095610966.png" alt="mark"></p><ul><li><strong>计算页表项的起始地址</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201020/095927512.png" alt="mark"></p><p><strong>基本地址转换流程小结</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201020/100102276.png" alt="mark"></p><p><strong>文字描述</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201020/100131838.png" alt="mark"></p><p><strong>基本地址转换例题分析</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201020/100218167.png" alt="mark"></p><p><strong>页表项的注意事项</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201020/100515245.png" alt="mark"></p><ol start="4"><li><strong>具有快表的地址变化机构</strong></li></ol><ul><li>局部性原理<ul><li><strong>时间局部性:</strong> 如果执行了程序中的某条指令,那么不久后这条指令很有可能再次执行;如果某个数据被访问过,不久之后该数据很可能再次被访问。(因为程序中存在大量的循环) </li><li><strong>空间局部性</strong>: 一旦程序访问了某个存储单元,在不久之后,其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的）</li></ul></li></ul><ul><li><strong>快表的概念</strong><ul><li>又称联想寄存器<strong>(TLB</strong>) ,是一种访问速度比内存快很多的<strong>高速缓冲存储器</strong>,用来存放当前访问的若干页表项,以加速地址变换的过程。与此对应,<strong>内存中的页表常称为慢表</strong>。</li></ul></li></ul><ul><li><strong>地址变化的过程</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201020/100837299.png" alt="mark"></p><ol start="5"><li><strong>两级页表</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/103445218.png" alt="mark"></p><ul><li>单级页表存在的问题<ul><li>页表需要很大的空间</li><li>局部性原理</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/104258447.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/104434834.png" alt="mark"></p><ul><li><strong>二级页表的地址结构</strong><ul><li>对页表再次进行分组</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/104612245.png" alt="mark"></p><ul><li><strong>二级页表的地址结构及对应关系</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/104813276.png" alt="mark"></p><ul><li><strong>二级页表的地址转换</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/105119924.png" alt="mark"></p><p><strong>上面的部分我们解决了问题一，接下来是问题二，这里简单叙述一下，后面的文章会继续深入剖析。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/105220284.png" alt="mark"></p><p><strong>注意事项</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/105235918.png" alt="mark"></p><h3 id="2-2-基本分段存储管理"><a href="#2-2-基本分段存储管理" class="headerlink" title="2.2 基本分段存储管理"></a>2.2 基本分段存储管理</h3><ol><li><strong>概念</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/105357143.png" alt="mark"></p><ul><li><strong>分页管理方式</strong> ： 从计算机角度出发考虑设计的，目的是提高内存的利用率，提供计算机的性能。</li><li><strong>分段管理方式：</strong> 从用户和程序员角度出发，以满足方便编程，信息共享和保护，动态增长和动态链接的需要</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/105649509.png" alt="mark"></p><ol start="2"><li><strong>分段的逻辑地址结构</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/105717517.png" alt="mark"></p><ul><li><strong>段号的位数</strong> ： 决定了每个进程最多可以分成几个段</li><li><strong>段内地址</strong> ： 决定了每个段的最大长度可以是多少</li></ul><ol start="3"><li><strong>段表</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/105919071.png" alt="mark"></p><ol start="4"><li><strong>分段的地址变换</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/110028224.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/110032527.png" alt="mark"></p><ul><li><strong>分段和分页的对比</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/110548592.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/110614987.png" alt="mark"></p><ul><li><strong>分段实现信息的共享</strong><ul><li>不能被修改的代码是可以数据共享的</li><li>可修改的代码是不能数据共享的</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/110651736.png" alt="mark"></p><ul><li><strong>分页不能实现数据共享的理由</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/110839480.png" alt="mark"></p><h3 id="2-3-段页式存储管理"><a href="#2-3-段页式存储管理" class="headerlink" title="2.3 段页式存储管理"></a>2.3 段页式存储管理</h3><ol><li><strong>概念</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/110918201.png" alt="mark"></p><ul><li><strong>分段和分页的优缺点分析</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/110955811.png" alt="mark"></p><ol start="2"><li><strong>分段 + 分页 = 段页式管理</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/111053497.png" alt="mark"></p><ol start="3"><li><strong>段页式管理的逻辑地址结构</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/111131508.png" alt="mark"></p><ol start="4"><li><strong>段页式存储的段表，页表</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/111415851.png" alt="mark"></p><ul><li><strong>每个段对应一个段表项</strong><ul><li>段号</li><li>页表长度</li><li>页面存放的块号</li></ul></li><li><strong>每个页对应一个页表项</strong><ul><li>页号</li><li>页面存放的内存块号</li></ul></li></ul><ol start="5"><li><strong>段页式管理的地址转换过程</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201021/111616858.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p><p>​                    <a href="https://blog.csdn.net/weixin_43914604/article/details/104415990" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43914604/article/details/104415990</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-15-内存的分配和回收&quot;&gt;&lt;a href=&quot;#操作系统-15-内存的分配和回收&quot; class=&quot;headerlink&quot; title=&quot;操作系统-15-内存的分配和回收&quot;&gt;&lt;/a&gt;操作系统-15-内存的分配和回收&lt;/h1&gt;&lt;h2 id=&quot;1-连续分配管理方式&quot;&gt;&lt;a href=&quot;#1-连续分配管理方式&quot; class=&quot;headerlink&quot; title=&quot;1. 连续分配管理方式&quot;&gt;&lt;/a&gt;1. 连续分配管理方式&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/111935038.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="内存管理" scheme="http://zhuuu.work/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-844-比较含退格的字符串</title>
    <link href="http://zhuuu.work/2020/10/19/Leetcode/Leetcode-844-%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://zhuuu.work/2020/10/19/Leetcode/Leetcode-844-%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-10-19T01:52:53.000Z</published>
    <updated>2020-10-19T01:23:29.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-844-比较含退格的字符串"><a href="#Leetcode-844-比较含退格的字符串" class="headerlink" title="Leetcode-844-比较含退格的字符串"></a>Leetcode-844-<a href="https://leetcode-cn.com/problems/backspace-string-compare/" target="_blank" rel="noopener">比较含退格的字符串</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。</p><p><strong>注意：</strong>如果对空文本输入退格字符，文本继续为空。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：S &#x3D; &quot;ab#c&quot;, T &#x3D; &quot;ad#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “ac”。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：S &#x3D; &quot;ab##&quot;, T &#x3D; &quot;c#d#&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “”。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：S &#x3D; &quot;a##c&quot;, T &#x3D; &quot;#a#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “c”。</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：S &#x3D; &quot;a#c&quot;, T &#x3D; &quot;b&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：S 会变成 “c”，但 T 仍然是 “b”。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法-：-双指针"><a href="#方法-：-双指针" class="headerlink" title="方法 ： 双指针"></a>方法 ： 双指针</h2><p>一个字符是否会被删掉，只取决于该字符后面的退格符，而与该字符前面的退格符无关。<strong>因此当我们逆序地遍历字符串，就可以立即确定当前字符是否会被删掉。</strong></p><p>具体地，我们定义 skip 表示当前待删除的字符的数量。每次我们遍历到一个字符：</p><ul><li><p>若该字符为<strong>退格符</strong>，则我们需要多删除一个普通字符，我们让 skip 加 1；</p></li><li><p>若该字符为普通字符：</p><ul><li>若 skip 为 0，则说明当前字符不需要删去；</li><li>若 skip 不为 0，则说明当前字符需要删去，我们让 skip 减 1。</li></ul></li></ul><p>这样，我们定义两个指针，分别指向两字符串的末尾。每次我们让两指针逆序地遍历两字符串，直到两字符串能够各自确定一个字符，然后将这两个字符进行比较。重复这一过程直到找到的两个字符不相等，或遍历完字符串为止。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/092038861.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/092057182.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/092127922.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = S.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = T.length() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录退格的变量</span></span><br><span class="line">        <span class="keyword">int</span> skipS = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> skipT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 处理字符串S</span></span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(S.charAt(i) == <span class="string">'#'</span>)&#123; <span class="comment">//若该字符为退格符，则我们需要多删除一个普通字符，让skip 加1；</span></span><br><span class="line">                    skipS++;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(skipS &gt; <span class="number">0</span>)&#123; <span class="comment">// 若该字符为普通字符</span></span><br><span class="line">                    <span class="comment">//若skip不为0，则说明当前字符需要删去，让skip 减 1。同时向后退一格</span></span><br><span class="line">                    skipS--;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//skip 为 0，则说明当前字符不需要删去；</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理字符串T</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(T.charAt(j) == <span class="string">'#'</span>)&#123; <span class="comment">//若该字符为退格符，则我们需要多删除一个普通字符，让skip 加1；</span></span><br><span class="line">                    skipT++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(skipT &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    skipT--;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123; <span class="comment">// 退完格之后两字符串能够各自确定一个字符</span></span><br><span class="line">                <span class="keyword">if</span> (S.charAt(i) != T.charAt(j)) &#123; <span class="comment">// 然后将这两个字符进行比较</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123; <span class="comment">// 遍历完字符串</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进入下一次循环</span></span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-844-比较含退格的字符串&quot;&gt;&lt;a href=&quot;#Leetcode-844-比较含退格的字符串&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-844-比较含退格的字符串&quot;&gt;&lt;/a&gt;Leetcode-844-&lt;a href=&quot;https://leetcode-cn.com/problems/backspace-string-compare/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;比较含退格的字符串&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;如果对空文本输入退格字符，文本继续为空。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：S &amp;#x3D; &amp;quot;ab#c&amp;quot;, T &amp;#x3D; &amp;quot;ad#c&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：S 和 T 都会变成 “ac”。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：S &amp;#x3D; &amp;quot;ab##&amp;quot;, T &amp;#x3D; &amp;quot;c#d#&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：S 和 T 都会变成 “”。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：S &amp;#x3D; &amp;quot;a##c&amp;quot;, T &amp;#x3D; &amp;quot;#a#c&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：S 和 T 都会变成 “c”。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 4：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：S &amp;#x3D; &amp;quot;a#c&amp;quot;, T &amp;#x3D; &amp;quot;b&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：S 会变成 “c”，但 T 仍然是 “b”。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-019-删除链表的倒数第N个节点</title>
    <link href="http://zhuuu.work/2020/10/18/Leetcode/Leetcode-019-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://zhuuu.work/2020/10/18/Leetcode/Leetcode-019-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</id>
    <published>2020-10-18T11:52:53.000Z</published>
    <updated>2020-10-18T01:06:59.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-019-删除链表的倒数第N个节点"><a href="#Leetcode-019-删除链表的倒数第N个节点" class="headerlink" title="Leetcode-019-删除链表的倒数第N个节点"></a>Leetcode-019-<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">删除链表的倒数第N个节点</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>给定的 <em>n</em> 保证是有效的。</p><h2 id="方法：两次遍历"><a href="#方法：两次遍历" class="headerlink" title="方法：两次遍历"></a>方法：两次遍历</h2><ul><li>首先从头节点开始对链表进行一次遍历，得到链表长度L</li><li>随后我们再从头节点开始对链表进行一次遍历，当遍历到链表的第L - n + 1个节点时，他就是我们需要删除的节点</li><li>为了和提题目中的n保持一致，节点的编号从1开始，头节点为编号1的节点。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201018/090557372.png" alt="mark"></p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dummynode: 将next指针指向链表的头节点，这样一来就不需要对头节点进行特殊的判断</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算链表的长度</span></span><br><span class="line">        <span class="keyword">int</span> length = getLength(head);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历链表进行删除</span></span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length - n + <span class="number">1</span>;++i)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur.next = cur.next.next; <span class="comment">// 断开链表</span></span><br><span class="line">        ListNode ans = dummy.next; <span class="comment">// 返回断开后的新头节点</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算链表长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ++length;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O（L） L是链表的长度</li><li>空间复杂度 ： O  (1)    没有使用额外的空间</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-019-删除链表的倒数第N个节点&quot;&gt;&lt;a href=&quot;#Leetcode-019-删除链表的倒数第N个节点&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-019-删除链表的倒数第N个节点&quot;&gt;&lt;/a&gt;Leetcode-019-&lt;a href=&quot;https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;删除链表的倒数第N个节点&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个链表，删除链表的倒数第 &lt;em&gt;n&lt;/em&gt; 个节点，并且返回链表的头结点。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;给定一个链表: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 和 n &amp;#x3D; 2.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;当删除了倒数第二个节点后，链表变为 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定的 &lt;em&gt;n&lt;/em&gt; 保证是有效的。&lt;/p&gt;
&lt;h2 id=&quot;方法：两次遍历&quot;&gt;&lt;a href=&quot;#方法：两次遍历&quot; class=&quot;headerlink&quot; title=&quot;方法：两次遍历&quot;&gt;&lt;/a&gt;方法：两次遍历&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;首先从头节点开始对链表进行一次遍历，得到链表长度L&lt;/li&gt;
&lt;li&gt;随后我们再从头节点开始对链表进行一次遍历，当遍历到链表的第L - n + 1个节点时，他就是我们需要删除的节点&lt;/li&gt;
&lt;li&gt;为了和提题目中的n保持一致，节点的编号从1开始，头节点为编号1的节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201018/090557372.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="链表" scheme="http://zhuuu.work/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-14-内存管理</title>
    <link href="http://zhuuu.work/2020/10/18/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-14-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://zhuuu.work/2020/10/18/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-14-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-10-18T08:00:53.000Z</published>
    <updated>2020-10-18T02:51:26.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-14-内存管理"><a href="#操作系统-14-内存管理" class="headerlink" title="操作系统-14-内存管理"></a>操作系统-14-内存管理</h1><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;操作系统-14-内存管理&quot;&gt;&lt;a href=&quot;#操作系统-14-内存管理&quot; class=&quot;headerlink&quot; title=&quot;操作系统-14-内存管理&quot;&gt;&lt;/a&gt;操作系统-14-内存管理&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;参考书籍：《王道考研计算机操作系统》&lt;/st
      
    
    </summary>
    
    
    
      <category term="内存管理" scheme="http://zhuuu.work/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-13-内存基础</title>
    <link href="http://zhuuu.work/2020/10/17/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-13-%E5%86%85%E5%AD%98%E5%9F%BA%E7%A1%80/"/>
    <id>http://zhuuu.work/2020/10/17/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-13-%E5%86%85%E5%AD%98%E5%9F%BA%E7%A1%80/</id>
    <published>2020-10-17T08:00:53.000Z</published>
    <updated>2020-10-18T02:50:53.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-13-内存基础"><a href="#操作系统-13-内存基础" class="headerlink" title="操作系统-13-内存基础"></a>操作系统-13-内存基础</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/165936625.png" alt="mark"></p><h2 id="1-内存的概念"><a href="#1-内存的概念" class="headerlink" title="1. 内存的概念"></a>1. 内存的概念</h2><h3 id="1-1-存储单元"><a href="#1-1-存储单元" class="headerlink" title="1.1 存储单元"></a>1.1 存储单元</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/170017151.png" alt="mark"></p><h3 id="1-2-几个常用数量单位-amp-内存地址"><a href="#1-2-几个常用数量单位-amp-内存地址" class="headerlink" title="1.2 几个常用数量单位&amp;内存地址"></a>1.2 几个常用数量单位&amp;内存地址</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/170143676.png" alt="mark"></p><h2 id="2-运行的基本原理"><a href="#2-运行的基本原理" class="headerlink" title="2. 运行的基本原理"></a>2. 运行的基本原理</h2><h3 id="2-1-指令的工作原理—操作码-若干参数（可能包含地址参数）"><a href="#2-1-指令的工作原理—操作码-若干参数（可能包含地址参数）" class="headerlink" title="2.1 指令的工作原理—操作码+若干参数（可能包含地址参数）"></a>2.1 指令的工作原理—操作码+若干参数（可能包含地址参数）</h3><ul><li>从X=X+1大致看一下指令的执行过程</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/170421561.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/170443542.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/170525816.png" alt="mark"></p><h3 id="2-2-逻辑地址（相对地址）vs物理地址（绝对地址）"><a href="#2-2-逻辑地址（相对地址）vs物理地址（绝对地址）" class="headerlink" title="2.2 逻辑地址（相对地址）vs物理地址（绝对地址）"></a>2.2 逻辑地址（相对地址）vs物理地址（绝对地址）</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/170554732.png" alt="mark"></p><p><strong>举个例子：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/170606666.png" alt="mark"></p><h3 id="2-3-从写程序到程序运行—编译、链接、装入"><a href="#2-3-从写程序到程序运行—编译、链接、装入" class="headerlink" title="2.3 从写程序到程序运行—编译、链接、装入"></a>2.3 从写程序到程序运行—编译、链接、装入</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/170730524.png" alt="mark"></p><h3 id="2-4-装入概念"><a href="#2-4-装入概念" class="headerlink" title="2.4 装入概念"></a>2.4 装入概念</h3><ol><li><strong>错误示范</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/170825742.png" alt="mark"></p><p><strong>不修改装入模块中的指令地址就直接装入内存的话：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/170847140.png" alt="mark"></p><h2 id="3-装入的三种方式"><a href="#3-装入的三种方式" class="headerlink" title="3. 装入的三种方式"></a>3. 装入的三种方式</h2><h4 id="①绝对装入"><a href="#①绝对装入" class="headerlink" title="①绝对装入"></a>①绝对装入</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/170930278.png" alt="mark"></p><h4 id="②静态重定位"><a href="#②静态重定位" class="headerlink" title="②静态重定位"></a>②静态重定位</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/171028325.png" alt="mark"></p><h4 id="③-动态重定位"><a href="#③-动态重定位" class="headerlink" title="③ 动态重定位"></a>③ 动态重定位</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/171035408.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/171103248.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/171129064.png" alt="mark"></p><h2 id="4-链接的三种方式"><a href="#4-链接的三种方式" class="headerlink" title="4. 链接的三种方式"></a>4. 链接的三种方式</h2><h4 id="①-静态链接"><a href="#①-静态链接" class="headerlink" title="① 静态链接"></a>① 静态链接</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/171203244.png" alt="mark"></p><h4 id="②-装入时动态链接"><a href="#②-装入时动态链接" class="headerlink" title="② 装入时动态链接"></a>② 装入时动态链接</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/171238658.png" alt="mark"></p><h4 id="③-运行时动态链接"><a href="#③-运行时动态链接" class="headerlink" title="③ 运行时动态链接"></a>③ 运行时动态链接</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/171253814.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;操作系统-13-内存基础&quot;&gt;&lt;a href=&quot;#操作系统-13-内存基础&quot; class=&quot;headerlink&quot; title=&quot;操作系统-13-内存基础&quot;&gt;&lt;/a&gt;操作系统-13-内存基础&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;
      
    
    </summary>
    
    
    
      <category term="内存管理" scheme="http://zhuuu.work/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-12-死锁</title>
    <link href="http://zhuuu.work/2020/10/17/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-12-%E6%AD%BB%E9%94%81/"/>
    <id>http://zhuuu.work/2020/10/17/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-12-%E6%AD%BB%E9%94%81/</id>
    <published>2020-10-17T06:00:53.000Z</published>
    <updated>2020-10-17T08:43:06.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-12-死锁"><a href="#操作系统-12-死锁" class="headerlink" title="操作系统-12-死锁"></a>操作系统-12-死锁</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/154418323.png" alt="mark"></p><a id="more"></a><h2 id="1-死锁的概念"><a href="#1-死锁的概念" class="headerlink" title="1. 死锁的概念"></a>1. 死锁的概念</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/154457617.png" alt="mark"></p><h2 id="2-四个必要条件"><a href="#2-四个必要条件" class="headerlink" title="2. 四个必要条件"></a>2. 四个必要条件</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/154548072.png" alt="mark"></p><p>同时什么时候会发生死锁呢？</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/154729905.png" alt="mark"></p><h2 id="3-死锁的处理策略"><a href="#3-死锁的处理策略" class="headerlink" title="3. 死锁的处理策略"></a>3. 死锁的处理策略</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/154757012.png" alt="mark"></p><h3 id="3-1-预防死锁"><a href="#3-1-预防死锁" class="headerlink" title="3.1 预防死锁"></a>3.1 预防死锁</h3><p><strong>① 破坏互斥条件</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/154820963.png" alt="mark"></p><p><strong>② 破坏不可剥夺条件</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/154906684.png" alt="mark"></p><p><strong>③ 破坏请求和保持条件</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/154924096.png" alt="mark"></p><p><strong>④ 破坏循环等待条件</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/154949485.png" alt="mark"></p><h3 id="3-2-避免死锁"><a href="#3-2-避免死锁" class="headerlink" title="3.2 避免死锁"></a>3.2 避免死锁</h3><p><strong>① 什么是安全序列？</strong></p><p><strong>不成功的案例</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/155027567.png" alt="mark"></p><p><strong>成功的案例</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/155055359.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/155134524.png" alt="mark"></p><p><strong>② 安全序列、安全状态、不安全状态、死锁之间的联系</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/155239988.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/155256144.png" alt="mark"></p><p><strong>③ 避免系统进入不安全状态——银行家算法</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/155316874.png" alt="mark"></p><ul><li><strong>安全的例子</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/155527891.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/155608913.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/155652128.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/155757001.png" alt="mark"></p><ul><li><strong>不安全的例子</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/155814061.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/155837858.png" alt="mark"></p><p><strong>代码实现</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/155856072.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/160310215.png" alt="mark"></p><h3 id="3-3-检测解除死锁"><a href="#3-3-检测解除死锁" class="headerlink" title="3.3 检测解除死锁"></a>3.3 检测解除死锁</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/163619748.png" alt="mark"></p><p><strong>① 死锁的检测</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/163702333.png" alt="mark"></p><ul><li>举个例子，可以消除所有边，即无死锁发生</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/164041521.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/164110167.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/164117093.png" alt="mark"></p><ul><li>举个例子，不可消除所有边，即产生死锁</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/164139437.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/164147784.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/164202551.png" alt="mark"></p><p><strong>检测死锁的算法：死锁定理</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/164211773.png" alt="mark"></p><p><strong>② 死锁的解除</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/164301428.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-12-死锁&quot;&gt;&lt;a href=&quot;#操作系统-12-死锁&quot; class=&quot;headerlink&quot; title=&quot;操作系统-12-死锁&quot;&gt;&lt;/a&gt;操作系统-12-死锁&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/154418323.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="进程同步" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程互斥" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>Netty-03-零拷贝</title>
    <link href="http://zhuuu.work/2020/10/16/Netty/Netty-03-%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    <id>http://zhuuu.work/2020/10/16/Netty/Netty-03-%E9%9B%B6%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-10-16T03:05:24.000Z</published>
    <updated>2020-10-19T01:38:56.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-03-零拷贝"><a href="#Netty-03-零拷贝" class="headerlink" title="Netty-03-零拷贝"></a>Netty-03-零拷贝</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Java程序中，常用的零拷贝有 mmap（内存映射）和 sendFile。</p><p>零拷贝不仅仅带来更少的数据复制，还能减少线程的上下文切换，减少CPU缓存伪共享以及无CPU校验和计算。</p><h2 id="1-传统的IO读写"><a href="#1-传统的IO读写" class="headerlink" title="1. 传统的IO读写"></a>1. 传统的IO读写</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"test.txt"</span>);</span><br><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) file.length()];</span><br><span class="line">raf.read(arr);</span><br><span class="line"></span><br><span class="line">Socket socket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>).accept();</span><br><span class="line">socket.getOutputStream().write(arr);</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/092714165.png" alt="mark"></p><ul><li><strong>三次内核态用户态切换</strong></li><li><strong>四次拷贝</strong><ul><li>DMA</li><li>kernel buffer - &gt; user buffer</li><li>user buffer -&gt; socket buffer</li><li>DMA</li></ul></li></ul><a id="more"></a><h2 id="2-mmap-优化"><a href="#2-mmap-优化" class="headerlink" title="2. mmap 优化"></a>2. mmap 优化</h2><p><strong>mmap优化的IO读写：</strong></p><ul><li><strong>mmap通过内存映射</strong>，将文件映射到内核缓冲区，同时，用户空间可以共享内存空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数。</li><li><strong>需要进行3次上下文切换，3次数据拷贝。</strong></li><li>适合小数据量的读写。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/092904500.png" alt="mark"></p><h2 id="3-sendFile-优化"><a href="#3-sendFile-优化" class="headerlink" title="3. sendFile 优化"></a>3. sendFile 优化</h2><ul><li>Linux2.1 版本提供了 <code>sendFile</code> 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到<code>SocketBuffer</code>，同时，由于和用户态完全无关，就减少了一次上下文切换。</li><li>需要3次上下文切换和最少2次数据拷贝。</li><li>适合大文件的传输。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/092941352.png" alt="mark"></p><ul><li>而 Linux 在 2.4 版本中，做了一些修改，避免了从内核缓冲区拷贝到 <code>Socket Buffer</code> 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/092953049.png" alt="mark"></p><p><strong>注：这里其实有一次CPU拷贝，<code>kernel buffer -&gt; socket buffer</code>。但是，拷贝的信息很少，只拷贝了数据的长度、偏移量等关键信息，消耗低，可以忽略不计。</strong></p><h2 id="4-NIO中的零拷贝（transferTo）"><a href="#4-NIO中的零拷贝（transferTo）" class="headerlink" title="4. NIO中的零拷贝（transferTo）"></a>4. <strong>NIO中的零拷贝（transferTo）</strong></h2><ul><li><strong>客户端</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOzerocopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>,<span class="number">7001</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到一个文件的channel</span></span><br><span class="line">        FileChannel channel = <span class="keyword">new</span> FileInputStream(<span class="string">"a.zip"</span>).getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备发送</span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在linux中一个transfer函数就可以完成传输</span></span><br><span class="line">        <span class="comment">// 在windows中调用一次transferTo 只能发送8M，就需要把数据分段传输</span></span><br><span class="line">        <span class="comment">// transferTo 底层使用到了零拷贝</span></span><br><span class="line">        <span class="keyword">long</span> transferCount = channel.transferTo(<span class="number">0</span>, channel.size(), socketChannel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结束发送</span></span><br><span class="line">        System.out.println(<span class="string">"发送的总的字节数："</span> + transferCount + <span class="string">" 耗时："</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-03-零拷贝&quot;&gt;&lt;a href=&quot;#Netty-03-零拷贝&quot; class=&quot;headerlink&quot; title=&quot;Netty-03-零拷贝&quot;&gt;&lt;/a&gt;Netty-03-零拷贝&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在Java程序中，常用的零拷贝有 mmap（内存映射）和 sendFile。&lt;/p&gt;
&lt;p&gt;零拷贝不仅仅带来更少的数据复制，还能减少线程的上下文切换，减少CPU缓存伪共享以及无CPU校验和计算。&lt;/p&gt;
&lt;h2 id=&quot;1-传统的IO读写&quot;&gt;&lt;a href=&quot;#1-传统的IO读写&quot; class=&quot;headerlink&quot; title=&quot;1. 传统的IO读写&quot;&gt;&lt;/a&gt;1. 传统的IO读写&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;File file = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; File(&lt;span class=&quot;string&quot;&gt;&quot;test.txt&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RandomAccessFile raf = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RandomAccessFile(file, &lt;span class=&quot;string&quot;&gt;&quot;rw&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] arr = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;) file.length()];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;raf.read(arr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Socket socket = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ServerSocket(&lt;span class=&quot;number&quot;&gt;8080&lt;/span&gt;).accept();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;socket.getOutputStream().write(arr);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201019/092714165.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;三次内核态用户态切换&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;四次拷贝&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;DMA&lt;/li&gt;
&lt;li&gt;kernel buffer - &amp;gt; user buffer&lt;/li&gt;
&lt;li&gt;user buffer -&amp;gt; socket buffer&lt;/li&gt;
&lt;li&gt;DMA&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="NIO" scheme="http://zhuuu.work/tags/NIO/"/>
    
      <category term="零拷贝" scheme="http://zhuuu.work/tags/%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-11-经典进程同步互斥问题</title>
    <link href="http://zhuuu.work/2020/10/16/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-11-%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98/"/>
    <id>http://zhuuu.work/2020/10/16/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-11-%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98/</id>
    <published>2020-10-16T00:00:53.000Z</published>
    <updated>2020-10-17T07:06:51.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-11-经典进程同步互斥问题"><a href="#操作系统-11-经典进程同步互斥问题" class="headerlink" title="操作系统-11-经典进程同步互斥问题"></a>操作系统-11-经典进程同步互斥问题</h1><h2 id="1-消费者-生产者问题"><a href="#1-消费者-生产者问题" class="headerlink" title="1. 消费者-生产者问题"></a>1. 消费者-生产者问题</h2><p><strong>1. 问题描述</strong></p><ul><li>系统中有<code>一组生产者进程</code>和<code>一组消费者进程</code>，生产者进程每次<code>生产一个</code>产品放入缓冲区，消费者进程每次从缓冲区中<code>取出一个</code>产品并使用。(注: 这里的“产品”理解为某种数据)</li><li>生产者、消费者<code>共享</code>一个初始为空、大小为n的<code>缓冲区</code>。</li><li>只有缓冲区<code>没满</code>时，<code>生产者</code>才能把产品<code>放入</code>缓冲区，否则必须等待。</li><li>只有缓冲区<code>不空</code>时，<code>消费者</code>才能从中<code>取出</code>产品，否则必须等待。</li><li>缓冲区是临界资源，各进程必须<code>互斥</code>地访问。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/091536548.png" alt="mark"></p><a id="more"></a><ol start="2"><li><strong>问题分析</strong></li></ol><ul><li><strong>1)关系分析</strong>。生产者和消费者对缓冲区互斥访问是<code>互斥关系</code>，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后,消费者才能消费，它们也是<code>同步关系</code>。</li><li><strong>2)整理思路</strong>。根据各进程的操作流程确定P、V操作的大致顺序。<br>生产者每次要消耗(P）一个空闲缓冲区，并生产(V)一个产品。<br>消费者每次要消耗(P）一个产品，并释放一个空闲缓冲区(V)。<br>往缓冲区放入/取走产品需要互斥。</li><li><strong>3)信号量设置。</strong>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。( 互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少)</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/091728863.png" alt="mark"></p><ol start="3"><li><strong>实现</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/091816753.png" alt="mark"></p><p><strong>注意 ： 实现互斥的P操作一定要在实现同步的P操作之后（否则会有死锁问题）</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/092337577.png" alt="mark"></p><p><strong>单生产者-消费者回顾</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/092555328.png" alt="mark"></p><h2 id="2-多生产者-消费者问题"><a href="#2-多生产者-消费者问题" class="headerlink" title="2. 多生产者-消费者问题"></a>2. 多生产者-消费者问题</h2><ol><li><strong>问题描述</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/142657247.png" alt="mark"></p><ol start="2"><li><strong>问题分析</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/142750028.png" alt="mark"></p><ol start="3"><li><strong>实现方式</strong></li></ol><p><strong>① 有mutex</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/142951274.png" alt="mark"></p><p><strong>② 无mutex</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/143000426.png" alt="mark"></p><p><strong>为什么有mutex和没有mutex一样呢？</strong></p><ul><li>原因在于:本题中的缓冲区大小为1，在任何时刻，apple、 orange、 plate 三个同步信号量中最多只有一个是1。</li><li>因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区…</li></ul><p><strong>如果有两个盘子plate</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/143354331.png" alt="mark"></p><ol start="4"><li><h5 id="知识总结与重要考点"><a href="#知识总结与重要考点" class="headerlink" title="知识总结与重要考点"></a>知识总结与重要考点</h5></li></ol><p><code>总结</code>:在生产者_消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，<code>这不是绝对的</code>，要具体问题具体分析。</p><p><code>建议</code>:在考试中如果来不及仔细分析，可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区。但需要注意的是，·<code>实现互斥的P操作一定要在实现同步的P操作之后</code>·，否则可能引起·<code>“死锁”</code>·。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/143729758.png" alt="mark"></p><h2 id="3-吸烟者问题"><a href="#3-吸烟者问题" class="headerlink" title="3. 吸烟者问题"></a>3. 吸烟者问题</h2><ol><li><strong>问题描述</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/092714018.png" alt="mark"></p><ol start="2"><li><h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5></li></ol><ul><li><strong>本质是单生产者 - 多消费者的问题</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/093058018.png" alt="mark"></p><ol start="3"><li><strong>实现方法</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/093158353.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/093214151.png" alt="mark"></p><p><strong>回顾 :</strong> </p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/093805017.png" alt="mark"></p><h2 id="4-读者写者问题"><a href="#4-读者写者问题" class="headerlink" title="4. 读者写者问题"></a>4. 读者写者问题</h2><ol><li><strong>问题描述</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/143934790.png" alt="mark"></p><ol start="2"><li><strong>问题分析</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/144022559.png" alt="mark"></p><ol start="3"><li><h5 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h5></li></ol><p><strong>① 给count加mutex互斥访问</strong></p><ul><li>这里说一下为什么要加mutex。</li><li>比如：当count=0时，第一个读者进程执行到p(rw),rw=0,假设此时时间片到了，切换到第二个读者进程,第二个进程发现count=0,则执行p(rw)，但是此时rw=0，于是第二个进程被堵在p（rw）这里，同理，后面的可能会有多个进程堵在p(rw)，只有当第一个进程再次获得时间片，执行count++,让count不为0，然后其他进程就可以直接绕过if直接进行count++来访问文件，但是第三个读者进程和后面的几个可能堵在p(rw)的多个读者进程则必须得等count–为0后才可以再次和写进程竞争来访问文件，对count的访问没有做到一气呵成，会导致本来一些进程一直堵在p（rw）。</li></ul><p><strong>② 加一个w实现“读写公平法”</strong></p><ul><li>在上面的算法中，读进程是优先的，即当存在读进程时，写操作将被延迟，且只要有 一个读进程活跃，随后而来的读进程都将被允许访问文件。这样的方式会导致写进程可能长时间等待，且存在写进程<code>“饿死”</code>的情况。</li><li>若希望写进程优先，<code>即当有读进程正在读共享文件时，有写进程请求访问，这时应禁止后续读进程的请求，等到已在共享文件的读进程执行完毕，立即让写进程执行，只有在无写进程执行的情况下才允许读进程再次运行</code>。</li><li>为此，增加一个信号量并在上面程序的<code>writer()</code>和 <code>reader()</code>函数中各增加一对PV操作，就可以得到写进程优先的解决程序。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/145521452.png" alt="mark"></p><ol start="4"><li><h5 id="知识回顾与重要考点"><a href="#知识回顾与重要考点" class="headerlink" title="知识回顾与重要考点"></a>知识回顾与重要考点</h5></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/145551296.png" alt="mark"></p><h2 id="5-哲学家进餐问题"><a href="#5-哲学家进餐问题" class="headerlink" title="5. 哲学家进餐问题"></a>5. 哲学家进餐问题</h2><ol><li><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/145634639.png" alt="mark"></p><ol start="2"><li><h5 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h5></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/145759644.png" alt="mark"></p><ol start="3"><li><h5 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h5></li></ol><ul><li><strong>实现一：最多允许四个哲学家同时进餐</strong></li><li><strong>实现二：</strong><ul><li><strong>奇数号哲学家先拿左边的筷子，再拿右边的筷子</strong></li><li><strong>偶数号哲学家先拿右边的筷子，再拿左边的筷子</strong></li></ul></li><li><strong>实现三：仅当一名哲学家左右两边筷子都可用的时候才允许拿起筷子</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/150150502.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/150153963.png" alt="mark"></p><p><strong>例子</strong></p><p><strong>实现三：仅当一名哲学家左右两边筷子都可用的时候才允许拿起筷子</strong> 为例</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/150440432.png" alt="mark"></p><ol start="4"><li><strong>总结和回顾</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201017/150635987.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-11-经典进程同步互斥问题&quot;&gt;&lt;a href=&quot;#操作系统-11-经典进程同步互斥问题&quot; class=&quot;headerlink&quot; title=&quot;操作系统-11-经典进程同步互斥问题&quot;&gt;&lt;/a&gt;操作系统-11-经典进程同步互斥问题&lt;/h1&gt;&lt;h2 id=&quot;1-消费者-生产者问题&quot;&gt;&lt;a href=&quot;#1-消费者-生产者问题&quot; class=&quot;headerlink&quot; title=&quot;1. 消费者-生产者问题&quot;&gt;&lt;/a&gt;1. 消费者-生产者问题&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1. 问题描述&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统中有&lt;code&gt;一组生产者进程&lt;/code&gt;和&lt;code&gt;一组消费者进程&lt;/code&gt;，生产者进程每次&lt;code&gt;生产一个&lt;/code&gt;产品放入缓冲区，消费者进程每次从缓冲区中&lt;code&gt;取出一个&lt;/code&gt;产品并使用。(注: 这里的“产品”理解为某种数据)&lt;/li&gt;
&lt;li&gt;生产者、消费者&lt;code&gt;共享&lt;/code&gt;一个初始为空、大小为n的&lt;code&gt;缓冲区&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;只有缓冲区&lt;code&gt;没满&lt;/code&gt;时，&lt;code&gt;生产者&lt;/code&gt;才能把产品&lt;code&gt;放入&lt;/code&gt;缓冲区，否则必须等待。&lt;/li&gt;
&lt;li&gt;只有缓冲区&lt;code&gt;不空&lt;/code&gt;时，&lt;code&gt;消费者&lt;/code&gt;才能从中&lt;code&gt;取出&lt;/code&gt;产品，否则必须等待。&lt;/li&gt;
&lt;li&gt;缓冲区是临界资源，各进程必须&lt;code&gt;互斥&lt;/code&gt;地访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201009/091536548.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="进程同步" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程互斥" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-530-二叉搜索树的最小绝对值</title>
    <link href="http://zhuuu.work/2020/10/12/Leetcode/Leetcode-530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%80%BC/"/>
    <id>http://zhuuu.work/2020/10/12/Leetcode/Leetcode-530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%80%BC/</id>
    <published>2020-10-12T04:52:53.000Z</published>
    <updated>2020-10-12T02:16:35.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-530-二叉搜索树的最小绝对差"><a href="#Leetcode-530-二叉搜索树的最小绝对差" class="headerlink" title="Leetcode-530-二叉搜索树的最小绝对差"></a>Leetcode-530-<a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/" target="_blank" rel="noopener">二叉搜索树的最小绝对差</a></h1><p><strong>题目描述：</strong></p><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span></span><br><span class="line">    \</span><br><span class="line">     <span class="number">3</span></span><br><span class="line">    /</span><br><span class="line">   <span class="number">2</span></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">最小绝对差为 <span class="number">1</span>，其中 <span class="number">2</span> 和 <span class="number">1</span> 的差的绝对值为 <span class="number">1</span>（或者 <span class="number">2</span> 和 <span class="number">3</span>）。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中至少有 2 个节点。</li></ul><a id="more"></a><h2 id="思路-中序遍历"><a href="#思路-中序遍历" class="headerlink" title="思路 :中序遍历"></a>思路 :中序遍历</h2><ul><li><strong>看到二叉搜索树，就能想到中序遍历。</strong></li><li>遍历一个二叉树，会访问每一个节点，拿节点做一些事情。</li><li>而中序遍历，它对于每一个节点，都先访问处理它的左子树中的节点，再访问处理它本身，再访问处理它的右子树中的节点。</li></ul><ul><li><strong>由于二叉搜索树的性质，中序遍历访问处理的节点值的大小是递增的。</strong></li><li><strong>题目要求任意两个节点的最小的差值，它肯定发生在递增排列后，相邻的节点值之间。</strong></li></ul><p><strong>优化 ：</strong> <strong>我们用一个变量，保存上一个访问处理的节点值</strong>，<strong>求出当前访问的节点值与它之差，挑战最小的纪录，更小就更新。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ans = Integer.MAX_VALUE;</span><br><span class="line">        pre = -<span class="number">1</span>; <span class="comment">//pre 用于保存前一个root.val</span></span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1. 递归结束的条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 中序遍历</span></span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="comment">// 处理逻辑</span></span><br><span class="line">        <span class="keyword">if</span>(pre == -<span class="number">1</span>)&#123;</span><br><span class="line">            pre = root.val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans = Math.min(ans,root.val - pre);</span><br><span class="line">            pre = root.val; <span class="comment">// pre更新为当前节点的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度 ：</strong> O(n) 其中n是二叉搜索树节点的个数。每个节点在中序遍历中只会被访问一次。因此总的时间复杂度是O(n)</li><li><strong>空间复杂度</strong> ： O(n) 递归函数递归栈使用的深度</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-530-二叉搜索树的最小绝对差&quot;&gt;&lt;a href=&quot;#Leetcode-530-二叉搜索树的最小绝对差&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-530-二叉搜索树的最小绝对差&quot;&gt;&lt;/a&gt;Leetcode-530-&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二叉搜索树的最小绝对差&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;最小绝对差为 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;，其中 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 和 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 的差的绝对值为 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;（或者 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 和 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;）。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;树中至少有 2 个节点。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>背包问题-合集</title>
    <link href="http://zhuuu.work/2020/10/12/LeetcodeExplore/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-%E5%90%88%E9%9B%86/"/>
    <id>http://zhuuu.work/2020/10/12/LeetcodeExplore/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-%E5%90%88%E9%9B%86/</id>
    <published>2020-10-12T02:52:53.000Z</published>
    <updated>2020-10-12T01:45:07.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背包问题-合集"><a href="#背包问题-合集" class="headerlink" title="背包问题-合集"></a>背包问题-合集</h1><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背包问题-合集&quot;&gt;&lt;a href=&quot;#背包问题-合集&quot; class=&quot;headerlink&quot; title=&quot;背包问题-合集&quot;&gt;&lt;/a&gt;背包问题-合集&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="背包问题" scheme="http://zhuuu.work/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-303-区域和检索</title>
    <link href="http://zhuuu.work/2020/10/09/Leetcode/Leetcode-303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2/"/>
    <id>http://zhuuu.work/2020/10/09/Leetcode/Leetcode-303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2/</id>
    <published>2020-10-09T01:52:53.000Z</published>
    <updated>2020-10-08T02:25:26.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-303-区域和检索-数组不可变"><a href="#Leetcode-303-区域和检索-数组不可变" class="headerlink" title="Leetcode-303-区域和检索 - 数组不可变"></a>Leetcode-303-<a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">区域和检索 - 数组不可变</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">给定 nums &#x3D; [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br></pre></td></tr></table></figure><p>说明:</p><p>你可以假设数组不可变。<br>会多次调用 sumRange 方法。</p><a id="more"></a><h2 id="思路-：-前缀和"><a href="#思路-：-前缀和" class="headerlink" title="思路 ： 前缀和"></a>思路 ： 前缀和</h2><ul><li>一上来我们不说前缀和这个思路，先说个普通的暴力解法</li></ul><p><strong>暴力解法</strong></p><ul><li>每次调用 <code>sumrange</code> 时，我们都使用for循环将索引 i 到 j 之间的每个元素相加。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] data;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    data = nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; k++) &#123;</span><br><span class="line">        sum += data[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：每次查询的时间 O(n)，每个 sumrange 查询需要 O(n)时间。</li><li>空间复杂度：O(1)，请注意，data 是对 nums 的引用，不是它的副本。</li></ul><p><strong>前缀和</strong></p><ul><li>假设我们预先计算了从数字 0 到 k的累积和。我们可以用这个信息得出 <code>sum(i，j)</code>吗？</li><li>让我们将 s<strong>u</strong>m[k] 定义为<code>nums[0⋯k−1]</code> 的累积和（包括这两个值）：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/102327279.png" alt="mark"></p><ul><li>现在，我们可以计算 <code>sumrange</code>如下：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/102342287.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// sum[0] = 0</span></span><br><span class="line">    <span class="comment">// sum[] 数组用于计算前缀和</span></span><br><span class="line">    sum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum[i + <span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算索引下标区间内的求和公式</span></span><br><span class="line">    <span class="keyword">return</span> sum[j + <span class="number">1</span>] - sum[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>注意，在上面的代码中，我们插入了一个虚拟 0 作为 sum 数组中的第一个元素。这个技巧可以避免在 <code>sumrange</code> 函数中进行额外的条件检查。</li></ul><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：每次查询的时间 O(1)，</p><ul><li>O(N)预计算时间。由于累积和被缓存，每个<code>sumrange</code>都可以用 O(1)时间计算。</li></ul></li><li><p>空间复杂度：O(n).</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-303-区域和检索-数组不可变&quot;&gt;&lt;a href=&quot;#Leetcode-303-区域和检索-数组不可变&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-303-区域和检索 - 数组不可变&quot;&gt;&lt;/a&gt;Leetcode-303-&lt;a href=&quot;https://leetcode-cn.com/problems/range-sum-query-immutable/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;区域和检索 - 数组不可变&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;给定 nums &amp;#x3D; [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sumRange(0, 2) -&amp;gt; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sumRange(2, 5) -&amp;gt; -1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sumRange(0, 5) -&amp;gt; -3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;说明:&lt;/p&gt;
&lt;p&gt;你可以假设数组不可变。&lt;br&gt;会多次调用 sumRange 方法。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="前缀和" scheme="http://zhuuu.work/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>java8-新特性-lambda</title>
    <link href="http://zhuuu.work/2020/10/08/java8new/java8-%E6%96%B0%E7%89%B9%E6%80%A7-lambda/"/>
    <id>http://zhuuu.work/2020/10/08/java8new/java8-%E6%96%B0%E7%89%B9%E6%80%A7-lambda/</id>
    <published>2020-10-08T14:30:53.000Z</published>
    <updated>2020-11-19T14:53:26.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java8-新特性-lambda"><a href="#java8-新特性-lambda" class="headerlink" title="java8-新特性-lambda"></a>java8-新特性-lambda</h1><h2 id="前言（从一个案例来引入优化）"><a href="#前言（从一个案例来引入优化）" class="headerlink" title="前言（从一个案例来引入优化）"></a>前言（从一个案例来引入优化）</h2><ol><li><strong>创建员工类</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;java8-新特性-lambda&quot;&gt;&lt;a href=&quot;#java8-新特性-lambda&quot; class=&quot;headerlink&quot; title=&quot;java8-新特性-lambda&quot;&gt;&lt;/a&gt;java8-新特性-lambda&lt;/h1&gt;&lt;h2 id=&quot;前言（从一个案例来引入优化）&quot;&gt;&lt;a href=&quot;#前言（从一个案例来引入优化）&quot; class=&quot;headerlink&quot; title=&quot;前言（从一个案例来引入优化）&quot;&gt;&lt;/a&gt;前言（从一个案例来引入优化）&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;创建员工类&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Employee&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; salary;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Employee&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; age, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; salary)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.salary = salary;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getAge&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setAge&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; age)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getSalary&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; salary;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setSalary&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; salary)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.salary = salary;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="lambda表达式" scheme="http://zhuuu.work/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="java8" scheme="http://zhuuu.work/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1038-把二叉搜索树转换为累加树</title>
    <link href="http://zhuuu.work/2020/10/08/Leetcode/Leetcode-1038-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/"/>
    <id>http://zhuuu.work/2020/10/08/Leetcode/Leetcode-1038-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/</id>
    <published>2020-10-08T07:52:53.000Z</published>
    <updated>2020-10-29T01:07:53.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-1038-把二叉搜索树转换为累加树"><a href="#Leetcode-1038-把二叉搜索树转换为累加树" class="headerlink" title="Leetcode-1038-把二叉搜索树转换为累加树"></a>Leetcode-1038-<a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/" target="_blank" rel="noopener">把二叉搜索树转换为累加树</a></h1><h2 id="思路：反向中序遍历"><a href="#思路：反向中序遍历" class="headerlink" title="思路：反向中序遍历"></a>思路：反向中序遍历</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给出二叉搜索树的根节点，该树的节点值各不相同，请你将其转换成累加树（Greater Sum Tree），使得每个节点的<code>node</code> 的新值等于原书中大于等于<code>node.val</code> 的值之和。</li></ul><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul><li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li><li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p><strong>示例 1：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201029/085842282.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：root &#x3D; [0,null,1]</span><br><span class="line">输出：[1,null,1]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：root &#x3D; [1,0,2]</span><br><span class="line">输出：[3,3,2]</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：root &#x3D; [3,2,4,1]</span><br><span class="line">输出：[7,9,4,10]</span><br></pre></td></tr></table></figure><h2 id="方法-反向中序遍历"><a href="#方法-反向中序遍历" class="headerlink" title="方法 : 反向中序遍历"></a>方法 : 反向中序遍历</h2><ul><li><strong>关于二叉搜索树的问题，第一个想到的就是中序遍历</strong>，这是二叉搜索树的一个非常重要的性质</li><li><strong>二叉搜索树的中序遍历是一个递增的有序序列</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201029/090116634.png" alt="mark"></p><p>观察<strong>累加前中序遍历</strong>和<strong>累加后中序遍历</strong>，我们会发现，其实后者就是前者的一个从后的累加结果。</p><p>那么问题就迎刃而解了，我们秩序反向中序遍历即可，并且把每次的节点值进行累加，就能得到最终的累加树。并且保证了这样只会访问每个节点一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">bstToGst</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 1. 如果是叶子节点的话</span></span><br><span class="line">            <span class="comment">// 进行反向的中序遍历</span></span><br><span class="line">            bstToGst(root.right); <span class="comment">// 递归右子树</span></span><br><span class="line">            sum = sum + root.val; <span class="comment">// 累加</span></span><br><span class="line">            root.val = sum; <span class="comment">// 更新节点的值</span></span><br><span class="line">            bstToGst(root.left); <span class="comment">// 递归左子树</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Leetcode-1038-把二叉搜索树转换为累加树&quot;&gt;&lt;a href=&quot;#Leetcode-1038-把二叉搜索树转换为累加树&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-1038-把二叉搜索树转换为累加树&quot;&gt;&lt;/a&gt;Leetcode
      
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="中序遍历" scheme="http://zhuuu.work/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-10-进程同步和互斥</title>
    <link href="http://zhuuu.work/2020/10/08/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-10-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5/"/>
    <id>http://zhuuu.work/2020/10/08/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-10-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5/</id>
    <published>2020-10-08T06:00:53.000Z</published>
    <updated>2020-10-08T14:04:23.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-10-进程同步和互斥"><a href="#操作系统-10-进程同步和互斥" class="headerlink" title="操作系统-10-进程同步和互斥"></a>操作系统-10-进程同步和互斥</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/135327192.png" alt="mark"></p><a id="more"></a><h2 id="1-同步和互斥的概念"><a href="#1-同步和互斥的概念" class="headerlink" title="1. 同步和互斥的概念"></a>1. 同步和互斥的概念</h2><h3 id="1-1-进程同步"><a href="#1-1-进程同步" class="headerlink" title="1.1 进程同步"></a>1.1 进程同步</h3><ul><li><code>同步也称为直接制约关系。</code></li><li>在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系,如等待、传递信息等，引入了进程同步的概念。进程同步是为了解决进程的异步问题。</li><li>一个简单的例子来理解这个概念。</li><li>例如，让系统计算1 + 2x3，假设系统产生两个进程: 一个是加法进程，一个是乘法进程。要让计算结果是正确的，一定要让加法进程发生在乘法进程之后,但实际上操作系统具有<code>异步性</code>,若不加以制约，加法进程发生在乘法进程之前是绝对有可能的，因此要制定一定的机制去约束加法进程，让它在乘法进程完成之后才发生。</li></ul><blockquote><p>异步性：进程具有异步性的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。</p></blockquote><h3 id="1-2-进程互斥"><a href="#1-2-进程互斥" class="headerlink" title="1.2 进程互斥"></a>1.2 进程互斥</h3><ul><li><code>互斥，亦称间接制约关系</code>。<code>进程互斥</code>指当一个进程访问某临界资源时，另一个想要访问该<code>临界资源</code>的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</li><li>在这里需复习一下<code>临界资源</code>的概念。</li><li>我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备(比如摄像头、打印机)都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</li><li>对临界资源的访问，必须互斥地进行。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/135625431.png" alt="mark"></p><ul><li>为了禁止两个进程同时进入<code>临界区</code>，需遵循以下准则</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/135640762.png" alt="mark"></p><h2 id="2-临界区进程互斥的实现方法"><a href="#2-临界区进程互斥的实现方法" class="headerlink" title="2. 临界区进程互斥的实现方法"></a>2. 临界区进程互斥的实现方法</h2><h3 id="2-1-软件实现方法"><a href="#2-1-软件实现方法" class="headerlink" title="2.1 软件实现方法"></a>2.1 软件实现方法</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/135912018.png" alt="mark"></p><ul><li>软件实现方法的思想：在进入区设置并检查一些标志 来标明是否有进程在临界区中,若已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。</li><li><code>入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。</code></li></ul><ol><li><strong>单标志法</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/140023554.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/140108733.png" alt="mark"></p><ol start="2"><li><strong>双标志先检查法</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/140538012.png" alt="mark"></p><ol start="3"><li><strong>双标志后检查法</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/140659932.png" alt="mark"></p><ol start="4"><li><strong>Peterson 算法</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/140915268.png" alt="mark"></p><h3 id="2-2-硬件实现方法"><a href="#2-2-硬件实现方法" class="headerlink" title="2.2 硬件实现方法"></a>2.2 硬件实现方法</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/141220331.png" alt="mark"></p><ol><li><strong>中断屏蔽</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/141252814.png" alt="mark"></p><ol start="2"><li><strong><code>TestAndSet</code>指令</strong></li></ol><ul><li>执行<strong>TSL指令时</strong>，它的内部运转逻辑：<ul><li><strong>假设lock现在为false</strong>，代表临界资源A空闲，那么我就可以访问这个资源，同时将lock=true，提醒别的进程，这个临界资源A我正在使用，让他们等等</li><li><strong>假设lock为true</strong>，代表临界资源正在有人使用，所以我必须等待，并且将lock=true，并不影响什么，所以没关系，只是为了让lock为false时可以上锁，将上锁与检查在一个TSL指令完成。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/141754753.png" alt="mark"></p><ol start="3"><li><strong>swap 指令</strong></li></ol><ul><li>old是每个进程都要进行的一步，都必须将<code>old=true</code></li><li>分析一下这样做的原因：<ul><li>因为lock是某一特定临界资源的共享变量，当每一个进程准备访问这个特定的临界资源时，初始化<code>old=true</code>，然后进入while循环进行交换，<strong>如果当前lock是false,则交换后old=false,则当前进程可以跳出循环进入临界区代码段，</strong></li><li>同时因为交换，<code>lock=old=true</code>上锁，不让别的进程来打扰，别的进程会因为lock变为true,一直在while循环等待,<strong>当我使用完临界资源，则将<code>lock=false</code>,此时别的进程再交换old和lock就能判断old=false,可以跳出循环，使用临界资源。</strong></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/142115031.png" alt="mark"></p><h2 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3. 信号量"></a>3. 信号量</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/142208661.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/142319507.png" alt="mark"></p><h3 id="3-1-整型信号量"><a href="#3-1-整型信号量" class="headerlink" title="3.1 整型信号量"></a>3.1 整型信号量</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/142307160.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/142412015.png" alt="mark"></p><h3 id="3-2-记录型信号量"><a href="#3-2-记录型信号量" class="headerlink" title="3.2 记录型信号量"></a>3.2 记录型信号量</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/142544410.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/142843431.png" alt="mark"></p><ul><li><strong>一个案例：打印机资源为2访问</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/142932870.png" alt="mark"></p><h3 id="3-3-信号量机制实现进程同步和互斥"><a href="#3-3-信号量机制实现进程同步和互斥" class="headerlink" title="3.3 信号量机制实现进程同步和互斥"></a>3.3 信号量机制实现进程同步和互斥</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/143121739.png" alt="mark"></p><h4 id="3-3-1-互斥"><a href="#3-3-1-互斥" class="headerlink" title="3.3.1 互斥"></a>3.3.1 互斥</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/143219225.png" alt="mark"></p><h4 id="3-3-2-同步"><a href="#3-3-2-同步" class="headerlink" title="3.3.2 同步"></a>3.3.2 同步</h4><ul><li>想象一下四则运算的顺序，加减乘除；</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/143432682.png" alt="mark"></p><ul><li>要想理解这一部分知识，必须知道P、V操作的内部实现原理</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/143455765.png" alt="mark"></p><h4 id="3-3-3-前驱关系"><a href="#3-3-3-前驱关系" class="headerlink" title="3.3.3 前驱关系"></a>3.3.3 前驱关系</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/144126344.png" alt="mark"></p><h2 id="4-管程"><a href="#4-管程" class="headerlink" title="4. 管程"></a>4. 管程</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/220151031.png" alt="mark"></p><h3 id="4-1-为什么要引入管程？"><a href="#4-1-为什么要引入管程？" class="headerlink" title="4.1 为什么要引入管程？"></a>4.1 为什么要引入管程？</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/220216654.png" alt="mark"></p><h3 id="4-2-管程的基本组成"><a href="#4-2-管程的基本组成" class="headerlink" title="4.2 管程的基本组成"></a>4.2 管程的基本组成</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/220241848.png" alt="mark"></p><h3 id="4-3-管程实现消费者生产者问题"><a href="#4-3-管程实现消费者生产者问题" class="headerlink" title="4.3 管程实现消费者生产者问题"></a>4.3 管程实现消费者生产者问题</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/220333491.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/220352798.png" alt="mark"></p><h3 id="4-4-java中的管程"><a href="#4-4-java中的管程" class="headerlink" title="4.4 java中的管程"></a>4.4 java中的管程</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/220416205.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-10-进程同步和互斥&quot;&gt;&lt;a href=&quot;#操作系统-10-进程同步和互斥&quot; class=&quot;headerlink&quot; title=&quot;操作系统-10-进程同步和互斥&quot;&gt;&lt;/a&gt;操作系统-10-进程同步和互斥&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201008/135327192.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="进程同步" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程互斥" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>partition-合集</title>
    <link href="http://zhuuu.work/2020/10/07/LeetcodeExplore/partition-%E5%90%88%E9%9B%86/"/>
    <id>http://zhuuu.work/2020/10/07/LeetcodeExplore/partition-%E5%90%88%E9%9B%86/</id>
    <published>2020-10-07T02:52:53.000Z</published>
    <updated>2020-10-07T07:33:36.703Z</updated>
    
    <content type="html"><![CDATA[<h1 id="partition-合集"><a href="#partition-合集" class="headerlink" title="partition-合集"></a>partition-合集</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/101823939.png" alt="mark"></p><h2 id="1-什么是-partition-？"><a href="#1-什么是-partition-？" class="headerlink" title="1. 什么是 partition ？"></a>1. 什么是 partition ？</h2><p>我们在学习 快速排序 的时候知道，可以选择一个标定元素（称为 pivot ，一般而言随机选择），然后通过一次扫描，把数组分成三个部分：</p><ul><li>第 1 部分严格小于 pivot 元素的值；</li><li>第 2 部分恰好等于 pivot 元素的值；</li><li>第 3 部分严格大于 pivot 元素的值。</li><li>第 2 部分元素就是排好序以后它们应该在的位置，接下来只需要递归处理第 1 部分和第 3 部分的元素。</li></ul><p>经过一次扫描把整个数组分成 3 个部分，正好符合当前问题的场景。写对这道题的方法是：把循环不变量的定义作为注释写出来，然后再编码。</p><a id="more"></a><h2 id="2-Leetcode-75-颜色分类-（荷兰旗问题）"><a href="#2-Leetcode-75-颜色分类-（荷兰旗问题）" class="headerlink" title="2. Leetcode-75. 颜色分类 （荷兰旗问题）"></a>2. Leetcode-<a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">75. 颜色分类</a> （荷兰旗问题）</h2><p><strong>题目描述</strong></p><ul><li>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</li><li>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</li></ul><p><strong>注意:</strong><br>不能使用代码库中的排序函数来解决这道题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [2,0,2,1,1,0]</span><br><span class="line">输出: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure><p><strong>进阶：</strong></p><p>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。<br>你能想出一个仅使用常数空间的一趟扫描算法吗？</p><h3 id="2-1-循环不变量"><a href="#2-1-循环不变量" class="headerlink" title="2.1 循环不变量"></a>2.1 循环不变量</h3><p><strong>循环不变量</strong>：声明的变量在遍历的过程中需要保持定义不变。</p><h3 id="2-2-循环不变量的设计原则"><a href="#2-2-循环不变量的设计原则" class="headerlink" title="2.2 循环不变量的设计原则"></a>2.2 循环不变量的设计原则</h3><ul><li>说明：设计循环不变量的原则是 <strong>不重不漏</strong>。</li></ul><p><strong>本题的分界线定义（变量定义）</strong></p><ul><li>len 是数组的长度；</li><li><strong>变量 zero</strong> 是前两个子区间的<strong>分界点</strong>，一个是闭区间，另一个就必须是开区间；</li><li><strong>变量 i 是循环变量</strong>，一般设置为开区间，表示 i 之前的元素是遍历过的；</li><li><strong>two 是另一个分界线</strong>，我设计成闭区间。</li></ul><p><strong>循环不变量定</strong>义如下：</p><ul><li>所有在子区间 [0, zero) 的元素都等于 0；</li><li>所有在子区间 [zero, i) 的元素都等于 1；</li><li>所有在子区间 [two, len - 1] 的元素都等于 2。</li></ul><p>于是<strong>编码要解决以下三个问题</strong>：</p><ul><li>变量初始化应该如何定义；</li><li>在遍历的时候，是先加减还是先交换；</li><li>什么时候循环终止。</li></ul><p><strong>处理这三个问题，完全看循环不变量的定义。</strong></p><ul><li>编码的时候，<code>**zero</code> 和 <code>two</code> 初始化的值就应该保证上面的三个子区间全为空；**</li><li>在遍历的过程中，「下标先加减再交换」、还是「先交换再加减」就看初始化的时候变量在哪里；</li><li><strong>退出循环的条件也看上面定义的循环不变量，在<code>i == two</code> 成立的时候</strong>，上面的三个子区间就正好 <strong>不重不漏 地覆盖了整个数组</strong>，并且给出的性质成立，题目的任务也就完成了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// all in [0, zero) = 0</span></span><br><span class="line">        <span class="comment">// all in [zero, i) = 1</span></span><br><span class="line">        <span class="comment">// all in [two, len - 1] = 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环终止的条件的 i == two 那么循环可以继续等待的条件是 i &lt; two</span></span><br><span class="line">        <span class="comment">// 为了保证初始化的时候[0,zero) 为空  , 设置 zero = 0；</span></span><br><span class="line">        <span class="comment">// 所以下面遍历到 0 的时候，先交换，再加</span></span><br><span class="line">        <span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了保证初始化的时候[two, len - 1] 为空 设置 two = len</span></span><br><span class="line">        <span class="comment">// 所以下面遍历到2的时候，先减 在交换</span></span><br><span class="line">        <span class="keyword">int</span> two = len;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当 i == two 上面的三个子区间正好覆盖了全部数组</span></span><br><span class="line">        <span class="comment">// 因为 循环可以继续的条件是 i  &lt; two</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt; two)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums,i,zero);</span><br><span class="line">                zero++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                two--;</span><br><span class="line">                swap(nums,i,two);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index1,<span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index1 == index2)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index2] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(N)，这里 N是输入数组的长度；</li><li>空间复杂度：O(N)。</li></ul><p><strong>这种做法是在 Java 的 JDK 的源码中 <code>Arrays.sort()</code> 中学到的。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/102513784.png" alt="mark"></p><h2 id="3-复习-partition习题"><a href="#3-复习-partition习题" class="headerlink" title="3. 复习 partition习题"></a>3. 复习 partition习题</h2><h3 id="3-1-「力扣」第-215-题：数组中的第-K-个最大元素（中等）"><a href="#3-1-「力扣」第-215-题：数组中的第-K-个最大元素（中等）" class="headerlink" title="3.1 「力扣」第 215 题：数组中的第 K 个最大元素（中等）"></a>3.1 「力扣」第 215 题：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">数组中的第 K 个最大元素</a>（中等）</h3><p><strong>题目描述</strong></p><p>在未排序的数组中找到第 <strong>k</strong> 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [3,2,1,5,6,4] 和 k &#x3D; 2</span><br><span class="line">输出: 5</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k &#x3D; 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>说明:</p><p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/144137037.png" alt="mark"></p><p><strong>解法一 ： 优先队列</strong></p><ul><li>这是直接明了的方法 使用 最小堆去做</li><li>虽然与本系列无关，但仍然是最快捷简单的方法</li></ul><p><strong>思路分析</strong> [参考链接][<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/]" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/]</a></p><ul><li><p>优先队列的思路是很朴素的。因为第 K 大元素，其实就是整个数组排序以后后半部分最小的那个元素。因此，我们可以<strong>维护一个有 K 个元素的最小堆：</strong></p><p>1、如果当前堆不满，直接添加；</p><p>2、堆满的时候，如果新读到的数小于等于堆顶，肯定不是我们要找的元素，只有新都到的数大于堆顶的时候，才将堆顶拿出，然后放入新读到的数，进而让堆自己去调整内部结构。</p></li><li><p>说明：这里最合适的操作其实是 replace，即直接把新读进来的元素放在堆顶，然后执行下沉（siftDown）操作。Java 当中的 <code>PriorityQueue</code> 没有提供这个操作，只好先 <code>poll()</code>再 <code>offer()</code>。</p></li></ul><ul><li><strong>思路1</strong>：把 <code>len</code>个元素都放入一个最小堆中，然后再 <code>pop()</code>出 len - k 个元素，此时最小堆只剩下 k 个元素，堆顶元素就是数组中的第 k 个最大元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用一个含有len个元素的最小堆，默认是最小堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把 len 个元素都放入一个最小堆中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            minHeap.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后再 pop() 出 len - k 个元素，此时最小堆只剩下 k 个元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len - k;i++)&#123;</span><br><span class="line">            minHeap.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 堆顶元素就是数组中的第 k 个最大元素。</span></span><br><span class="line">        <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>思路 2：综合考虑以上两种情况，总之都是为了节约空间复杂度。即 <code>k</code> 较小的时候使用最小堆，<code>k</code> 较大的时候使用最大堆。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 k 的不同，选最大堆和最小堆，目的是让堆中的元素更小</span></span><br><span class="line">    <span class="comment">// 思路 1：k 要是更靠近 0 的话，此时 k 是一个较大的数，用最大堆</span></span><br><span class="line">    <span class="comment">// 例如在一个有 6 个元素的数组里找第 5 大的元素</span></span><br><span class="line">    <span class="comment">// 思路 2：k 要是更靠近 len 的话，用最小堆</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所以分界点就是 k = len - k</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= len - k) &#123;</span><br><span class="line">            <span class="comment">// System.out.println("使用最小堆");</span></span><br><span class="line">            <span class="comment">// 特例：k = 1，用容量为 k 的最小堆</span></span><br><span class="line">            <span class="comment">// 使用一个含有 k 个元素的最小堆</span></span><br><span class="line">            PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, (a, b) -&gt; a - b);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                minHeap.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="comment">// 看一眼，不拿出，因为有可能没有必要替换</span></span><br><span class="line">                Integer topEle = minHeap.peek();</span><br><span class="line">                <span class="comment">// 只要当前遍历的元素比堆顶元素大，堆顶弹出，遍历的元素进去</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; topEle) &#123;</span><br><span class="line">                    minHeap.poll();</span><br><span class="line">                    minHeap.add(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> minHeap.peek();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// System.out.println("使用最大堆");</span></span><br><span class="line">            <span class="keyword">assert</span> k &gt; len - k;</span><br><span class="line">            <span class="comment">// 特例：k = 100，用容量为 len - k + 1 的最大堆</span></span><br><span class="line">            <span class="keyword">int</span> capacity = len - k + <span class="number">1</span>;</span><br><span class="line">            PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(capacity, (a, b) -&gt; b - a);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">                maxHeap.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = capacity; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="comment">// 看一眼，不拿出，因为有可能没有必要替换</span></span><br><span class="line">                Integer topEle = maxHeap.peek();</span><br><span class="line">                <span class="comment">// 只要当前遍历的元素比堆顶元素大，堆顶弹出，遍历的元素进去</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt; topEle) &#123;</span><br><span class="line">                    maxHeap.poll();</span><br><span class="line">                    maxHeap.add(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> maxHeap.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解法二 ： 暴力</strong></p><ul><li>最简单同时也一定是最容易编码的，编码成功的几率最高，可以用这个最简单思路编码的结果和其它思路编码的结果进行比对，验证高级算法的正确性；</li><li>在数据规模小、对时间复杂度、空间复杂度要求不高的时候，简单问题简单做；</li></ul><p>题目要求我们找到“数组排序后的第 k个最大的元素，而不是第 k个不同的元素” ，</p><ul><li>语义是从右边往左边数第 k个元素（从 1开始），那么从左向右数是第几个呢，我们列出几个找找规律就好了。</li><li>一共 6 个元素，找第 2 大，索引是 44；</li><li>一共 6个元素，找第 4 大，索引是 2。</li></ul><p>因此，升序排序以后，<strong>目标元素的索引是 <code>len - k</code></strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[len - k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：O(NlogN)，这里 NN 是数组的长度，算法的性能消耗主要在排序，JDK 默认使用快速排序，因此时间复杂度为 O(NlogN)。</li><li><strong>空间复杂度</strong>：O(1)，这里是原地排序，没有借助额外的辅助空间。</li></ul><p><strong>解法三 ： partition</strong></p><ul><li>学习过 “快速排序” 的朋友，一定知道一个操作叫 partition，它是 “分而治之” 思想当中 “分” 的那一步。</li><li><strong>经过 partition 操作以后，每一次都能排定一个元素，并且这个元素左边的数都不大于它，这个元素右边的数都不小于它，并且我们还能知道排定以后的元素的索引</strong>。</li><li>于是可以应用 “减而治之”（分治思想的特例）的思想，把问题规模转化到一个更小的范围里。</li></ul><p><strong>思路  ： 借助 partition 操作定位到最终排定以后索引为 <code>len - k</code> 的那个元素</strong></p><blockquote><p>快速排序虽然快，但是如果实现得不好，在遇到特殊测试用例的时候，时间复杂度会变得很高。如果你使用 partition 的方法完成这道题，时间排名不太理想，可以考虑一下是什么问题，这个问题很常见。</p></blockquote><p>以下的描述基于 “快速排序” 算法知识的学习，如果忘记的朋友们可以翻一翻自己的《数据结构与算法》教材，复习一下，partition 过程、分治思想和 “快速排序” 算法的优化。</p><ul><li>分析：我们在学习 “快速排序” 的时候，接触的第 1 个操作就是 partition（切分），简单介绍如下：</li><li>partition（切分）操作，使得：<ul><li>对于某个索引 j，nums[j] 已经排定，即 nums[j] 经过 partition（切分）操作以后会放置在它 “最终应该放置的地方”；</li><li><code>nums[left]</code>到 <code>nums[j - 1]</code> 中的所有元素都不大于<code>nums[j]</code>；</li><li><code>nums[j + 1]</code>到 <code>nums[right]</code> 中的所有元素都不小于 <code>nums[j]</code>。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/151535827.png" alt="mark"></p><ul><li><p><strong><code>partition</code>（切分）操作总能排定一个元素，还能够知道这个元素它最终所在的位置，这样每经过一次 <code>partition（切分）</code>操作就能缩小搜索的范围，这样的思想叫做 “减而治之”（是 “分而治之” 思想的特例）。</strong></p></li><li><p>切分过程可以不借助额外的数组空间，仅通过交换数组元素实现</p></li></ul><p><strong>代码一 ： 正常的pivot</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据题意，第k大元素索引是len - k</span></span><br><span class="line">        <span class="keyword">int</span> target = len - k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = partition(nums,left,right);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(index == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[index];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index &lt; target)&#123;</span><br><span class="line">                left = index + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = index - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在数组 nums 的子区间 [left, right] 执行 partition 操作，返回 nums[left] 排序以后应该在的位置</span></span><br><span class="line"><span class="comment">    * 在遍历过程中保持循环不变量的语义</span></span><br><span class="line"><span class="comment">    * 1、[left + 1, j] &lt; nums[left]</span></span><br><span class="line"><span class="comment">    * 2、(j, i] &gt;= nums[left]</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[left];</span><br><span class="line">        <span class="keyword">int</span> j = left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left + <span class="number">1</span>;i &lt;= right;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; pivot)&#123;</span><br><span class="line">                <span class="comment">// 小于pivot的元素都交换到pivot前面</span></span><br><span class="line">                j++;</span><br><span class="line">                swap(nums,j,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在之前的遍历过程中，满足[left + 1,j] &lt; pivot 并且 (j,i] &gt;= pivot</span></span><br><span class="line">        swap(nums,j,left);</span><br><span class="line">        <span class="comment">// 交换以后 [left, j - 1] &lt; pivot, nums[j] = pivot, [j + 1, right] &gt;= pivot</span></span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index1,<span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index1 == index2)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index2] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li><strong>时间复杂度</strong>：O(N)，这里 N 是数组的长度</li><li><strong>空间复杂度</strong>：O(1)，原地排序，没有借助额外的辅助空间。</li></ul><p><strong>代码二： random随机化pivot</strong></p><blockquote><p><strong>注意：本题必须随机初始化 <code>pivot</code> 元素，否则通过时间会很慢，因为测试用例中有极端测试用例。</strong></p></blockquote><ul><li><p><strong>为了应对极端测试用例，使得递归树加深，</strong>可以在循环一开始的时候，随机交换第 1个元素与它后面的任意 1 个元素的位置；</p></li><li><p>说明：最极端的是顺序数组与倒序数组，此时递归树画出来是链表，时间复杂度是 O(N^2) 根本达不到减治的效果。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> target = len - k;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = partition(nums, left, right);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; target) &#123;</span><br><span class="line">                left = index + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; target) &#123;</span><br><span class="line">                right = index - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在区间 [left, right] 这个区间执行 partition 操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在区间随机选择一个元素作为标定点</span></span><br><span class="line">        <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">            <span class="keyword">int</span> randomIndex = left + <span class="number">1</span> + random.nextInt(right - left);</span><br><span class="line">            swap(nums, left, randomIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pivot = nums[left];</span><br><span class="line">        <span class="keyword">int</span> j = left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                swap(nums, j, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, left, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码三 : 使用双指针，将与 <code>pivot</code> 相等的元素等概论地分到 <code>pivot</code> 最终排定位置的两边。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换一下，第 k 大元素的索引是 len - k</span></span><br><span class="line">        <span class="keyword">int</span> target = len - k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = partition(nums, left, right);</span><br><span class="line">            <span class="keyword">if</span> (index == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[index];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; target) &#123;</span><br><span class="line">                left = index + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = index - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在区间随机选择一个元素作为标定点</span></span><br><span class="line">        <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">            <span class="keyword">int</span> randomIndex = left + <span class="number">1</span> + random.nextInt(right - left);</span><br><span class="line">            swap(nums, left, randomIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pivot = nums[left];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将等于 pivot 的元素分散到两边</span></span><br><span class="line">        <span class="comment">// [left, lt) &lt;= pivot</span></span><br><span class="line">        <span class="comment">// (rt, right] &gt;= pivot</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lt = left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rt = right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (lt &lt;= rt &amp;&amp; nums[lt] &lt; pivot) &#123;</span><br><span class="line">                lt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (lt &lt;= rt &amp;&amp; nums[rt] &gt; pivot) &#123;</span><br><span class="line">                rt--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (lt &gt; rt) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, lt, rt);</span><br><span class="line">            lt++;</span><br><span class="line">            rt--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        swap(nums, left, rt);</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;partition-合集&quot;&gt;&lt;a href=&quot;#partition-合集&quot; class=&quot;headerlink&quot; title=&quot;partition-合集&quot;&gt;&lt;/a&gt;partition-合集&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/101823939.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-什么是-partition-？&quot;&gt;&lt;a href=&quot;#1-什么是-partition-？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是 partition ？&quot;&gt;&lt;/a&gt;1. 什么是 partition ？&lt;/h2&gt;&lt;p&gt;我们在学习 快速排序 的时候知道，可以选择一个标定元素（称为 pivot ，一般而言随机选择），然后通过一次扫描，把数组分成三个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第 1 部分严格小于 pivot 元素的值；&lt;/li&gt;
&lt;li&gt;第 2 部分恰好等于 pivot 元素的值；&lt;/li&gt;
&lt;li&gt;第 3 部分严格大于 pivot 元素的值。&lt;/li&gt;
&lt;li&gt;第 2 部分元素就是排好序以后它们应该在的位置，接下来只需要递归处理第 1 部分和第 3 部分的元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;经过一次扫描把整个数组分成 3 个部分，正好符合当前问题的场景。写对这道题的方法是：把循环不变量的定义作为注释写出来，然后再编码。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="partition" scheme="http://zhuuu.work/tags/partition/"/>
    
      <category term="循环不变量" scheme="http://zhuuu.work/tags/%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-09-进程调度算法</title>
    <link href="http://zhuuu.work/2020/10/06/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-09-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <id>http://zhuuu.work/2020/10/06/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-09-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</id>
    <published>2020-10-06T07:22:53.000Z</published>
    <updated>2020-10-07T04:05:21.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-09-进程调度算法"><a href="#Linux-09-进程调度算法" class="headerlink" title="Linux-09-进程调度算法"></a>Linux-09-进程调度算法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg" alt="mark"></p><ul><li>进程调度算法也称 CPU 调度算法，毕竟进程是由 CPU 调度的。</li><li>当 CPU 空闲时，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配 CPU。</li></ul><p>什么时候会发生 CPU 调度呢？通常有以下情况：</p><ol><li>当进程从运行状态转到等待状态；</li><li>当进程从运行状态转到就绪状态；</li><li>当进程从等待状态转到就绪状态；</li><li>当进程从运行状态转到终止状态；</li></ol><p>其中发生在 1 和 4 两种情况下的调度称为「非抢占式调度」，2 和 3 两种情况下发生的调度称为「抢占式调度」。</p><ul><li><strong>非抢占式</strong>的意思就是，当进程正在运行时，它就会一直运行，直到该进程完成或发生某个事件而被阻塞时，才会把 CPU 让给其他进程。</li><li>而<strong>抢占式调度</strong>，顾名思义就是进程正在运行的时，可以被打断，使其把 CPU 让给其他进程。那抢占的原则一般有三种，分别是时间片原则、优先权原则、短作业优先原则。</li></ul><a id="more"></a><ul><li>你可能会好奇为什么第 3 种情况也会发生 CPU 调度呢？<ul><li>假设有一个进程是处于等待状态的，但是它的优先级比较高，如果该进程等待的事件发生了，它就会转到就绪状态</li><li>一旦它转到就绪状态，如果我们的调度算法是以优先级来进行调度的，那么它就会立马抢占正在运行的进程，所以这个时候就会发生 CPU 调度。</li></ul></li></ul><ul><li>那第 2 种状态通常是时间片到的情况，因为时间片到了就会发生中断，于是就会抢占正在运行的进程，从而占用 CPU。</li></ul><p>调度算法影响的是等待时间（进程在就绪队列中等待调度的时间总和），而不能影响进程正在使用 CPU 的时间和 I/O 时间。</p><p>接下来，说说常见的调度算法：</p><ul><li>先来先服务调度算法</li><li>最短作业优先调度算法</li><li>高响应比优先调度算法</li><li>时间片轮转调度算法</li><li>最高优先级调度算法</li><li>多级反馈队列调度算法</li></ul><h2 id="1-进程调度算法"><a href="#1-进程调度算法" class="headerlink" title="1. 进程调度算法"></a>1. 进程调度算法</h2><h3 id="1-1-先来先服务调度算法"><a href="#1-1-先来先服务调度算法" class="headerlink" title="1.1 先来先服务调度算法"></a>1.1 先来先服务调度算法</h3><ul><li>最简单的一个调度算法，就是非抢占式的<strong>先来先服务（First Come First Severd, FCFS）算法</strong>了。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114729145.jpg" alt="mark"></p><ul><li>顾名思义，先来后到，<strong>每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</strong></li></ul><p><strong>缺点：</strong></p><ul><li>这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。（<strong>不会导致饥饿的产生</strong>）</li><li>FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I/O 繁忙型作业的系统。</li></ul><p><strong>小结：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153514117.png" alt="mark"></p><p><strong>例题分析</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153527091.png" alt="mark"></p><h3 id="1-2-最短作业优先调度算法"><a href="#1-2-最短作业优先调度算法" class="headerlink" title="1.2 最短作业优先调度算法"></a>1.2 最短作业优先调度算法</h3><ul><li><strong>最短作业优先（Shortest Job First, SJF）调度算法</strong>同样也是顾名思义，它会<strong>优先选择运行时间最短的进程来运行</strong>，这有助于提高系统的吞吐量。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114846841.jpg" alt="mark"></p><p><strong>缺点：</strong></p><ul><li>这显然对长作业不利，很容易造成一 种极端现象。（<strong>进程饥饿</strong>）</li><li>比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。</li></ul><p><strong>小结：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153545137.png" alt="mark"></p><p><strong>非抢占式—SJF</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153623881.png" alt="mark"></p><p><strong>抢占式—SJF(SRTN)</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153635107.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153640245.png" alt="mark"></p><h3 id="1-3-高响应比优先调度算法"><a href="#1-3-高响应比优先调度算法" class="headerlink" title="1.3 高响应比优先调度算法"></a>1.3 高响应比优先调度算法</h3><ul><li>前面的「先来先服务调度算法」和「最短作业优先调度算法」都没有很好的权衡短作业和长作业。</li><li>那么，<strong>高响应比优先 （Highest Response Ratio Next, HRRN）调度算法</strong>主要是权衡了短作业和长作业。</li><li><strong>每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行</strong>，「响应比优先级」的计算公式：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/135439932.png" alt="mark"></p><p>从上面的公式，可以发现：</p><ul><li><p><strong>如果两个进程的「等待时间」相同时</strong>，「要求的服务时间」越短，「响应比」就越高，这样短作业的进程容易被选中运行；</p></li><li><p><strong>如果两个进程「要求的服务时间」相同时</strong>，「等待时间」越长，「响应比」就越高，这就兼顾到了长作业进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会；</p></li><li><p><strong>不会导致饥饿</strong></p></li></ul><p><strong>小结：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153711214.png" alt="mark"></p><p><strong>例题分析</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153719376.png" alt="mark"></p><p><strong>上面三种算法注重的是进程调度的性能</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120514747.png" alt="mark"></p><hr><p><strong>下面三种算法注重的是用户交互的功能和性能的综合</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120440278.png" alt="mark"></p><h3 id="1-4-时间片轮转调度算法"><a href="#1-4-时间片轮转调度算法" class="headerlink" title="1.4 时间片轮转调度算法"></a>1.4 时间片轮转调度算法</h3><ul><li>最古老、最简单、最公平且使用最广的算法就是<strong>时间片轮转（*Round Robin, RR*）调度算法</strong>。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/135825753.png" alt="mark"></p><p><strong>每个进程被分配一个时间段，称为时间片（Quantum），即允许该进程在该时间段中运行。</strong></p><ul><li>如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程；</li><li>如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；</li></ul><p>另外，时间片的长度就是一个很关键的点：</p><ul><li>如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；</li><li>如果设得太长又可能引起对短作业进程的响应时间变长；</li></ul><p>通常时间片设为 <code>20ms~50ms</code> 通常是一个比较合理的折中值。</p><p><strong>小结</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/115816124.png" alt="mark"></p><p><strong>例题分析</strong></p><ul><li><strong>时间片为2举例</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/115903072.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/115911628.png" alt="mark"></p><ul><li><strong>以时间片为5举例</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/115927677.png" alt="mark"></p><ul><li><strong>可能出现的问题，比如与FCFS对比</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/115941047.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120001175.png" alt="mark"></p><h3 id="1-5-最高优先级调度算法"><a href="#1-5-最高优先级调度算法" class="headerlink" title="1.5 最高优先级调度算法"></a>1.5 最高优先级调度算法</h3><ul><li>前面的「时间片轮转算法」做了个假设，即让所有的进程同等重要，也不偏袒谁，大家的运行时间都一样。</li><li>但是，对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能<strong>从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（Highest Priority First，HPF）调度算法</strong>。</li></ul><p>进程的优先级可以分为，静态优先级或动态优先级：</p><ul><li><strong>静态优先级</strong>：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；</li><li><strong>动态优先级</strong>：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是<strong>随着时间的推移增加等待进程的优先级</strong>。</li></ul><p>该算法也有两种处理优先级高的方法，非抢占式和抢占式</p><ul><li><strong>非抢占式</strong>：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。</li><li><strong>抢占式</strong>：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。</li></ul><p><strong>缺点：</strong></p><p>但是依然有缺点，可能会导致低优先级的进程永远不会运行。</p><p><strong>小结</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120040368.png" alt="mark"></p><ul><li><strong>非抢占式例子</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120142289.png" alt="mark"></p><ul><li><strong>抢占式例子</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120158415.png" alt="mark"></p><ul><li><strong>优先级原则</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120213748.png" alt="mark"></p><h3 id="1-6-多级反馈队列调度算法"><a href="#1-6-多级反馈队列调度算法" class="headerlink" title="1.6 多级反馈队列调度算法"></a>1.6 多级反馈队列调度算法</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120242696.png" alt="mark"></p><ul><li><strong>多级反馈队列（Multilevel Feedback Queue）调度算法</strong>是「时间片轮转算法」和「最高优先级算法」的综合和发展。</li></ul><p>顾名思义：</p><ul><li>「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。</li><li>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/140252098.png" alt="mark"></p><p>来看看，它是如何工作的：</p><ul><li>设置了多个队列，赋予每个队列不同的优先级，每个<strong>队列优先级从高到低</strong>，同时<strong>优先级越高时间片越短</strong>；</li><li>新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；</li><li><strong>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行</strong>。</li><li>如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；(<strong>抢占式</strong>)</li></ul><p><strong>缺点：</strong></p><ul><li><strong>会导致进程饥饿</strong></li></ul><p><strong>小结：</strong></p><p>可以发现，对于<strong>短作业</strong>可能可以在第一级队列很快被处理完。</p><p>对于<strong>长作业</strong>，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了，所以该算法很好的<strong>兼顾了长短作业，同时有较好的响应时间。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120339197.png" alt="mark"></p><p><strong>例题分析</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120356739.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120402334.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120409886.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120414590.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120423613.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/120430247.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-09-进程调度算法&quot;&gt;&lt;a href=&quot;#Linux-09-进程调度算法&quot; class=&quot;headerlink&quot; title=&quot;Linux-09-进程调度算法&quot;&gt;&lt;/a&gt;Linux-09-进程调度算法&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程调度算法也称 CPU 调度算法，毕竟进程是由 CPU 调度的。&lt;/li&gt;
&lt;li&gt;当 CPU 空闲时，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配 CPU。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;什么时候会发生 CPU 调度呢？通常有以下情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当进程从运行状态转到等待状态；&lt;/li&gt;
&lt;li&gt;当进程从运行状态转到就绪状态；&lt;/li&gt;
&lt;li&gt;当进程从等待状态转到就绪状态；&lt;/li&gt;
&lt;li&gt;当进程从运行状态转到终止状态；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中发生在 1 和 4 两种情况下的调度称为「非抢占式调度」，2 和 3 两种情况下发生的调度称为「抢占式调度」。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;非抢占式&lt;/strong&gt;的意思就是，当进程正在运行时，它就会一直运行，直到该进程完成或发生某个事件而被阻塞时，才会把 CPU 让给其他进程。&lt;/li&gt;
&lt;li&gt;而&lt;strong&gt;抢占式调度&lt;/strong&gt;，顾名思义就是进程正在运行的时，可以被打断，使其把 CPU 让给其他进程。那抢占的原则一般有三种，分别是时间片原则、优先权原则、短作业优先原则。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="进程调度" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-08-进程调度</title>
    <link href="http://zhuuu.work/2020/10/06/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-08-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    <id>http://zhuuu.work/2020/10/06/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-08-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</id>
    <published>2020-10-06T07:20:53.000Z</published>
    <updated>2020-10-06T07:32:24.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-08-进程调度"><a href="#操作系统-08-进程调度" class="headerlink" title="操作系统-08-进程调度"></a>操作系统-08-进程调度</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152620848.png" alt="mark"></p><a id="more"></a><h2 id="1-进程调度的时机"><a href="#1-进程调度的时机" class="headerlink" title="1. 进程调度的时机"></a>1. 进程调度的时机</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152708655.png" alt="mark"></p><p><strong>那么什么时候不能进行进程调度呢？</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152758459.png" alt="mark"></p><h2 id="2-进程调度的方式"><a href="#2-进程调度的方式" class="headerlink" title="2. 进程调度的方式"></a>2. 进程调度的方式</h2><ul><li><strong>所谓进程调度方式</strong>，是指当某个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要处理，即有优先权更高的进程进入就绪队列，此时应如何分配处理机。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153113771.png" alt="mark"></p><h2 id="3-进程的切换"><a href="#3-进程的切换" class="headerlink" title="3. 进程的切换"></a>3. 进程的切换</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/153208197.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-08-进程调度&quot;&gt;&lt;a href=&quot;#操作系统-08-进程调度&quot; class=&quot;headerlink&quot; title=&quot;操作系统-08-进程调度&quot;&gt;&lt;/a&gt;操作系统-08-进程调度&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152620848.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="进程调度" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-07-CPU调度</title>
    <link href="http://zhuuu.work/2020/10/06/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-07-CPU%E8%B0%83%E5%BA%A6/"/>
    <id>http://zhuuu.work/2020/10/06/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-07-CPU%E8%B0%83%E5%BA%A6/</id>
    <published>2020-10-06T07:00:53.000Z</published>
    <updated>2020-10-06T07:25:55.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-07-CPU调度"><a href="#操作系统-07-CPU调度" class="headerlink" title="操作系统-07-CPU调度"></a>操作系统-07-CPU调度</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152136370.png" alt="mark"></p><h2 id="1-调度的基本概念"><a href="#1-调度的基本概念" class="headerlink" title="1. 调度的基本概念"></a>1. 调度的基本概念</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152233238.png" alt="mark"></p><a id="more"></a><h2 id="2-调度的三个层次"><a href="#2-调度的三个层次" class="headerlink" title="2. 调度的三个层次"></a>2. 调度的三个层次</h2><h5 id="（1）高级调度（-作业调度）"><a href="#（1）高级调度（-作业调度）" class="headerlink" title="（1）高级调度（ 作业调度）"></a>（1）高级调度（ 作业调度）</h5><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152300101.png" alt="mark"></p><h5 id="（2）中级调度（内存调度）"><a href="#（2）中级调度（内存调度）" class="headerlink" title="（2）中级调度（内存调度）"></a>（2）中级调度（内存调度）</h5><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152329541.png" alt="mark"></p><h5 id="（3）进程的挂起状态与七状态模型"><a href="#（3）进程的挂起状态与七状态模型" class="headerlink" title="（3）进程的挂起状态与七状态模型"></a>（3）进程的挂起状态与七状态模型</h5><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152353463.png" alt="mark"></p><h5 id="（4）低级调度（进程调度）"><a href="#（4）低级调度（进程调度）" class="headerlink" title="（4）低级调度（进程调度）"></a>（4）低级调度（进程调度）</h5><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152402582.png" alt="mark"></p><h5 id="三层调度的联系和对比"><a href="#三层调度的联系和对比" class="headerlink" title="三层调度的联系和对比"></a>三层调度的联系和对比</h5><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152427705.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-07-CPU调度&quot;&gt;&lt;a href=&quot;#操作系统-07-CPU调度&quot; class=&quot;headerlink&quot; title=&quot;操作系统-07-CPU调度&quot;&gt;&lt;/a&gt;操作系统-07-CPU调度&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152136370.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-调度的基本概念&quot;&gt;&lt;a href=&quot;#1-调度的基本概念&quot; class=&quot;headerlink&quot; title=&quot;1. 调度的基本概念&quot;&gt;&lt;/a&gt;1. 调度的基本概念&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/152233238.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="进程调度" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-018-四数之和</title>
    <link href="http://zhuuu.work/2020/10/05/Leetcode/Leetcode-018-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://zhuuu.work/2020/10/05/Leetcode/Leetcode-018-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2020-10-05T11:52:53.000Z</published>
    <updated>2020-10-06T12:33:44.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-18-四数之和"><a href="#Leecode-18-四数之和" class="headerlink" title="Leecode-18. 四数之和"></a>Leecode-<a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a></h1><h2 id="思路：排序-双指针"><a href="#思路：排序-双指针" class="headerlink" title="思路：排序+双指针"></a>思路：排序+双指针</h2><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p><strong>注意：</strong></p><p>答案中不可以包含重复的四元组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums &#x3D; [1, 0, -1, 0, -2, 2]，和 target &#x3D; 0。</span><br><span class="line"></span><br><span class="line">满足要求的四元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法：排序-双指针"><a href="#方法：排序-双指针" class="headerlink" title="方法：排序+双指针"></a>方法：排序+双指针</h2><p><strong>算法思路（同leetcode015 所以这里不再阐述 有15题基础看代码就秒懂了）</strong></p><ul><li>首先对排序后的数组进行遍历，固定一个nums[i] 。</li><li>其次使用一个指针L指向 <code>i + 1</code> 的位置，一个指针R指向 <code>nums.length - 1</code>的位置，同时计算<code>nums[i] + nums[L] + nums[R]</code>,计算这三个数的和是否等于0</li><li>细节条件一定要注意<ul><li>如果<code>nums[i] &gt; 0</code> ，那么这三个数的和比不可能等于0</li><li>如果<code>nums[i] == nums[i -1]</code> ,则说明该数字重复，会导致结果的重复，所以应该跳过</li><li>当sum == 0的时候，如果<code>nums[L] == nums[L+1]</code>,则会导致结果的重复，应该跳过，(L++)</li><li>当sum == 0的时候，如果<code>nums[R] == nums[R - 1]</code>,则会导致结果的重复，应该跳过，(R–)</li></ul></li></ul><p><strong>举个例子：</strong></p><ol><li><strong>首先进行排序</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100358932.png" alt="mark"></p><ol start="2"><li><strong>第一轮循环</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100418544.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100451353.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100458185.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100504327.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100511291.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100527129.png" alt="mark"></p><ol start="3"><li><strong>第二轮循环</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100538257.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100548763.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100554929.png" alt="mark"></p><ol start="4"><li><strong>第三轮循环</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100609939.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200625/100615721.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// 结果集</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.对数组进行排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 双指针遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len - <span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// 剪枝操作</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[len - <span class="number">3</span>] + nums[len - <span class="number">2</span>] + nums[len - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j  &lt; len - <span class="number">2</span>;j++)&#123;</span><br><span class="line">                <span class="comment">// 剪枝操作</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>] &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[len - <span class="number">2</span>] + nums[len - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 双指针操作</span></span><br><span class="line">                <span class="keyword">int</span> left  = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 找到对应的结果</span></span><br><span class="line">                    <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                        res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 去重操作</span></span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>])&#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        left++;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 去重操作</span></span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>])&#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                        <span class="comment">// 和小于target</span></span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// 和大于target</span></span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;          </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(fourSum(arr,<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li><p><strong>时间复杂度</strong>：O（n^3） 排序O(nlogn) + 循环O（n^3） = O(n^3)</p></li><li><p><strong>空间复杂度</strong>：O(n)，其中 n 是数组的长度。空间复杂度主要取决于排序额外使用的空间。此外排序修改了输入数组 nums，实际情况中不一定允许，因此也可以看成使用了一个额外的<strong>数组存储了数组nums 的副本并排序</strong>，空间复杂度为 O(n)。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-18-四数之和&quot;&gt;&lt;a href=&quot;#Leecode-18-四数之和&quot; class=&quot;headerlink&quot; title=&quot;Leecode-18. 四数之和&quot;&gt;&lt;/a&gt;Leecode-&lt;a href=&quot;https://leetcode-cn.com/problems/4sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;18. 四数之和&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：排序-双指针&quot;&gt;&lt;a href=&quot;#思路：排序-双指针&quot; class=&quot;headerlink&quot; title=&quot;思路：排序+双指针&quot;&gt;&lt;/a&gt;思路：排序+双指针&lt;/h2&gt;&lt;p&gt;给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答案中不可以包含重复的四元组。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定数组 nums &amp;#x3D; [1, 0, -1, 0, -2, 2]，和 target &amp;#x3D; 0。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;满足要求的四元组集合为：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [-1,  0, 0, 1],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [-2, -1, 1, 2],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [-2,  0, 0, 2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="排序" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-06-线程</title>
    <link href="http://zhuuu.work/2020/10/05/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-06-%E7%BA%BF%E7%A8%8B/"/>
    <id>http://zhuuu.work/2020/10/05/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-06-%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-10-05T02:00:53.000Z</published>
    <updated>2020-10-04T10:59:25.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-06-线程"><a href="#操作系统-06-线程" class="headerlink" title="操作系统-06-线程"></a>操作系统-06-线程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185326649.png" alt="mark"></p><a id="more"></a><h2 id="1-为什么要引入线程？"><a href="#1-为什么要引入线程？" class="headerlink" title="1. 为什么要引入线程？"></a>1. 为什么要引入线程？</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185358306.png" alt="mark"></p><ul><li>为了方便于理解，我打开了我的任务管理器，可以看出chrome一个进程，下面有很多分支，可以把这些分支当做线程看待，PID即进程和线程都有的标识符。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185415092.png" alt="mark"></p><h2 id="2-线程的定义"><a href="#2-线程的定义" class="headerlink" title="2. 线程的定义"></a>2. 线程的定义</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185431932.png" alt="mark"></p><ul><li>资源分配、调度<br>传统进程机制中，<strong>进程是资源分配、调度的基本单位</strong><br><strong>引入线程后，进程是资源分配的基本单位，线程是调度的基本单位</strong></li><li>并发性<br>传统进程机制，只能进程间并发<br>现在各线程之间也能并发</li><li>系统开销<br>传统进程并发，需要<strong>切换进程的运行环境，系统开销大</strong><br><strong>同一个进程内的线程间并发，不需要切换环境，开销小</strong></li></ul><h2 id="3-线程的属性"><a href="#3-线程的属性" class="headerlink" title="3. 线程的属性"></a>3. 线程的属性</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185546111.png" alt="mark"></p><p>内核线程是处理机调度的单位，线程几乎不拥有系统资源，同一个进程的线程间共享进程资源，各个线程可以占用不同的CPU。 线程有自己的ID，线程控制块TCP，线程也有就绪、阻塞、运行三种基本状态。 同一进程内的线程通信无需系统干预，线程切换不会引起进程切换，系统开销很小。 不同进程的线程切换会导致进程切换。</p><h2 id="4-线程的实现方式"><a href="#4-线程的实现方式" class="headerlink" title="4. 线程的实现方式"></a>4. 线程的实现方式</h2><p><strong>用户级线程</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185636034.png" alt="mark"></p><p><strong>内核级线程</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185659747.png" alt="mark"></p><p><strong>组合方式</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185720348.png" alt="mark"></p><h2 id="5-多线程模型"><a href="#5-多线程模型" class="headerlink" title="5. 多线程模型"></a>5. 多线程模型</h2><p><strong>多对一模型</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185810274.png" alt="mark"></p><p><strong>一对一模型</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185824641.png" alt="mark"></p><p><strong>多对多模型</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185839178.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-06-线程&quot;&gt;&lt;a href=&quot;#操作系统-06-线程&quot; class=&quot;headerlink&quot; title=&quot;操作系统-06-线程&quot;&gt;&lt;/a&gt;操作系统-06-线程&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/185326649.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>好文阅读-01-后端学习路线</title>
    <link href="http://zhuuu.work/2020/10/04/recommendation/%E5%A5%BD%E6%96%87%E9%98%85%E8%AF%BB-01-%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <id>http://zhuuu.work/2020/10/04/recommendation/%E5%A5%BD%E6%96%87%E9%98%85%E8%AF%BB-01-%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</id>
    <published>2020-10-04T10:32:24.000Z</published>
    <updated>2020-10-04T14:30:00.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="好文阅读-01-后端学习路线"><a href="#好文阅读-01-后端学习路线" class="headerlink" title="好文阅读-01-后端学习路线"></a>好文阅读-01-后端学习路线</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><strong>说到后端开发，难免会遇到各种所谓高大上的「关键词 」，对于我们应届生小白，难免会觉得比较陌生，因为在学校确实比较少遇见这些所谓高大上的东西，那么今天就带着学习的态度和大家分享这些看似可以装逼可以飞的带逼格的关键词吧。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/152056275.jpg" alt="mark"></p><a id="more"></a><h2 id="1-分布式"><a href="#1-分布式" class="headerlink" title="1. 分布式"></a>1. 分布式</h2><blockquote><p>在学校里的项目中，一个 Web 系统可能咋们一个人就搞定，因为几乎不考虑并发量，性能咋样，所谓「<strong>过得去</strong> 」足矣，但是为了面试考虑，我们又不得不找点类似<strong>秒杀系统</strong>作为我们简历的支撑项目(即使已经烂大街)。那么先问你第一个问题，为什么就采用了<strong>分布式</strong>的方案落地这个项目？</p></blockquote><ul><li>当一个人或者几十个使用你的系统，哎呀我去，请求秒回，效果倍棒，于是乎简历砰砰写上却多么牛X，当面试官就会问你你这项目做了啥，测试过没，并发量如何，性能如何？你就…..</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/155639381.gif" alt="mark"></p><ul><li>当访问系统的用户越来越多，可是我们的系统资源有限，所以需要更多的 <strong>CPU</strong> 和<strong>内存</strong>去处理用户的计算请求，当然也就要求更大的<strong>网络带宽</strong>去处理数据的传输，也需要更多的磁盘空间存储数据。资源不够，消耗过度，服务器崩溃，系统也就不干活了，那么在这样的情况怎么处理？</li></ul><h3 id="1-1-垂直伸缩"><a href="#1-1-垂直伸缩" class="headerlink" title="1.1 垂直伸缩"></a>1.1 垂直伸缩</h3><blockquote><p>纵向生长。通过提升<strong>单台</strong>服务器的<strong>计算处理</strong>能力来抵抗更大的请求访问量。比如使用更快频率的CPU，更快的网卡，塞更多的磁盘等。其实这样的处理方式在电信，银行等企业比较常见，让摩托车变为小汽车，更强大的计算机，处理能力也就越强，但是对于运维而言也就越来越复杂。那真的就这样花钱买设备就完事了？</p></blockquote><ul><li>当然不，单台服务器的计算处理能力是有限的，而且也会严重受到计算机硬件水平的制约。</li></ul><h3 id="1-2-水平伸缩"><a href="#1-2-水平伸缩" class="headerlink" title="1.2 水平伸缩"></a>1.2 水平伸缩</h3><blockquote><p>一台机器处理不过来，我就用多台<strong>廉价</strong>的机器合并同时处理，人多力量大嘛，通过多台服务器构成分布式集群从而提升系统的整体处理能力。这里说到了分布式，那我们看看分布式的成长过程</p></blockquote><p>记住一句话：<strong>系统的技术架构是需求所驱动</strong></p><ul><li>最初的<strong>单体系统</strong>，只需要部分用户访问，</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/160035576.png" alt="mark"></p><p>做系统的原因当然是有需求，有价值，可赚钱。</p><p>随着使用系统的用户越来越多，这时候关注的人越来越多，单台服务器扛不住了，关注的人觉得响应真慢，没啥意思，就开始吐槽，但是这一吐槽，导致用户更多，毕竟大家都爱吃瓜。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/160108772.gif" alt="mark"></p><ul><li>这样下去不得不进行系统的升级，将<strong>数据库和应用</strong>分离。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/160133438.png" alt="mark"></p><p>这样子，咋们将数据库和应用程序分离后，部署在不同的服务器中，从1台服务器变为多台服务器，处理响应更快，内容也够干，访问的用户呈<strong>指数增长</strong>，这多台服务器都有点扛不住了，怎么办？</p><p>加一个<strong>缓存</strong>吧，我们不每次从数据库中读取数据，而将应用程序需要的数据暂存在<strong>缓冲</strong>中。缓存呢，又分为<strong>本地缓存</strong>和<strong>分布式的缓存</strong>。分布式缓存，顾名思义，使用多台服务器构成集群，存储更多的数据并提供缓存服务，从而提升缓存的能力。</p><ul><li><strong>加了缓存哪些好处？</strong></li></ul><p>应用程序不再直接访问数据库，提升访问效率。因为缓存内容在内存中，不用每次连接存放磁盘中的数据库，</p><p>系统越来越火，于是考虑将应用服务器也作为<strong>集群</strong>。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/160223826.png" alt="mark"></p><h2 id="2-缓存架构"><a href="#2-缓存架构" class="headerlink" title="2. 缓存架构"></a>2. 缓存架构</h2><blockquote><p>干啥啥不行，缓存第一名。不吹牛，缓存应用在计算机的各个角落。<strong>缓存</strong>可说是软件技术中的的杀手锏，无论是程序代码使用buffer，还是网络架构中使用缓存，虚拟机也会使用大量的缓存。其实最初在CPU中也就开始使用缓存。缓存分为两种，一种是<strong>通读缓存</strong>，一种是<strong>旁路缓存</strong></p></blockquote><h3 id="2-1-通读缓存"><a href="#2-1-通读缓存" class="headerlink" title="2.1 通读缓存"></a>2.1 通读缓存</h3><ul><li>假设当前应用程序获取数据，如果数据存在于通读缓存中就直接返回。如果不存在于通读缓存，那么就访问数据源，同时将数据存放于缓存中。下次访问就直接从缓存直接获取。比较常见的为<strong>CDN</strong>和<strong>反向代理</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/160318763.png" alt="mark"></p><p><strong>CDN</strong></p><blockquote><p>CDN称为内容分发网络。想象我们京东购物的时候，假设我们在成都，如果买的东西在成都仓库有就直接给我们寄送过来，可能半天就到了，用户体验也非常好，就不用从北京再寄过来。同样的道理，用户就可以近距离获得自己需要的数据，既提高了响应速度，又节约了网络带宽和服务器资源。</p></blockquote><h3 id="2-2-旁路缓存"><a href="#2-2-旁路缓存" class="headerlink" title="2.2 旁路缓存"></a>2.2 旁路缓存</h3><ul><li>应用程序需要自己从数据源读取数据，然后将这个数据写入到<strong>旁路缓存</strong>中。</li><li>这样，下次应用程序需要数据的时候，就可以通过旁路缓存直接获得数据了</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/160429403.png" alt="mark"></p><p><strong>缓存的好处</strong></p><ul><li>因为大部分缓存的数据存储在内存中，相比于硬盘或者从网络中获取效率更高，响应时间更快，性能更好</li><li>通过 <strong>CDN</strong> 等通读缓存可以降低服务器的负载能力。</li><li>因为缓存通常会记录计算结果。如果缓存命中直接返回，否则需要进行大量的运算。所以使用缓存也减少了<strong>CPU</strong> 的计算消耗，加快处理速度</li></ul><p><strong>缓存缺点</strong></p><ul><li><p>我们缓存的数据来自源数据，如果源数据被修改了，俺么缓存数据很肯能也是被修改过的，成为脏数据，所以怎么办？</p></li><li><p>过期失效</p></li></ul><blockquote><p>在每次写入缓存数据的时候标记失效时间，读取数据的时候检查数据是否失效，如果失效了就重新从数据源获取数据。、</p></blockquote><ul><li>失效通知</li></ul><blockquote><p>应用程序在更新数据源的时候，通知清除缓存中的数据。</p></blockquote><p><strong>是不是数据使用缓存都有意义呢？</strong></p><ul><li>非也，通常放入缓存中的数据都是带有热点的数据，比如当日热卖商品，或者热门吃瓜新闻，这样将数据存放在缓存中，会被多次读取，从而缓存的命中率也会比较高</li></ul><h2 id="3-异步架构"><a href="#3-异步架构" class="headerlink" title="3. 异步架构"></a>3. 异步架构</h2><blockquote><p>在前面中，通过缓存实际上很多时候是解决了读的问题，加快了读取数据的能力。因为缓存通常很难保证数据的持久性和一致性，所以我们通常不会将数据直接写入缓存中，而是写入 RDBMAS 等数据中，那如何提升系统的<strong>写操作性能</strong>呢？</p></blockquote><p><strong>场景：</strong></p><blockquote><p>此时假设两个系统分别为A,B，其中A系统<strong>依赖</strong>B系统，两者通信采用<strong>远程调用</strong>的方式，此时如果B系统出故障，很可能引起A系统出故障。</p><p>从而不得不单独进行升级，怎么办？</p></blockquote><ul><li>使用<strong>消息队列</strong>的异步架构，也称为事件驱动模型。</li></ul><p><strong>异步相对于同步</strong>而言，同步通常是当应用程序调用服务的时候，不得不阻塞等待服务期完成，此时CPU空闲比较浪费，直到返回服务结果后才会继续执行。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/160754809.png" alt="mark"></p><p><strong>同步举例子：</strong></p><blockquote><p>举个例子，小蓝今天想在系统中加一个发邮件的功能，通过SMTP和远程服务器通信，但是远程服务器有很多邮件需要等待发送呢，当前邮件就可能等待比较长时间才能发送成功，发送成功后反馈与应用程序。这个过程中，远程服务器发送邮件的时候，应用程序就阻塞，准确的说是执行应用程序的线程阻塞。</p></blockquote><blockquote><p>这样阻塞带来什么问题“？</p></blockquote><ul><li>不能释放占用的系统资源，导致系统资源不足，影响系统性能</li><li>无法快速给用户响应结果</li></ul><blockquote><p>但是在实际情况中，我们发送邮件，并不需要得到发送结果。比如用户注册，发送账号激活邮件，无论邮件是否发送成功都会收到”返回邮件已经发送，请查收邮件确认激活”，怎样才能让应用程序不阻塞？</p></blockquote><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/160906353.png" alt="mark"></p><p>此时就比较清晰了，调用者将消息发送给消息队列直接返回，应用程序收到返回以后继续执行，快读响应用户释放资源。有专门的消费队列程序从中消息队列取出数据并进行消费。如果远程服务出现故障，只会传递给消费者程序而不会影响到应用程序。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/161031308.png" alt="mark"></p><h3 id="3-1-消息队列模型"><a href="#3-1-消息队列模型" class="headerlink" title="3.1 消息队列模型"></a>3.1 消息队列模型</h3><ul><li>消息队列模型中通常有三个角色，分别为<strong>生产者</strong>，<strong>消息队列</strong>和<strong>消费者</strong>。</li><li>生产者产生数据封装为消息发送给消息队列，专门的消费程序从消息队列中取出数据，消费数据。</li><li>在我看来，消息队列主要是缓冲消息，等待消费者消费。其中<strong>消费的方式分为两种</strong></li></ul><ol><li><strong>点对点</strong></li></ol><blockquote><p>对生产者多消费者的情况。一个消息被一个消费者消费</p></blockquote><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/161152869.png" alt="mark"></p><p>上述的发邮件例子就是典型的点对点模式。互不干扰，其中某个服务出现问题不会印象到全局</p><ol start="2"><li><strong>订阅模式</strong></li></ol><blockquote><p>开发人员在消息队列中设置主题，生产者往相应的主题发送数据，消费者从对应的主题中消费数据，每个消费者按照自己业务逻辑分别进行计算</p></blockquote><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/161242379.png" alt="mark"></p><p>这个比较好理解，比如在用户注册的时候，我们将注册信息放入主题用户中，消费者订阅了这个主题，可能有构造短信消息的消费者，也有推广产品的消费者，都可以根据自己业务逻辑进行数据处理。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/161351841.png" alt="mark"></p><p><strong>使用异步模型的优点</strong></p><ul><li>快速响应</li></ul><blockquote><p>不在需要等待。生产者将数据发送消息队列后，可继续往下执行，不虚等待耗时的消费处理</p></blockquote><ul><li>削峰填谷(需要修改)</li></ul><blockquote><p>互联网产品会在不同的场景其并发请求量不同。互联网应用的访问压力随时都在变化，系统的访问高峰和低谷的并发压力可能也有非常大的差距。如果按照压力最大的情况部署服务器集群，那么服务器在绝大部分时间内都处于<strong>闲置状态</strong>。但利用消息队列，我们可以将需要处理的消息放入消息队列，而消费者可以控制消费速度，因此能够降低系统访问高峰时压力，而在访问低谷的时候还可以继续消费消息队列中<br>未处理的消息，保持系统的资源利用率</p></blockquote><ul><li>降低耦合</li></ul><blockquote><p>如果调用是同步，如果调用是同步的，那么意味着调用者和被调用者必然存在依赖，一方面是代码上的依赖，应用程序需要依赖发送邮件相关的代码，如果需要修改发送邮件的代码，就必须修改应用程序，而且如果要增加新的功能</p></blockquote><p><strong>那么目前主要的消息队列有哪些，其有缺点是什么？</strong>(好好记下这个高频题目啦)</p><h2 id="4-负载均衡"><a href="#4-负载均衡" class="headerlink" title="4. 负载均衡"></a>4. 负载均衡</h2><blockquote><p>一台机器扛不住了，需要多台机器帮忙，既然使用多台机器，就希望不要把压力都给一台机器，所以需要一种或者多种策略分散高并发的计算压力，从而引入负载均衡，那么到底是如何分发到不同的服务器的呢？</p></blockquote><ol><li><strong>砸钱</strong></li></ol><blockquote><p>最初实现负载均衡采取的方案很直接，直接上硬件，当然也就比较贵，互联网的普及，和各位科学家的无私奉献，各个企业开始部署自己的方案，从而出现负载均衡服务器</p></blockquote><ol start="2"><li><strong>HTTP重定向负载均衡</strong></li></ol><ul><li>也属于比较直接，当HTTP请求叨叨负载均衡服务器后，使用一套负载均衡算法计算到后端服务器的地址，然后将新的地址给用户浏览器，浏览器收到重定向响应后发送请求到新的应用服务器从而实现负载均衡，如下图所示</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/222128709.png" alt="mark"></p><p>优点：</p><ul><li>简单，如果是java开发工程师，只需要servlet中几句代码即可</li></ul><p>缺点：</p><ul><li>加大请求的工作量。第一次请求给负载均衡服务器，第二次请求给应用服务器</li><li>因为要先计算到应用服务器的 IP 地址，所以 IP 地址可能暴露在公网，既然暴露在了公网还有什么安全可言</li></ul><ol start="3"><li><strong>DNS负载均衡</strong></li></ol><blockquote><p>了解计算机网络的你应该很清楚如何获取 IP 地址，其中比较常见的就是 DNS 解析获取 IP 地址。用户通过浏览器发起HTTP请求的时候，DNS 通过对域名进行即系得到 IP 地址，用户委托协议栈的 IP 地址简历 HTTP 连接访问真正的服务器。这样不同的用户进行域名解析将会获取不同的IP地址从而实现负载均衡</p></blockquote><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/222244275.png" alt="mark"></p><p>乍一看，和HTTP重定向的方案不是很相似吗而且还有 DNS 解析这一步骤，也会解析出 IP 地址，不一样的暴露？每次都需要解析吗，当然不，通常本机就会有缓存，在实际的工程项目中通常是怎么样的呢</p><ul><li>通过 DNS 解析获取负载均衡集群某台服务器的地址</li><li><strong>负载均衡服务器再一次获取某台应用服务器</strong>，这样子就不会将应用服务器的 IP 地址暴露在官网了</li></ul><ol start="4"><li><strong>反向代理负载均衡</strong></li></ol><blockquote><p>这里典型的就是Nginx提供的反向代理和负载均衡功能。用户的请求直接叨叨反向代理服务器，服务器先看本地是缓存过，有直接返回，没有则发送给后台的应用服务器处理。</p></blockquote><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/222406909.png" alt="mark"></p><ol start="5"><li><strong>IP负载均衡</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/222457447.png" alt="mark"></p><ul><li>注意，这种方案通常属于内核级别，如果数据比较小还好，但是大部分情况是图片等资源文件，这样负载均衡服务器会出现响应或者请求过大所带来的瓶颈</li></ul><ol start="6"><li><strong>数据链路负载均衡</strong></li></ol><blockquote><p>它可以解决因为数据量太大而导致负载均衡服务器带宽不足这个问题。怎么实现的呢。它不修改数据包的IP地址，而是更改mac地址。应用服务器和负载均衡服务器使用相同的虚拟IP</p></blockquote><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/222553607.png" alt="mark"></p><p>以上介绍了几种负载均衡的方式，但是很重要的<strong>负载均衡算法却没有设计，其中包含了轮询，随机</strong></p><h2 id="5-数据存储"><a href="#5-数据存储" class="headerlink" title="5. 数据存储"></a>5. 数据存储</h2><ul><li>公司存在的价值在于流量，流量需要数据，可想而知数据的存储，数据的高可用可说是公司的灵魂。那么改善数据的存储都有哪些手段或方法呢？</li></ul><ol><li><strong>数据主从复制</strong></li></ol><blockquote><p>主从复制比较好理解，需要使用两个数据库存储一样的数据。</p><p>其原理为当应用程序A发送更新命令到主服务器的时候，数据库会将这条命令同步记录到Binlog中，然后其他线程会从Binlog中读取并通过远程通讯的方式复制到另外服务器。服务器收到这更新日志后加入到自己Relay Log中，</p><p>然后SQL执行线程从Relay Log中读取次日志并在本地数据库执行一遍，从而实现主从数据库同样的数据。</p></blockquote><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/222817995.png" alt="mark"></p><ul><li>主从复制可以方便进行读写分离，可以使用一主多从的方式保证高可用，如果从数据库A挂了，可以将读操作迁移到从数据库完成高可用。</li><li>但是如果主数据库挂了咋搞，那就Mysql的主主复制。可是不管上面说的那种方式都不是提升它的存储能力，这就需要进行<strong>数据库的分片</strong>了</li></ul><ol start="2"><li><strong>数据库分片</strong></li></ol><blockquote><p>将一张表分成若干片，其中每一片都包含一部分行记录，然后将每一片存储在不同的服务器中，这样就实现一张表存放在多台服务器中，哪都有哪些分片存储的方案？</p></blockquote><ul><li>最开始使用<strong>“硬编码”</strong>的方式，此方式从字面上可以理解为直接在代码中指定。假定表为用户表，通过ID的奇偶存放在不同的服务器上，如下图</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/222949802.png" alt="mark"></p><p>这种方式的<strong>缺点</strong>很明显，当需要增加服务器的时候，就需要改动代码，这就不友好了。比较常见的数据库分片算法是通过余数Hash算法，根据主键ID和服务器的数量取模，根据余数确定服务器</p><p><strong>参考博客</strong> ： <a href="https://mp.weixin.qq.com/s/co6ZiALBCUHxc-8SpcKxPw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/co6ZiALBCUHxc-8SpcKxPw</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;好文阅读-01-后端学习路线&quot;&gt;&lt;a href=&quot;#好文阅读-01-后端学习路线&quot; class=&quot;headerlink&quot; title=&quot;好文阅读-01-后端学习路线&quot;&gt;&lt;/a&gt;好文阅读-01-后端学习路线&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;说到后端开发，难免会遇到各种所谓高大上的「关键词 」，对于我们应届生小白，难免会觉得比较陌生，因为在学校确实比较少遇见这些所谓高大上的东西，那么今天就带着学习的态度和大家分享这些看似可以装逼可以飞的带逼格的关键词吧。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/152056275.jpg&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="后端学习路线" scheme="http://zhuuu.work/tags/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
      <category term="好文阅读" scheme="http://zhuuu.work/tags/%E5%A5%BD%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-05-进程通信</title>
    <link href="http://zhuuu.work/2020/10/04/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-05-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <id>http://zhuuu.work/2020/10/04/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-05-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</id>
    <published>2020-10-04T09:00:53.000Z</published>
    <updated>2020-10-04T08:57:56.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-05-进程通信"><a href="#操作系统-05-进程通信" class="headerlink" title="操作系统-05-进程通信"></a>操作系统-05-进程通信</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/151330566.png" alt="mark"></p><ul><li>很明显，在这一场面试中， 张三在<strong>进程间通信</strong>这一块没复习好，虽然列出了进程间通信的方式，但这只是表面功夫，<strong>应该需要进一步了解每种通信方式的优缺点及应用场景。</strong></li></ul><a id="more"></a><h2 id="1-思维导图"><a href="#1-思维导图" class="headerlink" title="1. 思维导图"></a>1. 思维导图</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/151432253.png" alt="mark"></p><h2 id="2-正文"><a href="#2-正文" class="headerlink" title="2. 正文"></a>2. 正文</h2><ul><li><strong>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/151456483.png" alt="mark"></p><p>Linux 内核提供了不少进程间通信的机制，我们来一起瞧瞧有哪些？</p><h3 id="2-1-管道"><a href="#2-1-管道" class="headerlink" title="2.1 管道"></a>2.1 管道</h3><p><strong>匿名管道</strong></p><ul><li>如果你学过 Linux 命令，那你肯定很熟悉「<code>|</code>」这个竖线。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps auxf | grep mysql</span><br></pre></td></tr></table></figure><ul><li>上面命令行里的「<code>|</code>」竖线就是一个<strong>管道</strong>，它的功能是将前一个命令（<code>ps auxf</code>）的输出，作为后一个命令（<code>grep mysql</code>）的输入，从这功能描述，可以看出<strong>管道传输数据是单向的</strong>，如果想相互通信，我们需要创建两个管道才行。<ul><li>同时，我们得知上面这种管道是没有名字，所以「<code>|</code>」表示的管道称为<strong>匿名管道</strong>，用完了就销毁。</li></ul></li></ul><p><strong>命名管道</strong></p><ul><li>管道还有另外一个类型是<strong>命名管道</strong>，也被叫做 <code>FIFO</code>，因为数据是先进先出的传输方式。<ul><li>在使用命名管道前，先需要通过 <code>mkfifo</code> 命令来创建，并且指定管道名字：</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkfifo myPipe</span><br></pre></td></tr></table></figure><ul><li><code>myPipe</code>就是这个管道的名称，基于 Linux 一切皆文件的理念，所以管道也是以文件的方式存在，我们可以用 ls 看一下，这个文件的类型是 p，也就是 pipe（管道） 的意思：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">prw-r--r--. 1 root    root         0 Jul 17 02:45 myPipe</span><br></pre></td></tr></table></figure><ul><li>接下来，我们往 myPipe 这个管道写入数据：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;hello&quot; &gt; myPipe  &#x2F;&#x2F; 将数据写进管道</span><br><span class="line">                         &#x2F;&#x2F; 停住了 ...</span><br></pre></td></tr></table></figure><ul><li><p>你操作了后，你会发现命令执行后就停在这了，这是因为管道里的内容没有被读取，只有当管道里的数据被读完后，命令才可以正常退出。</p></li><li><p>于是，我们执行另外一个命令来读取这个管道里的数据：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt; myPipe  &#x2F;&#x2F; 读取管道里的数据</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><ul><li><p>可以看到，管道里的内容被读取出来了，并打印在了终端上，另外一方面，echo 那个命令也正常退出了。</p></li><li><p>我们可以看出，<strong>管道这种通信方式效率低，不适合进程间频繁地交换数据</strong>。当然，它的好处，自然就是简单，同时也我们很容易得知管道里的数据已经被另一个进程读取了。</p></li></ul><blockquote><p>那管道如何创建呢，背后原理是什么？</p></blockquote><p><strong>匿名管道</strong>的创建，需要通过下面这个系统调用：</p><p><code>int pipe(int fd[2])</code></p><ul><li>这里表示创建一个匿名管道，并返回了两个描述符，<ul><li>一个是管道的读取端描述符 <code>fd[0]</code>，另一个是管道的写入端描述符 <code>fd[1]</code>。</li><li>注意，这个匿名管道是特殊的文件，只存在于内存，不存于文件系统中。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/163516413.png" alt="mark"></p><ul><li>其实，<strong>所谓的管道，就是内核里面的一串缓存</strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。</li><li>看到这，你可能会有疑问了，这两个描述符都是在一个进程里面，并没有起到进程间通信的作用，怎么样才能使得管道是跨过两个进程的呢？</li><li>我们可以使用 <code>fork</code> 创建子进程，<strong>创建的子进程会复制父进程的文件描述符</strong>，这样就做到了两个进程各有两个「 <code>fd[0]</code> 与 <code>fd[1]</code>」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/163605213.png" alt="mark"></p><p>管道只能一端写入，另一端读出，所以上面这种模式容易造成混乱，因为父进程和子进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是：</p><ul><li>父进程关闭读取的 <code>fd[0]</code>，只保留写入的<code>fd[1]</code>；</li><li>子进程关闭写入的<code>fd[1]</code>，只保留读取的<code>fd[0]</code>；</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/163701458.png" alt="mark"></p><p><strong>所以说如果需要双向通信，则应该创建两个管道。</strong></p><ul><li>到这里，我们仅仅解析了使用管道进行父进程与子进程之间的通信，<strong>但是在我们 shell 里面并不是这样的。</strong><ul><li>在 shell 里面执行 <code>A | B</code>命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/163801175.png" alt="mark"></p><p>所以说，在 shell 里通过「<code>|</code>」匿名管道将多个命令连接在一起，实际上也就是创建了多个子进程，那么在我们编写 shell 脚本时，能使用一个管道搞定的事情，就不要多用一个管道，这样可以减少创建子进程的系统开销。</p><p><strong>小结：</strong></p><ul><li><p><strong>对于匿名管道，它的通信范围是存在父子关系的进程</strong>。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。</p></li><li><p>另外，<strong>对于命名管道，它可以在不相关的进程间也能相互通信</strong>。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。</p></li><li><p>不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</p></li></ul><h3 id="2-2-消息队列"><a href="#2-2-消息队列" class="headerlink" title="2.2 消息队列"></a>2.2 消息队列</h3><ul><li>前面说到管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。</li><li>对于这个问题，<strong>消息队列</strong>的通信模式就可以解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。</li><li>再来，<strong>消息队列是保存在内核中的消息链表</strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，<strong>消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。</strong></li><li>如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</li><li>消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。</li><li>消息这种模型，两个进程之间的通信就像平时发邮件一样，你来一封，我回一封，可以频繁沟通了。</li></ul><p>但邮件的通信方式存在不足的地方有两点，<strong>一是通信不及时，二是附件也有大小限制</strong>，这同样也是消息队列通信不足的点。</p><ul><li><strong>消息队列不适合比较大数据的传输</strong>，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 <code>MSGMAX</code> 和 <code>MSGMNB</code>，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。</li><li><strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong>，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</li></ul><h3 id="2-3-共享内存"><a href="#2-3-共享内存" class="headerlink" title="2.3 共享内存"></a>2.3 共享内存</h3><ul><li>消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那<strong>共享内存</strong>的方式，就很好的解决了这一问题。</li><li>现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</li><li><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/164240759.png" alt="mark"></p><h3 id="2-4-信号量"><a href="#2-4-信号量" class="headerlink" title="2.4 信号量"></a>2.4 信号量</h3><ul><li>用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。</li><li>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，<strong>信号量</strong>就实现了这一保护机制。</li></ul><p><strong>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</strong>。</p><p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p><ul><li>一个是 <strong>P 操作</strong>，这个操作会把信号量减去 -1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;= 0，则表明还有资源可使用，进程可正常继续执行。</li><li>另一个是 <strong>V 操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li></ul><p><strong>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。</strong></p><p><strong>互斥访问</strong></p><ul><li>接下来，举个例子，如果要使得两个进程互斥访问共享内存，我们可以初始化信号量为 <code>1</code>。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/164357574.png" alt="mark"></p><p>具体的过程如下：</p><ul><li>进程 A 在访问共享内存前，先执行了 P 操作，由于信号量的初始值为 1，故在进程 A 执行 P 操作后信号量变为 0，表示共享资源可用，于是进程 A 就可以访问共享内存。</li><li>若此时，进程 B 也想访问共享内存，执行了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占用，因此进程 B 被阻塞。</li><li>直到进程 A 访问完共享内存，才会执行 V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的线程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执行 V 操作，使信号量恢复到初始值 1。</li></ul><p>可以发现，信号初始化为 <code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。</p><p><strong>同步访问</strong></p><ul><li>另外，在多进程里，每个进程并不一定是顺序执行的，它们基本是以各自独立的、不可预知的速度向前推进，但有时候我们又希望多个进程能密切合作，以实现一个共同的任务。</li><li>例如，进程 A 是负责生产数据，而进程 B 是负责读取数据，这<strong>两个进程是相互合作、相互依赖的，进程 A 必须先生产了数据，进程 B 才能读取到数据，所以执行是有前后顺序的。</strong></li></ul><p>那么这时候，就可以用信号量来实现多<strong>进程同步的方式，我们可以初始化信号量为 <code>0</code>。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/164459468.png" alt="mark"></p><p>具体过程：</p><ul><li>如果进程 B 比进程 A 先执行了，那么执行到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没生产数据，于是进程 B 就阻塞等待；</li><li>接着，当进程 A 生产完数据后，执行了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B；</li><li>最后，进程 B 被唤醒后，意味着进程 A 已经生产了数据，于是进程 B 就可以正常读取数据了。</li></ul><p>可以发现，信号初始化为 <code>0</code>，就代表着是<strong>同步信号量</strong>，它可以保证进程 A 应在进程 B 之前执行。</p><h3 id="2-5-信号"><a href="#2-5-信号" class="headerlink" title="2.5 信号"></a>2.5 信号</h3><ul><li>上面说的进程间通信，都是常规状态下的工作模式。<strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/164625864.png" alt="mark"></p><ul><li>信号跟信号量虽然名字相似度 66.66%，但两者用途完全不一样，就好像 Java 和 JavaScript 的区别。</li><li><strong>在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 <code>kill -l</code> 命令，查看所有的信号：</strong></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure><p><strong>1. 运行在 shell 终端的进程</strong>，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如</p><ul><li>Ctrl+C 产生 <code>SIGINT</code> 信号，表示终止该进程；</li><li>Ctrl+Z 产生 <code>SIGTSTP</code> 信号，表示停止该进程，但还未结束；</li></ul><p><strong>2. 如果进程在后台运行</strong>，可以通过 <code>kill</code> 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：</p><ul><li>kill -9 1050 ，表示给 PID 为 1050 的进程发送 <code>SIGKILL</code> 信号，用来立即结束该进程；</li></ul><p><strong>所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。</strong></p><ul><li><p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p><p><strong>1.执行默认操作</strong>。Linux 对每种信号都规定了默认操作，例如，上面列表中的<code>SIGTERM</code>信号，就是终止进程的意思。<code>Core</code>的意思是<code>Core Dump</code>，也即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。</p><p><strong>2.捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p><p><strong>3.忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。</p></li></ul><h3 id="2-6-Socket"><a href="#2-6-Socket" class="headerlink" title="2.6 Socket"></a>2.6 Socket</h3><ul><li><p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想<strong>跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。</strong></p></li><li><p>实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。</p><p>我们来看看创建 socket 的系统调用：</p></li></ul><p><code>int socket(int domain, int type, int protocal)</code></p><p><strong>三个参数分别代表：</strong></p><ul><li><code>domain</code> 参数用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、AF_LOCAL/AF_UNIX 用于本机；</li><li><code>type</code>参数用来指定通信特性，比如 <code>SOCK_STREAM</code>表示的是字节流，对应<code>TCP</code>、<code>SOCK_DGRAM</code>表示的是数据报，对应 <code>UDP</code>、<code>SOCK_RAW</code>表示的是原始套接字；</li><li><code>protocal</code> 参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可；</li></ul><p><strong>根据创建 socket 类型的不同，通信的方式也就不同：</strong></p><ul><li>实现 TCP 字节流通信：socket 类型是 AF_INET 和 SOCK_STREAM；</li><li>实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；</li><li>实现本地进程间通信：「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；</li></ul><p><strong>接下来，简单说一下这三种通信的编程模式。</strong></p><h4 id="2-6-1-针对-TCP-协议通信的-socket-编程模型"><a href="#2-6-1-针对-TCP-协议通信的-socket-编程模型" class="headerlink" title="2.6.1 针对 TCP 协议通信的 socket 编程模型"></a>2.6.1 针对 TCP 协议通信的 socket 编程模型</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/165037742.png" alt="mark"></p><ul><li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li><li>服务端调用 <code>bind</code>，将绑定在 IP 地址和端口;</li><li>服务端调用 <code>listen</code>，进行监听；</li><li>服务端调用 <code>accept</code>，等待客户端连接；</li><li>客户端调用 <code>connect</code>，向服务器端的地址和端口发起连接请求；</li><li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li><li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li><li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</li></ul><p>这里需要注意的是，服务端调用 <code>accept</code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</p><p>所以，监听的 socket 和真正用来传送数据的 socket，是「<strong>两个</strong>」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p><p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p><h4 id="2-6-2-针对-UDP-协议通信的-socket-编程模型"><a href="#2-6-2-针对-UDP-协议通信的-socket-编程模型" class="headerlink" title="2.6.2 针对 UDP 协议通信的 socket 编程模型"></a>2.6.2 针对 UDP 协议通信的 socket 编程模型</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/165208111.png" alt="mark"></p><ul><li>UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。</li><li>对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个<code>socket</code> 多台机器就可以任意通信，因此每一个 <code>UDP</code> 的 <code>socket</code>都需要 bind。</li></ul><p>另外，每次通信时，调用<code>sendto</code> 和 <code>recvfrom</code>，都要传入目标主机的 IP 地址和端口。</p><h4 id="2-6-3-针对本地进程间通信的-socket-编程模型"><a href="#2-6-3-针对本地进程间通信的-socket-编程模型" class="headerlink" title="2.6.3 针对本地进程间通信的 socket 编程模型"></a>2.6.3 针对本地进程间通信的 socket 编程模型</h4><p>本地 socket  被用于在<strong>同一台主机上进程间通信</strong>的场景：</p><ul><li>本地 socket 的编程接口和 IPv4 、IPv6 套接字编程接口是一致的，<strong>可以支持「字节流」和「数据报」两种协议；</strong></li><li>本地 socket 的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报 socket 实现；</li></ul><p>对于本地字节流 socket，其 socket 类型是 AF_LOCAL 和 SOCK_STREAM。</p><p>对于本地数据报 socket，其 socket 类型是 AF_LOCAL 和 SOCK_DGRAM。</p><p>本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是<strong>绑定一个本地文件</strong>，这也就是它们之间的最大区别。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><h3 id="3-1-进程的通信方式"><a href="#3-1-进程的通信方式" class="headerlink" title="3.1 进程的通信方式"></a>3.1 进程的通信方式</h3><p>由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。</p><p>Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。</p><ul><li><strong>匿名管道</strong>顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「<code>|</code>」竖线就是匿名管道，通信的数据是<strong>无格式的流并且大小受限</strong>，通信的方式是<strong>单向</strong>的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来<strong>匿名管道是只能用于存在父子关系的进程间通信</strong>，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。</li><li><strong>命名管道</strong>突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是<strong>缓存在内核</strong>中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</li></ul><ul><li><strong>消息队列</strong>克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟<strong>每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。</strong></li></ul><ul><li><p><strong>共享内存</strong>可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，<strong>它直接分配一个共享空间，每个进程都可以直接访问</strong>，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有<strong>最快</strong>的进程间通信方式之名。但是便捷高效的共享内存通信，<strong>带来新的问题，多进程竞争同个共享资源会造成数据的错乱。</strong></p></li><li><p>那么，就需要<strong>信号量</strong>来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。<strong>信号量不仅可以实现访问的互斥性，还可以实现进程间的同步</strong>，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 <strong>P 操作和 V 操作</strong>。</p></li></ul><ul><li>与信号量名字很相似的叫<strong>信号</strong>，它俩名字虽然相似，但功能一点儿都不一样。信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，<strong>进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号</strong>。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，这是为了方便我们能在任何时候结束或停止某个进程。</li></ul><p>前面说到的通信机制，都是工作于同一台主机，如果<strong>要与不同主机的进程间通信，那么就需要 Socket 通信了</strong>。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。</p><h3 id="3-2-线程的通信方式"><a href="#3-2-线程的通信方式" class="headerlink" title="3.2 线程的通信方式"></a>3.2 线程的通信方式</h3><p><strong>以上，就是进程间通信的主要机制了。你可能会问了，那线程通信间的方式呢？</strong></p><ul><li><p>同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步：</p></li><li><p>互斥的方式，可保证任意时刻只有一个线程访问共享资源；</p></li><li><p>同步的方式，可保证线程 A 应在线程 B 之前执行；</p></li></ul><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mp.weixin.qq.com/s/mblyh6XrLj1bCwL0Evs-Vg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/mblyh6XrLj1bCwL0Evs-Vg</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-05-进程通信&quot;&gt;&lt;a href=&quot;#操作系统-05-进程通信&quot; class=&quot;headerlink&quot; title=&quot;操作系统-05-进程通信&quot;&gt;&lt;/a&gt;操作系统-05-进程通信&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/151330566.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;很明显，在这一场面试中， 张三在&lt;strong&gt;进程间通信&lt;/strong&gt;这一块没复习好，虽然列出了进程间通信的方式，但这只是表面功夫，&lt;strong&gt;应该需要进一步了解每种通信方式的优缺点及应用场景。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程通信" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-04-进程控制</title>
    <link href="http://zhuuu.work/2020/10/04/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-04-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>http://zhuuu.work/2020/10/04/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-04-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</id>
    <published>2020-10-04T06:00:53.000Z</published>
    <updated>2020-10-04T07:11:03.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-04-进程控制"><a href="#操作系统-04-进程控制" class="headerlink" title="操作系统-04-进程控制"></a>操作系统-04-进程控制</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>什么是进程控制？<br>进程控制的主要功能是对系统中的所有进程实施有效的管理,它具有创建新进程、撤销已有进程、实现进程状态转换等功能。简而言之就是实现进程状态切换。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/150250419.png" alt="mark"></p><a id="more"></a><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/150328172.png" alt="mark"></p><ul><li><strong>使用原语进行实现</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/150428635.png" alt="mark"></p><ul><li><strong>大致流程</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/150533562.png" alt="mark"></p><blockquote><p>这里说明一下调度和切换的区别：<br><code>调度</code>是指决定资源分配给哪个进程的行为，是一种决策行为<br><code>切换</code>是指实际分配的行为，是执行行为<br>一般来说现有资源调度，后有进程切换</p></blockquote><h2 id="2-进程控制相关原语"><a href="#2-进程控制相关原语" class="headerlink" title="2. 进程控制相关原语"></a>2. 进程控制相关原语</h2><p>进程控制会导致进程状态的转换。<strong>无论哪个原语,要做的无非三类事情:</strong> </p><ol><li><p><strong>更新PCB中的信息</strong>(如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境)    </p><p>a.所有的进程控制原语一定都会修改进程状态标志    </p><p>b.剥夺当前运行进程的CPU使用权必然需要保存其运行环境    </p><p>c.某进程开始运行前必然要恢复期运行环境 </p></li><li><p><strong>将PCB插入合适的队列</strong> </p></li><li><p><strong>分配/回收资源</strong></p></li></ol><p>以下针对每种原语进行说明：</p><ul><li><p><strong>进程创建</strong></p><ul><li><p>创建原语<br>1.申请空白PCB<br>​2.为新进程分配所需资源<br>3.初始化PCB<br>4.将PCB插入就绪队列​</p></li><li><p>引发事件<br>1.分时系统，用户登录<br>2.多道批处理系统，新的作业提交到内存<br>3.用户向操作系统提取请求<br>4.用户进程自动请求创建子进程​</p></li></ul></li><li><p><strong>进程终止</strong></p><ul><li><p>撤销原语<br>1.从PCB集合找到终止进程的PCB<br>2.若进程正在运行，立即剥夺CPU，将CPU分配给其它进程<br>3.终止其所有子进程<br>4.回收资源给父进程或者操作系统<br>5.删除PCB​​</p></li><li><p>引发事件<br>1.正常结束<br>2.异常结束<br>3.外界干预​</p></li></ul></li><li><p><strong>进程阻塞</strong></p><ul><li><p>阻塞原语<br>1.找到进程对于的PCB<br>2.保护进程运行现场，设置PCB状态为阻塞态，暂停进程运行<br>3.将PCB插入对应的事件等待队列</p></li><li><p>引发事件<br>1.需要等待系统分配某种资源<br>2.需要等待相互合作的其它进程完成工作</p></li></ul></li><li><p><strong>进程唤醒</strong></p><ul><li><p>唤醒原语<br>1.在事件等待队列中找到PCB<br>​2.将其从等待队列移除，设置进程为就绪态<br>3.将PCB插入就绪队列，等待被调度</p></li><li><p>引发原因<br>因何事阻塞，因何事唤醒<br>阻塞和唤醒成对出现</p></li></ul></li><li><p><strong>进程切换</strong></p><ul><li><p>切换原语<br>1.保存运行环境到PCB<br>2.PCB移入相应队列<br>3.选择另一个PCB执行，更新其PCB<br>4.根据PCB恢复新进程的运行环境​</p></li><li><p>引发原因<br>1.当前进程时间片用完<br>2.更高优先级进程达到<br>3.当前进程主动阻塞<br>4.当前进程终止​</p></li></ul></li></ul><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ： <a href="https://mubu.com/doc/Cd-Y4YOfkh#" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#</a></p><p>​                    <a href="https://blog.csdn.net/weixin_43914604/article/details/104415990" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43914604/article/details/104415990</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-04-进程控制&quot;&gt;&lt;a href=&quot;#操作系统-04-进程控制&quot; class=&quot;headerlink&quot; title=&quot;操作系统-04-进程控制&quot;&gt;&lt;/a&gt;操作系统-04-进程控制&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;什么是进程控制？&lt;br&gt;进程控制的主要功能是对系统中的所有进程实施有效的管理,它具有创建新进程、撤销已有进程、实现进程状态转换等功能。简而言之就是实现进程状态切换。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/150250419.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-03-进程状态</title>
    <link href="http://zhuuu.work/2020/10/04/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-03-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/"/>
    <id>http://zhuuu.work/2020/10/04/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-03-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/</id>
    <published>2020-10-04T05:00:53.000Z</published>
    <updated>2020-10-04T07:01:02.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-03-进程状态"><a href="#操作系统-03-进程状态" class="headerlink" title="操作系统-03-进程状态"></a>操作系统-03-进程状态</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>上一篇博客介绍了进程的定义和特性等等</li><li>本篇单独开篇就是讲进程的状态，因为是个重要的知识点得单独说</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/145220849.png" alt="mark"></p><a id="more"></a><h2 id="1-进程的状态"><a href="#1-进程的状态" class="headerlink" title="1. 进程的状态"></a>1. 进程的状态</h2><ul><li><strong>运行状态(Running)</strong><br>占有CPU，并在CPU上运行<br>单核处理器一个时刻只有一个进程处于运行态，双核两个</li><li><strong>就绪状态(Ready)</strong><br>进程已经具备一切运行条件，除了没有空闲CPU，导致暂时不能运行<br>万事俱备，只差CPU</li><li><strong>阻塞状态(Waiting/Blocked)</strong><br>等待某一事件而暂时不能运行，比如等待操作系统分配打印机、等待磁盘读写<br>为了提高CPU利用效率，进程需要先准备好其它所需资源，才能得到CPU的服务</li><li>创建状态(New)<br>操作系统为该进程分配所需内存等系统资源，为其创建、初始化PCB(分配PID等等)</li><li>终止状态(Terminated)<br>进程运行结束，或者出现Bug导致无法继续执行，操作系统需要撤销进程<br>完成资源回收，撤销PCB​</li></ul><p><strong>注意 ：</strong> </p><ul><li><strong>基本状态：运行、就绪、阻塞/等待态</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/145824038.png" alt="mark"></p><ul><li>创建态和结束态</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/145834883.png" alt="mark"></p><p><strong>创建态</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/145927447.png" alt="mark"></p><p><strong>结束态</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/145954012.png" alt="mark"></p><h2 id="2-进程状态之间的转换"><a href="#2-进程状态之间的转换" class="headerlink" title="2. 进程状态之间的转换"></a>2. 进程状态之间的转换</h2><ul><li>进程一共有如下5种状态，那么他们之间如何实现切换呢？</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/145456852.png" alt="mark"></p><ul><li>来一张形象生动的图片感受一下5种状态之间的切换</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/150053112.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ： <a href="https://mubu.com/doc/Cd-Y4YOfkh#" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#</a></p><p>​                    <a href="https://blog.csdn.net/weixin_43914604/article/details/104415990" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43914604/article/details/104415990</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-03-进程状态&quot;&gt;&lt;a href=&quot;#操作系统-03-进程状态&quot; class=&quot;headerlink&quot; title=&quot;操作系统-03-进程状态&quot;&gt;&lt;/a&gt;操作系统-03-进程状态&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;上一篇博客介绍了进程的定义和特性等等&lt;/li&gt;
&lt;li&gt;本篇单独开篇就是讲进程的状态，因为是个重要的知识点得单独说&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/145220849.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-02-进程管理</title>
    <link href="http://zhuuu.work/2020/10/04/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://zhuuu.work/2020/10/04/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</id>
    <published>2020-10-04T04:00:53.000Z</published>
    <updated>2020-10-04T06:49:57.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-02-进程管理"><a href="#操作系统-02-进程管理" class="headerlink" title="操作系统-02-进程管理"></a>操作系统-02-进程管理</h1><h2 id="1-进程的定义"><a href="#1-进程的定义" class="headerlink" title="1. 进程的定义"></a>1. 进程的定义</h2><ol><li><strong>程序</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/143830157.png" alt="mark"></p><ol start="2"><li><strong>进程</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/143852853.png" alt="mark"></p><ul><li>进程和程序的区别和联系：</li></ul><blockquote><p>区别：<br>(1) 进程是动态的;程序是静态的。<br>(2) 进程有独立性，能并发执行;程序不能并发执行。<br>(3) 二者无一一对应关系。<br>(4) 进程异步运行，会相互制约;程序不具备此特征。<br>但是，进程与程序又有密切的联系： 进程不能脱离具体程序而虚设， 程序规定了相应进程所要完成的动作。<br>(5) 组成不同。进程包含PCB、程序段、数据段。程序包含数据和指令代码。<br>(6) 程序是一个包含了所有指令和数据的静态实体。本身除占用磁盘的存储空间外，并不占用系统如CPU、内存等运行资源。<br>(7) 进程由程序段、数据段和PCB构成,会占用系统如CPU、内存等运行资源。<br>(8) 一个程序可以启动多个进程来共同完成。<br>联系：进程不能脱离具体程序而虚设， 程序规定了相应进程所要完成的动作。</p></blockquote><a id="more"></a><p><strong>进程定义</strong></p><ul><li>程序段、数据段、PCB三部分组成了进程实体(进程映像) 。<ul><li>一般情况下,我们把进程实体就简称为进程,</li><li>例如,所谓创建进程,实质上是创建进程实体中的PCB;</li><li>而撤销进程,实质上是撤销进程实体中的PCB.</li><li><strong>注意: PCB是进程存在的唯一标志!</strong>从不同的角度,进程可以有不同的定义,比较传统典型的定义有:<ul><li>1,进程是程序的一次执行过程。 </li><li>2,进程是一个程序及其数据在处理机上顺序执行时所发生的活动。 </li><li>3,进程是具有独立功能的程序在数据集合上运行的过程,它是<strong>系统进行资源分配和调度的一个独立单位（强调“动态性”）</strong> </li><li>引入进程实体的概念后,可把进程定义为:进程是进程实体的运行过程,是系统进行资源分配和调度的一个独立单位。</li></ul></li></ul></li></ul><h2 id="2-进程的组成"><a href="#2-进程的组成" class="headerlink" title="2. 进程的组成"></a>2. 进程的组成</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/144324116.png" alt="mark"></p><ul><li><p><strong>程序段</strong><br>存放程序代码本身</p></li><li><p><strong>数据段</strong><br>存放程序运行过程中处理的各种数据</p></li><li><p><strong>PCB</strong></p><p>进程管理所需的数据都放在这里<br>​PCB是进程存在的唯一标志</p><ul><li><p>进程描述信息</p><ul><li><p>进程标识符 PID</p></li><li><p>用户标识符 UID</p></li><li><p>父进程 PID</p></li><li><p>子进程 PID</p></li></ul></li><li><p>进程控制和管理信息</p><ul><li><p>进程优先级</p></li><li><p>进程当前状态</p></li><li><p>进程阻塞原因</p></li><li><p>进程同步和通信机制</p></li><li><p>其它调度所需的信息</p></li></ul></li><li><p>资源分配清单</p><ul><li><p>程序段指针</p></li><li><p>数据段指针</p></li><li><p>外设资源</p></li></ul></li><li><p>处理器现场信息</p><ul><li>各种寄存器的值<br>进程切换时需要把当前进程的运行状态保存在PCB里面<br>比如程序计数器的值记录了当前程序执行到那一句了，通用寄存器，程序状态字寄存器，栈指针等等</li></ul></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/144521644.png" alt="mark"></p><p><strong>注意</strong></p><ul><li>而其中最重要的就是<code>进程控制块PCB</code>（Process Control Block）</li><li>在进程的整个生命期中，系统总是通过PCB对进程进行控制的，即系统是根据进程的PCB而不是任何别的什么而感知到该进程的存在的。</li><li>所以说，PCB是进程存在的唯一标志。</li></ul><h2 id="3-进程的组织方式"><a href="#3-进程的组织方式" class="headerlink" title="3. 进程的组织方式"></a>3. 进程的组织方式</h2><h3 id="3-1-链接方式"><a href="#3-1-链接方式" class="headerlink" title="3.1 链接方式"></a>3.1 链接方式</h3><ul><li>按照进程状态将PCB分为多个队列</li><li>操作系统持有指向个个队列的指针</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/144740393.png" alt="mark"></p><h3 id="3-2-索引方式"><a href="#3-2-索引方式" class="headerlink" title="3.2 索引方式"></a>3.2 索引方式</h3><ul><li>根据进程状态不同，建立几张索引表</li><li>操作系统持有指向各索引表的指针</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/144755298.png" alt="mark"></p><h2 id="4-进程的特征"><a href="#4-进程的特征" class="headerlink" title="4. 进程的特征"></a>4. 进程的特征</h2><ul><li><strong>动态性</strong><br><strong>最基本特征</strong>。进程是程序的一次执行过程，是动态地产生、变化和消亡的</li><li>并发性<br>内存中有多个进程实体，各进程可以并行执行</li><li>独立性<br>进程是能独立运行、获得资源、接受调度的基本单位</li><li>异步性<br>各进程按各自独立的、不可预测的速度向前推进，异步性会导致并发程序执行结果的不确定性，操作系统要提供“进程同步机制”来解决异步问题</li><li>结构性<br>每一个进程都会配置PCB</li></ul><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ： <a href="https://mubu.com/doc/Cd-Y4YOfkh#" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#</a></p><p>​                    <a href="https://blog.csdn.net/weixin_43914604/article/details/104415990" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43914604/article/details/104415990</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-02-进程管理&quot;&gt;&lt;a href=&quot;#操作系统-02-进程管理&quot; class=&quot;headerlink&quot; title=&quot;操作系统-02-进程管理&quot;&gt;&lt;/a&gt;操作系统-02-进程管理&lt;/h1&gt;&lt;h2 id=&quot;1-进程的定义&quot;&gt;&lt;a href=&quot;#1-进程的定义&quot; class=&quot;headerlink&quot; title=&quot;1. 进程的定义&quot;&gt;&lt;/a&gt;1. 进程的定义&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;程序&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/143830157.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;strong&gt;进程&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201004/143852853.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程和程序的区别和联系：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;区别：&lt;br&gt;(1) 进程是动态的;程序是静态的。&lt;br&gt;(2) 进程有独立性，能并发执行;程序不能并发执行。&lt;br&gt;(3) 二者无一一对应关系。&lt;br&gt;(4) 进程异步运行，会相互制约;程序不具备此特征。&lt;br&gt;但是，进程与程序又有密切的联系： 进程不能脱离具体程序而虚设， 程序规定了相应进程所要完成的动作。&lt;br&gt;(5) 组成不同。进程包含PCB、程序段、数据段。程序包含数据和指令代码。&lt;br&gt;(6) 程序是一个包含了所有指令和数据的静态实体。本身除占用磁盘的存储空间外，并不占用系统如CPU、内存等运行资源。&lt;br&gt;(7) 进程由程序段、数据段和PCB构成,会占用系统如CPU、内存等运行资源。&lt;br&gt;(8) 一个程序可以启动多个进程来共同完成。&lt;br&gt;联系：进程不能脱离具体程序而虚设， 程序规定了相应进程所要完成的动作。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-977-有序数组的平方</title>
    <link href="http://zhuuu.work/2020/10/03/Leetcode/Leetcode-977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"/>
    <id>http://zhuuu.work/2020/10/03/Leetcode/Leetcode-977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</id>
    <published>2020-10-03T07:52:53.000Z</published>
    <updated>2020-10-03T12:16:53.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-977-有序数组的平方https-leetcode-cn-com-problems-rotting-oranges"><a href="#Leecode-977-有序数组的平方https-leetcode-cn-com-problems-rotting-oranges" class="headerlink" title="Leecode-977. 有序数组的平方https://leetcode-cn.com/problems/rotting-oranges/)"></a>Leecode-<a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/" target="_blank" rel="noopener">977. 有序数组的平方</a><a href="https://leetcode-cn.com/problems/rotting-oranges/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotting-oranges/</a>)</h1><h2 id="思路：双指针"><a href="#思路：双指针" class="headerlink" title="思路：双指针"></a>思路：双指针</h2><p><strong>题目描述</strong></p><ul><li>给定一个按非递减顺序排序的整数数组 <code>A</code>，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：[-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：[-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;&#x3D; A.length &lt;&#x3D; 10000</span><br><span class="line">-10000 &lt;&#x3D; A[i] &lt;&#x3D; 10000</span><br><span class="line">A 已按非递减顺序排序。</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>思路： 双指针</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> length;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="keyword">null</span> || (length = A.length) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双指针</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结果集</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 一遍数组</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(A[i] * A[i] &gt; A[j] * A[j])&#123;</span><br><span class="line">                temp = A[i] * A[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp = A[j] * A[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result[k--] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-977-有序数组的平方https-leetcode-cn-com-problems-rotting-oranges&quot;&gt;&lt;a href=&quot;#Leecode-977-有序数组的平方https-leetcode-cn-com-problems-rotting-oranges&quot; class=&quot;headerlink&quot; title=&quot;Leecode-977. 有序数组的平方https://leetcode-cn.com/problems/rotting-oranges/)&quot;&gt;&lt;/a&gt;Leecode-&lt;a href=&quot;https://leetcode-cn.com/problems/squares-of-a-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;977. 有序数组的平方&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/rotting-oranges/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/rotting-oranges/&lt;/a&gt;)&lt;/h1&gt;&lt;h2 id=&quot;思路：双指针&quot;&gt;&lt;a href=&quot;#思路：双指针&quot; class=&quot;headerlink&quot; title=&quot;思路：双指针&quot;&gt;&lt;/a&gt;思路：双指针&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定一个按非递减顺序排序的整数数组 &lt;code&gt;A&lt;/code&gt;，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[-4,-1,0,3,10]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[0,1,9,16,100]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[-7,-3,2,3,11]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[4,9,9,49,121]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;提示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; A.length &amp;lt;&amp;#x3D; 10000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-10000 &amp;lt;&amp;#x3D; A[i] &amp;lt;&amp;#x3D; 10000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A 已按非递减顺序排序。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-977-有序数组的平方</title>
    <link href="http://zhuuu.work/2020/10/03/Leetcode/Leetcode-976-%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%91%A8%E9%95%BF/"/>
    <id>http://zhuuu.work/2020/10/03/Leetcode/Leetcode-976-%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%91%A8%E9%95%BF/</id>
    <published>2020-10-03T07:52:53.000Z</published>
    <updated>2020-12-01T01:45:54.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-976-三角形的最大周长"><a href="#Leetcode-976-三角形的最大周长" class="headerlink" title="Leetcode-976-三角形的最大周长"></a>Leetcode-976-<a href="https://leetcode-cn.com/problems/largest-perimeter-triangle/" target="_blank" rel="noopener">三角形的最大周长</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><p>给定由一些正数（代表长度）组成的数组 <code>A</code>，返回由其中三个长度组成的、<strong>面积不为零</strong>的三角形的最大周长。</p><p>如果不能形成任何面积不为零的三角形，返回 <code>0</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：[2,1,2]</span><br><span class="line">输出：5</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：[1,2,1]</span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：[3,2,3,4]</span><br><span class="line">输出：10</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：[3,6,2,3]</span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-：-数学"><a href="#思路-：-数学" class="headerlink" title="思路  ： 数学"></a>思路  ： 数学</h2><p><strong>1. 为什么只需要判断 a + b &gt; c ?</strong></p><p>正常情况下，对于三条边长，判断能否组成三角形需要判断任何两条边长相加都大于其余的一条边长，即：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a + b &gt; <span class="built_in">c</span> &amp;&amp; a + <span class="built_in">c</span> &gt; b &amp;&amp; b + <span class="built_in">c</span> &gt; a</span><br></pre></td></tr></table></figure><p>而如果已知<code>a&lt;=b&lt;=c</code>，那么必然有：</p><ol><li><code>a + c &gt; b</code>，因为<code>c &gt;= b</code>，那c加上一个正数一定就比b大了。而题目里说所数都&gt;=1，所以c加上a一定比b大。</li><li><code>b + c &gt; a</code>，因为b和c至少跟a一样大<code>(b&gt;=a, c&gt;=a)</code>，加起来的结果至少有<code>2a</code>，即 <code>b+c &gt;= 2a &gt; a</code>所以最终只需要判断<code>a + b &gt; c</code>即可。</li></ol><p><strong>2. 为什么只需要判断数组中相邻的三个数？</strong></p><p><strong>在固定最后一个数 A[i] 时，前两个数需不需要再往前找呢？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果 A[i-2] + A[i-1] &lt;&#x3D; A[i] ，这三个数一定不能构成三角形，而A[i-3]以及更往前的数，都小于等于A[i-2]，所以再往前取任何两个数只会让相加的值更小，就更不能满足 A[j] + A[k] &gt; A[i]了 (j&lt;i-2, k&lt;i-1, j&lt;k)。所以如果相邻的数构不成三角形，就不需要再固定第三个数并往前找两个数了。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果 A[i-2] + A[i-1] &gt; A[i]，这三个数可以构成三角形，再往前找只会让周长变短，所以也不用再往前了。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestPerimeter</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 对数组进行排序</span></span><br><span class="line">        Arrays.sort(A);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. a + b &gt; c 假定 a &lt;= b &lt;= c</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>  i = A.length - <span class="number">1</span>;i &gt;= <span class="number">2</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i - <span class="number">2</span>] + A[i - <span class="number">1</span>] &gt; A[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> A[i - <span class="number">2</span>] + A[i - <span class="number">1</span>] + A[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><p><strong>时间复杂度</strong> ： <code>O(nlogn)</code></p></li><li><p><strong>空间复杂度</strong>：  <code>O (logn)</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-976-三角形的最大周长&quot;&gt;&lt;a href=&quot;#Leetcode-976-三角形的最大周长&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-976-三角形的最大周长&quot;&gt;&lt;/a&gt;Leetcode-976-&lt;a href=&quot;https://leetcode-cn.com/problems/largest-perimeter-triangle/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;三角形的最大周长&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;给定由一些正数（代表长度）组成的数组 &lt;code&gt;A&lt;/code&gt;，返回由其中三个长度组成的、&lt;strong&gt;面积不为零&lt;/strong&gt;的三角形的最大周长。&lt;/p&gt;
&lt;p&gt;如果不能形成任何面积不为零的三角形，返回 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[2,1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[1,2,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[3,2,3,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 4：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[3,6,2,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-01-概述</title>
    <link href="http://zhuuu.work/2020/10/03/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-01-%E6%A6%82%E8%BF%B0/"/>
    <id>http://zhuuu.work/2020/10/03/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-01-%E6%A6%82%E8%BF%B0/</id>
    <published>2020-10-03T04:00:53.000Z</published>
    <updated>2020-10-03T04:01:13.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-01-概述"><a href="#操作系统-01-概述" class="headerlink" title="操作系统-01-概述"></a>操作系统-01-概述</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>是系统最基本最核心的软件，属于系统软件</li><li>控制和管理整个计算机的硬件和软件资源</li><li>合理的组织、调度计算机的工作与资源的分配</li><li>为用户和其它软件提供方便的接口和环境</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/103437449.png" alt="mark"></p><a id="more"></a><h2 id="1-基本特征"><a href="#1-基本特征" class="headerlink" title="1. 基本特征"></a>1. 基本特征</h2><ol><li><strong>并发</strong></li></ol><ul><li><code>并发</code>：两个或多个事件在同一<code>时间间隔内</code>发生，这些事件在宏观上是同时发生的，在微观上是交替发生的， 操作系统的并发性指系统中同时存在着多个运行的程序</li><li><code>并行</code>：两个或多个事件在同一<code>时刻</code>发生</li><li>一个单核(CPU)同一时刻只能执行一个程序，因此操作系统会协调多个程序使他们交替进行（这些程序在宏观上是同时发生的，在微观上是交替进行的）</li></ul><ol start="2"><li><strong>共享</strong></li></ol><ul><li>互斥共享<br>同一个时间段只允许一个进程访问资源(摄像头/麦克风)</li><li>同时共享<br>允许一个时间段多个进程“同时”(宏观上)访问某些资源（微观上是分时共享），比如硬盘读写</li></ul><ol start="3"><li><strong>虚拟</strong></li></ol><ul><li>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体(前者)是实际存在的,而逻辑上对应物(后者)是用户感受到的。<ul><li><strong>空分复用</strong>(虚拟储存技术)<ul><li>物理4GB内存，用户看来远大于4GB</li></ul></li><li><strong>时分复用</strong>(虚拟处理器技术)<ul><li>一个CPU看上去是几个CPU,多个程序并发运行</li></ul></li></ul></li></ul><ol start="4"><li><strong>异步</strong></li></ol><ul><li>异步是指,在多道程序环境下,允许多个程序并发执行,但由于资源有限,进程的执行不是一贯到底的,是走走停停（等待资源进程阻塞）,以不可预知的速度向前推异步性。</li></ul><h2 id="2-发展和分类"><a href="#2-发展和分类" class="headerlink" title="2. 发展和分类"></a>2. 发展和分类</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/105010362.png" alt="mark"></p><ol><li><p><strong>手工操作阶段</strong>(IO靠纸带打孔，资源利用率低)</p></li><li><p><strong>批处理阶段</strong></p><ul><li><p>单道批处理系统<br>引入了脱机输入/输出技术（磁带），通过监督程序（操作系统雏形）控制作业输入输出</p><p>外围机负责把输入纸带录入磁带</p><p>缓解了人机速度矛盾，提高了资源利用率，但是CPU是串行的，大量CPU时间浪费在I/O等待上</p></li><li><p>多道批处理系统<br>磁带往内存输入多道程序，并发执行，输入、计算、输出互不干扰</p><p>操作系统诞生，引入了中断技术，资源利用率大幅上升，但是缺少人机交互功能，用户响应时间长（用户提交作业之后只能等待作业完成）</p></li></ul></li><li><p><strong>分时操作系统</strong></p><ul><li>分时操作系统：计算机以时间片为单位轮流为各个用户/作业服务,各个用户可通过终端与计算机进行交互。</li><li>主要优点:用户请求可以被即时响应,解决了人机交互问题。允许多个用户同时使用一台计算机,并且用户对计算机的操作相互独立,感受不到别人的存在。</li><li>主要缺点:不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的,循环地为每个用户/作业服务一个时间片,不区分任务的紧急性。</li></ul></li></ol><ol start="4"><li><strong>网络操作系统</strong><ul><li>网络操作系统:是伴随着计算机网络的发展而诞生的,能把网络中各个计算机有机地结合起来,实现数据传送等功能,实现网络中各种资源的共享(如文件共享)和各台计算机之间的通信。(如: Windows NT就是一种典型的网络操作系统,网站服务器就可以使用)</li></ul></li></ol><ol start="5"><li><strong>分布式操作系统</strong><ul><li>分布式操作系统:主要特点是分布性和并行性。系统中的各台计算机地位相同,任何工作都可以分布在这些计算机上,由它们并行、协同完成这个任务。</li></ul></li></ol><ol start="6"><li><p><strong>PC操作系统</strong></p><ul><li><p>Windows10</p></li><li><p>MacOS</p></li><li><p>Ubuntu</p></li></ul></li></ol><p><strong>小结：发展历程</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/105106471.png" alt="mark"></p><h2 id="3-运行机制和体系结构"><a href="#3-运行机制和体系结构" class="headerlink" title="3. 运行机制和体系结构"></a>3. 运行机制和体系结构</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/105349798.png" alt="mark"></p><h3 id="3-1-运行机制"><a href="#3-1-运行机制" class="headerlink" title="3.1 运行机制"></a>3.1 运行机制</h3><ul><li><p><strong>指令</strong></p><ul><li><p><strong>特权指令</strong></p><ul><li>内存清零指令</li></ul></li><li><p><strong>非特权指令</strong></p><ul><li>加减乘除运算指令</li></ul></li></ul></li></ul><ul><li><p><strong>处理器状态</strong></p><ul><li><p><strong>核心态(目管态)</strong></p><ul><li>PSW=0，<strong>运行执行特权指令</strong><br>PSW 程序状态字寄存器，通过标志位标识处理器的运行状态</li></ul></li><li><p><strong>用户态(目态)</strong></p><ul><li>PSW=1，<strong>只能使用非特权指令</strong></li></ul></li></ul></li></ul><ul><li><p><strong>程序</strong></p><ul><li><p><strong>应用程序</strong><br>为了安全，运行在用户态</p></li><li><p><strong>内核程序</strong><br>系统管理者，运行在核心态</p></li></ul></li></ul><h3 id="3-2-体系结构"><a href="#3-2-体系结构" class="headerlink" title="3.2 体系结构"></a>3.2 体系结构</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/112129093.png" alt="mark"></p><ul><li><strong>大内核</strong><br>将操作系统的主要功能模块都作为系统内核，运行在核心态<br>高性能，但是内核代码庞大难以维护</li><li><strong>微内核</strong><br>只把基本概念保留在内核<br>功能少，功能清晰方便维护，但是需要频繁的在核心态和用户态之间切换，性能低</li></ul><h3 id="3-3-OS内核结构"><a href="#3-3-OS内核结构" class="headerlink" title="3.3 OS内核结构"></a>3.3 OS内核结构</h3><ul><li><p><strong>时钟管理</strong></p><ul><li>用于计时</li><li>通过时钟中断的管理,可以实现进程的切换</li></ul></li><li><p><strong>中断处理</strong></p></li><li><p><strong>原语</strong></p><ul><li>运行时间短，调用频繁，原子性运行只能一气呵成，不可中断</li></ul></li><li><p><strong>系统资源管理</strong></p><p>有的操作系统不把这个作为“内核功能”（微内核）</p><ul><li><p>进程管理</p></li><li><p>储存器管理</p></li><li><p>设备管理</p></li></ul></li></ul><h2 id="4-中断和异常"><a href="#4-中断和异常" class="headerlink" title="4. 中断和异常"></a>4. 中断和异常</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/112855093.png" alt="mark"></p><h3 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h3><ul><li>发生了中断,就意味着需要操作系统介入,开展管理工作。 </li><li>由于操作系统的管理工作(比如进程切换、分配I/O设备等)需要<strong>使用特权指令</strong>,<strong>因此CPU要从用户态转为核心态</strong>。 </li><li>中断可以使CPU从用户态切换为核心态,使操作系统获得计算机的控制权。有了中断才能实现多道程序并发执行。 </li><li><strong>中断是CPU从用户态-&gt;核心态切换的唯一途径。</strong> </li><li><strong>核心态-&gt;用户态切换只需要执行一个特权指令</strong>，<code>将PSW设置为0</code></li></ul><h3 id="4-2-中断分类"><a href="#4-2-中断分类" class="headerlink" title="4.2 中断分类"></a>4.2 中断分类</h3><ul><li><p><strong>内中断(异常/例外/陷入)</strong></p><p><strong>信号来源CPU内部，与当前执行的指令有关</strong></p><ul><li><p>自愿中断(指令中断)<br>系统调用时使用的访管指令(陷入指令/trap指令)</p></li><li><p>强迫中断</p><ul><li><p>硬件故障<br>缺页错误</p></li><li><p>软件中断<br>除0错误</p></li></ul></li></ul></li><li><p><strong>外中断(狭义中断)</strong></p><p><strong>信号来源CPU外部，与当前执行的指令无关</strong></p><ul><li><p>外设请求<br>外设(比如打印机)I/O操作完成发出中断信号<br>键盘输入一个字符</p></li><li><p>人工干预<br>用户强制终止一个进程</p></li></ul></li></ul><h3 id="4-3-中断处理的过程"><a href="#4-3-中断处理的过程" class="headerlink" title="4.3 中断处理的过程"></a>4.3 中断处理的过程</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/114138459.png" alt="mark"></p><p><strong>大致处理过程</strong></p><ul><li>Step 1:执行完每个指令之后, CPU都要检查当前是否有外部中断信号 </li><li>Step 2:如果检测到外部中断信号,则需要保护被中断进程的CPU环境(如程序状态字Psw、程序计数器PC、各种通用寄存器) </li><li>Step 3:根据中断信号类型转入相应的中断处理程序(进入核心态) </li><li>Step 4:恢复原进程的CPU环境并退出中断,返回原进程继续往下执行</li></ul><h2 id="5-系统调用"><a href="#5-系统调用" class="headerlink" title="5. 系统调用"></a>5. 系统调用</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/114523218.png" alt="mark"></p><h3 id="5-1-概念"><a href="#5-1-概念" class="headerlink" title="5.1 概念"></a>5.1 概念</h3><ul><li>“系统调用”是操作系统提供给应用程序(程序员/编程人员)使用的接口,可以理解为一种可供应用程序调用的特殊函数,应用程序可以<strong>发出系统调用请求来获得操作系统的服务</strong>。 </li><li>应用程序通过系统调用请求操作系统的服务。 系统中的各种共享资源都由操作系统统一掌管,因此在用户程序中,凡是与资源有关的操作(如存储分配、1/0操作、文件管理等) ,都必须通过系统调用的方式向操作系统提出服务请求,由操作系统代为完成。</li><li><strong>这样可以保证系统的稳定性和安全性,防止用户进行非法操作。</strong> </li><li><strong>系统调用相关的处理需要在核心态下完成。</strong></li></ul><h3 id="5-2-系统调用和库函数的区别"><a href="#5-2-系统调用和库函数的区别" class="headerlink" title="5.2 系统调用和库函数的区别"></a>5.2 系统调用和库函数的区别</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/115154503.png" alt="mark"></p><h3 id="5-3-系统调用过程"><a href="#5-3-系统调用过程" class="headerlink" title="5.3 系统调用过程"></a>5.3 系统调用过程</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/115353845.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ： <a href="https://mubu.com/doc/Cd-Y4YOfkh#" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#</a></p><p>​                    <a href="https://blog.csdn.net/weixin_43914604/article/details/104415990" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43914604/article/details/104415990</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-01-概述&quot;&gt;&lt;a href=&quot;#操作系统-01-概述&quot; class=&quot;headerlink&quot; title=&quot;操作系统-01-概述&quot;&gt;&lt;/a&gt;操作系统-01-概述&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;是系统最基本最核心的软件，属于系统软件&lt;/li&gt;
&lt;li&gt;控制和管理整个计算机的硬件和软件资源&lt;/li&gt;
&lt;li&gt;合理的组织、调度计算机的工作与资源的分配&lt;/li&gt;
&lt;li&gt;为用户和其它软件提供方便的接口和环境&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201003/103437449.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-717-1比特与2比特字符</title>
    <link href="http://zhuuu.work/2020/10/02/Leetcode/Leetcode-717-1%E6%AF%94%E7%89%B9%E4%B8%8E2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6/"/>
    <id>http://zhuuu.work/2020/10/02/Leetcode/Leetcode-717-1%E6%AF%94%E7%89%B9%E4%B8%8E2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6/</id>
    <published>2020-10-02T05:24:53.000Z</published>
    <updated>2020-10-02T02:29:18.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-717-1比特与2比特字符"><a href="#Leetcode-717-1比特与2比特字符" class="headerlink" title="Leetcode-717-1比特与2比特字符"></a>Leetcode-717-<a href="https://leetcode-cn.com/problems/1-bit-and-2-bit-characters/" target="_blank" rel="noopener">1比特与2比特字符</a></h1><p><strong>题目描述：</strong></p><p>有两种特殊字符。第一种字符可以用一比特0来表示。第二种字符可以用两比特(10 或 11)来表示。</p><p>现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">bits &#x3D; [1, 0, 0]</span><br><span class="line">输出: True</span><br><span class="line">解释: </span><br><span class="line">唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">bits &#x3D; [1, 1, 1, 0]</span><br><span class="line">输出: False</span><br><span class="line">解释: </span><br><span class="line">唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>1 &lt;= len(bits) &lt;= 1000</code>.</li><li><code>bits[i]</code> 总是<code>0</code> 或 <code>1</code>.</li></ul><a id="more"></a><h2 id="思路-：-线性扫描"><a href="#思路-：-线性扫描" class="headerlink" title="思路 ： 线性扫描"></a>思路 ： 线性扫描</h2><ul><li>我们可以对bits数组从左到右扫描来判断最后一位是否是一比特字符<ul><li>当扫描到第i位的时候，如果bits[i] = 1, 那么说明这是一个两比特字符，那么将步长调整为2（也就是i的值加2）</li><li>当扫描到第i位的时候，如果bits[i] = 0,说明这是个一比特字符,步长设置为1</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOneBitCharacter</span><span class="params">(<span class="keyword">int</span>[] bits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; bits.length - <span class="number">1</span>) &#123;</span><br><span class="line">            i += bits[i] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == bits.length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)，其中 n是 bits 数组的长度。</li><li>空间复杂度：O(1)。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-717-1比特与2比特字符&quot;&gt;&lt;a href=&quot;#Leetcode-717-1比特与2比特字符&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-717-1比特与2比特字符&quot;&gt;&lt;/a&gt;Leetcode-717-&lt;a href=&quot;https://leetcode-cn.com/problems/1-bit-and-2-bit-characters/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1比特与2比特字符&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有两种特殊字符。第一种字符可以用一比特0来表示。第二种字符可以用两比特(10 或 11)来表示。&lt;/p&gt;
&lt;p&gt;现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bits &amp;#x3D; [1, 0, 0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: True&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bits &amp;#x3D; [1, 1, 1, 0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: False&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= len(bits) &amp;lt;= 1000&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bits[i]&lt;/code&gt; 总是&lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;1&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-771-宝石与石头</title>
    <link href="http://zhuuu.work/2020/10/02/Leetcode/Leetcode-771-%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4/"/>
    <id>http://zhuuu.work/2020/10/02/Leetcode/Leetcode-771-%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4/</id>
    <published>2020-10-02T02:22:53.000Z</published>
    <updated>2020-10-02T02:14:07.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-771-宝石与石头"><a href="#Leetcode-771-宝石与石头" class="headerlink" title="Leetcode-771-宝石与石头"></a>Leetcode-771-<a href="https://leetcode-cn.com/problems/jewels-and-stones/" target="_blank" rel="noopener">宝石与石头</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p></li><li><p>J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: J &#x3D; &quot;aA&quot;, S &#x3D; &quot;aAAbbbb&quot;</span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: J &#x3D; &quot;z&quot;, S &#x3D; &quot;ZZ&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>S</code> 和 <code>J</code> 最多含有50个字母。</li><li><code>J</code> 中的字符不重复。</li></ul><a id="more"></a><h2 id="思路-1：-HashSet"><a href="#思路-1：-HashSet" class="headerlink" title="思路 1： HashSet"></a>思路 1： HashSet</h2><ul><li>标签：字符串</li><li>首先对J进行遍历，将字符分别存到HashSet中，以便之后遍历S的时候查找</li><li>遍历S，并将每个字符与HashSet中的进行比对，如果存在，则结果res++，遍历结束，返回res</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 把J中字符都加入到hashset中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; J.length();i++)&#123;</span><br><span class="line">            set.add(J.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.判断 S中是否有对应的字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; S.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(S.charAt(i)))&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong> </p><ul><li>时间复杂度：O(m+n)，m为J的长度，n为S的长度</li><li>空间复杂度： O(m) 需要把J中字符都加入到hashset中</li></ul><h2 id="思路2：暴力求解"><a href="#思路2：暴力求解" class="headerlink" title="思路2：暴力求解"></a>思路2：暴力求解</h2><ul><li>暴力法的思路很直观，遍历字符串 S<em>S</em>，对于 S<em>S</em> 中的每个字符，遍历一次字符串 J，如果其和 J中的某一个字符相同，则是宝石。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len1 = J.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = S.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2;++i)&#123;</span><br><span class="line">            <span class="keyword">char</span> curr = S.charAt(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len1;++j)&#123;</span><br><span class="line">                <span class="keyword">char</span> jewel = J.charAt(j);</span><br><span class="line">                <span class="keyword">if</span>(curr == jewel)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><ul><li><strong>时间复杂度：O(mn)</strong>，其中 mm 是字符串 J的长度，n 是字符串 S的长度。遍历字符串 S 的时间复杂度是 O(n)，对于 SS 中的每个字符，需要遍历字符串 J判断是否是宝石，时间复杂度是 O(m)，因此总时间复杂度是 O(mn)。</li><li><strong>空间复杂度：O(1)</strong>。只需要维护常量的额外空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-771-宝石与石头&quot;&gt;&lt;a href=&quot;#Leetcode-771-宝石与石头&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-771-宝石与石头&quot;&gt;&lt;/a&gt;Leetcode-771-&lt;a href=&quot;https://leetcode-cn.com/problems/jewels-and-stones/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;宝石与石头&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: J &amp;#x3D; &amp;quot;aA&amp;quot;, S &amp;#x3D; &amp;quot;aAAbbbb&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: J &amp;#x3D; &amp;quot;z&amp;quot;, S &amp;#x3D; &amp;quot;ZZ&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt; 和 &lt;code&gt;J&lt;/code&gt; 最多含有50个字母。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;J&lt;/code&gt; 中的字符不重复。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>股票问题-合集</title>
    <link href="http://zhuuu.work/2020/10/01/LeetcodeExplore/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98-%E5%90%88%E9%9B%86/"/>
    <id>http://zhuuu.work/2020/10/01/LeetcodeExplore/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98-%E5%90%88%E9%9B%86/</id>
    <published>2020-10-01T07:11:53.000Z</published>
    <updated>2020-12-17T02:29:49.849Z</updated>
    
    <content type="html"><![CDATA[<h1 id="股票问题-合集"><a href="#股票问题-合集" class="headerlink" title="股票问题-合集"></a>股票问题-合集</h1><p>题号    题解<br>121. 买卖股票的最佳时机    暴力解法、动态规划（Java）<br>122. 买卖股票的最佳时机 II    暴力搜索、贪心算法、动态规划（Java）<br>123. 买卖股票的最佳时机 III    动态规划（Java）<br>188. 买卖股票的最佳时机 IV    动态规划（「力扣」更新过用例，只有优化空间的版本可以 AC）<br>309. 最佳买卖股票时机含冷冻期    动态规划（Java）<br>714. 买卖股票的最佳时机含手续费    动态规划（Java）</p><table><thead><tr><th><strong>题号</strong></th><th><strong>题解</strong></th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></td><td><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/bao-li-mei-ju-dong-tai-gui-hua-chai-fen-si-xiang-b/" target="_blank" rel="noopener">暴力解法、动态规划（Java）</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii" target="_blank" rel="noopener"> 122. 买卖股票的最佳时机 II</a></td><td><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/tan-xin-suan-fa-by-liweiwei1419-2/" target="_blank" rel="noopener">暴力搜索、贪心算法、动态规划（Java）</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii" target="_blank" rel="noopener">123. 买卖股票的最佳时机 III</a></td><td><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/dong-tai-gui-hua-by-liweiwei1419-7/" target="_blank" rel="noopener">动态规划（Java）</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv" target="_blank" rel="noopener">188. 买卖股票的最佳时机 IV</a></td><td><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/dong-tai-gui-hua-by-liweiwei1419-4/" target="_blank" rel="noopener">动态规划（「力扣」更新过用例，只有优化空间的版本可以 AC）</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期</a></td><td><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/dong-tai-gui-hua-by-liweiwei1419-5/" target="_blank" rel="noopener">动态规划（Java）</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee" target="_blank" rel="noopener">714. 买卖股票的最佳时机含手续费</a></td><td><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/dong-tai-gui-hua-by-liweiwei1419-6/" target="_blank" rel="noopener">动态规划（Java）</a></td></tr></tbody></table><ul><li><strong>推荐阅读</strong><ul><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/dong-tai-gui-hua-by-liweiwei1419-5/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/dong-tai-gui-hua-by-liweiwei1419-5/</a></li><li><a href="https://leetcode-cn.com/circle/article/qiAgHn/" target="_blank" rel="noopener">https://leetcode-cn.com/circle/article/qiAgHn/</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/si-chong-shi-xian-tu-jie-714-mai-mai-gu-piao-de-zu/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/si-chong-shi-xian-tu-jie-714-mai-mai-gu-piao-de-zu/</a></li></ul></li></ul><a id="more"></a><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></h2><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h3><ul><li><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p></li><li><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p></li></ul><p>注意：你不能在买入股票前卖出股票。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class="line">     </span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><h3 id="2-思路一-：-暴力"><a href="#2-思路一-：-暴力" class="headerlink" title="2. 思路一 ： 暴力"></a>2. 思路一 ： 暴力</h3><p><strong>思路</strong>：枚举所有发生一次交易的股价差。</p><p><strong>代码1 ：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)&#123;        <span class="comment">// 1. 特判</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;        <span class="comment">// 有可能不发生交易，所以结果集的初始值设置为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 枚举所有发生一次交易的股票价格差</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; len;j++)&#123;</span><br><span class="line">                res =  Math.max(res,prices[j] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<code>O(N^2)</code>，这里 N 是股价数组的长度；</li><li>空间复杂度：<code>O(1)</code>。</li></ul><h3 id="3-思路二-：-动态规划"><a href="#3-思路二-：-动态规划" class="headerlink" title="3. 思路二 ： 动态规划"></a>3. 思路二 ： 动态规划</h3><p><strong>思路</strong>：题目只问最大利润，没有问这几天具体哪一天买、哪一天卖，因此可以考虑使用 <strong>动态规划</strong> 的方法来解决。</p><p>买卖股票有约束，根据题目意思，有以下两个约束条件：</p><ul><li>条件 1：你不能在买入股票前卖出股票；</li><li>条件 2：最多只允许完成一笔交易。</li></ul><p>因此 <strong>当天是否持股</strong> 是一个很重要的因素，而当前是否持股和昨天是否持股有关系，为此我们需要把 <strong>是否持股</strong> 设计到状态数组中。</p><p><strong>1. 状态定义：</strong></p><p><code>dp[i] [j]</code>：下标为 i 这一天结束的时候，手上持股状态为 j 时，我们持有的现金数。</p><ul><li>j = 0，表示当前不持股；</li><li>j = 1，表示当前持股。</li></ul><p><strong>注意</strong>：这个状态具有前缀性质，下标为 <code>i</code> 的这一天的计算结果包含了区间 <code>[0, i]</code> 所有的信息，因此最后输出 <code>dp[len - 1][0]</code>。</p><p><strong>说明：</strong></p><ul><li>使用「现金数」这个说法主要是为了体现 <strong>买入股票手上的现金数减少，卖出股票手上的现金数增加 这个事实；</strong></li><li>「现金数」等价于题目中说的「利润」，即先买入这只股票，后买入这只股票的差价；</li><li>因此在刚开始的时候，我们的手上肯定是有一定现金数能够买入这只股票，即刚开始的时候现金数肯定不为 0，但是写代码的时候可以设置为 0。极端情况下（股价数组为 [5, 4, 3, 2, 1]），此时不发生交易是最好的（这一点是补充说明，限于我的表达，希望不要给大家造成迷惑）。</li></ul><p><strong>2.状态转移</strong></p><p><code>dp[i][0]</code> : 规定了今天不持股，有以下两种情况</p><ul><li>昨天不持股，今天什么都不做</li><li>昨天持股 ，今天卖出股票（现金数增加）</li></ul><p><code>dp[i][1]</code> : 规定了今天持股，有以下两种情况</p><ul><li>昨天持股，今天什么都不做</li><li>昨天不持股，今天买入股票（<strong>注意</strong>：只允许交易一次，因此手上的现金数就是当天的股价的相反数）</li></ul><p><strong>知识点</strong>：</p><ul><li>多阶段决策问题：动态规划常常用于求解多阶段决策问题；</li><li><strong>无后效性</strong>：每一天是否持股设计成状态变量的一维。状态设置具体，推导状态转移方程方便。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 状态定义</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// dp[i][0] 下标为i这天结束的时候，不持股，手上拥有的现金数</span></span><br><span class="line">        <span class="comment">// dp[i][1] 下标为i这天结束的时候，持股，手上的现金数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 初始化 : 不持股显然为0,持股就需要减去第1天（下标为0）的股价</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 状态转移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>],dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>],-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 返回值</span></span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(N)，遍历股价数组可以得到最优解；</li><li>空间复杂度：O(N)，状态数组的长度为 N。</li></ul><h3 id="4-处理输入"><a href="#4-处理输入" class="headerlink" title="4. 处理输入"></a>4. 处理输入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] stringToIntegerArray(String input)&#123;</span><br><span class="line">        input = input.trim();</span><br><span class="line">        input = input.substring(<span class="number">1</span>,input.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (input.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] parts = input.split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">int</span>[] output = <span class="keyword">new</span> <span class="keyword">int</span>[parts.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>;index &lt; parts.length;index++)&#123;</span><br><span class="line">            String part = parts[index].trim();</span><br><span class="line">            output[index] = Integer.parseInt(part);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = in.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] prices = stringToIntegerArray(line);</span><br><span class="line">            <span class="keyword">int</span> ret = <span class="keyword">new</span> Solution().maxProfit(prices);</span><br><span class="line">            String out = String.valueOf(ret);</span><br><span class="line">            System.out.println(out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试输出</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[7,1,5,3,6,4]</span><br><span class="line">5</span><br><span class="line">[7,1,5,3,6,4]</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="5-优化1：滚动数组"><a href="#5-优化1：滚动数组" class="headerlink" title="5. 优化1：滚动数组"></a>5. 优化1：滚动数组</h3><h3 id="6-知识点：无后效性"><a href="#6-知识点：无后效性" class="headerlink" title="6. 知识点：无后效性"></a>6. 知识点：无后效性</h3><ul><li><p>以下截图来自《算法导论》中文版第 15 章第 1 节的描述，这里借用它的图说明动态规划求解过程需要满足无后效性的意思</p></li><li><p>一个问题的递归结构如下图所示（这里忽略问题场景）。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201217/102756669.png" alt="mark"></p><ul><li>可以发现有重复求解的部分，需要添加缓存，这是「记忆化递归」。</li><li>另外还可以从通过发现一个问题最开始的样子，通过「递推」一步一步求得原始问题的解，此时求解的过程如下图所示：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201217/102816884.png" alt="mark"></p><p>箭头指向的地方表示当前求解的过程中参考了以前求解过的问题的结果，这个过程不能形成回路，<strong>形成回路就无法求解</strong>。</p><p><strong>总结 ： 动态规划的两种求解形式</strong></p><ul><li><strong>自顶向下</strong>：也就是记忆化递归，求解过程会遇到重复子问题，所以需要记录每一个子问题的结果；</li><li><strong>自底向上</strong>：通过发现一个问题最开始的样子，通过「递推」一步一步求得原始问题的解。</li></ul><p>在「力扣」上的绝大多数问题都可以通过「自底向上」递推的方式去做。</p><h2 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期</a></h2><h2 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee" target="_blank" rel="noopener">714. 买卖股票的最佳时机含手续费</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;股票问题-合集&quot;&gt;&lt;a href=&quot;#股票问题-合集&quot; class=&quot;headerlink&quot; title=&quot;股票问题-合集&quot;&gt;&lt;/a&gt;股票问题-合集&lt;/h1&gt;&lt;p&gt;题号    题解&lt;br&gt;121. 买卖股票的最佳时机    暴力解法、动态规划（Java）&lt;br&gt;122. 买卖股票的最佳时机 II    暴力搜索、贪心算法、动态规划（Java）&lt;br&gt;123. 买卖股票的最佳时机 III    动态规划（Java）&lt;br&gt;188. 买卖股票的最佳时机 IV    动态规划（「力扣」更新过用例，只有优化空间的版本可以 AC）&lt;br&gt;309. 最佳买卖股票时机含冷冻期    动态规划（Java）&lt;br&gt;714. 买卖股票的最佳时机含手续费    动态规划（Java）&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;题号&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;题解&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;121. 买卖股票的最佳时机&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/bao-li-mei-ju-dong-tai-gui-hua-chai-fen-si-xiang-b/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;暴力解法、动态规划（Java）&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; 122. 买卖股票的最佳时机 II&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/tan-xin-suan-fa-by-liweiwei1419-2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;暴力搜索、贪心算法、动态规划（Java）&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;123. 买卖股票的最佳时机 III&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/dong-tai-gui-hua-by-liweiwei1419-7/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;动态规划（Java）&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;188. 买卖股票的最佳时机 IV&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/dong-tai-gui-hua-by-liweiwei1419-4/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;动态规划（「力扣」更新过用例，只有优化空间的版本可以 AC）&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;309. 最佳买卖股票时机含冷冻期&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/dong-tai-gui-hua-by-liweiwei1419-5/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;动态规划（Java）&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;714. 买卖股票的最佳时机含手续费&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/dong-tai-gui-hua-by-liweiwei1419-6/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;动态规划（Java）&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/dong-tai-gui-hua-by-liweiwei1419-5/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/dong-tai-gui-hua-by-liweiwei1419-5/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/circle/article/qiAgHn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/circle/article/qiAgHn/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/si-chong-shi-xian-tu-jie-714-mai-mai-gu-piao-de-zu/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/si-chong-shi-xian-tu-jie-714-mai-mai-gu-piao-de-zu/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://zhuuu.work/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="贪心算法" scheme="http://zhuuu.work/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>哲学家进餐-多线程</title>
    <link href="http://zhuuu.work/2020/10/01/LeetcodeExplore/%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://zhuuu.work/2020/10/01/LeetcodeExplore/%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-10-01T07:11:53.000Z</published>
    <updated>2020-11-17T08:34:46.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哲学家进餐-多线程"><a href="#哲学家进餐-多线程" class="headerlink" title="哲学家进餐-多线程"></a>哲学家进餐-多线程</h1><h1 id="哲学家进餐"><a href="#哲学家进餐" class="headerlink" title="哲学家进餐"></a><a href="https://leetcode-cn.com/problems/the-dining-philosophers/" target="_blank" rel="noopener">哲学家进餐</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>5 个沉默寡言的哲学家围坐在圆桌前，每人面前一盘意面。叉子放在哲学家之间的桌面上。（5 个哲学家，5 根叉子）</p><p>所有的哲学家都只会在<strong>思考和进餐两种行为间交替</strong>。<strong>哲学家只有同时拿到左边和右边的叉子才能吃到面，而同一根叉子在同一时间只能被一个哲学家使用</strong>。每个哲学家吃完面后都需要把叉子放回桌面以供其他哲学家吃面。<strong>只要条件允许，哲学家可以拿起左边或者右边的叉子，但在没有同时拿到左右叉子时不能进食。</strong></p><p>假设面的数量没有限制，哲学家也能随便吃，不需要考虑吃不吃得下。</p><p><strong>设计一个进餐规则（并行算法）使得每个哲学家都不会挨饿；</strong></p><p>也就是说，在没有人知道别人什么时候想吃东西或思考的情况下，每个哲学家都可以在吃饭和思考之间一直交替下去。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201117/155006163.png" alt="mark"></p><a id="more"></a><p><strong>具体描述</strong></p><ol><li><strong>哲学家从<code>0</code> 到 <code>4</code> 按 顺时针 编号。请实现函数 <code>void wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork)</code>：</strong></li></ol><ul><li><code>philosopher</code> 哲学家的编号。</li><li><code>pickLeftFork</code> 和 <code>pickRightFork</code> 表示拿起左边或右边的叉子。</li><li><code>eat</code> 表示吃面。</li><li><code>putLeftFork</code> 和 <code>putRightFork</code> 表示放下左边或右边的叉子。</li></ul><ol start="2"><li><p><strong>由于哲学家不是在吃面就是在想着啥时候吃面，所以思考这个方法没有对应的回调。</strong></p></li><li><p><strong>给你 5 个线程，每个都代表一个哲学家，请你使用类的同一个对象来模拟这个过程。在最后一次调用结束之前，可能会为同一个哲学家多次调用该函数。</strong></p></li></ol><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：[[4,2,1],[4,1,1],[0,1,1],[2,2,1],[2,1,1],[2,0,3],[2,1,2],[2,2,2],[4,0,3],[4,1,2],[0,2,1],[4,2,2],[3,2,1],[3,1,1],[0,0,3],[0,1,2],[0,2,2],[1,2,1],[1,1,1],[3,0,3],[3,1,2],[3,2,2],[1,0,3],[1,1,2],[1,2,2]]</span><br><span class="line">解释:</span><br><span class="line">n 表示每个哲学家需要进餐的次数。</span><br><span class="line">输出数组描述了叉子的控制和进餐的调用，它的格式如下：</span><br><span class="line">output[i] &#x3D; [a, b, c] (3个整数)</span><br><span class="line">- a 哲学家编号。</span><br><span class="line">- b 指定叉子：&#123;1 : 左边, 2 : 右边&#125;.</span><br><span class="line">- c 指定行为：&#123;1 : 拿起, 2 : 放下, 3 : 吃面&#125;。</span><br><span class="line">如 [4,2,1] 表示 4 号哲学家拿起了右边的叉子。</span><br></pre></td></tr></table></figure><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>这道题本质上其实是想考察<strong>如何避免死锁</strong>。</li><li>易知：当 5 个哲学家都拿着其左边(或右边)的叉子时，会进入死锁。</li></ul><p><strong>PS：死锁的 4 个必要条件：</strong></p><ol><li><strong>互斥条件：</strong>一个资源每次只能被一个进程使用，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li><li><strong>请求与保持条件：</strong>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li><li><strong>不可剥夺条件:</strong>进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。</li><li><strong>循环等待条件:</strong> 若干进程间形成首尾相接循环等待资源的关系。</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201117/155916028.png" alt="mark"></p><ul><li><strong>情形一：允许四个哲学家进餐</strong></li></ul><p>故最多只允许 4 个哲学家去持有叉子，可保证至少有 1 个哲学家能吃上意大利面（即获得到 2个叉子）。<br>因为最差情况下是：4 个哲学家都各自持有1个叉子，此时还 剩余 1 个叉子 可供使用，这 4 个哲学家中必然有1人能获取到这个 剩余的 1 个叉子，从而手持 2 个叉子，可以吃意大利面。<br><strong>即：4 个人中，1 个人有 2 个叉子，3 个人各持 1 个叉子，共计 5 个叉子。</strong></p><ul><li><strong>情形二 ： 允许三个哲学家进餐</strong></li></ul><p><strong>当然可行，3个哲学家可以先都各自持有1把叉子，此时还剩余2把叉子；</strong></p><p><strong>当这3个哲学家刚好都相邻</strong>(比如：编号为图中的0, 1, 2)，可能会造成只有1个哲学家能吃到意面的情况，具体而言即0号哲学家拿到了其左侧的叉子(编号为1)，</p><p>1号哲学家也拿到了其左侧的叉子(编号为2)</p><p>2号哲学家也拿到了其左侧的叉子(编号为3)，此时只有0号哲学家能拿到其右侧的叉子(编号为0)，因此只有0号哲学家能吃到意面。<br>而其余情况下，3个哲学家中都能有2人吃到意面。</p><p><strong>即：3 个人中，2 个人各自持有 2 个叉子，1 个人持有 1个叉子，共计 5 个叉子。</strong></p><p>并且仔细想想，叉子的数目是<strong>固定</strong>的(个数为<code>5</code>)，直觉上来讲<code>3</code>个人去抢<code>5</code>个叉子 比 <code>4</code>个人去抢<code>5</code>个叉子效率高。</p><h2 id="1-思路一-：-互斥量实现"><a href="#1-思路一-：-互斥量实现" class="headerlink" title="1. 思路一 ： 互斥量实现"></a>1. 思路一 ： 互斥量实现</h2><ul><li><p>用Semaphore去实现上述的限制：<code>Semaphore eatLimit = new Semaphore(4);</code><br>一共有5个叉子，视为5个ReentrantLock，并将它们全放入1个数组中。</p></li><li><p>给叉子编号 <code>0, 1, 2, 3, 4</code>（对应数组下标）。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 1个Fork视为1个ReentrantLock，5个叉子即5个ReentrantLock，将其都放入数组中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock[] lockList = &#123;<span class="keyword">new</span> ReentrantLock(),</span><br><span class="line">            <span class="keyword">new</span> ReentrantLock(),</span><br><span class="line">            <span class="keyword">new</span> ReentrantLock(),</span><br><span class="line">            <span class="keyword">new</span> ReentrantLock(),</span><br><span class="line">            <span class="keyword">new</span> ReentrantLock()&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 限制 ： 最多只有4个哲学家持有叉子</span></span><br><span class="line">    <span class="keyword">private</span> Semaphore eatLimit = <span class="keyword">new</span> Semaphore(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiningPhilosophers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the run() method of any runnable to execute its code</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable pickRightFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable eat,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putLeftFork,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Runnable putRightFork)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftFork  = (philosopher + <span class="number">1</span>) % <span class="number">5</span>;  <span class="comment">// 左边的叉子编号</span></span><br><span class="line">        <span class="keyword">int</span> rightFork = philosopher;            <span class="comment">// 右边的叉子编号</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让一个人进餐 进入临界区</span></span><br><span class="line">        eatLimit.acquire();  <span class="comment">// 限制人数 -1</span></span><br><span class="line">        lockList[leftFork].lock();     <span class="comment">// 拿起左边的叉子</span></span><br><span class="line">        lockList[rightFork].lock();     <span class="comment">// 拿起右边的叉子</span></span><br><span class="line"></span><br><span class="line">        pickLeftFork.run();    <span class="comment">//拿起左边的叉子 的具体执行</span></span><br><span class="line">        pickRightFork.run();    <span class="comment">//拿起右边的叉子 的具体执行</span></span><br><span class="line">        eat.run();</span><br><span class="line"></span><br><span class="line">        putLeftFork.run();    <span class="comment">//放下左边的叉子 的具体执行</span></span><br><span class="line">        putRightFork.run();    <span class="comment">//放下右边的叉子 的具体执行</span></span><br><span class="line"></span><br><span class="line">        lockList[leftFork].unlock();    <span class="comment">//放下左边的叉子</span></span><br><span class="line">        lockList[rightFork].unlock();    <span class="comment">//放下右边的叉子</span></span><br><span class="line"></span><br><span class="line">        eatLimit.release(); <span class="comment">//限制的人数 +</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;哲学家进餐-多线程&quot;&gt;&lt;a href=&quot;#哲学家进餐-多线程&quot; class=&quot;headerlink&quot; title=&quot;哲学家进餐-多线程&quot;&gt;&lt;/a&gt;哲学家进餐-多线程&lt;/h1&gt;&lt;h1 id=&quot;哲学家进餐&quot;&gt;&lt;a href=&quot;#哲学家进餐&quot; class=&quot;headerlink&quot; title=&quot;哲学家进餐&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/the-dining-philosophers/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;哲学家进餐&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;5 个沉默寡言的哲学家围坐在圆桌前，每人面前一盘意面。叉子放在哲学家之间的桌面上。（5 个哲学家，5 根叉子）&lt;/p&gt;
&lt;p&gt;所有的哲学家都只会在&lt;strong&gt;思考和进餐两种行为间交替&lt;/strong&gt;。&lt;strong&gt;哲学家只有同时拿到左边和右边的叉子才能吃到面，而同一根叉子在同一时间只能被一个哲学家使用&lt;/strong&gt;。每个哲学家吃完面后都需要把叉子放回桌面以供其他哲学家吃面。&lt;strong&gt;只要条件允许，哲学家可以拿起左边或者右边的叉子，但在没有同时拿到左右叉子时不能进食。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设面的数量没有限制，哲学家也能随便吃，不需要考虑吃不吃得下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计一个进餐规则（并行算法）使得每个哲学家都不会挨饿；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也就是说，在没有人知道别人什么时候想吃东西或思考的情况下，每个哲学家都可以在吃饭和思考之间一直交替下去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201117/155006163.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="死锁" scheme="http://zhuuu.work/tags/%E6%AD%BB%E9%94%81/"/>
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="进程同步" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Netty-02-NIO实战及原理</title>
    <link href="http://zhuuu.work/2020/10/01/Netty/Netty-02-NIO%E5%AE%9E%E6%88%98%E5%8F%8A%E5%8E%9F%E7%90%86/"/>
    <id>http://zhuuu.work/2020/10/01/Netty/Netty-02-NIO%E5%AE%9E%E6%88%98%E5%8F%8A%E5%8E%9F%E7%90%86/</id>
    <published>2020-10-01T03:05:24.000Z</published>
    <updated>2020-10-09T02:46:12.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-02-NIO实战及原理"><a href="#Netty-02-NIO实战及原理" class="headerlink" title="Netty-02-NIO实战及原理"></a>Netty-02-NIO实战及原理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>Java NIO 全称 <code>java non-blocking IO</code>，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入/输出的新特性，被统称为 NIO(即 New IO)，是<strong>同步非阻塞</strong>的</p></li><li><p>NIO 相关类都被放在 <code>java.nio</code> 包及子包下，并且对原 <code>java.io</code> 包中的很多类进行改写。</p></li><li><p>NIO 有三大核心部分：<strong>Channel(通道)</strong>，<strong>Buffer(缓冲区)</strong>, <strong>Selector(选择器)</strong></p></li><li><p>NIO是 面向<strong>缓</strong>冲区 ，或者面向 <strong>块</strong> 编程的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供<strong>非阻塞</strong>式的高伸缩性网络</p></li><li><p><code>Java NIO</code>的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而<strong>不是保持线程阻塞</strong>，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。</p></li><li><p>通俗理解：<code>NIO</code>是可以做到用一个线程来处理多个操作的。假设有<code>10000</code>个请求过来,根据实际情况，可以分配<code>50</code>或者<code>100</code>个线程来处理。不像之前的阻塞<code>IO</code>那样，非得分配<code>10000</code>个。</p></li><li><p><code>HTTP2.0</code>使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比<code>HTTP1.1</code>大了好几个数量级。</p></li></ul><a id="more"></a><h2 id="1-NIO三大核心概述"><a href="#1-NIO三大核心概述" class="headerlink" title="1. NIO三大核心概述"></a>1. NIO三大核心概述</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201002/111307133.png" alt="mark"></p><p><strong>Buffer：</strong></p><ul><li>缓存数组，就是一个内存块，底层用数组实现</li><li>与<code>Channel</code>进行数据的读写。</li><li>数据的读取写入是通过<code>Buffer</code>, 这个和<code>BIO</code> 一样, 而<code>BIO</code> 中要么是输入流，或者是输出流, 不能双向，但是<code>NIO</code>的<code>Buffer</code> 是可以读也可以写, 需要 <code>flip</code> 方法切换。</li></ul><p><strong>Channel：</strong></p><ul><li>通信通道，每个客户端连接都会建立一个<code>Channel</code>通道</li><li>客户端直接与<code>Channel</code>进行通信，当客户端发送消息时，消息就流通到<code>Channel</code>里面，本地程序需要将<code>Channel</code>里面的数据存放在<code>Buffer</code>里面，才可以查看；当本地需要发送消息时，先把消息存在<code>Buffer</code>里面，再将<code>Buffer</code>里面的数据放入<code>Channel</code>，数据就流通到了客户端</li><li>总而言之：<code>Buffer</code>就是本地程序与<code>Channel</code>数据交换的一个中间媒介。</li></ul><p><strong>Selector</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201002/111954021.png" alt="mark"></p><ul><li>NIO之所以是非阻塞的，关键在于它一个线程可以同时处理多个客户端的通信。而<code>Selector</code>就是它一个线程如何处理多个客户端通信的关键，一个<code>Selector</code>就对应一个线程</li><li>首先在创建与客户端连接的<code>Channel</code>时，应该调用 <code>Channel.register()</code>方法，将Channel注册到一个<code>Selector</code>上面。调用该方法后，会返回一个<code>SelectionKey</code>对象，该对象与<code>Channel</code>是一一对应的。而<code>Selector</code>则通过管理<code>SelectionKey</code>的集合间接的去管理各个<code>Channel</code>。示例图如下：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201002/112011816.png" alt="mark"></p><p><code>Selector</code>具体是如何管理这么多个通信的呢？这就引出了<strong>事件</strong>。</p><p><strong>事件、以及NIO的工作流程介绍</strong></p><ul><li><strong>事件：</strong>当将<code>Channel</code>绑定到<code>Selector</code>上面时，必须同时为该<code>Channel</code>声明一个监听该<code>Channel</code>的事件（由<code>Channel</code>和该<code>Channel的事件</code>一起组成了<code>SelectionKey</code>），并将<code>SelectionKey</code>加入到<code>Selector</code>的<code>Set</code>集合中去</li><li>当有客户端建立连接或者进行通信，会在对应的各个<code>Channel</code>中产生不同的事件。</li><li><code>Selector</code>会一直监听所有的事件，当他监听到某个<code>SelectionKey</code>中有事件产生时，会将所有产生事件的<code>SelectionKey</code>统一加入到一个集合中去</li><li>而我们则需要获取到这个集合，首先对集合中的各个<code>SelectionKey</code>进行判断，判断它产生的是什么事件，再根据不同的事件进行不同的处理。</li><li>在操作这个<code>SelectionKey</code>集合的时候，其实我们就是在一个线程里面对几个不同客户端的连接进行操作。具体的关系图如下：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/184806838.png" alt="mark"></p><h2 id="2-Buffer"><a href="#2-Buffer" class="headerlink" title="2. Buffer"></a>2. Buffer</h2><ul><li>缓冲区（Buffer）：缓冲区本质上是一个<strong>可以读写数据的内存块</strong>，可以理解成是一个容器对象（<strong>含数组</strong>），</li><li>该对象提供了一组方法，可以更轻松地使用内存块，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。</li><li><code>Channel</code>提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由<code>Buffer</code>。</li></ul><h3 id="2-1-Buffer类介绍"><a href="#2-1-Buffer类介绍" class="headerlink" title="2.1 Buffer类介绍"></a>2.1 Buffer类介绍</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The characteristics of Spliterators that traverse and split elements</span></span><br><span class="line"><span class="comment">     * maintained in Buffers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SPLITERATOR_CHARACTERISTICS =</span><br><span class="line">        Spliterator.SIZED | Spliterator.SUBSIZED | Spliterator.ORDERED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Used only by direct buffers</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> hoisted here for speed in JNI GetDirectBufferAddress</span></span><br><span class="line">    <span class="keyword">long</span> address;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/185018679.png" alt="mark"></p><ul><li><p>基类是<code>Buffer</code>抽象类</p></li><li><p>基类派生出基于基本数据类型的7个<code>xxxBuffer</code> 抽象类，没有<code>boolean</code>相关的<code>buffer</code>类。</p></li><li><p>除了<code>ByteBuffer</code>外，每个基本数据的抽象类 <code>xxxBuffer</code> 类下面都派生出转向 <code>ByteBuffer</code> 的类 <code>ByteBufferXxxAsBufferL</code> 和 <code>ByteBufferAsXxxBufferB</code>实现类；以及 <code>DirectXxxBufferU</code> 和 <code>DirectXxxBufferS</code> 和 <code>HeapXxxBuffer</code>==（具体实例对象类）==这五个类。</p></li><li><p>就只有抽象类<code>CharBuffer</code> 派生出了第六个类<code>StringCharBuffer</code>。</p></li><li><p><code>ByteBuffer</code>只派生出了 <code>HeapByteBuffer</code> 和 <code>MappedByteBufferR</code> 两个类</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/185139008.png" alt="mark"></p><h3 id="2-2-Buffer-属性"><a href="#2-2-Buffer-属性" class="headerlink" title="2.2 Buffer 属性"></a>2.2 Buffer 属性</h3><table><thead><tr><th><strong>属性</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Capacity</td><td>容量，即可以容纳的最大数据量；在缓冲区创建时被设定并且不能改变</td></tr><tr><td>Limit</td><td>表示缓冲区的当前终点，不能对缓冲区超过极限的位置进行读写操作。且极限是可以修改的</td></tr><tr><td>Position</td><td>位置，下一个要被读或写的元素的索引，每次读写缓冲区数据时都会改变改值，为下次读写作准备</td></tr><tr><td>Mark</td><td>标记 ，一般不会主动修改，在<code>flip()</code>被调用后，mark就作废了。</td></tr></tbody></table><blockquote><p>mark &lt;= position &lt;= limit &lt;= capacity</p></blockquote><h3 id="2-3-简单使用"><a href="#2-3-简单使用" class="headerlink" title="2.3 简单使用"></a>2.3 简单使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 举例说明Buffer的使用</span></span><br><span class="line">        <span class="comment">// 创建一个IntBuffer,大小为5,即存放5个int类型</span></span><br><span class="line">        IntBuffer intBuffer = IntBuffer.allocate(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 向Buffer中存储数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intBuffer.capacity(); i++) &#123;</span><br><span class="line">            intBuffer.put(i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 从Buffer中读取数据</span></span><br><span class="line">        <span class="comment">// 将buffer进行读写切换（重要）</span></span><br><span class="line">        intBuffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (intBuffer.hasRemaining())&#123;</span><br><span class="line">            System.out.println(intBuffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Buffer<code>刚创建时，</code>capacity = 5<code>，固定不变。</code>limit<code>指针指向</code>5<code>，</code>position<code>指向</code>0<code>，</code>mark<code>指向</code>-1</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/185326111.png" alt="mark"></p><ul><li>之后调用 <code>intBuffer.put</code>方法，向<code>buffer</code>中添加数据，会不断移动<code>position</code>指针，最后<code>position</code>变量会和<code>limit</code>指向相同。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/185351549.png" alt="mark"></p><ul><li>调用 <code>buffer.flip()</code>实际上是重置了<code>position</code>和<code>limit</code>两个变量，将<code>limit</code>放在<code>position</code>的位置，<code>position</code>放在<code>0</code>的位置。这里只是最后的<code>position</code>和<code>limit</code>位置相同，所以<code>flip</code>后<code>limit</code>位置没变。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/185407014.png" alt="mark"></p><ul><li>调用 <code>intBuffer.get()</code>实际上是不断移动<code>position</code>指针，直到它移动到<code>limit</code>的位置</li></ul><h3 id="2-4-Buffer-类方法"><a href="#2-4-Buffer-类方法" class="headerlink" title="2.4 Buffer 类方法"></a>2.4 Buffer 类方法</h3><h5 id="Buffer基类（抽象类）"><a href="#Buffer基类（抽象类）" class="headerlink" title="Buffer基类（抽象类）"></a>Buffer基类（抽象类）</h5><ul><li><code>public final int capacity();</code><ul><li>直接返回了此缓冲区的容量，<code>capacity</code></li></ul></li><li><code>public final int position();</code><ul><li>直接返回了此缓冲区指针的当前位置</li></ul></li><li><code>public final Buffer position(int newPosition);</code><ul><li>设置此缓冲区的位置，设置<code>position</code></li></ul></li><li><code>public final int limit();</code><ul><li>返回此缓冲区的限制</li></ul></li><li><code>public final Buffer limit(int newLimit);</code><ul><li>设置此缓冲区的限制，设置<code>limit</code></li></ul></li><li><code>public final Buffer clear();</code><ul><li>清除此缓冲区，即将各个标记恢复到初识状态， <code>position = 0;limit = capacity; mark = -1</code>，但是并没有删除数据。</li></ul></li><li><code>public final Buffer flip();</code><ul><li>反转此缓冲区， <code>limit = position;position = 0;mark = -1</code>。</li><li>当指定数据存放在缓冲区中后，<code>position</code>所指向的即为此缓冲区数据最后的位置。只有当数据大小和此缓冲区大小相同时，<code>position</code>才和<code>limit</code>的指向相同。</li><li><code>flip()</code>方法将<code>limit</code>置向<code>position</code>， <code>position</code>置<code>0</code>，那么从<code>position</code>读取数据到<code>limit</code>即为此缓冲区中所有的数据。</li></ul></li><li><code>public final boolean hasRemaining();</code><ul><li>告知当前位置和限制之间是否有元素。<code>return position &lt; limit;</code></li></ul></li><li><code>public abstract boolean isReadOnly();</code><ul><li>此方法为抽象方法，告知此缓冲区是否为只读缓冲区，具体实现在各个实现类中。</li></ul></li><li><code>public abstract boolean hasArray();</code><ul><li>告知此缓冲区是否具有可访问的底层实现数组</li></ul></li><li><code>public abstract Object array();</code><ul><li>返回此缓冲区的底层实现数组</li></ul></li></ul><h3 id="2-5-ByteBuffer的使用"><a href="#2-5-ByteBuffer的使用" class="headerlink" title="2.5 ByteBuffer的使用"></a>2.5 ByteBuffer的使用</h3><p>从前面可以看出来对于Java中的基本数据类型（<strong>boolean除外</strong>），都有一个<code>Buffer</code>类型与之对应，最常用的自然是<code>ByteBuffer</code>类（二进制数据），该类的主要方法如下：</p><ul><li><code>public static ByteBuffer allocateDirect(int capacity);</code><ul><li>创建直接缓冲区</li></ul></li><li><code>public static ByteBuffer allocate(int capacity) ;</code><ul><li>设置缓冲区的初识容量</li></ul></li><li><code>public abstract byte get();</code><ul><li>从当前位置<code>position</code>上<code>get</code>数据，获取之后，<code>position</code>会自动加<code>1</code></li></ul></li><li><code>public abstract byte get(int index);</code><ul><li>通过绝对位置获取数据。</li></ul></li><li><code>public abstract ByteBuffer put(byte b);</code><ul><li>从当前位置上添加，<code>put</code>之后，<code>position</code>会自动加<code>1</code></li></ul></li><li><code>public abstract ByteBuffer put(int index, byte b);</code><ul><li>从绝对位置上添加数据</li></ul></li><li><code>public abstract ByteBuffer putXxx(Xxx value [, int index]);</code><ul><li>从<code>position</code>当前位置插入元素。<code>Xxx</code>表示基本数据类型</li><li>此方法时类型化的 <code>put</code> 和 <code>get</code>，<code>put</code>放入的是什么数据类型，<code>get</code>就应该使用相应的数据类型来取出，否则可能有 <code>BufferUnderflowException</code> 异常。</li></ul></li></ul><p><strong>demo01</strong> :  <em>当取出的顺序和上面插入的数据类型的顺序不对时，就会抛出BufferUnderflowException异常</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//类型化方式放入数据</span></span><br><span class="line">buf.putInt(<span class="number">100</span>);</span><br><span class="line">buf.putLong(<span class="number">20</span>);</span><br><span class="line">buf.putChar(<span class="string">'上'</span>);</span><br><span class="line">buf.putShort((<span class="keyword">short</span>)<span class="number">44</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出，当取出的顺序和上面插入的数据类型的顺序不对时，就会抛出BufferUnderflowException异常</span></span><br><span class="line">buf.flip();</span><br><span class="line">System.out.println(buf.getInt());</span><br><span class="line">System.out.println(buf.getLong());</span><br><span class="line">System.out.println(buf.getChar());</span><br><span class="line">System.out.println(buf.getShort());</span><br></pre></td></tr></table></figure><p><strong>demo02 : 可以将一个普通的Buffer转成只读的Buffer</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个Buffer</span></span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">    byteBuffer.put((<span class="keyword">byte</span>)i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读取</span></span><br><span class="line">byteBuffer.flip();</span><br><span class="line"><span class="comment">//得到一个只读的Buffer</span></span><br><span class="line">ByteBuffer readOnlyBuffer = byteBuffer.asReadOnlyBuffer();</span><br><span class="line">System.out.println(readOnlyBuffer.getClass());</span><br><span class="line"><span class="comment">//读取</span></span><br><span class="line"><span class="keyword">while</span> (readOnlyBuffer.hasRemaining())&#123;</span><br><span class="line">    System.out.println(readOnlyBuffer.get());</span><br><span class="line">&#125;</span><br><span class="line">readOnlyBuffer.put((<span class="keyword">byte</span>)<span class="number">100</span>); <span class="comment">//会抛出 ReadOnlyBufferException</span></span><br></pre></td></tr></table></figure><p><strong>demo03: <code>MappedByteBuffer</code>可以让文件直接在内存（堆外内存）中进行修改，而如何同步到文件由NIO来完成</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1、MappedByteBuffer可以让文件直接在内存中（堆外内存）修改，操作系统不需要拷贝一次</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"1.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">    <span class="comment">//获取对应的文件通道</span></span><br><span class="line">    FileChannel channel = randomAccessFile.getChannel();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 参数1: FileChannel.MapMode.READ_WRITE，使用的读写模式</span></span><br><span class="line"><span class="comment">    * 参数2: 0，可以直接修改的起始位置</span></span><br><span class="line"><span class="comment">    * 参数3: 5，是映射到内存的大小(不是文件中字母的索引位置），即将 1.txt 的多少个字节映射到内存，也就是可以直接修改的范围就是 [0, 5)</span></span><br><span class="line"><span class="comment">    * 实际的实例化类型：DirectByteBuffer</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    mappedByteBuffer.put(<span class="number">0</span>,(<span class="keyword">byte</span>)<span class="string">'N'</span>);</span><br><span class="line">    mappedByteBuffer.put(<span class="number">3</span>, (<span class="keyword">byte</span>)<span class="string">'M'</span>);</span><br><span class="line">    mappedByteBuffer.put(<span class="number">5</span>, (<span class="keyword">byte</span>)<span class="string">'Y'</span>); <span class="comment">//会抛出 IndexOutOfBoundsException</span></span><br><span class="line"></span><br><span class="line">    randomAccessFile.close();</span><br><span class="line">    System.out.println(<span class="string">"修改成功~"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-通道（Channel）"><a href="#3-通道（Channel）" class="headerlink" title="3. 通道（Channel）"></a>3. 通道（Channel）</h2><h3 id="3-1-基本介绍"><a href="#3-1-基本介绍" class="headerlink" title="3.1 基本介绍"></a>3.1 基本介绍</h3><p>NIO的通道类似于流，但有些区别</p><ul><li>通道可以同时进行读写，而流只能读或者只能写</li><li>通道可以实现异步读写数据</li><li>通道可以从缓存读数据，也可以写数据到缓存</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/190004844.png" alt="mark"></p><ul><li>BIO 中的 <code>stream</code> 是单向的，例如：<code>FileInputStream</code>对象只能进行读取数据的操作，而NIO中的通道（Channel）是双向的，可以读操作，也可以写操作。</li><li><code>Channel</code> 在 NIO 中是一个接口：<code>public interface Channel extends Closeable{}</code></li><li>常用的<code>Channel</code>类有：<code>FileChannel</code>、<code>DatagramChannel</code>、<code>ServerSocketChannel</code>（类似<code>ServerSocket</code>）、<code>SocketChannel</code>（类似<code>Socket</code>）</li><li><code>FileChannel</code> 用于<strong>文件</strong>数据的读写，<code>DatagramChannel</code>用于<strong>UDP</strong>数据的读写，<code>ServerSocketChannel</code>和<code>SocketChannel</code>用于<strong>TCP</strong>数据读写</li></ul><p><strong>类关系图：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/190142717.png" alt="mark"></p><h3 id="3-2-FileChannel"><a href="#3-2-FileChannel" class="headerlink" title="3.2 FileChannel"></a>3.2 FileChannel</h3><ul><li><pre><code>public int read(ByteBuffer dst)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 从通道读取数据并放到缓冲区中</span><br><span class="line">  - 此操作也会移动 &#96;Buffer&#96; 中的&#96;position&#96;指针，不断往&#96;position&#96;中放数据，&#96;read&#96;完成后&#96;position&#96;指向&#96;limit&#96;。</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>public int write(ByteBuffer src)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 把缓冲区的数据写到通道中</span><br><span class="line">  - 此操作也会不断移动&#96;Buffer&#96;中的&#96;position&#96;位置直到&#96;limit&#96;，读取到的数据就是&#96;position&#96;到&#96;limit&#96;这两个指针之间的数据。</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>public long transferFrom(ReadableByteChannel src, long position, long count)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 从目标通道中复制数据到当前通道</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>public long transferTo(long position, long count, WritableByteChannel target)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 把数据从当前通道复制给目标通道</span><br><span class="line">  - 该方法拷贝数据使用了**零拷贝**，通常用来在网络&#96;IO&#96;传输中，将&#96;FileChannel&#96;里面的文件数据直接拷贝到与客户端或者服务端连接的&#96;Channel&#96;里面从而达到文件传输。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**应用实例**</span><br><span class="line"></span><br><span class="line">**实例1：将数据写入到本地文件**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">String str &#x3D; &quot;hello,尚硅谷&quot;;</span><br><span class="line">&#x2F;&#x2F;创建一个输出流 -&gt; Channel</span><br><span class="line">FileOutputStream fileOutputStream &#x3D; new FileOutputStream(&quot;d:\\file01.txt&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过 FileOutputStream 获取对应的 FileChannel</span><br><span class="line">&#x2F;&#x2F;这个 FileChannel 真实类型是 FileChannelImpl</span><br><span class="line">FileChannel fileChannel &#x3D; fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建一个缓冲区 ByteBuffer</span><br><span class="line">ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024);</span><br><span class="line">&#x2F;&#x2F;将str放入ByteBuffer</span><br><span class="line">byteBuffer.put(str.getBytes());</span><br><span class="line">&#x2F;&#x2F;对ByteBuffer进行反转，开始读取</span><br><span class="line">byteBuffer.flip();</span><br><span class="line">&#x2F;&#x2F;将ByteBuffer数据写入到FileChannel</span><br><span class="line">&#x2F;&#x2F;此操作会不断移动 Buffer中的 position到 limit 的位置</span><br><span class="line">fileChannel.write(byteBuffer);</span><br><span class="line">fileOutputStream.close();</span><br></pre></td></tr></table></figure></code></pre></li></ul><p><strong>实例2：从本地文件读取数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建文件的输入流</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"d:\\file01.txt"</span>);</span><br><span class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"><span class="comment">//通过fileInputStream 获取对应的FileChannel -&gt; 实际类型 FileChannelImpl</span></span><br><span class="line">FileChannel fileChannel = fileInputStream.getChannel();</span><br><span class="line"><span class="comment">//创建缓冲区</span></span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate((<span class="keyword">int</span>) file.length());</span><br><span class="line"><span class="comment">//将通道的数据读入到buffer</span></span><br><span class="line">fileChannel.read(byteBuffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将ByteBuffer 的字节数据转成String</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(byteBuffer.array()));</span><br><span class="line">fileInputStream.close();</span><br></pre></td></tr></table></figure><p>实例1、2的示例图：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/190523361.png" alt="mark"></p><p><strong>实例3：使用一个Buffer完成文件的读取</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"1.txt"</span>);</span><br><span class="line">FileChannel fileChannel1 = fileInputStream.getChannel();</span><br><span class="line"></span><br><span class="line">FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"2.txt"</span>);</span><br><span class="line">FileChannel fileChannel2 = fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">//清空buffer，由于循环的最后执行了 write 操作，会将 position 移动到 limit 的位置</span></span><br><span class="line">    <span class="comment">//清空 Buffer的操作才为上一次的循环重置position的位置</span></span><br><span class="line">    <span class="comment">// 如果没有重置position，那么上次读取后，position和limit位置一样，读取后read的值永远为0</span></span><br><span class="line">    byteBuffer.clear();</span><br><span class="line">    <span class="comment">//将数据存入 ByteBuffer，它会基于 Buffer 此刻的 position 和 limit 的值，</span></span><br><span class="line">    <span class="comment">// 将数据放入position的位置，然后不断移动position直到其与limit相等；</span></span><br><span class="line">    <span class="keyword">int</span> read = fileChannel1.read(byteBuffer);</span><br><span class="line">    System.out.println(<span class="string">"read="</span> + read);</span><br><span class="line">    <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123; <span class="comment">//表示读完</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将buffer中的数据写入到 FileChannel02 ---- 2.txt</span></span><br><span class="line">    byteBuffer.flip();</span><br><span class="line">    fileChannel2.write(byteBuffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭相关的流</span></span><br><span class="line">fileInputStream.close();</span><br><span class="line">fileOutputStream.close();</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201006/190859988.png" alt="mark"></p><p><strong>实例4：拷贝文件 transferFrom 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建相关流</span></span><br><span class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"d:\\a.gif"</span>);</span><br><span class="line">FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\a2.gif"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取各个流对应的FileChannel</span></span><br><span class="line">FileChannel source = fileInputStream.getChannel();</span><br><span class="line">FileChannel dest = fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 transferForm 完成拷贝</span></span><br><span class="line">dest.transferFrom(source, <span class="number">0</span>, source.size());</span><br><span class="line"><span class="comment">//关闭相关的通道和流</span></span><br><span class="line">source.close();</span><br><span class="line">dest.close();</span><br><span class="line">fileInputStream.close();</span><br><span class="line">fileOutputStream.close();</span><br></pre></td></tr></table></figure><ul><li>实例4相当于封装了实例3</li></ul><h3 id="3-3-ServerSocketChannel-和-SocketChannel-类"><a href="#3-3-ServerSocketChannel-和-SocketChannel-类" class="headerlink" title="3.3 ServerSocketChannel 和 SocketChannel 类"></a>3.3 ServerSocketChannel 和 SocketChannel 类</h3><p><strong>ServerSocketChannel</strong>：主要用于在<strong>服务器监听新的客户端<code>Socket</code>连接</strong></p><ul><li><code>public static ServerSocketChannel open()</code><ul><li>得到一个 <code>ServerSocketChannel</code> 通道</li></ul></li><li><code>public final ServerSocketChannel bind(SocketAddress local)</code><ul><li>设置服务器监听端口</li></ul></li><li><code>public final SelectableChannel configureBlocking(boolean block)</code><ul><li>用于设置阻塞或非阻塞模式，取值 <code>false</code> 表示采用非阻塞模式</li><li>此方法位于 <code>ServerSocketChannel</code> 和 <code>SocketChannel</code>的共同父类<code>AbstractSelectableChannel</code>类中</li></ul></li><li><code>public abstract SocketChannel accept()</code><ul><li>接受一个连接，返回代表这个连接的通道对象</li></ul></li><li><code>public final SelectionKey register(Selector sel, int ops)</code><ul><li>将<code>Channel</code>注册到选择器并设置监听事件，也可以在绑定的同时注册多个事件，如下所示：</li><li><code>channel.register(selector,Selectionkey.OP_READ | Selectionkey.OP_CONNECT)</code></li></ul></li></ul><p><strong>SocketChannel</strong>：网络IO通道，<strong>具体负责进行读写操作</strong>。NIO把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区</p><ul><li><code>public static SocketChannel open()</code><ul><li>得到一个<code>SocketChannel</code>通道</li></ul></li><li><code>public final SelectableChannel configureBlocking(boolean block)</code><ul><li>设置阻塞或非阻塞模式，取值 false表示采用非阻塞模式</li><li>此方法位于 <code>ServerSocketChannel</code> 和 <code>SocketChannel</code>的共同父类<code>AbstractSelectableChannel</code>类中</li></ul></li><li><code>public abstract boolean connect(SocketAddress remote)</code><ul><li>连接服务器</li></ul></li><li><code>public boolean finishConnect()</code><ul><li>如果上面的方法连接失败，接下来就要通过该方法完成连接操作</li></ul></li><li><code>public int write(ByteBuffer src)</code><ul><li>往通道里写数据</li><li>这里写入的是<code>buffer</code>里面<code>position</code>到<code>limit</code>这个之间的数据</li></ul></li><li><code>public int read(ByteBuffer dst)</code><ul><li>从通道里读数据</li></ul></li><li><code>public final SelectionKey register(Selector sel, int ops, Object att)</code><ul><li>注册<code>Channel</code>到选择器并设置监听事件，最后一个参数可以设置共享数据</li></ul></li><li><code>public final void close()</code><ul><li>关闭通道</li></ul></li></ul><p><strong>应用实例</strong></p><ul><li>通过<code>Buffer</code>数组来完成读写操作，即<code>Scattering</code>和<code>Gathering</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Scattering：将数据写入到buffer时，可以采用buffer数组，初次写入 【分散】</span></span><br><span class="line"><span class="comment">* Gathering：从buffer读取数据时，也可以采用buffer数组，依次读</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//使用 ServerSocketChannel 和 SocketChannel</span></span><br><span class="line">    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">    InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="number">7000</span>);</span><br><span class="line">    <span class="comment">//绑定端口到socket，并启动</span></span><br><span class="line">    serverSocketChannel.socket().bind(inetSocketAddress);</span><br><span class="line">    <span class="comment">//创建一个Buffer数组</span></span><br><span class="line">    ByteBuffer[] byteBuffers = <span class="keyword">new</span> ByteBuffer[<span class="number">2</span>];</span><br><span class="line">    byteBuffers[<span class="number">0</span>] = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">    byteBuffers[<span class="number">1</span>] = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待客户端的连接（Telnet）</span></span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">    <span class="keyword">int</span> msgLength = <span class="number">8</span>; <span class="comment">//假定从客户端接受8个字节</span></span><br><span class="line">    <span class="comment">//循环的读取</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> byteRead = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (byteRead &lt; msgLength) &#123;</span><br><span class="line">            <span class="keyword">long</span> l = socketChannel.read(byteBuffers);</span><br><span class="line">            byteRead += l; <span class="comment">//累计读取的字节数</span></span><br><span class="line">            System.out.println(<span class="string">"byteRead= "</span> + byteRead);</span><br><span class="line">            <span class="comment">//使用流打印，看看当前这个buffer的position和limit</span></span><br><span class="line">            Arrays.stream(byteBuffers)</span><br><span class="line">                .map(buffer -&gt; <span class="string">"position="</span> + buffer.position() + <span class="string">", limit = "</span> + buffer.limit())</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读书数据后需要将所有的buffer进行flip</span></span><br><span class="line">        Arrays.asList(byteBuffers).forEach(Buffer::flip);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将数据读出显示到客户端</span></span><br><span class="line">        <span class="keyword">long</span> byteWrite = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (byteWrite &lt; msgLength) &#123;</span><br><span class="line">            <span class="keyword">long</span> l = socketChannel.write(byteBuffers);</span><br><span class="line">            byteWrite += l;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将所有的 buffer 进行clear操作</span></span><br><span class="line">        Arrays.asList(byteBuffers).forEach(Buffer::clear);</span><br><span class="line">        System.out.println(<span class="string">"byteRead="</span> + byteRead + <span class="string">", byteWrite="</span> + byteWrite</span><br><span class="line">                           + <span class="string">", msgLength="</span> + msgLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Selector-选择器"><a href="#4-Selector-选择器" class="headerlink" title="4. Selector(选择器)"></a>4. Selector(选择器)</h2><h3 id="4-1-基本介绍"><a href="#4-1-基本介绍" class="headerlink" title="4.1 基本介绍"></a>4.1 基本介绍</h3><ul><li>Java 的 NIO，用非阻塞的 IO 方式。可以用一个线程，处理多个的客户端连接，就会使用到<strong>Selector</strong>(选择器)</li><li><code>Selector</code>能够检测多个注册的通道上是否有事件发生(注意:多个Channel以<strong>事件</strong>的方式可以注册到同一个<code>Selector</code>)，如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。</li><li>只有在 连接/通道 真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程</li><li>避免了多线程之间的上下文切换导致的开销</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/202710545.png" alt="mark"></p><p>其中 : <code>Netty</code>的<code>IO</code>线程<code>NioEventLoop</code>聚合了<code>Selector</code>（选择器，也叫多路复用器），可以同时并发处理成百上千个客户端连接。</p><ul><li><p>当线程从某客户端 <code>Socket</code> 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。</p></li><li><p>线程通常将非阻塞 <code>IO</code> 的空闲时间用于在其他通道上执行 <code>IO</code> 操作，所以单独的线程可以管理多个输入和输出通道。</p></li><li><p>由于读写操作都是非阻塞的，这就可以充分提升 <code>IO</code> 线程的运行效率，避免由于频繁 <code>I/O</code> 阻塞导致的线程挂起。</p></li><li><p>一个 <code>I/O</code> 线程可以并发处理 <code>N</code> 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 <code>I/O</code> 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</p></li></ul><h3 id="4-2-SelectionKey-介绍"><a href="#4-2-SelectionKey-介绍" class="headerlink" title="4.2 SelectionKey 介绍"></a>4.2 SelectionKey 介绍</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201007/203002487.png" alt="mark"></p><ul><li><code>Selector</code>通过管理<code>SelectionKey</code>的集合从而去监听各个<code>Channel</code>。</li><li>当<code>Channel</code>注册到<code>Selector</code>上面时，会携带该<code>Channel</code>关注的事件<strong>（SelectionKey包含Channel以及与之对应的事件）</strong>，并会返回一个<code>SelectionKey</code>的对象，<code>Selector</code>将该对象加入到它统一管理的集合中去，从而对<code>Channel</code>进行管理。</li><li><code>SelectionKey</code>表示的是<code>Selector</code>和网络通道的注册关系，故<code>FileChannel</code>是没有办法通过<code>SelectionKey</code>注册到<code>Selector</code>上去的。</li></ul><p><strong>四大事件</strong></p><ul><li><code>public static final int OP_READ = 1 &lt;&lt; 0</code><ul><li>值为<code>1</code>，表示读操作，</li><li>代表本<code>Channel</code>已经接受到其他客户端传过来的消息，需要将<code>Channel</code>中的数据读取到<code>Buffer</code>中去</li></ul></li><li><code>public static final int OP_WRITE = 1 &lt;&lt; 2</code><ul><li>值为<code>4</code>，表示写操作</li><li>一般临时将<code>Channel</code>的事件修改为它，在处理完后又修改回去。</li></ul></li><li><code>public static final int OP_CONNECT = 1 &lt;&lt; 3</code><ul><li>值为<code>8</code>，代表建立连接。</li><li>一般在<code>ServerSocketChannel</code>上绑定该事件，结合 <code>channel.finishConnect()</code>在连接建立异常时进行异常处理</li></ul></li><li><code>public static final int OP_ACCEPT = 1 &lt;&lt; 4</code><ul><li>值为<code>16</code>，表示由新的网络连接可以<code>accept</code>。</li><li>与<code>ServerSocketChannel</code>进行绑定，用于创建新的<code>SocketChannel</code>，并把其注册到<code>Selector</code>上去</li></ul></li></ul><p><strong>相关方法</strong></p><ul><li><code>public abstract Selector selector()</code><ul><li>得到该<code>SelectionKey</code>具体是属于哪个<code>Selector</code>对象的</li></ul></li><li><code>public abstract SelectableChannel channel()</code><ul><li>通过<code>SelectionKey</code>的到对应的<code>Channel</code></li></ul></li><li><code>public final Object attachment()</code><ul><li>得到与之关联的共享数据，一般用于获取<code>buffer</code></li><li>在使用<code>register</code>注册通道时，也可以为该<code>Channel</code>绑定一个<code>Buffer</code>，可以通过本方法获取这个<code>Buffer</code>。</li><li>通过<code>selectionKey.attach(Object ob)</code>绑定的数据，也是通过该方法获取</li></ul></li><li><code>public abstract SelectionKey interestOps()</code><ul><li>获取该<code>SelectionKey</code>下面的事件</li></ul></li><li><code>public abstract SelectionKey interestOps(int ops)</code><ul><li>用于设置或改变某个<code>Channel</code>关联的事件</li><li>增加事件：<code>key.interestOps(key.interestOps | SelectionKey.OP_WRITE)</code></li><li>减少事件：<code>key.interestOps(key.interestOps &amp; ~SelectionKey.OP_WRITE)</code></li></ul></li><li><code>public final boolean isAcceptable(),isReadable(),isWritable(),isConnectable()</code><ul><li>用于判断这个<code>SelectionKey</code>产生的是什么事件，与上面的事件类型一一对应</li></ul></li></ul><h3 id="4-3-Selector-常见方法"><a href="#4-3-Selector-常见方法" class="headerlink" title="4.3 Selector 常见方法"></a>4.3 Selector 常见方法</h3><ul><li><code>public static Selector open();</code><ul><li>得到一个选择器对象，实例化出 <code>WindowsSelectorImpl</code>对象。</li></ul></li><li><code>public int select(long timeout)</code><ul><li>监控所有注册的通道，当其中有<code>IO</code>操作可以进行时，将对应的<code>SelectionKey</code>加入到内部集合中并返回，返回的结果为<code>Channel</code>响应的事件总和，当结果为<code>0</code>时，表示本<code>Selector</code>监听的所有<code>Channel</code>中没有<code>Channel</code>产生事件。</li><li>如果不传入<code>timeout</code>值，就会阻塞线程，传入值则为阻塞多少毫秒，通过它设置超时时间。</li><li>之所以需要传入时间，是为了让它等待几秒钟再看有没有<code>Channel</code>会产生事件，从而获取一段时间内产生事件的<code>Channel</code>的总集合再一起处理。</li></ul></li><li><code>selector.selectNow();</code><ul><li>不会阻塞，立马返回冒泡的事件数</li></ul></li><li><code>public Set&lt;SelectionKey&gt; selectedKeys()</code><ul><li>从内部集合中得到所有的<code>SelectionKey</code></li></ul></li></ul><h3 id="4-4-Demo-实例"><a href="#4-4-Demo-实例" class="headerlink" title="4.4 Demo 实例"></a>4.4 Demo 实例</h3><p><strong>编码步骤</strong></p><ol><li>当客户端连接时，会通过<code>ServerSocketChannel</code> 得到 <code>SocketChannel</code></li><li><code>Selector</code> 进行监听 <code>select</code>方法, 返回有事件发生的通道的个数.</li><li>将<code>socketChannel</code>注册到<code>Selector</code>上, register(Selector sel, <strong>int</strong> ops), 一个<code>selector</code>上可以注册多个<code>SocketChannel</code></li><li>注册后返回一个 <code>SelectionKey</code>, 会和该<code>Selector</code> 关联(集合)</li><li>进一步得到各个 <code>SelectionKey</code> (有事件发生)</li><li>在通过 <code>SelectionKey</code> 反向获取 <code>SocketChannel</code> , 方法 <code>channel()</code></li><li>判断该<code>Channel</code>的事件类型，对不同事件进行不同的业务处理</li></ol><p><strong>NIO入门案例：实现服务器和客户端的简单通讯</strong></p><ul><li><strong>服务器端</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Server</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建ServerSocketChannel -&gt; ServerSocket</span></span><br><span class="line">    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">    <span class="comment">//得到一个Selector对象</span></span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    <span class="comment">//绑定一个端口6666</span></span><br><span class="line">    serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">6666</span>));</span><br><span class="line">    <span class="comment">//设置非阻塞</span></span><br><span class="line">    serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把 serverSocketChannel 注册到 selector ，关心事件为：OP_ACCEPT，有新的客户端连接</span></span><br><span class="line">    SelectionKey register = serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">//循环等待客户端连接</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//等待1秒，如果没有事件发生，就返回</span></span><br><span class="line">        <span class="keyword">if</span> (selector.select(<span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"服务器等待了1秒，无连接"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果返回的 &gt; 0,表示已经获取到关注的事件</span></span><br><span class="line">        <span class="comment">// 就获取到相关的 selectionKey 集合，反向获取通道</span></span><br><span class="line">        Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历 Set&lt;SelectionKey&gt;，使用迭代器遍历</span></span><br><span class="line">        Iterator&lt;SelectionKey&gt; keyIterator = selectionKeys.iterator();</span><br><span class="line">        <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">            <span class="comment">//获取到SelectionKey</span></span><br><span class="line">            SelectionKey key = keyIterator.next();</span><br><span class="line">            <span class="comment">//根据 key 对应的通道发生的事件，做相应的处理</span></span><br><span class="line">            <span class="keyword">if</span> (key.isAcceptable()) &#123;<span class="comment">//如果是 OP_ACCEPT，有新的客户端连接</span></span><br><span class="line">                <span class="comment">//该客户端生成一个 SocketChannel</span></span><br><span class="line">                SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                System.out.println(<span class="string">"客户端连接成功，生成了一个SocketChannel："</span> + socketChannel.hashCode());</span><br><span class="line">                <span class="comment">//将SocketChannel设置为非阻塞</span></span><br><span class="line">                socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">//将socketChannel注册到selector，关注事件为 OP_READ，同时给SocketChannel关联一个Buffer</span></span><br><span class="line">                socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                <span class="comment">//通过key，反向获取到对应的Channel</span></span><br><span class="line">                SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                <span class="comment">//获取到该channel关联的Buffer</span></span><br><span class="line">                ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">                channel.read(buffer);</span><br><span class="line">                System.out.println(<span class="string">"from 客户端："</span> + <span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//手动从集合中移除当前的 selectionKey，防止重复操作</span></span><br><span class="line">            keyIterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>客户端</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Client</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//得到一个网络通道</span></span><br><span class="line">    SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">    <span class="comment">//设置非阻塞</span></span><br><span class="line">    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//提供服务器端的IP和端口</span></span><br><span class="line">    InetSocketAddress socketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">6666</span>);</span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    <span class="keyword">if</span> (!socketChannel.connect(socketAddress))&#123; <span class="comment">//如果不成功</span></span><br><span class="line">        <span class="keyword">while</span> (!socketChannel.finishConnect())&#123;</span><br><span class="line">            System.out.println(<span class="string">"因为连接需要时间，客户端不会阻塞，可以做其他工作。。。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果连接成功，就发送数据</span></span><br><span class="line">    String str = <span class="string">"hello, 尚硅谷"</span>;</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.wrap(str.getBytes());</span><br><span class="line">    <span class="comment">//发送数据,实际上就是将buffer数据写入到channel</span></span><br><span class="line">    socketChannel.write(byteBuffer);</span><br><span class="line">    System.in.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-NIO-实战-群聊系统demo"><a href="#5-NIO-实战-群聊系统demo" class="headerlink" title="5. NIO 实战(群聊系统demo)"></a>5. NIO 实战(群聊系统demo)</h2><ul><li>需要实现客户端和服务器端之间的数据通讯，服务端能够将数据转发给其他所有客户端。</li></ul><h3 id="5-1-服务端"><a href="#5-1-服务端" class="headerlink" title="5.1 服务端"></a>5.1 服务端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> GroupChat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel listenChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">6677</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatServer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 打开连接通道</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            listenChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 绑定端口</span></span><br><span class="line">            listenChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">            <span class="comment">// 设置非阻塞</span></span><br><span class="line">            listenChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 注册到选择器上</span></span><br><span class="line">            listenChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> count = selector.select(<span class="number">2000</span>);</span><br><span class="line">                <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123; <span class="comment">// 返回就绪的socket的数量</span></span><br><span class="line">                    <span class="comment">// 遍历得到SelectionKey集合</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 获取key</span></span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 反向获取accept的事件的channel</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                        SocketChannel socketChannel = listenChannel.accept();</span><br><span class="line">                        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 将socketChannel 注册到选择器上</span></span><br><span class="line">                        socketChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 提示客户端上线了</span></span><br><span class="line">                        System.out.println(socketChannel.getRemoteAddress().toString().substring(<span class="number">1</span>) + <span class="string">"上线了"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (key.isReadable())&#123; <span class="comment">// 通道数据为可读的状态</span></span><br><span class="line">                        <span class="comment">// 读取数据</span></span><br><span class="line">                        readData(key);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 删除当前的key,防止重复处理</span></span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e2)&#123;</span><br><span class="line">            e2.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取客户端发送的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">(SelectionKey key)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个socketChannel</span></span><br><span class="line">        SocketChannel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 得到channel</span></span><br><span class="line">            channel = (SocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建buffer</span></span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">int</span> read = channel.read(byteBuffer);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(read &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 缓存区的数据转存到字符串</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(byteBuffer.array());</span><br><span class="line">                <span class="comment">// 输出消息</span></span><br><span class="line">                System.out.println(<span class="string">"来自客户端的消息"</span> + msg);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将服务器消息转发给其他用户</span></span><br><span class="line">                sendToOthers(msg,channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123; <span class="comment">// 表示客户端此时下线了</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(channel.getRemoteAddress() + <span class="string">"离线了...."</span>);</span><br><span class="line">                <span class="comment">//取消注册</span></span><br><span class="line">                key.cancel();</span><br><span class="line">                <span class="comment">//关闭通道</span></span><br><span class="line">                channel.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e2)&#123;</span><br><span class="line">                e2.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息转发给其他用户</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendToOthers</span><span class="params">(String msg,SocketChannel self)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器消息转发中..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历已经注册到selector 的 socketchannel，排除掉自己</span></span><br><span class="line">        <span class="keyword">for</span> (SelectionKey key : selector.keys()) &#123;</span><br><span class="line">            <span class="comment">// 通过key取出对应的SocketChannel</span></span><br><span class="line">            Channel channel = key.channel();</span><br><span class="line">            <span class="comment">// 排除自己</span></span><br><span class="line">            <span class="keyword">if</span>(channel <span class="keyword">instanceof</span> SocketChannel &amp; channel != self)&#123;</span><br><span class="line">                <span class="comment">// 转型</span></span><br><span class="line">                SocketChannel dest = (SocketChannel) channel;</span><br><span class="line">                <span class="comment">// 将msg放入buffer中</span></span><br><span class="line">                ByteBuffer byteBuffer = ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">                <span class="comment">// 将buffer数据写入到通道</span></span><br><span class="line">                dest.write(byteBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器启动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GroupChatServer groupChatServer = <span class="keyword">new</span> GroupChatServer();</span><br><span class="line">        groupChatServer.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-客户端"><a href="#5-2-客户端" class="headerlink" title="5.2 客户端"></a>5.2 客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> GroupChat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Selector selector = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> PORT = <span class="number">6677</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String HOST = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        selector = <span class="keyword">this</span>.selector.open();</span><br><span class="line">        <span class="comment">//链接服务器</span></span><br><span class="line">        socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(HOST, PORT));</span><br><span class="line">        <span class="comment">//设置非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册到selector上</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取用户名</span></span><br><span class="line">        userName = socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line">        System.out.println(userName + <span class="string">"  is ok...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendInfo</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        info = userName + <span class="string">"说:"</span> + info;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(info.getBytes()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取从服务器回显的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> select = selector.select();</span><br><span class="line">            <span class="keyword">if</span> (select &gt; <span class="number">0</span>)&#123; <span class="comment">// 说明有可用的通道</span></span><br><span class="line">                <span class="comment">// 获取key集合</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                <span class="comment">// 迭代</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                        <span class="comment">// 得到相关通道</span></span><br><span class="line">                        SocketChannel  channel = (SocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">// 得到一个buffer</span></span><br><span class="line">                        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="comment">// 读取数据</span></span><br><span class="line">                        channel.read(byteBuffer);</span><br><span class="line">                        <span class="comment">// 将数据转换成字符串</span></span><br><span class="line">                        String s = <span class="keyword">new</span> String(byteBuffer.array());</span><br><span class="line">                        System.out.println(s.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 读完了删除这个key</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 这里可以干点别的东西</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        GroupChatClient groupChatClient = <span class="keyword">new</span> GroupChatClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启一个线程读取数据</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;<span class="keyword">while</span> (<span class="keyword">true</span>)&#123;groupChatClient.readInfo();&#125;&#125;).start();</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNextLine())&#123;</span><br><span class="line">            String s= sc.nextLine();</span><br><span class="line">            groupChatClient.sendInfo(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li><p>使用<code>int read = channel.read(buffer)</code></p><p><strong>读取数据时</strong>，读取的结果情况：</p><ul><li>当<code>read=-1</code>时，说明客户端的数据发送完毕，并且主动的关闭<code>socket</code>。所以这种情况下，服务器程序需要关闭<code>socketSocket</code>，并且取消<code>key</code>的注册。注意：这个时候继续使用<code>SocketChannel</code>进行读操作的话，就会抛出：==<strong>远程主机强迫关闭一个现有的连接</strong>==的IO异常</li><li>当<code>read = 0</code>时：<ul><li>某一时刻<code>SocketChannel</code>中当前没有数据可读。</li><li>客户端的数据发送完毕。</li><li><a href="https://blog.csdn.net/cao478208248/article/details/41648359" target="_blank" rel="noopener">详情见此博文</a></li><li>但是对于博文中的这一条，经过本人测试，这种情况下返回的是读取的数据的大小，而不是<code>0</code>：<strong><code>ByteBuffer</code>的<code>position</code>等于<code>limit</code>，这个时候也会返回<code>0</code></strong></li></ul></li></ul></li></ul><p><strong>参考博客</strong> : <a href="https://www.cnblogs.com/hyy9527/p/13059248.html" target="_blank" rel="noopener">https://www.cnblogs.com/hyy9527/p/13059248.html</a></p><p>​                    <a href="https://blog.csdn.net/qq_35751014/article/details/104411347" target="_blank" rel="noopener">https://blog.csdn.net/qq_35751014/article/details/104411347</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-02-NIO实战及原理&quot;&gt;&lt;a href=&quot;#Netty-02-NIO实战及原理&quot; class=&quot;headerlink&quot; title=&quot;Netty-02-NIO实战及原理&quot;&gt;&lt;/a&gt;Netty-02-NIO实战及原理&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Java NIO 全称 &lt;code&gt;java non-blocking IO&lt;/code&gt;，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入/输出的新特性，被统称为 NIO(即 New IO)，是&lt;strong&gt;同步非阻塞&lt;/strong&gt;的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NIO 相关类都被放在 &lt;code&gt;java.nio&lt;/code&gt; 包及子包下，并且对原 &lt;code&gt;java.io&lt;/code&gt; 包中的很多类进行改写。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NIO 有三大核心部分：&lt;strong&gt;Channel(通道)&lt;/strong&gt;，&lt;strong&gt;Buffer(缓冲区)&lt;/strong&gt;, &lt;strong&gt;Selector(选择器)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NIO是 面向&lt;strong&gt;缓&lt;/strong&gt;冲区 ，或者面向 &lt;strong&gt;块&lt;/strong&gt; 编程的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供&lt;strong&gt;非阻塞&lt;/strong&gt;式的高伸缩性网络&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Java NIO&lt;/code&gt;的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而&lt;strong&gt;不是保持线程阻塞&lt;/strong&gt;，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通俗理解：&lt;code&gt;NIO&lt;/code&gt;是可以做到用一个线程来处理多个操作的。假设有&lt;code&gt;10000&lt;/code&gt;个请求过来,根据实际情况，可以分配&lt;code&gt;50&lt;/code&gt;或者&lt;code&gt;100&lt;/code&gt;个线程来处理。不像之前的阻塞&lt;code&gt;IO&lt;/code&gt;那样，非得分配&lt;code&gt;10000&lt;/code&gt;个。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;HTTP2.0&lt;/code&gt;使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比&lt;code&gt;HTTP1.1&lt;/code&gt;大了好几个数量级。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="NIO" scheme="http://zhuuu.work/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Netty-01-BIO实战</title>
    <link href="http://zhuuu.work/2020/10/01/Netty/Netty-01-BIO%E5%AE%9E%E6%88%98%E5%8F%8A%E5%8E%9F%E7%90%86/"/>
    <id>http://zhuuu.work/2020/10/01/Netty/Netty-01-BIO%E5%AE%9E%E6%88%98%E5%8F%8A%E5%8E%9F%E7%90%86/</id>
    <published>2020-10-01T03:02:24.000Z</published>
    <updated>2020-10-02T03:08:32.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-01-BIO实战及原理"><a href="#Netty-01-BIO实战及原理" class="headerlink" title="Netty-01-BIO实战及原理"></a>Netty-01-BIO实战及原理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>参考书籍：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201002/105929076.png" alt="mark"></p><ul><li>Netty权威指南 以5.x版本编写，建议还是以Netty in action为主</li></ul><a id="more"></a><h2 id="1-Netty-介绍和应用场景"><a href="#1-Netty-介绍和应用场景" class="headerlink" title="1. Netty 介绍和应用场景"></a>1. Netty 介绍和应用场景</h2><ol><li><code>Netty</code>是由<code>JBOSS</code>提供的一个<code>Java</code>开源框架，现为<code>Github</code>上的独立项目</li><li><code>Netty</code>是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络<code>IO</code>程序</li><li><code>Netty</code>主要针对在<code>TCP</code>协议下，面向<code>Clients</code>端的高并发应用，或者<code>Peer-to-Peer</code>场景下的大量数据持续传输的应用。</li><li><code>Netty</code>本质是一个<code>NIO</code>框架，适用于服务器通讯相关的多种应用场景</li><li>要透彻理解<code>Netty</code> ， 需要先学习 <code>NIO</code> ， 这样我们才能阅读 <code>Netty</code> 的源码。</li></ol><p><strong>应用场景：</strong></p><ul><li>互联网行业<ul><li>分布式系统中，各个节点之间需要远程服务调用，高性能的<code>RPC</code>框架必不可少，<code>Netty</code>作为异步高性能的通信框架，往往作为基础通信组件被这些<code>RPC</code>框架使用</li><li>典型的应用有：阿里分布式服务框架<code>Dubbo</code>的<code>RPC</code>框架使用<code>Dubbo</code>协议进行节点间通信，<code>Dubbo</code>协议进行节点间通信，<code>Dubbo</code>协议默认使用<code>Netty</code>作为基础通信组件，用于实现各进程节点之间的内部通信</li></ul></li><li>游戏行业<ul><li>无论是手游服务端还是大型的网络游戏，<code>Java</code> 语言得到了越来越广泛的应用</li><li><code>Netty</code> 作为高性能的基础通信组件，提供了 <code>TCP/UDP</code> 和 <code>HTTP</code> 协议栈，方便定制和开发私有协议栈，账号登录服务器</li><li>地图服务器之间可以方便的通过 <code>Netty</code> 进行高性能的通信</li></ul></li><li>大数据领域<ul><li>经典的 <code>Hadoop</code>的高性能通信和序列化组件<code>Avro</code> 的 <code>RPC</code> 框架，默认采用 <code>Netty</code> 进行跨界点通信</li><li>它的 <code>Netty Service</code> 基于 <code>Netty</code> 框架二次封装实现。</li></ul></li></ul><h2 id="2-Java-IO模型"><a href="#2-Java-IO模型" class="headerlink" title="2. Java IO模型"></a>2. Java IO模型</h2><ul><li><code>I/O</code> 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能</li><li><code>Java</code>共支持3种网络编程模型IO模式：<code>BIO、NIO、AIO</code><ul><li><code>Java BIO</code> ： 同步并阻塞(<strong>传统阻塞型</strong>)，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销</li><li><code>Java NIO</code>： 同步非阻塞，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求就进行处理 </li><li><code>Java AIO(NIO.2)</code> ： <strong>异步非阻塞</strong>，<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</li></ul></li></ul><h2 id="3-BIO-简单实战"><a href="#3-BIO-简单实战" class="headerlink" title="3. BIO 简单实战"></a>3. BIO 简单实战</h2><h3 id="3-1-流程概述"><a href="#3-1-流程概述" class="headerlink" title="3.1 流程概述"></a>3.1 流程概述</h3><ul><li>服务端启动一个<code>ServerSocket</code></li><li>客户端启动<code>Socket</code>对服务器进行通信，默认情况下服务器端需要对每个客户 建立一个线程与之通讯</li><li>客户端发出请求后, 先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝</li><li>如果有响应，客户端线程会等待请求结束后，在继续执行</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201002/110804813.png" alt="mark"></p><h3 id="3-2-应用实例"><a href="#3-2-应用实例" class="headerlink" title="3.2 应用实例"></a>3.2 应用实例</h3><ul><li>使用<code>BIO</code>模型编写一个服务器端，监听<code>6666</code>端口，当有客户端连接时，就启动一个线程与之通讯。</li><li>要求使用线程池机制改善，可以连接多个客户端.</li><li>服务器端可以接收客户端发送的数据(通过<code>cmd</code>的<code>telnet</code> 方式即可)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1、创建一个线程池</span></span><br><span class="line">        <span class="comment">//2、如果有客户端连接，就创建一个线程，与之通讯（单独写一个方法）</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        System.out.println(<span class="string">"服务器启动了"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程信息：id= "</span>+ Thread.currentThread().getId() + <span class="string">"; 线程名字："</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">//监听，等待客户端连接</span></span><br><span class="line">            System.out.println(<span class="string">"等待连接"</span>);</span><br><span class="line">            <span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">"连接到一个客户端"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建一个线程，与之通讯</span></span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//重写Runnable方法，与客户端进行通讯</span></span><br><span class="line">                handler(socket);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个Handler方法，和客户端通讯</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程信息：id= "</span>+ Thread.currentThread().getId() + <span class="string">"; 线程名字："</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//通过socket获取输入流</span></span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            <span class="comment">//循环的读取客户端发送的数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程信息：id= "</span>+ Thread.currentThread().getId() + <span class="string">"; 线程名字："</span> + Thread.currentThread().getName());</span><br><span class="line">                System.out.println(<span class="string">"read...."</span>);</span><br><span class="line">                <span class="keyword">int</span> read = inputStream.read(bytes);</span><br><span class="line">                <span class="keyword">if</span> (read != -<span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, read));<span class="comment">//输出客户端发送的数据</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"关闭和client的连接"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-BIO-问题分析"><a href="#3-3-BIO-问题分析" class="headerlink" title="3.3 BIO 问题分析"></a>3.3 BIO 问题分析</h3><ul><li>每个请求都需要创建独立的线程，与对应的客户端进行数据 <code>Read</code>，业务处理，数据 <code>Write</code> 。</li><li>当并发数较大时，需要<strong>创建大量线程来处理连接</strong>，系统资源占用较大。</li><li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 <code>Read</code> 操作上，造成线程资源浪费</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-01-BIO实战及原理&quot;&gt;&lt;a href=&quot;#Netty-01-BIO实战及原理&quot; class=&quot;headerlink&quot; title=&quot;Netty-01-BIO实战及原理&quot;&gt;&lt;/a&gt;Netty-01-BIO实战及原理&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;参考书籍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201002/105929076.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Netty权威指南 以5.x版本编写，建议还是以Netty in action为主&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-17-主从复制原理</title>
    <link href="http://zhuuu.work/2020/09/24/Mysql/Mysql-17-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86/"/>
    <id>http://zhuuu.work/2020/09/24/Mysql/Mysql-17-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86/</id>
    <published>2020-09-24T08:02:27.000Z</published>
    <updated>2020-09-25T11:04:47.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-17-主从复制原理"><a href="#Mysql-17-主从复制原理" class="headerlink" title="Mysql-17-主从复制原理"></a>Mysql-17-主从复制原理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><strong>主从复制</strong>是指将主数据库的DDL和DML操作通过二进制日志传到从数据库上，然后在从数据库上对这些日志进行重新执行，从而使从数据库和主数据库的数据保持一致。</li></ul><h2 id="1-主从复制的原理"><a href="#1-主从复制的原理" class="headerlink" title="1. 主从复制的原理"></a>1. 主从复制的原理</h2><ul><li><p><code>MySql</code>主库在事务提交时会把数据变更作为事件记录在二进制日志<code>Binlog</code>中；</p></li><li><p>主库推送二进制日志文件<code>Binlog</code>中的事件到从库的中继日志<code>Relay Log</code>中，之后从库根据中继日志重做数据变更操作，通过逻辑复制来达到主库和从库的数据一致性；</p></li><li><p><code>MySql</code>通过三个线程来完成主从库间的数据复制，其中<code>Binlog Dump</code>线程跑在主库上，I/O线程和<code>SQL</code>线程跑着从库上；</p></li><li><p>当在从库上启动复制时，首先创建I/O线程连接主库，主库随后创建<code>Binlog Dump</code>线程读取数据库事件并发送给<code>I/O</code>线程，<code>I/O</code>线程获取到事件数据后更新到从库的中继日志Relay Log中去，之后从库上的<code>SQL</code>线程读取中继日志<code>Relay Log</code>中更新的数据库事件并应用，如下图所示。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200925/190401809.png" alt="mark"></p><a id="more"></a><p><strong>参考博客</strong> ： <a href="https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&amp;mid=2453141544&amp;idx=2&amp;sn=da0ea11633faed02e1a1c1e03944b529&amp;chksm=8cf2daabbb8553bd4c62e19855707cacca6b6d0c5fcf500305bd8ca729c78dbe8f8372bb7d4e&amp;mpshare=1&amp;scene=1&amp;srcid=0924EQob7Vlt43qQ2WiqWEOt&amp;sharer_sharetime=1600909299821&amp;sharer_shareid=28c303bffd97904e2336a200423a1133&amp;key=50c6d0ff50751a997508b262a322b559b1b0d4d10c76c70ca94b15f61e691441497eabafb2218f1e05ae9802c61778d5bf6130e7db891e0b29bd2b3d4eb04ed4738b52fb046116adde4c9dfb8f79df9d6d892478ece561576c9d0b88d1a80be411b19d0993bcb1b092885e57ef27b58b20043eb931b4f22fb2fd31695693632e&amp;ascene=1&amp;uin=MTU5MDExNDg2MQ%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090529&amp;lang=zh_CN&amp;exportkey=AWvlglZ%2BXI9nU%2BxmH77cjLU%3D&amp;pass_ticket=empX%2Byd3FBncFv9Y3htB8V3ce9CK6LHHJOlGyuSLskLcjwytQcRRiL0ELWZl3dk0&amp;wx_header=0" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&amp;mid=2453141544&amp;idx=2&amp;sn=da0ea11633faed02e1a1c1e03944b529&amp;chksm=8cf2daabbb8553bd4c62e19855707cacca6b6d0c5fcf500305bd8ca729c78dbe8f8372bb7d4e&amp;mpshare=1&amp;scene=1&amp;srcid=0924EQob7Vlt43qQ2WiqWEOt&amp;sharer_sharetime=1600909299821&amp;sharer_shareid=28c303bffd97904e2336a200423a1133&amp;key=50c6d0ff50751a997508b262a322b559b1b0d4d10c76c70ca94b15f61e691441497eabafb2218f1e05ae9802c61778d5bf6130e7db891e0b29bd2b3d4eb04ed4738b52fb046116adde4c9dfb8f79df9d6d892478ece561576c9d0b88d1a80be411b19d0993bcb1b092885e57ef27b58b20043eb931b4f22fb2fd31695693632e&amp;ascene=1&amp;uin=MTU5MDExNDg2MQ%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090529&amp;lang=zh_CN&amp;exportkey=AWvlglZ%2BXI9nU%2BxmH77cjLU%3D&amp;pass_ticket=empX%2Byd3FBncFv9Y3htB8V3ce9CK6LHHJOlGyuSLskLcjwytQcRRiL0ELWZl3dk0&amp;wx_header=0</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mysql-17-主从复制原理&quot;&gt;&lt;a href=&quot;#Mysql-17-主从复制原理&quot; class=&quot;headerlink&quot; title=&quot;Mysql-17-主从复制原理&quot;&gt;&lt;/a&gt;Mysql-17-主从复制原理&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主从复制&lt;/strong&gt;是指将主数据库的DDL和DML操作通过二进制日志传到从数据库上，然后在从数据库上对这些日志进行重新执行，从而使从数据库和主数据库的数据保持一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-主从复制的原理&quot;&gt;&lt;a href=&quot;#1-主从复制的原理&quot; class=&quot;headerlink&quot; title=&quot;1. 主从复制的原理&quot;&gt;&lt;/a&gt;1. 主从复制的原理&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;MySql&lt;/code&gt;主库在事务提交时会把数据变更作为事件记录在二进制日志&lt;code&gt;Binlog&lt;/code&gt;中；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;主库推送二进制日志文件&lt;code&gt;Binlog&lt;/code&gt;中的事件到从库的中继日志&lt;code&gt;Relay Log&lt;/code&gt;中，之后从库根据中继日志重做数据变更操作，通过逻辑复制来达到主库和从库的数据一致性；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;MySql&lt;/code&gt;通过三个线程来完成主从库间的数据复制，其中&lt;code&gt;Binlog Dump&lt;/code&gt;线程跑在主库上，I/O线程和&lt;code&gt;SQL&lt;/code&gt;线程跑着从库上；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当在从库上启动复制时，首先创建I/O线程连接主库，主库随后创建&lt;code&gt;Binlog Dump&lt;/code&gt;线程读取数据库事件并发送给&lt;code&gt;I/O&lt;/code&gt;线程，&lt;code&gt;I/O&lt;/code&gt;线程获取到事件数据后更新到从库的中继日志Relay Log中去，之后从库上的&lt;code&gt;SQL&lt;/code&gt;线程读取中继日志&lt;code&gt;Relay Log&lt;/code&gt;中更新的数据库事件并应用，如下图所示。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200925/190401809.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux-09-进程调度算法</title>
    <link href="http://zhuuu.work/2020/09/22/Linux/Linux-09-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <id>http://zhuuu.work/2020/09/22/Linux/Linux-09-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</id>
    <published>2020-09-22T03:22:53.000Z</published>
    <updated>2020-10-04T12:46:54.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-09-进程调度算法"><a href="#Linux-09-进程调度算法" class="headerlink" title="Linux-09-进程调度算法"></a>Linux-09-进程调度算法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg" alt="mark"></p><ul><li>进程调度算法也称 CPU 调度算法，毕竟进程是由 CPU 调度的。</li><li>当 CPU 空闲时，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配 CPU。</li></ul><p>什么时候会发生 CPU 调度呢？通常有以下情况：</p><ol><li>当进程从运行状态转到等待状态；</li><li>当进程从运行状态转到就绪状态；</li><li>当进程从等待状态转到就绪状态；</li><li>当进程从运行状态转到终止状态；</li></ol><p>其中发生在 1 和 4 两种情况下的调度称为「非抢占式调度」，2 和 3 两种情况下发生的调度称为「抢占式调度」。</p><ul><li><strong>非抢占式</strong>的意思就是，当进程正在运行时，它就会一直运行，直到该进程完成或发生某个事件而被阻塞时，才会把 CPU 让给其他进程。</li><li>而<strong>抢占式调度</strong>，顾名思义就是进程正在运行的时，可以被打断，使其把 CPU 让给其他进程。那抢占的原则一般有三种，分别是时间片原则、优先权原则、短作业优先原则。</li></ul><a id="more"></a><ul><li>你可能会好奇为什么第 3 种情况也会发生 CPU 调度呢？<ul><li>假设有一个进程是处于等待状态的，但是它的优先级比较高，如果该进程等待的事件发生了，它就会转到就绪状态</li><li>一旦它转到就绪状态，如果我们的调度算法是以优先级来进行调度的，那么它就会立马抢占正在运行的进程，所以这个时候就会发生 CPU 调度。</li></ul></li></ul><ul><li>那第 2 种状态通常是时间片到的情况，因为时间片到了就会发生中断，于是就会抢占正在运行的进程，从而占用 CPU。</li></ul><p>调度算法影响的是等待时间（进程在就绪队列中等待调度的时间总和），而不能影响进程正在使用 CPU 的时间和 I/O 时间。</p><p>接下来，说说常见的调度算法：</p><ul><li>先来先服务调度算法</li><li>最短作业优先调度算法</li><li>高响应比优先调度算法</li><li>时间片轮转调度算法</li><li>最高优先级调度算法</li><li>多级反馈队列调度算法</li></ul><h2 id="1-进程调度算法"><a href="#1-进程调度算法" class="headerlink" title="1. 进程调度算法"></a>1. 进程调度算法</h2><h3 id="1-1-先来先服务调度算法"><a href="#1-1-先来先服务调度算法" class="headerlink" title="1.1 先来先服务调度算法"></a>1.1 先来先服务调度算法</h3><ul><li>最简单的一个调度算法，就是非抢占式的<strong>先来先服务（First Come First Severd, FCFS）算法</strong>了。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114729145.jpg" alt="mark"></p><ul><li>顾名思义，先来后到，<strong>每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</strong></li></ul><p><strong>缺点：</strong></p><ul><li>这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。（<strong>不会导致饥饿的产生</strong>）</li><li>FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I/O 繁忙型作业的系统。</li></ul><h3 id="1-2-最短作业优先调度算法"><a href="#1-2-最短作业优先调度算法" class="headerlink" title="1.2 最短作业优先调度算法"></a>1.2 最短作业优先调度算法</h3><ul><li><strong>最短作业优先（Shortest Job First, SJF）调度算法</strong>同样也是顾名思义，它会<strong>优先选择运行时间最短的进程来运行</strong>，这有助于提高系统的吞吐量。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114846841.jpg" alt="mark"></p><p><strong>缺点：</strong></p><ul><li>这显然对长作业不利，很容易造成一 种极端现象。（<strong>进程饥饿</strong>）</li><li>比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。</li></ul><h3 id="1-3-高响应比优先调度算法"><a href="#1-3-高响应比优先调度算法" class="headerlink" title="1.3 高响应比优先调度算法"></a>1.3 高响应比优先调度算法</h3><ul><li>前面的「先来先服务调度算法」和「最短作业优先调度算法」都没有很好的权衡短作业和长作业。</li><li>那么，<strong>高响应比优先 （Highest Response Ratio Next, HRRN）调度算法</strong>主要是权衡了短作业和长作业。</li><li><strong>每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行</strong>，「响应比优先级」的计算公式：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/135439932.png" alt="mark"></p><p>从上面的公式，可以发现：</p><ul><li><p><strong>如果两个进程的「等待时间」相同时</strong>，「要求的服务时间」越短，「响应比」就越高，这样短作业的进程容易被选中运行；</p></li><li><p><strong>如果两个进程「要求的服务时间」相同时</strong>，「等待时间」越长，「响应比」就越高，这就兼顾到了长作业进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会；</p></li><li><p><strong>不会导致饥饿</strong></p></li></ul><h3 id="1-4-时间片轮转调度算法"><a href="#1-4-时间片轮转调度算法" class="headerlink" title="1.4 时间片轮转调度算法"></a>1.4 时间片轮转调度算法</h3><ul><li>最古老、最简单、最公平且使用最广的算法就是<strong>时间片轮转（*Round Robin, RR*）调度算法</strong>。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/135825753.png" alt="mark"></p><p><strong>每个进程被分配一个时间段，称为时间片（*Quantum*），即允许该进程在该时间段中运行。</strong></p><ul><li>如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程；</li><li>如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；</li></ul><p>另外，时间片的长度就是一个很关键的点：</p><ul><li>如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；</li><li>如果设得太长又可能引起对短作业进程的响应时间变长；</li></ul><p>通常时间片设为 <code>20ms~50ms</code> 通常是一个比较合理的折中值。</p><h3 id="1-5-最高优先级调度算法"><a href="#1-5-最高优先级调度算法" class="headerlink" title="1.5 最高优先级调度算法"></a>1.5 最高优先级调度算法</h3><ul><li>前面的「时间片轮转算法」做了个假设，即让所有的进程同等重要，也不偏袒谁，大家的运行时间都一样。</li><li>但是，对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能<strong>从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（*Highest Priority First，HPF*）调度算法</strong>。</li></ul><p>进程的优先级可以分为，静态优先级或动态优先级：</p><ul><li>静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；</li><li>动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是<strong>随着时间的推移增加等待进程的优先级</strong>。</li></ul><p>该算法也有两种处理优先级高的方法，非抢占式和抢占式</p><ul><li>非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。</li><li>抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。</li></ul><p>但是依然有缺点，可能会导致低优先级的进程永远不会运行。</p><h3 id="1-6-多级反馈队列调度算法"><a href="#1-6-多级反馈队列调度算法" class="headerlink" title="1.6 多级反馈队列调度算法"></a>1.6 多级反馈队列调度算法</h3><ul><li><strong>多级反馈队列（*Multilevel Feedback Queue*）调度算法</strong>是「时间片轮转算法」和「最高优先级算法」的综合和发展。</li></ul><p>顾名思义：</p><ul><li>「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。</li><li>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/140252098.png" alt="mark"></p><p>来看看，它是如何工作的：</p><ul><li>设置了多个队列，赋予每个队列不同的优先级，每个<strong>队列优先级从高到低</strong>，同时<strong>优先级越高时间片越短</strong>；</li><li>新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；</li><li>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；</li></ul><p>可以发现，对于<strong>短作业</strong>可能可以在第一级队列很快被处理完。</p><p>对于<strong>长作业</strong>，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了，所以该算法很好的<strong>兼顾了长短作业，同时有较好的响应时间。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-09-进程调度算法&quot;&gt;&lt;a href=&quot;#Linux-09-进程调度算法&quot; class=&quot;headerlink&quot; title=&quot;Linux-09-进程调度算法&quot;&gt;&lt;/a&gt;Linux-09-进程调度算法&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程调度算法也称 CPU 调度算法，毕竟进程是由 CPU 调度的。&lt;/li&gt;
&lt;li&gt;当 CPU 空闲时，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配 CPU。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;什么时候会发生 CPU 调度呢？通常有以下情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当进程从运行状态转到等待状态；&lt;/li&gt;
&lt;li&gt;当进程从运行状态转到就绪状态；&lt;/li&gt;
&lt;li&gt;当进程从等待状态转到就绪状态；&lt;/li&gt;
&lt;li&gt;当进程从运行状态转到终止状态；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中发生在 1 和 4 两种情况下的调度称为「非抢占式调度」，2 和 3 两种情况下发生的调度称为「抢占式调度」。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;非抢占式&lt;/strong&gt;的意思就是，当进程正在运行时，它就会一直运行，直到该进程完成或发生某个事件而被阻塞时，才会把 CPU 让给其他进程。&lt;/li&gt;
&lt;li&gt;而&lt;strong&gt;抢占式调度&lt;/strong&gt;，顾名思义就是进程正在运行的时，可以被打断，使其把 CPU 让给其他进程。那抢占的原则一般有三种，分别是时间片原则、优先权原则、短作业优先原则。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="进程调度" scheme="http://zhuuu.work/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper-02-ZAB协议</title>
    <link href="http://zhuuu.work/2020/09/17/Zookeeper/ZooKeeper-02-ZAB%E5%8D%8F%E8%AE%AE/"/>
    <id>http://zhuuu.work/2020/09/17/Zookeeper/ZooKeeper-02-ZAB%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-09-17T09:38:38.000Z</published>
    <updated>2020-09-25T07:58:30.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ZooKeeper-02-ZAB协议"><a href="#ZooKeeper-02-ZAB协议" class="headerlink" title="ZooKeeper-02-ZAB协议"></a>ZooKeeper-02-ZAB协议</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><code>Zab（Zookeeper Atomic Broadcast）</code>是为ZooKeeper协设计的崩溃恢复原子广播协议，它保证zookeeper集群数据的一致性和命令的全局有序性。</li></ul><a id="more"></a><h2 id="1-概念介绍"><a href="#1-概念介绍" class="headerlink" title="1. 概念介绍"></a>1. 概念介绍</h2><h3 id="1-1-集群角色"><a href="#1-1-集群角色" class="headerlink" title="1.1 集群角色"></a>1.1 集群角色</h3><ul><li><p><code>Leader</code>：同一时间集群总只允许有一个Leader，提供对客户端的读写功能，负责将数据同步至各个节点；</p></li><li><p><code>Follower</code>：提供对客户端读功能，写请求则转发给Leader处理，当Leader崩溃失联之后参与Leader选举；</p></li><li><p><code>Observer</code>：与Follower不同的是但不参与Leader选举。</p></li></ul><h3 id="1-2-服务状态"><a href="#1-2-服务状态" class="headerlink" title="1.2 服务状态"></a>1.2 服务状态</h3><ul><li><code>LOOKING</code>：当节点认为群集中没有Leader，服务器会进入LOOKING状态，目的是为了查找或者选举Leader；</li><li><code>FOLLOWING</code>：follower角色；</li><li><code>LEADING</code>：leader角色；</li><li><code>OBSERVING</code>：observer角色；</li></ul><p>可以知道Zookeeper是通过自身的状态来区分自己所属的角色，来执行自己应该的任务。</p><h3 id="1-3-ZAB四种状态"><a href="#1-3-ZAB四种状态" class="headerlink" title="1.3 ZAB四种状态"></a>1.3 ZAB四种状态</h3><ul><li><strong>ZAB状态</strong>Zookeeper还给ZAB定义的4种状态，反应Zookeeper从选举到对外提供服务的过程中的四个步骤。状态枚举定义：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200925/153730944.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. ELECTION: 集群进入选举状态，此过程会选出一个节点作为leader角色；</span><br><span class="line">2. DISCOVERY：连接上leader，响应leader心跳，并且检测leader的角色是否更改，通过此步骤之后选举出的leader才能执行真正职务；</span><br><span class="line">3. SYNCHRONIZATION：整个集群都确认leader之后，将会把leader的数据同步到各个节点，保证整个集群的数据一致性；</span><br><span class="line">4. BROADCAST：过渡到广播状态，集群开始对外提供服务。</span><br></pre></td></tr></table></figure><h3 id="1-4-ZXID"><a href="#1-4-ZXID" class="headerlink" title="1.4 ZXID"></a>1.4 ZXID</h3><ul><li><code>Zxid</code>是极为重要的概念，它是一个long型（64位）整数，分为两部分：纪元（epoch）部分和计数器（<code>counter</code>）部分，是一个<strong>全局有序</strong>的数字。<ul><li>epoch代表当前集群所属的哪个leader，leader的选举就类似一个朝代的更替，你前朝的剑不能斩本朝的官，用epoch代表当前命令的有效性，</li><li>counter是一个<strong>递增的数字</strong>。</li></ul></li></ul><h2 id="2-选举"><a href="#2-选举" class="headerlink" title="2. 选举"></a>2. 选举</h2><ul><li>基础概念介绍完了，下面开始介绍zab协议是怎么支持leader选举的。</li><li>进行leader有三个问题<ul><li>什么时候进行？</li><li>选举规则？</li><li>选择流程？</li></ul></li></ul><ol><li><p><strong>选举发生的时机</strong>Leader发生选举有两个时机，一个是服务启动的时候当整个集群都没有leader节点会进入选举状态，如果leader已经存在就会告诉该节点leader的信息，自己连接上leader，整个集群不用进入选举状态。</p><p>还有一个就是在服务运行中，可能会出现各种情况，服务宕机、断电、网络延迟很高的时候leader都不能再对外提供服务了，所有当其他几点通过<strong>心跳检测</strong>到leader失联之后，集群也会进入选举状态。（<strong>可能会出现脑裂问题）</strong></p></li></ol><ol start="2"><li><strong>选举规则</strong>进入投票选举流程，怎么才能选举出leader？或者说按照什么规则来让其他节点都能选举你当leader。<ul><li>zab协议是按照几个比较规则来进行投票的筛选，如果你的票比我更好，就修改自身的投票信息，改投你当leader。</li><li>下面代码是zookeeper投票比较规则：</li><li>当其他节点的纪元比自身高投它，如果纪元相同比较自身的zxid的大小，选举zxid大的节点，这里的zxid代表节点所提交事务最大的id，zxid越大代表该节点的数据越完整。</li><li>最后如果epoch和zxid都相等，则比较服务的serverId，这个Id是配置zookeeper集群所配置的，所以我们配置zookeeper集群的时候可以把服务性能更高的集群的serverId配置大些，让性能好的机器担任leader角色。</li></ul></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200925/154615159.png" alt="mark"></p><ol start="3"><li><strong>选举流程</strong></li></ol><ul><li>时机和规则都有了，下面就是leader的选举流程：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200925/154749324.jpg" alt="mark"></p><ul><li>所有节点第一票先选举自己当leader，将投票信息广播出去；</li><li>从队列中接受投票信息；</li><li>按照规则判断是否需要更改投票信息，将更改后的投票信息再次广播出去；</li><li>判断是否有超过一半的投票选举同一个节点，如果是选举结束根据投票结果设置自己的服务状态，选举结束，否则继续进入投票流程。</li></ul><p><strong>举个例子</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200925/154846036.jpg" alt="mark"></p><h2 id="3-广播"><a href="#3-广播" class="headerlink" title="3. 广播"></a>3. 广播</h2><ul><li>集群在经过leader选举之后还会有连接leader和同步两个步骤，这里就不具体分析这两个步骤的流程了，主要介绍集群<strong>对外提供服务如何保证各个节点数据的一致性</strong>。</li></ul><p>zab在广播状态中保证以下特征</p><ul><li><strong>可靠传递:</strong> 如果消息m由一台服务器传递，那么它最终将由所有服务器传递。</li><li><strong>全局有序:</strong> 如果一个消息a在消息b之前被一台服务器交付，那么所有服务器都交付了a和b，并且a先于b。</li><li><strong>因果有序:</strong> 如果消息a在因果上先于消息b并且二者都被交付，那么a必须排在b之前。</li></ul><p><strong>有序性</strong>是zab协议必须要保证的一个很重要的属性，因为zookeeper是以类似目录结构的数据结构存储数据的，必须要求命名的有序性。（比如一个命名a创建路径为/test，然后命名b创建路径为/test/123，如果不能保证有序性b命名在a之前，b命令会因为父节点不存在而创建失败。）</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200925/155158176.jpg" alt="mark"></p><p>如上图所示，整个写请求类似一个二阶段的提交。</p><p>当收到客户端的写请求的时候会经历以下几个步骤：</p><ol><li>Leader收到客户端的写请求，生成一个事务（Proposal），其中包含了zxid；</li><li>Leader开始广播该事务，需要注意的是所有节点的通讯都是由一个FIFO的队列维护的；</li><li>Follower接受到事务之后，将事务写入本地磁盘，写入成功之后返回Leader一个ACK；</li><li>Leader收到过半的ACK之后，开始提交本事务，并广播事务提交信息</li><li>从节点开始提交本事务。</li></ol><p><strong>有以上流程可知，zookeeper通过二阶段提交来保证集群中数据的一致性，因为只需要收到过半的ACK就可以提交事务，所以zookeeper的数据并不是强一致性。</strong></p><p>zab协议的有序性保证是通过几个方面来体现的，</p><ul><li>第一，服务之前用TCP协议进行通讯，保证在网络传输中的有序性；</li><li>第二，节点之前都维护了一个FIFO的队列，保证全局有序性；</li><li>第三，通过全局递增的zxid保证因果有序性。</li></ul><h2 id="4-状态流转"><a href="#4-状态流转" class="headerlink" title="4. 状态流转"></a>4. 状态流转</h2><ul><li>前面介绍了zookeeper服务状态有四种，ZAB状态也有四种。这里就简单介绍一个他们之间的状态流转，更能加深对zab协议在zookeeper工作流程中的作用。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200925/155422758.jpg" alt="mark"></p><ol><li>服务在启动或者和leader失联之后服务状态转为LOOKING；</li><li>如果leader不存在选举leader，如果存在直接连接leader，此时zab协议状态为ELECTION；</li><li>如果有超过半数的投票选择同一台server，则leader选举结束，被选举为leader的server服务状态为LEADING，其他server服务状态为FOLLOWING/OBSERVING；</li><li>所有server连接上leader，此时zab协议状态为DISCOVERY；</li><li>leader同步数据给learner，使各个从节点数据和leader保持一致，此时zab协议状态为SYNCHRONIZATION；</li><li>同步超过一半的server之后，集群对外提供服务，此时zab状态为BROADCAST。</li></ol><p><strong>可以知道整个zookeeper服务的工作流程类似一个状态机的转换，而zab协议就是驱动服务状态流转的关键，理解了zab就理解了zookeeper工作的关键原理</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ZooKeeper-02-ZAB协议&quot;&gt;&lt;a href=&quot;#ZooKeeper-02-ZAB协议&quot; class=&quot;headerlink&quot; title=&quot;ZooKeeper-02-ZAB协议&quot;&gt;&lt;/a&gt;ZooKeeper-02-ZAB协议&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Zab（Zookeeper Atomic Broadcast）&lt;/code&gt;是为ZooKeeper协设计的崩溃恢复原子广播协议，它保证zookeeper集群数据的一致性和命令的全局有序性。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="分布式" scheme="http://zhuuu.work/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Zookeeper" scheme="http://zhuuu.work/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Linux-05-C10K</title>
    <link href="http://zhuuu.work/2020/09/10/Linux/Linux-05-C10K/"/>
    <id>http://zhuuu.work/2020/09/10/Linux/Linux-05-C10K/</id>
    <published>2020-09-10T07:12:53.000Z</published>
    <updated>2020-09-16T00:33:31.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-05-C10K"><a href="#Linux-05-C10K" class="headerlink" title="Linux-05-C10K"></a>Linux-05-C10K</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>随着互联网的普及，应用的用户群体几何倍增长，此时<strong>服务器性能问题就出现。最初的服务器是基于进程/线程模型。新到来一个TCP连接，就需要分配一个进程。假如有C10K，就需要创建1W个进程，可想而知单机是无法承受的。</strong></li><li>那么如何突破单机性能是高性能网络编程必须要面对的问题，进而这些局限和问题就统称为C10K问题，最早是由Dan Kegel进行归纳和总结的，并且他也系统的分析和提出解决方案。</li></ul><h2 id="C10的本质"><a href="#C10的本质" class="headerlink" title="C10的本质"></a>C10的本质</h2><ul><li><strong>C10K问题的本质上是操作系统的问题。</strong></li><li>对于Web 1.0/2.0时代的操作系统，传统的同步阻塞I/O模型处理方式都是requests per second。</li><li>当创建的进程或线程多了，数据拷贝频繁（缓存I/O、内核将数据拷贝到用户进程空间、阻塞，进程/线程上下文切换消耗大， 导致操作系统崩溃，这就是C10K问题的本质。</li></ul><p>可见, 解决C10K问题的关键就是尽可能减少这些CPU资源消耗。</p><a id="more"></a><h2 id="C10K的解决方案"><a href="#C10K的解决方案" class="headerlink" title="C10K的解决方案"></a>C10K的解决方案</h2><p>从网络编程技术的角度来说，主要思路：</p><ol><li><strong>每个连接分配一个独立的线程/进程</strong></li><li><strong>同一个线程/进程同时处理多个连接</strong></li></ol><p><strong>方案一：每个连接分配一个独立的线程/进程</strong></p><ul><li>该思路最为直接，但是申请进程/线程是需要系统资源的，且系统需要管理这些进程/线程，所以会使资源占用过多，可扩展性差</li></ul><p><strong>方法二： 每个进程/线程同时处理 多个连接(I/O多路复用)</strong></p><ul><li><p><strong>select方式：</strong>使用fd_set结构体告诉内核同时监控那些文件句柄，使用逐个排查方式去检查是否有文件句柄就绪或者超时。该方式有以下缺点：文件句柄数量是有上线的，逐个检查吞吐量低，每次调用都要重复初始化fd_set。</p></li><li><p><strong>poll方式：</strong></p><ul><li>该方式主要解决了select方式的2个缺点，文件句柄上限问题(链表方式存储)以及重复初始化问题(不同字段标注关注事件和发生事件)，</li><li>但是逐个去检查文件句柄是否就绪的问题仍然没有解决。</li></ul></li><li><p><strong>epoll方式：</strong></p><ul><li>该方式可以说是C10K问题的killer，他不去轮询监听所有文件句柄是否已经就绪。epoll只对发生变化的文件句柄感兴趣。</li><li>其工作机制是，使用”事件”的就绪通知方式，通过epoll_ctl注册文件描述符fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd, epoll_wait便可以收到通知, 并通知应用程序。</li><li>而且epoll使用一个文件描述符管理多个描述符,将用户进程的文件描述符的事件存放到内核的一个事件表中, 这样数据只需要从内核缓存空间拷贝一次到用户进程地址空间。</li><li>而且epoll是通过内核与用户空间共享内存方式来实现事件就绪消息传递的，其效率非常高。但是epoll是依赖系统的(Linux)。</li></ul></li></ul><p>以及异步I/O以及Windows，该方式在windows上支持很好</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-05-C10K&quot;&gt;&lt;a href=&quot;#Linux-05-C10K&quot; class=&quot;headerlink&quot; title=&quot;Linux-05-C10K&quot;&gt;&lt;/a&gt;Linux-05-C10K&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;随着互联网的普及，应用的用户群体几何倍增长，此时&lt;strong&gt;服务器性能问题就出现。最初的服务器是基于进程/线程模型。新到来一个TCP连接，就需要分配一个进程。假如有C10K，就需要创建1W个进程，可想而知单机是无法承受的。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;那么如何突破单机性能是高性能网络编程必须要面对的问题，进而这些局限和问题就统称为C10K问题，最早是由Dan Kegel进行归纳和总结的，并且他也系统的分析和提出解决方案。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;C10的本质&quot;&gt;&lt;a href=&quot;#C10的本质&quot; class=&quot;headerlink&quot; title=&quot;C10的本质&quot;&gt;&lt;/a&gt;C10的本质&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;C10K问题的本质上是操作系统的问题。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;对于Web 1.0/2.0时代的操作系统，传统的同步阻塞I/O模型处理方式都是requests per second。&lt;/li&gt;
&lt;li&gt;当创建的进程或线程多了，数据拷贝频繁（缓存I/O、内核将数据拷贝到用户进程空间、阻塞，进程/线程上下文切换消耗大， 导致操作系统崩溃，这就是C10K问题的本质。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可见, 解决C10K问题的关键就是尽可能减少这些CPU资源消耗。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
      <category term="多路复用" scheme="http://zhuuu.work/tags/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-final全家桶</title>
    <link href="http://zhuuu.work/2020/09/08/JavaInterview/Java-%E5%9F%BA%E7%A1%80-final%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    <id>http://zhuuu.work/2020/09/08/JavaInterview/Java-%E5%9F%BA%E7%A1%80-final%E5%85%A8%E5%AE%B6%E6%A1%B6/</id>
    <published>2020-09-08T09:34:38.000Z</published>
    <updated>2020-09-19T08:51:48.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-final全家桶"><a href="#Java-基础-final全家桶" class="headerlink" title="Java-基础-final全家桶"></a>Java-基础-final全家桶</h1><h2 id="1-final"><a href="#1-final" class="headerlink" title="1. final"></a>1. final</h2><ul><li>在java中，final可以用来修饰类，方法和变量（成员变量或局部变量）。下面将对其详细介绍。</li></ul><h3 id="1-1-修饰类"><a href="#1-1-修饰类" class="headerlink" title="1.1 修饰类"></a>1.1 修饰类</h3><ul><li>当用final修饰类的时，表明该类不能被其他类所继承。当我们需要让一个类永远不被继承，此时就可以用final修饰，<strong>但要注意：</strong></li><li>final类中所有的成员方法都会隐式的定义为final方法。</li></ul><a id="more"></a><h3 id="1-2-修饰方法"><a href="#1-2-修饰方法" class="headerlink" title="1.2 修饰方法"></a>1.2 修饰方法</h3><ul><li>使用final方法的原因主要有两个：<ul><li>(1) 把方法锁定，以防止继承类对其进行更改。</li><li>(2) 效率，在早期的java版本中，会将final方法转为内嵌调用。但若方法过于庞大，可能在性能上不会有多大提升。因此在最近版本中，不需要final方法进行这些优化了。</li></ul></li></ul><p>final方法意味着“最后的、最终的”含义，即此方法不能被重写。</p><p><strong>注意：</strong></p><ul><li><strong>若父类中final方法的访问权限为private，将导致子类中不能直接继承该方法，因此，此时可以在子类中定义相同方法名的函数，此时不会与重写final的矛盾，而是在子类中重新地定义了新方法。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"OK"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在java中，String被设计成final类，那为什么平时使用时，String的值可以被改变呢？<ul><li>字符串常量池是java堆内存中一个特殊的存储区域，当我们建立一个String对象时，假设常量池不存在该字符串，则创建一个，若存在则直接引用已经存在的字符串。</li><li>当我们对String对象值改变的时候，例如 String a=”A”; a=”B” 。a是String对象的一个引用（我们这里所说的String对象其实是指字符串常量）<ul><li>当a=“B”执行时，并不是原本String对象(“A”)发生改变，而是创建一个新的对象(“B”)，令a引用它。</li></ul></li></ul></li></ul><h3 id="1-3-修饰变量"><a href="#1-3-修饰变量" class="headerlink" title="1.3 修饰变量"></a>1.3 修饰变量</h3><ul><li><p>final成员变量表示常量，只能被赋值一次，赋值后其值不再改变。类似于C++中的const。</p><ul><li>当final修饰一个<strong>基本数据类型</strong>时，表示该基本数据类型的值一旦在初始化后便不能发生变化；</li><li>如果final修饰一个<strong>引用类型时</strong>，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。</li></ul></li><li><p><strong>final修饰一个成员变量（属性），必须要显示初始化。**</strong>这里有两种初始化方式**，一种是在变量声明的时候初始化；第二种方法是在声明变量的时候不赋初值，但是要在这个变量所在的类的所有的构造函数中对这个变量赋初值。</p></li><li><p>当函数的参数类型声明为final时，说明该参数是只读型的。即你可以读取使用该参数，但是无法改变该参数的值。</p></li></ul><h2 id="2-finally"><a href="#2-finally" class="headerlink" title="2. finally"></a>2. finally</h2><ul><li>finally作为异常处理的一部分，它只能用在try/catch语句中，并且附带一个语句块，表示这段语句最终一定会被执行（不管有没有抛出异常），经常被用在需要释放资源的情况下。（×）（这句话其实存在一定的问题）</li><li>很多人都认为finally语句块一定会执行，但真的是这样么？答案是否定的，例如下面这个例子：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200919/164140271.png" alt="mark"></p><p>当我们去掉注释的三行语句，执行结果为：</p><p><code>return 0</code></p><ul><li><p>为什么在以上两种情况下都没有执行finally语句呢，说明什么问题？</p><ul><li><strong>只有与<code>finally</code>对应的<code>try</code>语句块得到执行的情况下，<code>finally</code>语句块才会执行。以上两种情况在执行<code>try</code>语句块之前已经返回或抛出异常，所以try对应的<code>finally</code>语句并没有执行。</strong></li></ul></li><li><p>但是，在某些情况下，即使try语句执行了，finally语句也不一定执行。例如以下情况：</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200919/164323776.png" alt="mark"></p><ul><li>finally 语句块还是没有执行，为什么呢？因为我们在 try 语句块中执行了 <code>System.exit (0)</code>语句，终止了 Java 虚拟机的运行。那有人说了，在一般的 Java 应用中基本上是不会调用这个 <code>System.exit(0)</code> 方法的。OK ！没有问题，我们不调用 <code>System.exit(0)</code>这个方法，那么<code>finally</code> 语句块就一定会执行吗？</li><li>再一次让大家失望了，答案还是否定的。当一个线程在执行 try 语句块或者 catch 语句块时被打断（<code>interrupted</code>）或者被终止（killed），与其相对应的 finally 语句块可能不会执行。</li><li>还有更极端的情况，就是在线程运行<code>try</code> 语句块或者 <code>catch</code> 语句块时，突然死机或者断电，<code>finally</code> 语句块肯定不会执行了。可能有人认为死机、断电这些理由有些强词夺理，没有关系，我们只是为了说明这个问题。</li></ul><h3 id="2-1-一个易错点"><a href="#2-1-一个易错点" class="headerlink" title="2.1 一个易错点"></a>2.1 一个易错点</h3><ul><li>在try-catch-finally语句中执行return语句。我们看如下代码：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200919/164625386.png" alt="mark"></p><p><strong>答案：4,4,4 。  为什么呢？</strong></p><ul><li>首先finally语句在改代码中一定会执行，从运行结果来看，每次return的结果都是4（即finally语句），仿佛其他return语句被屏蔽掉了。</li><li>事实也确实如此，因为finally用法特殊，所以会撤销之前的return语句，继续执行最后的finally块中的代码。 </li></ul><h2 id="3-finalize"><a href="#3-finalize" class="headerlink" title="3. finalize"></a>3. finalize</h2><ul><li><p><code>finalize()</code>是在<code>java.lang.Object</code>里定义的，也就是说每一个对象都有这么个方法。</p></li><li><p><strong>这个方法在gc启动，该对象被回收的时候被调用</strong>。其实gc可以回收大部分的对象（凡是new出来的对象，gc都能搞定，一般情况下我们又不会用new以外的方式去创建对象），所以一般是不需要程序员去实现finalize的。 </p></li><li><p>特殊情况下，需要程序员实现<code>finalize</code>，当对象被回收的时候释放一些资源，比如：一个<code>socket</code>链接，在对象初始化时创建，整个生命周期内有效，那么就需要实现finalize，关闭这个链接。 </p></li></ul><p><strong>使用finalize还需要注意一个事，调用super.finalize();</strong></p><ul><li>一个对象的finalize()方法只会被调用一次，而且finalize()被调用不意味着gc会立即回收该对象，所以有可能调用finalize()后，该对象又不需要被回收了</li><li>然后到了真正要被回收的时候，因为前面调用过一次，所以不会调用finalize()，产生问题。</li><li>所以，推荐不要使用finalize()方法，它跟析构函数不一样.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-final全家桶&quot;&gt;&lt;a href=&quot;#Java-基础-final全家桶&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-final全家桶&quot;&gt;&lt;/a&gt;Java-基础-final全家桶&lt;/h1&gt;&lt;h2 id=&quot;1-final&quot;&gt;&lt;a href=&quot;#1-final&quot; class=&quot;headerlink&quot; title=&quot;1. final&quot;&gt;&lt;/a&gt;1. final&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在java中，final可以用来修饰类，方法和变量（成员变量或局部变量）。下面将对其详细介绍。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-1-修饰类&quot;&gt;&lt;a href=&quot;#1-1-修饰类&quot; class=&quot;headerlink&quot; title=&quot;1.1 修饰类&quot;&gt;&lt;/a&gt;1.1 修饰类&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;当用final修饰类的时，表明该类不能被其他类所继承。当我们需要让一个类永远不被继承，此时就可以用final修饰，&lt;strong&gt;但要注意：&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;final类中所有的成员方法都会隐式的定义为final方法。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="final" scheme="http://zhuuu.work/tags/final/"/>
    
      <category term="finally" scheme="http://zhuuu.work/tags/finally/"/>
    
      <category term="finalize" scheme="http://zhuuu.work/tags/finalize/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-16-索引覆盖和索引下推</title>
    <link href="http://zhuuu.work/2020/09/08/Mysql/Mysql-16-%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E5%92%8C%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/"/>
    <id>http://zhuuu.work/2020/09/08/Mysql/Mysql-16-%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E5%92%8C%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/</id>
    <published>2020-09-08T08:02:27.000Z</published>
    <updated>2020-09-22T13:49:21.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-16-索引覆盖和索引下推"><a href="#Mysql-16-索引覆盖和索引下推" class="headerlink" title="Mysql-16-索引覆盖和索引下推"></a>Mysql-16-索引覆盖和索引下推</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>数据表结构如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create table user (</span><br><span class="line">    id int primary key,</span><br><span class="line">    name varchar(20),</span><br><span class="line">    sex varchar(5),</span><br><span class="line">    index(name)</span><br><span class="line">)engine&#x3D;innodb;</span><br><span class="line"></span><br><span class="line"># 接下来两个查询是截然不同的</span><br><span class="line">select id,name where name&#x3D;&#39;shenjian&#39;</span><br><span class="line"> </span><br><span class="line">select id,name,sex where name&#x3D;&#39;shenjian&#39;</span><br></pre></td></tr></table></figure><p><strong>多查询了一个属性，为何检索过程完全不同？</strong></p><p>　1. 　<strong>什么是回表查询？</strong></p><p>　2. 　<strong>什么是索引覆盖？</strong></p><p>　3. 　<strong>如何实现索引覆盖？</strong></p><p><strong>哪些场景，可以利用索引覆盖来优化SQL？</strong></p><p>PS： <em>本文试验基于MySQL5.6-InnoDB。</em></p><a id="more"></a><h2 id="1-回表查询"><a href="#1-回表查询" class="headerlink" title="1. 回表查询"></a>1. 回表查询</h2><p>这先要从<code>InnoDB</code>的索引实现说起，<code>InnoDB</code>有两大类索引：</p><ul><li>聚集索引(<code>clustered index</code>)</li><li>普通索引(<code>secondary index</code>)</li></ul><p><strong>InnoDB聚集索引和普通索引有什么差异？</strong></p><ul><li>InnoDB<strong>聚集索引</strong>的叶子节点存储行记录，因此， InnoDB必须要有，且只有一个聚集索引：</li></ul><ol><li>关于聚集索引有如下特性：</li></ol><p>（1）如果表定义了PK，则PK就是聚集索引；</p><p>（2）如果表没有定义PK，则第一个<code>not NULL unique</code>列是聚集索引；</p><p>（3）否则，<code>InnoDB</code>会创建一个隐藏的<code>row-id</code>作为聚集索引；</p><p><em>画外音：所以PK查询非常快，直接定位行记录。</em></p><ol start="2"><li><strong>普通索引又叫做非聚集索引：存放主键值</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">举个栗子，不妨设有表：</span><br><span class="line"></span><br><span class="line">　　t(id PK, name KEY, sex, flag);</span><br><span class="line"></span><br><span class="line">画外音：id是聚集索引，name是普通索引。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">表中有四条记录：</span><br><span class="line"></span><br><span class="line">　　1, shenjian, m, A</span><br><span class="line"></span><br><span class="line">　　3, zhangsan, m, A</span><br><span class="line"></span><br><span class="line">　　5, lisi, m, A</span><br><span class="line"></span><br><span class="line">　　9, wangwu, f, B</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200922/202123097.png" alt="mark"></p><p>两个B+树索引分别如上图：</p><ul><li>id为PK，聚集索引，叶子节点存储行记录；</li><li>name为KEY，普通索引，叶子节点存储PK值，即id；</li></ul><p>既然从普通索引无法直接定位行记录，那<strong>普通索引的查询过程是怎么样的呢？</strong></p><ul><li><strong>回表查询因此出现了</strong></li><li>通常情况下，需要扫码两遍索引树。</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where name&#x3D;&#39;lisi&#39;;</span><br></pre></td></tr></table></figure><p><strong>是如何执行的呢？</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200922/202248321.png" alt="mark"></p><p>如<strong>粉红色</strong>路径，需要扫码两遍索引树：</p><p>（1）先通过普通索引定位到主键值id=5；</p><p>（2）在通过聚集索引定位到行记录；</p><p>这就是所谓的<strong>回表查询</strong>，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。</p><h2 id="2-索引覆盖"><a href="#2-索引覆盖" class="headerlink" title="2. 索引覆盖"></a>2. 索引覆盖</h2><ol><li><strong>什么是索引覆盖(Covering index)？</strong></li></ol><ul><li>借用一下SQL-Server官网的说法。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200922/202458539.png" alt="mark"></p><ul><li>MySQL官网，类似的说法出现在explain查询计划优化章节，即explain的输出结果Extra字段为<strong>Using index</strong>时，能够触发索引覆盖。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200922/202522480.png" alt="mark"></p><p>不管是SQL-Server官网，还是MySQL官网，都表达了：<strong>只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。</strong></p><ol start="2"><li><strong>如何实现索引覆盖？</strong></li></ol><ul><li>常见的方法是：<strong>将被查询的字段，建立到联合索引里去。</strong></li></ul><p>仍是之前中的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table user (</span><br><span class="line">    id int primary key,</span><br><span class="line">    name varchar(20),</span><br><span class="line">    sex varchar(5),</span><br><span class="line">    index(name)</span><br><span class="line">)engine&#x3D;innodb;</span><br></pre></td></tr></table></figure><ul><li>第一个SQL语句：　<code>select</code> <code>id,name</code> <code>from</code> <code>user</code> <code>where</code> <code>name=&#39;shenjian&#39;;</code></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200922/202917251.png" alt="mark"></p><p>能够命中name索引，索引叶子节点存储了主键id，通过name的索引树即可获取id和name，无需回表，符合索引覆盖，效率较高。</p><p><em>画外音，Extra：<strong>Using index</strong>。</em></p><ul><li>第二个SQL语句： <code>select</code> <code>id,name,sex from</code> <code>user</code> <code>where</code> <code>name=&#39;shenjian&#39;;</code></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200922/203020049.png" alt="mark"></p><p>能够命中name索引，索引叶子节点存储了主键id，但sex字段必须回表查询才能获取到，不符合索引覆盖，需要再次通过id值扫码聚集索引获取sex字段，效率会降低。</p><p><em>画外音，Extra：<strong>Using index condition</strong>。</em></p><ul><li><strong>如果把(name)单列索引升级为联合索引(name, sex)就不同了。</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table user (</span><br><span class="line">    id int primary key,</span><br><span class="line">    name varchar(20),</span><br><span class="line">    sex varchar(5),</span><br><span class="line">    index(name, sex)</span><br><span class="line">)engine&#x3D;innodb;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200922/203205054.png" alt="mark"></p><p><strong>可以看到：都能够命中索引覆盖，无需回表。</strong></p><p><em>画外音，Extra：<strong>Using index</strong>。</em></p><h2 id="3-索引覆盖的场景"><a href="#3-索引覆盖的场景" class="headerlink" title="3. 索引覆盖的场景"></a>3. 索引覆盖的场景</h2><p><strong>场景1：全表count查询优化</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200922/203321222.png" alt="mark"></p><p>原表为：</p><p><em>user(PK id, name, sex)；</em></p><ul><li><p>如果直接<code>select</code> <code>count(name) from</code> <code>user;</code>不能利用索引覆盖。</p></li><li><p>添加索引：<code>alter</code> <code>table</code> <code>user</code> <code>add</code> <code>key(name);</code>   就能够利用索引覆盖提效。</p></li></ul><p><strong>场景2：列查询回表优化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select&#96; &#96;id,&#96;&#96;name&#96;&#96;,sex ... &#96;&#96;where&#96; &#96;name&#96;&#96;&#x3D;&#96;&#96;&#39;shenjian&#39;&#96;&#96;;</span><br></pre></td></tr></table></figure><ul><li>这个例子不再赘述，将单列索引(name)升级为联合索引(name, sex)，即可避免回表。</li></ul><p><strong>场景3：分页查询</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select&#96; &#96;id,&#96;&#96;name&#96;&#96;,sex ... &#96;&#96;order&#96; &#96;by&#96; &#96;name&#96; &#96;limit 500,100;</span><br></pre></td></tr></table></figure><ul><li>将单列索引(name)升级为联合索引(name, sex)，也可以避免回表。</li></ul><h2 id="4-索引下推"><a href="#4-索引下推" class="headerlink" title="4. 索引下推"></a>4. 索引下推</h2><ul><li><p><strong>索引下推</strong>（index condition pushdown ）简称ICP，在<strong>Mysql5.6</strong>的版本上推出，用于优化查询。</p></li><li><p><strong>在不使用ICP</strong>的情况下，在使用<strong>非主键索引（又叫普通索引或者二级索引）</strong>进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。</p></li><li><p><strong>在使用ICP的情况</strong>下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。</p></li></ul><p><strong>小结：</strong> </p><ul><li><strong>索引条件下推优化可以减少存储引擎查询基础表的次数（回表次数），也可以减少MySQL服务器从存储引擎接收数据的次数</strong>。</li></ul><h3 id="4-1-举个例子"><a href="#4-1-举个例子" class="headerlink" title="4.1 举个例子"></a>4.1 举个例子</h3><ul><li>在开始之前先先准备一张用户表(user)，其中主要几个字段有：<code>id、name、age、address</code>。建立<strong>联合索引（name，age）</strong>。</li><li>假设有一个需求，要求匹配姓名第一个为陈的所有用户，sql语句如下：</li></ul><p><code>SELECT * from user where  name like &#39;陈%&#39;</code></p><ul><li>根据 “最佳左前缀” 的原则，这里使用了联合索引（name，age）进行了查询，性能要比全表扫描肯定要高。</li><li><strong>问题来了，如果有其他的条件呢？假设又有一个需求，要求匹配姓名第一个字为陈，年龄为20岁的用户</strong>，此时的sql语句如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from user where  name like &#39;陈%&#39; and age&#x3D;20</span><br></pre></td></tr></table></figure><p>这条sql语句应该如何执行呢？下面对Mysql5.6之前版本和之后版本进行分析。</p><h3 id="4-2-Mysql5-6之前的版本"><a href="#4-2-Mysql5-6之前的版本" class="headerlink" title="4. 2 Mysql5.6之前的版本"></a>4. 2 Mysql5.6之前的版本</h3><ul><li>5.6之前的版本是没有索引下推这个优化的，因此执行的过程如下图：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200922/214616079.png" alt="mark"></p><ul><li>会忽略age这个字段，直接通过name进行查询，在(name,age)这课树上查找到了两个结果，id分别为2,1，然后拿着取到的id值一次次的回表查询，因此这个过程需要<strong>回表两次</strong>。</li></ul><h3 id="4-3-Mysql5-6及之后版本"><a href="#4-3-Mysql5-6及之后版本" class="headerlink" title="4.3 Mysql5.6及之后版本"></a>4.3 Mysql5.6及之后版本</h3><ul><li>5.6版本添加了索引下推这个优化，执行的过程如下图：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200922/214701758.png" alt="mark"></p><ul><li>InnoDB并没有忽略age这个字段，而是在索引内部就判断了age是否等于20，对于不等于20的记录直接跳过，因此在(name,age)这棵索引树中只匹配到了一个记录，此时拿着这个id去主键索引树中回表查询全部数据，这个过程只需要<strong>回表一次</strong>。</li></ul><ul><li>当然上述的分析只是原理上的，我们可以实战分析一下，因此陈某装了Mysql5.6版本的Mysql，解析了上述的语句，如下图：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200922/214754104.png" alt="mark"></p><ul><li>根据explain解析结果可以看出Extra的值为<strong>Using index condition</strong>，表示已经使用了索引下推。</li></ul><h3 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4 总结"></a>4.4 总结</h3><ul><li>索引下推在<strong>非主键索引</strong>上的优化，可以有效减少回表的次数，大大提升了查询的效率。</li><li>关闭索引下推可以使用如下命令，配置文件的修改不再讲述了，毕竟这么优秀的功能干嘛关闭呢：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　set optimizer_switch&#x3D;&#39;index_condition_pushdown&#x3D;off&#39;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mysql-16-索引覆盖和索引下推&quot;&gt;&lt;a href=&quot;#Mysql-16-索引覆盖和索引下推&quot; class=&quot;headerlink&quot; title=&quot;Mysql-16-索引覆盖和索引下推&quot;&gt;&lt;/a&gt;Mysql-16-索引覆盖和索引下推&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;数据表结构如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;create table user (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    id int primary key,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name varchar(20),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sex varchar(5),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    index(name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)engine&amp;#x3D;innodb;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 接下来两个查询是截然不同的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select id,name where name&amp;#x3D;&amp;#39;shenjian&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select id,name,sex where name&amp;#x3D;&amp;#39;shenjian&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;多查询了一个属性，为何检索过程完全不同？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　1. 　&lt;strong&gt;什么是回表查询？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　2. 　&lt;strong&gt;什么是索引覆盖？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　3. 　&lt;strong&gt;如何实现索引覆盖？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;哪些场景，可以利用索引覆盖来优化SQL？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PS： &lt;em&gt;本文试验基于MySQL5.6-InnoDB。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis-17-动态字符串SDS</title>
    <link href="http://zhuuu.work/2020/09/07/Redis/Redis-17-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS/"/>
    <id>http://zhuuu.work/2020/09/07/Redis/Redis-17-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS/</id>
    <published>2020-09-07T10:32:24.000Z</published>
    <updated>2020-09-21T11:26:16.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-17-动态字符串SDS"><a href="#Redis-17-动态字符串SDS" class="headerlink" title="Redis-17-动态字符串SDS"></a>Redis-17-动态字符串SDS</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>面试场景</strong></p><p>面试官：Redis有哪些数据类型？</p><p>我：String，List，set，zset，hash</p><p>面试官：没了？</p><p><strong>我：哦哦哦，还有HyperLogLog，bitMap，GeoHash，BloomFilter</strong></p><p>面试官：就这？回家等通知吧。(GG)</p><ul><li><p>但是，一场面试少说都是半小时起步上不封顶，你这样一句话就回答了这么重要的五个知识点，这个结果是你想要的么？是面试官想要的么？</p></li><li><p>String在Redis底层是怎么存储的？这些数据类型在Redis中是怎么存放的？Redis快的原因就只有单线程和基于内存么？</p></li></ul><a id="more"></a><h2 id="1-SDS"><a href="#1-SDS" class="headerlink" title="1. SDS"></a>1. SDS</h2><ul><li>Redis是C语言开发的，C语言自己就有字符类型，但是Redis却没直接采用C语言的字符串类型，而是自己构建了<code>动态字符串（SDS）</code>的抽象类型。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/165529250.png" alt="mark"></p><ul><li><p>就好比这样的一个命令，其实我是在Redis创建了两个SDS，一个是名为<code>aobing</code>的Key SDS，另一个是名为<code>cool</code>的Value SDS，就算是字符类型的List，也是由很多的SDS构成的Key和Value罢了。</p></li><li><p>SDS在Redis中除了用作字符串，还用作缓冲区（buffer），那到这里大家都还是有点疑惑的，C语言的字符串不好么为啥用SDS？SDS长啥样？有什么优点呢?</p></li></ul><p><strong>去找到了Redis的源码，可以看到SDS值的结果大概是这样的，源码的在GitHub上是开源的大家一搜就有了。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line"> <span class="keyword">int</span> len;</span><br><span class="line"> <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"> <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/165739509.png" alt="mark"></p><ul><li>回到最初的问题，为什么Redis用了自己新开发的SDS，而不用C语言的字符串？那好我们去看看他们的区别。</li></ul><h3 id="1-1-SDS-和-C字符串的区别"><a href="#1-1-SDS-和-C字符串的区别" class="headerlink" title="1.1 SDS 和 C字符串的区别"></a>1.1 SDS 和 C字符串的区别</h3><ol><li><strong>计数方式不同</strong></li></ol><ul><li>C语言对字符串长度的统计，就完全来自遍历，从头遍历到末尾，直到发现空字符就停止，以此统计出字符串的长度，这样获取长度的时间复杂度来说是0（n），大概就像下面这样</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/170018810.gif" alt="mark"></p><ul><li><p>但是这样的计数方式会留下隐患，所以Redis没有采用C的字符串，我后面会提到。</p></li><li><p>而Redis我在上面已经给大家看过结构了，他自己本身就保存了长度的信息，所以我们获取长度的时间复杂度为0（1），是不是发现了Redis快的一点小细节了？还没完，不止这些。</p></li></ul><ol start="2"><li><strong>杜绝缓冲区溢出</strong></li></ol><ul><li>字符串拼接是我们经常做的操作，在C和Redis中一样，也是很常见的操作，但是问题就来了，C是不记录字符串长度的，一旦我们调用了拼接的函数，如果没有提前计算好内存，是会产生缓存区溢出的。</li></ul><p>比如本来字符串长这样：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/170206424.png" alt="mark"></p><p>你现在需要在后面拼接 ，但是你没计算好内存，结果就可能这样了：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/170225389.png" alt="mark"></p><ul><li>这是你要的结果么？很显然，不是，你的结果意外的被修改了，这要是放在线上的系统，这不是完了？那Redis是怎么避免这样的情况的？</li><li>我们都知道，<strong>他结构存储了当前长度，还有free未使用的长度</strong>，那简单呀，你现在做了拼接操作，我去判断一些是否可以放得下，如果长度够就直接执行，如果不够，那我就进行扩容。</li><li>这些大家在Redis源码里面都是可以看到对应的API的，后面我就不一一贴源码了，有兴趣的可以自己去看一波，需要一点C语言的基础。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/170510217.png" alt="mark"></p><ol start="3"><li><strong>减少修改字符串时带来的内存重分配次数</strong></li></ol><ul><li>C语言字符串底层也是一个数组，每次创建的时候就创建一个N+1长度的字符，多的那个1，就是为了保存空字符的，这个空字符也是个坑，但是不是这个环节探讨的内容。</li><li>Redis是个高速缓存数据库，如果我们需要对字符串进行频繁的拼接和截断操作，如果我们写代码忘记了重新分配内存，就可能造成缓冲区溢出，以及内存泄露。</li><li>内存分配算法很耗时，且不说你会不会忘记重新分配内存，就算你全部记得，对于一个高速缓存数据库来说，这样的开销也是我们应该要避免的。</li></ul><p><strong>Redis为了避免C字符串这样的缺陷，就分别采用了两种解决方案，去达到性能最大化，空间利用最大化：</strong></p><ul><li>空间预分配：当我们对SDS进行扩展操作的时候，Redis会为SDS分配好内存，并且根据特定的公式，分配多余的free空间，还有多余的1byte空间（这1byte也是为了存空字符），这样就可以避免我们连续执行字符串添加所带来的内存分配消耗。</li></ul><p>比如现在有这样的一个字符：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/170956217.png" alt="mark"></p><p>我们调用了拼接函数，字符串变长了，Redis还会根据算法计算出一个free值给他备用：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/171058868.png" alt="mark"></p><p>我们再继续拼接，你会发现，备用的free用上了，省去了这次的内存重分配：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/171131120.png" alt="mark"></p><ul><li><strong>惰性空间释放</strong>：刚才提到了会预分配多余的空间，很多小伙伴会担心带来内存的泄露或者浪费，别担心，Redis大佬一样帮我们想到了，当我们执行完一个字符串缩减的操作，redis并不会马上收回我们的空间，因为可以预防你继续添加的操作，这样可以减少分配空间带来的消耗，但是当你再次操作还是没用到多余空间的时候，Redis也还是会收回对于的空间，防止内存的浪费的。</li></ul><p>还是一样的字符串：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/171207003.png" alt="mark"></p><p>当我们调用了删减的函数，并不会马上释放掉free空间：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/171227873.png" alt="mark"></p><p>如果我们需要继续添加这个空间就能用上了，减少了内存的重分配，如果空间不需要了，调用函数删掉就好了：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/171246466.png" alt="mark"></p><ol start="4"><li><strong>二进制安全</strong></li></ol><ul><li>仔细看的仔肯定看到上面我不止一次提到了空字符也就是’\0‘，C语言是判断空字符去判断一个字符的长度的，但是有很多数据结构经常会穿插空字符在中间，比如图片，音频，视频，压缩文件的二进制数据，就比如下面这个单词，他只能识别前面的 不能识别后面的字符，那对于我们开发者而言，这样的结果显然不是我们想要的对不对。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/171334719.png" alt="mark"></p><ul><li>Redis就不存在这个问题了，他不是保存了字符串的长度嘛，他不判断空字符，他就判断长度对不对就好了，所以redis也经常被我们拿来保存各种二进制数据，我反正是用的很high，经常用来保存小文件的二进制。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200917/171356886.png" alt="mark"></p><p><strong>总结</strong></p><ul><li>大家是不是发现，一个小小的SDS居然有这么多道理在这？</li><li>以前就知道Redis快，最多说个Redis是单线程的，说个多路IO复用，说个基于内存的操作就完了，现在是不是还可以展开说说了？</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis-17-动态字符串SDS&quot;&gt;&lt;a href=&quot;#Redis-17-动态字符串SDS&quot; class=&quot;headerlink&quot; title=&quot;Redis-17-动态字符串SDS&quot;&gt;&lt;/a&gt;Redis-17-动态字符串SDS&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;面试场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;面试官：Redis有哪些数据类型？&lt;/p&gt;
&lt;p&gt;我：String，List，set，zset，hash&lt;/p&gt;
&lt;p&gt;面试官：没了？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我：哦哦哦，还有HyperLogLog，bitMap，GeoHash，BloomFilter&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;面试官：就这？回家等通知吧。(GG)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;但是，一场面试少说都是半小时起步上不封顶，你这样一句话就回答了这么重要的五个知识点，这个结果是你想要的么？是面试官想要的么？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;String在Redis底层是怎么存储的？这些数据类型在Redis中是怎么存放的？Redis快的原因就只有单线程和基于内存么？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="http://zhuuu.work/tags/Redis/"/>
    
      <category term="SDS" scheme="http://zhuuu.work/tags/SDS/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-异常</title>
    <link href="http://zhuuu.work/2020/09/07/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E5%BC%82%E5%B8%B8/"/>
    <id>http://zhuuu.work/2020/09/07/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E5%BC%82%E5%B8%B8/</id>
    <published>2020-09-07T09:34:38.000Z</published>
    <updated>2020-09-07T12:11:38.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-异常"><a href="#Java-基础-异常" class="headerlink" title="Java-基础-异常"></a>Java-基础-异常</h1><h2 id="1-什么是异常？"><a href="#1-什么是异常？" class="headerlink" title="1. 什么是异常？"></a>1. 什么是异常？</h2><ul><li><p>事实上，异常本质上是程序上的错误，包括程序逻辑错误和系统错误。比如使用<strong>空的引用</strong>、<strong>数组下标越界</strong>、<strong>内存溢出错误</strong>等，这些都是意外的情况，背离我们程序本身的意图。错误在我们编写程序的过程中会经常发生，包括编译期间和运行期间的错误，在编译期间出现的错误有编译器帮助我们一起修正，然而运行期间的错误便不是编译器力所能及了，并且运行期间的错误往往是难以预料的。</p></li><li><p><strong>假若程序在运行期间出现了错误，如果置之不理，程序便会终止或直接导致系统崩溃，显然这不是我们希望看到的结果</strong>。因此，如何对运行期间出现的错误进行处理和补救呢？Java提供了异常机制来进行处理，<strong>通过异常机制来处理程序运行期间出现的错误</strong>。通过异常机制，我们可以更好地提升程序的健壮性。</p></li><li><p>在java等面向对象的编程语言中，异常本身就是一个类，产生异常就是创建异常对象并抛出一个异常对象。java中的处理就是中断处理。</p></li></ul><p>　<strong>在Java中，异常类的结构层次图如下图所示：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200903/145710336.png" alt="mark"></p><a id="more"></a><p><strong>异常的分类：</strong></p><ul><li><p>在Java中异常被当做对象来处理，根类是<code>java.lang.Throwable</code>类，在Java中定义了很多异常类（如<code>OutOfMemoryError、NullPointerException</code>、<code>IndexOutOfBoundsException</code>等），这些异常类分为两大类：<code>Error</code>和<code>Exception</code>。</p></li><li><p><code>Exception</code>类的异常包括<code>checked exception</code>和<code>unchecked exception</code>（<code>unchecked exception</code>也称运行时异常<code>RuntimeException</code>，当然这里的运行时异常并不是前面我所说的运行期间的异常，只是Java中用运行时异常这个术语来表示，Exception类的异常都是在运行期间发生的）。</p><ul><li><code>unchecked exception</code>（非检查异常），也称运行时异常<code>（RuntimeException）</code>，比如常见的<code>NullPointerException</code>、<code>IndexOutOfBoundsException</code>。对于运行时异常，java编译器不要求必须进行异常捕获处理或者抛出声明，由程序员自行决定。</li><li><code>checked exception</code>（检查异常），也称非运行时异常（运行时异常以外的异常就是非运行时异常），<code>java</code>编译器强制程序员必须进行捕获处理，比如常见的<code>IOExeption</code>和<code>SQLException</code>。对于非运行时异常如果不进行捕获或者抛出声明处理，编译都不会通过</li></ul></li><li><p>在Java中，所有异常类的父类是<code>Throwable</code>类，</p><ul><li>Error类是error类型异常的父类，</li><li>Exception类是exception类型异常的父类，<ul><li>RuntimeException类是所有运行时异常的父类</li><li>RuntimeException以外的并且继承Exception的类是非运行时异常。</li><li>典型的<code>RuntimeException</code>包括<code>NullPointerException</code>、<code>IndexOutOfBoundsException</code>、<code>IllegalArgumentException</code> <code>InterrupterException</code>等。</li><li>典型的非<code>RuntimeException</code>包括<code>IOException</code>、<code>SQLException</code>等。</li></ul></li></ul></li></ul><h2 id="2-Java中如何处理异常？"><a href="#2-Java中如何处理异常？" class="headerlink" title="2. Java中如何处理异常？"></a>2. Java中如何处理异常？</h2><ul><li>在Java中如果需要处理异常，必须先对异常进行捕获，然后再对异常情况进行处理。如何对可能发生异常的代码进行异常捕获和处理呢？使用try和catch关键字即可，如下面一段代码所示：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  File file = <span class="keyword">new</span> File(<span class="string">"d:/a.txt"</span>);</span><br><span class="line">  <span class="keyword">if</span>(!file.exists())</span><br><span class="line">    file.createNewFile();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(被try块包围的代码说明这段代码可能会发生异常，一旦发生异常，异常便会被catch捕获到，然后需要在catch块中进行异常处理。)</p><ul><li>在Java中还提供了另一种异常处理方式即抛出异常，顾名思义，也就是说一旦发生异常，我把这个异常抛出去，让调用者去进行处理，自己不进行具体的处理，此时需要用到throw和throws关键字。　</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            createFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"d:/a.txt"</span>);</span><br><span class="line">        <span class="keyword">if</span>(!file.exists())</span><br><span class="line">            file.createNewFile();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>两者区别：</strong></p><ul><li>这段代码和上面一段代码的区别是，在实际的createFile方法中并没有捕获异常，而是用throws关键字声明抛出异常，</li><li>即告知这个方法的调用者此方法可能会抛出<code>IOException</code>。那么在main方法中调用<code>createFile</code>方法的时候，采用try…catch块进行了异常捕获处理。</li></ul><ul><li>当然还可以采用throw关键字手动来抛出异常对象。下面看一个例子：然后在catch块中进行捕获。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">            System.out.println(getDataByIndex(-<span class="number">1</span>,data));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDataByIndex</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span>||index&gt;=data.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"数组下标越界"</span>);</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>也就说在Java中进行异常处理的话，对于可能会发生异常的代码，可以选择三种方法来进行异常处理：<ul><li>对代码块用<code>try..catch</code>进行异常捕获处理；</li><li>在 该代码的方法体外用<strong>throws进行抛出声明</strong>，告知此方法的调用者这段代码可能会出现这些异常，你需要谨慎处理。<ul><li>如果声明抛出的异常是非运行时异常，此方法的调用者必须显示地用try..catch块进行捕获或者继续向上层抛出异常。</li><li>如果声明抛出的异常是运行时异常，此方法的调用者可以选择地进行异常捕获处理。</li></ul></li><li>在代码块用throw手动抛出一个异常对象，此时也有两种情况，<strong>跟throw中的类似</strong>：<ul><li>如果抛出的异常对象是非运行时异常，此方法的调用者必须显示地用try..catch块进行捕获或者继续向上层抛出异常。</li><li>如果抛出的异常对象是运行时异常，此方法的调用者可以选择地进行异常捕获处理。</li></ul></li></ul></li></ul><ul><li>如果最终将异常抛给<code>main</code>方法，则相当于交给<code>jvm</code>自动处理，此时<code>jvm</code>会简单地打印异常信息）<strong>同时是中断处理</strong></li></ul><p><strong>未完待续：</strong></p><p><strong>参考博客 ：</strong> <a href="https://www.cnblogs.com/dolphin0520/p/3769804.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3769804.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-异常&quot;&gt;&lt;a href=&quot;#Java-基础-异常&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-异常&quot;&gt;&lt;/a&gt;Java-基础-异常&lt;/h1&gt;&lt;h2 id=&quot;1-什么是异常？&quot;&gt;&lt;a href=&quot;#1-什么是异常？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是异常？&quot;&gt;&lt;/a&gt;1. 什么是异常？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;事实上，异常本质上是程序上的错误，包括程序逻辑错误和系统错误。比如使用&lt;strong&gt;空的引用&lt;/strong&gt;、&lt;strong&gt;数组下标越界&lt;/strong&gt;、&lt;strong&gt;内存溢出错误&lt;/strong&gt;等，这些都是意外的情况，背离我们程序本身的意图。错误在我们编写程序的过程中会经常发生，包括编译期间和运行期间的错误，在编译期间出现的错误有编译器帮助我们一起修正，然而运行期间的错误便不是编译器力所能及了，并且运行期间的错误往往是难以预料的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;假若程序在运行期间出现了错误，如果置之不理，程序便会终止或直接导致系统崩溃，显然这不是我们希望看到的结果&lt;/strong&gt;。因此，如何对运行期间出现的错误进行处理和补救呢？Java提供了异常机制来进行处理，&lt;strong&gt;通过异常机制来处理程序运行期间出现的错误&lt;/strong&gt;。通过异常机制，我们可以更好地提升程序的健壮性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在java等面向对象的编程语言中，异常本身就是一个类，产生异常就是创建异常对象并抛出一个异常对象。java中的处理就是中断处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　&lt;strong&gt;在Java中，异常类的结构层次图如下图所示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200903/145710336.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="异常总结" scheme="http://zhuuu.work/tags/%E5%BC%82%E5%B8%B8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-15-Mysql死锁</title>
    <link href="http://zhuuu.work/2020/09/07/Mysql/Mysql-15-Mysql%E6%AD%BB%E9%94%81/"/>
    <id>http://zhuuu.work/2020/09/07/Mysql/Mysql-15-Mysql%E6%AD%BB%E9%94%81/</id>
    <published>2020-09-07T08:02:27.000Z</published>
    <updated>2020-09-18T11:06:15.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-15-Mysql死锁"><a href="#Mysql-15-Mysql死锁" class="headerlink" title="Mysql-15-Mysql死锁"></a>Mysql-15-Mysql死锁</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>在数据库中有两种基本的锁类型：排它锁（Exclusive Locks，即X锁）和共享锁（Share Locks，即S锁）。当数据对象被加上排它锁时，其他的事务不能对它读取和修改。加了共享锁的数据对象可以被其他事务读取，但不能修改。数据库利用这两种基本的锁类型来对数据库的事务进行并发控制。</p></li><li><p><code>InnoDB</code>引擎提供了行级锁，表锁。<code>MyISAM</code>提供了表锁，如题，MySQL会发生死锁吗？</p></li></ul><a id="more"></a><h2 id="1-案例一"><a href="#1-案例一" class="headerlink" title="1. 案例一"></a>1. 案例一</h2><ul><li>在InnoDB引擎下，<code>RR(REPEATABLE-READ)</code>级别，如果多个事务争抢同一个资源，会发生死锁。在RR级别下，MySQL提供了next-key lock。假如一个索引的行有<code>10,11,13,20</code></li><li>那么可能的<code>next-key lock</code>的包括</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(无穷小, 10]</span><br><span class="line">(10,11]</span><br><span class="line">(11,13]</span><br><span class="line">(13,20]</span><br><span class="line">(20, 无穷大)</span><br></pre></td></tr></table></figure><ul><li>即：当你查询12时，如果数据未查到，那么将对(12,13]范围内的数据进行锁定。<code>next-key lock</code>的定义可以到官方具体查看，这里做个演示。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/174336612.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;查看隔离级别，</span><br><span class="line">show variables like &#39;%tx_isolation%&#39;;</span><br><span class="line">&#x2F;&#x2F; 设置隔离界别</span><br><span class="line">SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE&#125;</span><br><span class="line">&#x2F;&#x2F; 不设置自动提交</span><br><span class="line">SET autocommit &#x3D; 0;</span><br></pre></td></tr></table></figure><p><strong>演示</strong></p><ol><li>首先将隔离级别都设置为RR级别的，并且不让事务自动提交</li><li>根据上面的数据，在事务1中查询</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 得到空结果集，此时锁定的范围是(33,100]</span><br><span class="line">select * FROM user where id&#x3D;33 for update;</span><br></pre></td></tr></table></figure><ol start="3"><li>在事务2中也进行查询</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查询到空的结果，在事务2中锁定的范围是(34,100]</span><br><span class="line">select * FROM user where id&#x3D;34 for update</span><br></pre></td></tr></table></figure><ol start="4"><li>在事务1中插入数据</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 虽然事务1锁定了范围，事务2也锁定了范围</span><br><span class="line">insert into user values(35,&#39;ac&#39;,10);</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/174511421.png" alt="mark"></p><ol start="5"><li>在事务2中也插入数据</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into user values(34,&#39;ac&#39;,10)</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/174533500.png" alt="mark"></p><p><strong>解决方案</strong></p><ol><li><strong>设置死锁的超时时长</strong></li></ol><p><code>innodb_lock_wait_timeout=500</code></p><ol start="2"><li><strong>查询到当前正在锁定的事务线程，将其杀死</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 可以看到正在运行的事务线程，还有运行状态</span><br><span class="line">SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;trx_mysql_thread_id为上一条命令获取的结果，将具体的数字替换一下即可。</span><br><span class="line">kill trx_mysql_thread_id</span><br></pre></td></tr></table></figure><h2 id="2-案例二"><a href="#2-案例二" class="headerlink" title="2. 案例二"></a>2. 案例二</h2><ul><li><strong>索引不当导致全表扫描</strong></li></ul><ol><li>如果在事务中执行了一条不满足条件的语句，执行全表扫描，把行级锁上升为表级锁，多个这样的事务执行后，就很容易产生死锁和阻塞。</li><li>类似的情况还有当表中的数据量非常庞大而索引建的过少或不合适的时候，使得经常发生全表扫描，最终应用系统会越来越慢，最终发生阻塞或死锁。</li></ol><p><strong>解决方案</strong></p><ul><li>SQL语句中不要使用太复杂的关联多表的查询；</li><li>使用“执行计划”对SQL语句进行分析，对于有全表扫描的SQL语句，建立相应的索引进行优化。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mysql-15-Mysql死锁&quot;&gt;&lt;a href=&quot;#Mysql-15-Mysql死锁&quot; class=&quot;headerlink&quot; title=&quot;Mysql-15-Mysql死锁&quot;&gt;&lt;/a&gt;Mysql-15-Mysql死锁&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在数据库中有两种基本的锁类型：排它锁（Exclusive Locks，即X锁）和共享锁（Share Locks，即S锁）。当数据对象被加上排它锁时，其他的事务不能对它读取和修改。加了共享锁的数据对象可以被其他事务读取，但不能修改。数据库利用这两种基本的锁类型来对数据库的事务进行并发控制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;InnoDB&lt;/code&gt;引擎提供了行级锁，表锁。&lt;code&gt;MyISAM&lt;/code&gt;提供了表锁，如题，MySQL会发生死锁吗？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis-13-跳表</title>
    <link href="http://zhuuu.work/2020/09/06/Redis/Redis-13-%E8%B7%B3%E8%A1%A8/"/>
    <id>http://zhuuu.work/2020/09/06/Redis/Redis-13-%E8%B7%B3%E8%A1%A8/</id>
    <published>2020-09-06T10:32:24.000Z</published>
    <updated>2020-09-10T09:23:53.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-13-跳表"><a href="#Redis-13-跳表" class="headerlink" title="Redis-13-跳表"></a>Redis-13-跳表</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>首先为什么要把mysql索引和redis跳表放在一起讨论呢，因为他们解决的都是同一种问题，用于<strong>解决数据集合的查找问题，即根据指定的key，快速查到它所在的位置（或者对应的value）</strong></li></ul><a id="more"></a><p>现在我们将问题领域边界划分清楚了，就是为了解决数据集合的查找问题。这一块需要考虑哪些问题呢</p><ol><li>需要支持哪些查找方式，单key/多key/范围查找，</li><li>插入/删除效率</li><li>查找效率（即时间复杂度）</li><li>存储大小（空间复杂度）</li></ol><ul><li>我们看下<strong>几种常用的查找结构</strong></li></ul><ol><li><strong>Hash : hash是key,value形式，通过一个散列函数，能够根据key快速找到value</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200807-154119174.png" alt="mark"></p><ol start="2"><li><strong>B+树</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200807-154302337.png" alt="mark"></p><ul><li>B+树首先是有序结构，为了不至于树的高度太高，影响查找效率，在叶子节点上存储的不是单个数据，而是一页数据，提高了查找效率，而为了更好的支持范围查询，B+树在叶子节点冗余了非叶子节点数据，为了支持翻页，叶子节点之间通过指针连接。</li></ul><p><strong>跳表</strong></p><ul><li><strong>跳表是在链表的基础上进行扩展的，为的是实现redis的sorted set数据结构。（Zset）</strong></li><li>level0: 是存储原始数据的，是一个有序链表，每个节点都在链上</li><li>每个节点都在链上 level0+: 通过指针串联起节点，是原始数据的一个子集，level等级越高，串联的数据越少，这样可以显著提高查找效率，</li></ul><p><strong>总结：</strong></p><table><thead><tr><th>数据结构</th><th>实现原理</th><th>key查询方式</th><th>查找效率</th><th>存储大小</th><th>插入、删除效率</th></tr></thead><tbody><tr><td>Hash</td><td>哈希表</td><td>支持单key</td><td>接近O(1)</td><td>小，除了数据没有额外的存储</td><td>O(1)</td></tr><tr><td>B+树</td><td>平衡二叉树扩展而来</td><td>单key,范围，分页</td><td>O(Log(n)</td><td>除了数据，还多了左右指针，以及叶子节点指针</td><td>O(Log(n)，需要调整树的结构，算法比较复杂</td></tr><tr><td>跳表</td><td>有序链表扩展而来</td><td>单key，分页</td><td>O(Log(n)</td><td>除了数据，还多了指针，但是每个节点的指针小于&lt;2,所以比B+树占用空间小</td><td>O(Log(n)，只用处理链表，算法比较简单</td></tr></tbody></table><h2 id="1-Zset-原理分析"><a href="#1-Zset-原理分析" class="headerlink" title="1. Zset 原理分析"></a>1. Zset 原理分析</h2><h3 id="1-1-Zset编码的选择"><a href="#1-1-Zset编码的选择" class="headerlink" title="1.1 Zset编码的选择"></a>1.1 Zset编码的选择</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/165054478.png" alt="mark"></p><p><strong>1.有序集合对象的编码可以是<code>ziplist</code>或者<code>skiplist</code>。同时满足以下条件时使用ziplist编码：</strong></p><ul><li><p>元素数量小于128个</p></li><li><p>所有member的长度都小于64字节</p></li><li><p>其他：</p></li><li><ul><li>不能满足上面两个条件的使用 skiplist 编码。以上两个条件也可以通过Redis配置文件zset-max-ziplist-entries 选项和 zset-max-ziplist-value 进行修改</li><li>对于一个 <code>REDIS_ENCODING_ZIPLIST</code> 编码的 Zset， 只要满足以上任一条件， 则会被转换为 <code>REDIS_ENCODING_SKIPLIST</code> 编码</li></ul></li></ul><p><strong>2.zset操作命令</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">zadd(key, score, member)：向名称为key的zset中添加元素member，score用于排序。如果该元素已经存在，则根据score更新该元素的顺序。</span><br><span class="line">zrem(key, member) ：删除名称为key的zset中的元素member</span><br><span class="line">zincrby(key, increment, member) ：如果在名称为key的zset中已经存在元素member，则该元素的score增加increment；否则向集合中添加该元素，其score的值为increment</span><br><span class="line">zrank(key, member) ：返回名称为key的zset（元素已按score从小到大排序）中member元素的rank（即index，从0开始），若没有member元素，返回“nil”</span><br><span class="line">zrevrank(key, member) ：返回名称为key的zset（元素已按score从大到小排序）中member元素的rank（即index，从0开始），若没有member元素，返回“nil”</span><br><span class="line">zrange(key, start, end)：返回名称为key的zset（元素已按score从小到大排序）中的index从start到end的所有元素</span><br><span class="line">zrevrange(key, start, end)：返回名称为key的zset（元素已按score从大到小排序）中的index从start到end的所有元素</span><br><span class="line">zrangebyscore(key, min, max)：返回名称为key的zset中score &gt;= min且score &lt;= max的所有元素 zcard(key)：返回名称为key的zset的基数</span><br><span class="line">zscore(key, element)：返回名称为key的zset中元素element的score zremrangebyrank(key, min, max)：删除名称为key的zset中rank &gt;= min且rank &lt;= max的所有元素 zremrangebyscore(key, min, max) ：删除名称为key的zset中score &gt;= min且score &lt;= max的所有元素</span><br></pre></td></tr></table></figure><h2 id="2-ziplist"><a href="#2-ziplist" class="headerlink" title="2. ziplist"></a>2. ziplist</h2><ul><li>ziplist 编码的 Zset 使用紧挨在一起的压缩列表节点来保存，第一个节点保存 member，第二个保存 score。</li><li>ziplist 内的集合元素按 score 从小到大排序，其实质是一个双向链表。虽然元素是按 <code>score</code> 有序排序的， 但对 <code>ziplist</code> 的节点指针只能线性地移动，所以在 <code>REDIS_ENCODING_ZIPLIST</code> 编码的 Zset 中， 查找某个给定元素的复杂度为 O(n)</li></ul><p><strong>如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;操作</span><br><span class="line">ZADD price 8.5 apple 5.0 banana 6.0 cherry</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;存储顺序</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/165634662.png" alt="mark"></p><p><strong>3. 从以上的布局中，我们可以看到ziplist内存数据结构，由如下5部分构成：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/165706567.png" alt="mark"></p><p>各个部分在内存上是前后相邻的并连续的，每一部分作用如下：</p><ul><li><p>zlbytes： 存储一个无符号整数，固定四个字节长度（32bit），用于存储压缩列表所占用的字节（也包括<zlbytes>本身占用的4个字节），当重新分配内存的时候使用，不需要遍历整个列表来计算内存大小。</p></li><li><p>zltail： 存储一个无符号整数，固定四个字节长度（32bit），表示ziplist表中最后一项（entry）在ziplist中的偏移字节数。<zltail>的存在，使得我们可以很方便地找到最后一项（不用遍历整个ziplist），从而可以在ziplist尾端快速地执行push或pop操作。</p></li><li><p>zllen： 压缩列表包含的节点个数，固定两个字节长度（16bit）， 表示ziplist中数据项（entry）的个数。由于zllen字段只有16bit，所以可以表达的最大值为2^16-1。</p><p>注意点：如果ziplist中数据项个数超过了16bit能表达的最大值，ziplist仍然可以表示。ziplist是如何做到的？</p><p>如果<zllen>小于等于2^16-2（也就是不等于2^16-1），那么<zllen>就表示ziplist中数据项的个数；否则，也就是<zllen>等于16bit全为1的情况，那么<zllen>就不表示数据项个数了，这时候要想知道ziplist中数据项总数，那么必须对ziplist从头到尾遍历各个数据项，才能计数出来。</p></li><li><p>entry，表示真正存放数据的数据项，长度不定。一个数据项（entry）也有它自己的内部结构。</p></li><li><p>zlend， ziplist最后1个字节，值固定等于255，其是一个结束标记。</p></li></ul><h2 id="3-skiplist"><a href="#3-skiplist" class="headerlink" title="3. skiplist"></a>3. skiplist</h2><ul><li><p>skiplist 编码的 Zset 底层为一个被称为 zset 的结构体，这个结构体中包含一个字典和一个跳跃表。跳跃表按 score 从小到大保存所有集合元素，查找时间复杂度为平均 </p><p>O(logN)，最坏 O(N)</p></li><li><p><em>字典则保存着从 member 到 score 的映射，这样就可以用 O(1)的复杂度来查找 member 对应的 score 值。虽然同时使用两种结构，但它们会通过指针来共享相同元素的 member 和 score，因此不会浪费额外的内存。</em></p></li></ul><p><strong>详细解析</strong></p><ul><li>跳表(skip List)是一种随机化的数据结构，基于并联的链表，实现简单，插入、删除、查找的复杂度均为O(logN)。</li><li>简单说来<strong>跳表也是链表</strong>的一种，只不过它在<strong>链表的基础上增加了跳跃功能</strong>，正是这个跳跃的功能，使得在查找元素时，跳表能够提供O(logN)的时间复杂度。</li></ul><p>先来看一个有序链表，如下图（最左侧的灰色节点表示一个空的头结点）：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/170230031.png" alt="mark"></p><p>在这样一个链表中，如果我们要<strong>查找某个数据，那么需要从头开始逐个进行比较**</strong>，直到找到包含数据的那个节点，或者找到第一个比给定数据大的节点为止（没找到）。也就是说，<strong>时间复杂度为O(n)。</strong>同样，当我们要插入新数据的时候，也要经历同样的查找过程，从而确定插入位置。</p><p>假如我们每相邻两个节点增加一个指针，让指针指向下下个节点，如下图：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/170358081.png" alt="mark"></p><ul><li>这样所有新增加的指针连成了一个新的链表，但它包含的节点个数只有原来的一半（上图中是7, 19, 26）。</li><li>现在当我们想查找数据的时候，可以先沿着这个新链表进行查找。</li><li>当碰到比待查数据大的节点时，再回到原来的链表中进行查找。比如，我们想查找23，查找的路径是沿着下图中标红的指针所指向的方向进行的：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/170518070.png" alt="mark"></p><ol><li>23首先和7比较，再和19比较，比它们都大，继续向后比较。</li><li>但23和26比较的时候，比26要小，因此回到下面的链表（原链表），与22比较。</li><li>23比22要大，沿下面的指针继续向后和26比较。23比26小，说明待查数据23在原链表中不存在，而且它的插入位置应该在22和26之间。</li></ol><p><strong>在这个查找过程中，由于新增加的指针，我们不再需要与链表中每个节点逐个进行比较了。需要比较的节点数大概只有原来的一半。</strong></p><p><strong>利用同样的方式，我们可以在上层新产生的链表上，继续为每相邻的两个节点增加一个指针，从而产生第三层链表。如下图：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/170624567.png" alt="mark"></p><ul><li>在这个新的三层链表结构上，如果我们还是查找23，那么沿着最上层链表首先要比较的是19，发现23比19大，</li><li>接下来我们就知道只需要到19的后面去继续查找，从而一下子跳过了19前面的所有节点。</li><li>可以想象，当链表足够长的时候，这种多层链表的查找方式能让我们跳过很多下层节点，大大加快查找的速度。</li></ul><h3 id="3-1-小结"><a href="#3-1-小结" class="headerlink" title="3.1 小结"></a>3.1 小结</h3><ul><li><code>skiplist</code>正是受这种多层链表的想法的启发而设计出来的。<strong>实际上，按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找</strong>，使得查找的时间复杂度可以降低到O(log n)。</li><li>但是，这种方法在插入数据的时候有很大的问题。新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的2:1的对应关系。</li><li>如果要维持这种对应关系，就必须把新插入的节点后面的所有节点（也包括新插入的节点）重新进行调整，这会让时间复杂度重新蜕化成O(n)。删除数据也有同样的问题。</li></ul><p><strong>skiplist为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数(level)。</strong>比如，一个节点随机出的层数是3，那么就把它链入到第1层到第3层这三层链表中。为了表达清楚，下图展示了如何通过一步步的插入操作从而形成一个skiplist的过程：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/171220254.png" alt="mark"></p><ul><li>从上面skiplist的创建和插入过程可以看出，每一个节点的层数（level）是随机出来的，而且新插入一个节点不会影响其它节点的层数。</li><li>因此，插入操作只需要修改插入节点前后的指针，而不需要对很多节点都进行调整。这就降低了插入操作的复杂度。</li><li><strong>实际上，这是skiplist的一个很重要的特性，这让它在插入性能上明显优于平衡树的方案</strong>。这在后面我们还会提到。</li></ul><p><strong>总结：</strong></p><ul><li><strong>skiplist，指的就是除了最下面第1层链表之外，它会产生若干层稀疏的链表，这些链表里面的指针故意跳过了一些节点（而且越高层的链表跳过的节点越多）。</strong></li><li><strong>这就使得我们在查找数据的时候能够先在高层的链表中进行查找，然后逐层降低，最终降到第1层链表来精确地确定数据位置。</strong></li></ul><h3 id="3-2-举个例子"><a href="#3-2-举个例子" class="headerlink" title="3.2 举个例子"></a>3.2 举个例子</h3><ul><li>刚刚创建的这个skiplist总共包含4层链表，现在假设我们在它里面依然查找23，下图给出了查找路径：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200910/171415212.png" alt="mark"></p><ul><li><p>需要注意的是，前面演示的各个节点的插入过程，实际上在插入之前也要先经历一个类似的查找过程，在确定插入位置后，再完成插入操作。</p></li><li><p>实际应用中的skiplist每个节点应该包含key和value两部分。前面的描述中我们没有具体区分key和value，但实际上列表中是按照key(score)进行排序的，查找过程也是根据key在比较。</p></li></ul><ul><li>执行<strong>插入操作时计算随机数</strong>的过程，是一个很关键的过程，它对skiplist的统计特性有着很重要的影响。这并不是一个普通的服从均匀分布的随机数，它的计算过程如下：<ul><li>首先，每个节点肯定都有第1层指针（每个节点都在第1层链表里）。</li><li>如果一个节点有第i层(i&gt;=1)指针（即节点已经在第1层到第i层链表中），那么它有第(i+1)层指针的概率为p。</li><li>节点最大的层数不允许超过一个最大值，记为MaxLevel。</li></ul></li><li>这个随机数伪码如下：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">randomLevel()</span><br><span class="line">level := 1</span><br><span class="line">// random()返回一个[0...1)的随机数</span><br><span class="line"><span class="keyword">while</span> random() &lt; p and level &lt; MaxLevel <span class="keyword">do</span></span><br><span class="line">level := level + 1</span><br><span class="line"><span class="built_in">return</span> leve</span><br><span class="line">    </span><br><span class="line"><span class="comment">## randomLevel()的伪码中包含两个参数，一个是p，一个是MaxLevel。在Redis的skiplist实现中，这两个参数的取值为：  </span></span><br><span class="line">p = 1/4</span><br><span class="line">MaxLevel = 32</span><br></pre></td></tr></table></figure><h2 id="4-skiplist与平衡树、哈希表的比较"><a href="#4-skiplist与平衡树、哈希表的比较" class="headerlink" title="4. skiplist与平衡树、哈希表的比较"></a>4. skiplist与平衡树、哈希表的比较</h2><ul><li><p>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</p></li><li><p>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</p></li><li><p>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</p></li><li><p>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</p></li><li><p>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</p></li><li><p>从算法实现难度上来比较，skiplist比平衡树要简单得多。</p></li></ul><h2 id="5-Redis中skiplist的实现"><a href="#5-Redis中skiplist的实现" class="headerlink" title="5. Redis中skiplist的实现"></a>5. Redis中skiplist的实现</h2><p>skiplist的数据结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_MAXLEVEL 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_P 0.25</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">robj *obj;</span><br><span class="line"><span class="keyword">double</span> score;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">&#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line"><span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><p> 简单分析一下几个查询命令:</p><ul><li>zrevrank由数据查询它对应的排名，这在前面介绍的skiplist中并不支持。</li><li>zscore由数据查询它对应的分数，这也不是skiplist所支持的。</li><li>zrevrange根据一个排名范围，查询排名在这个范围内的数据。这在前面介绍的skiplist中也不支持。</li><li>zrevrangebyscore根据分数区间查询数据集合，是一个skiplist所支持的典型的范围查找（score相当于key，数据相当于value）。</li></ul><p>实际上，Redis中sorted set的实现是这样的：</p><ul><li>当数据较少时，sorted set是由一个ziplist来实现的。</li><li>当数据多的时候，sorted set是由一个dict + 一个skiplist来实现的。简单来讲，dict用来查询数据到分数的对应关系，而skiplist用来根据分数查询数据（可能是范围查找）。</li></ul><p>看一下sorted set与skiplist的关系，：</p><ul><li>zscore的查询，不是由skiplist来提供的，而是由那个dict来提供的。</li><li>为了支持排名(rank)，Redis里对skiplist做了扩展，使得根据排名能够快速查到数据，或者根据分数查到数据之后，也同时很容易获得排名。而且，根据排名的查找，时间复杂度也为O(log n)。</li><li>zrevrange的查询，是根据排名查数据，由扩展后的skiplist来提供。</li><li>zrevrank是先在dict中由数据查到分数，再拿分数到skiplist中去查找，查到后也同时获得了排名。</li></ul><p><strong>总结起来，Redis中的skiplist跟前面介绍的经典的skiplist相比，有如下不同：</strong></p><ul><li>分数(score)允许重复，即skiplist的key允许重复。这在最开始介绍的经典skiplist中是不允许的。</li><li>在比较时，不仅比较分数（相当于skiplist的key），还比较数据本身。在Redis的skiplist实现中，数据本身的内容唯一标识这份数据，而不是由key来唯一标识。另外，当多个元素分数相同的时候，还需要根据数据内容来进字典排序。</li><li>第1层链表不是一个单向链表，而是一个双向链表。这是为了方便以倒序方式获取一个范围内的元素。</li><li>在skiplist中可以很方便地计算出每个元素的排名(rank)。</li></ul><h2 id="6-Redis为什么用skiplist而不用平衡树？"><a href="#6-Redis为什么用skiplist而不用平衡树？" class="headerlink" title="6. Redis为什么用skiplist而不用平衡树？"></a>6. Redis为什么用skiplist而不用平衡树？</h2><p><strong>这里从内存占用、对范围查找的支持和实现难易程度这三方面总结的原因。</strong></p><p><strong>原因一</strong></p><p><code>There are a few reasons:</code></p><p>1) <code>They are not very memory intensive. It’s up to you basically. Changing parameters about the probability of a node to have a given number of levels will make then less memory intensive than btrees.</code><br><strong>1) 也不是非常耗费内存，实际上取决于生成层数函数里的概率 p，取决得当的话其实和平衡树差不多。</strong></p><p><strong>原因二</strong></p><p>2) <code>A sorted set is often target of many ZRANGE or ZREVRANGE operations, that is, traversing the skip list as a linked list. With this operation the cache locality of skip lists is at least as good as with other kind of balanced trees.</code><br><strong>2) 因为有序集合经常会进行 ZRANGE 或 ZREVRANGE 这样的范围查找操作，跳表里面的双向链表可以十分方便地进行这类操作</strong></p><p><strong>原因三</strong></p><p>3) <code>They are simpler to implement, debug, and so forth. For instance thanks to the skip list simplicity I received a patch (already in Redis master) with augmented skip lists implementing ZRANK in O(log(N)). It required little changes to the code.</code><br><strong>3) 实现简单，ZRANK 操作还能达到 o(logn)的时间复杂度</strong></p><p><strong>参考博客 : <a href="https://www.cnblogs.com/yuanfang0903/p/12165394.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuanfang0903/p/12165394.html</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis-13-跳表&quot;&gt;&lt;a href=&quot;#Redis-13-跳表&quot; class=&quot;headerlink&quot; title=&quot;Redis-13-跳表&quot;&gt;&lt;/a&gt;Redis-13-跳表&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;首先为什么要把mysql索引和redis跳表放在一起讨论呢，因为他们解决的都是同一种问题，用于&lt;strong&gt;解决数据集合的查找问题，即根据指定的key，快速查到它所在的位置（或者对应的value）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="http://zhuuu.work/tags/Redis/"/>
    
      <category term="跳表" scheme="http://zhuuu.work/tags/%E8%B7%B3%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁</title>
    <link href="http://zhuuu.work/2020/09/05/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://zhuuu.work/2020/09/05/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2020-09-05T00:02:27.000Z</published>
    <updated>2020-09-26T07:00:14.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为什么要使用分布式锁呢？</p><p>在<code>Nginx</code>实现负载均衡服务器集群时会产生很多问题，在提高并发的同时，服务器也会产生非常多的问题例如，这些问题应该一一的考虑到。</p><ul><li><strong>分布式Session一致性</strong></li><li><strong>分布式全局ID生成方案</strong></li><li>分布式事务解决方案</li><li>分布式任务调度平台</li><li>分布式配置中心</li><li><strong>分布式锁多种实现方案</strong></li><li>分布式日志收集系统</li><li>各种网站跨域请求解决方案</li><li>高并发下服务降级与限流实战</li><li>……</li></ul><p>本次就先以分布式锁来探讨一下分布式场景下的使用与注意事项，和为什么要使用分布式锁。</p><a id="more"></a><ul><li><p>目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。<strong>分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）</strong></p></li><li><p><strong>最多只能同时满足两项</strong>。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都<strong>需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。</strong></p></li><li><p>在很多场景中，我们为了<strong>保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等</strong>。有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行</p></li><li><p>在单机环境中，<code>Java</code>中其实提供了很多并发处理相关的<code>API</code>，但是这些API在分布式场景中就无能为力了。也就是说单纯的<code>Java Api</code>并不能提供分布式锁的能力。所以针对分布式锁的实现目前有多种方案。</p></li></ul><h2 id="为什么要使用分布式锁？"><a href="#为什么要使用分布式锁？" class="headerlink" title="为什么要使用分布式锁？"></a>为什么要使用分布式锁？</h2><ul><li>原因：采用了集群的部署方案</li></ul><p><strong>如何在单台机器上生成唯一的订单号</strong></p><ul><li>UUID、时间戳、redis等。。。</li></ul><p>其实有一种取巧的解决方案，可以适当的避免突然的高并发下的服务宕机（或反应慢）的尴尬场景。</p><ul><li><strong>可以使用<code>redis</code>提前生成150W订单号（假设是在下单场景下）</strong><ul><li>提前生成好150W订单号，存放在<code>redis</code>中，当客户端下单之后，直接到<code>redis</code>中取对应的订单号即可，</li><li>因为<code>redis</code>本身是单线程的，如果<code>redis</code>还只剩下50W个订单号的时候，在继续生产100W个订单号。（这种技巧视业务场景而定，一般我们在面对需求或者发生的问题时，可以从根源下手，这种情况明显就是针对在高并发场景下能一定程度的提高程序的响应速度。提高了整个程序的健壮性。）</li></ul></li></ul><p><strong>那么如果在集群环境下使用<code>UUID</code>的方式安全嘛？</strong></p><ul><li><p>答案是肯定的，<strong>肯定是不安全的</strong>，大概率是会出现重复的<code>ID</code>的。所以<strong>这个时候就提出了分布式锁。</strong></p></li><li><p>可想而知，在多线程下我们可以简单的使用<code>Lock</code>或者<code>synchronized</code>来实现安全性，但是在分布式场景下，这些就显得力不从心了。因为这个时候在微服务场景下，很有可能同一个服务分别安装在不同的服务器上，这样的话，传统的加锁方式根本不可能保证数据的最终一致性。所以分布式锁就诞生了。</p></li></ul><p>针对分布式锁的实现，目前比较常用的有以下几种方案：</p><ul><li><strong>基于数据库实现分布式锁</strong></li><li><strong>基于缓存（redis，memcached，tair）实现分布式锁</strong></li><li><strong>基于Zookeeper实现分布式锁</strong></li></ul><p>在分析这几种实现方案之前我们先来想一下，我们需要的分布式锁应该是怎么样的？（这里以方法锁为例，资源锁同理）</p><ul><li>可以保证在分布式部署的应用集群中，<strong>同一个方法在同一时间只能被一台机器上的一个线程执行</strong>。</li><li>有<strong>高可用的获取锁和释放锁功能</strong></li><li>获取锁和释放锁的性能要好</li><li>这把锁要是一把<strong>可重入锁</strong>（避免死锁）</li><li>这把锁<strong>最好是一把阻塞锁（</strong>根据业务需求考虑要不要这条）</li></ul><h2 id="1-基于数据库实现分布式锁"><a href="#1-基于数据库实现分布式锁" class="headerlink" title="1. 基于数据库实现分布式锁"></a>1. 基于数据库实现分布式锁</h2><h3 id="1-1-基于数据表"><a href="#1-1-基于数据表" class="headerlink" title="1.1 基于数据表"></a>1.1 基于数据表</h3><ul><li>要实现分布式锁，最简单的方式可能就是直接<strong>创建一张锁表</strong>，然后通过操作该表中的数据来实现了。</li><li><strong>当我们要锁住某个方法或资源时，我们就在该表中增加一条记录，</strong></li><li><strong>想要释放锁的时候就删除这条记录。</strong></li></ul><p>创建这样一张数据库表：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200905-091537484.png" alt="mark"></p><p>当我们想要锁住某个方法时，执行以下SQL：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200905-091612208.png" alt="mark"></p><p>因为我们对<code>method_name</code>做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p><p>当方法执行完毕之后，想要释放锁的话，需要执行以下Sql:</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200905-091905207.png" alt="mark"></p><ul><li><p>上面这种简单的实现有以下几个问题：</p><ul><li>这把锁强<strong>依赖数据库的可用性</strong>，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li><li>这把<strong>锁没有失效时间</strong>，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li><li>这把<strong>锁是非重入的</strong>，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li><li>这把锁<strong>只能是非阻塞的</strong>，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li></ul></li><li><p>当然，我们也可以有其他方式解决上面的问题。</p><ul><li>数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。</li><li>没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。</li><li>非阻塞的？搞一个while循环，直到insert成功再返回成功。</li><li>非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li></ul></li></ul><h3 id="1-2-基于数据库的排他锁"><a href="#1-2-基于数据库的排他锁" class="headerlink" title="1.2 基于数据库的排他锁"></a>1.2 基于数据库的排他锁</h3><ul><li>除了可以通过增删操作数据表中的记录以外，其实还可以借助数据中自带的锁来实现分布式的锁。</li><li>我们还用刚刚创建的那张数据库表。可以通过数据库的排他锁来实现分布式锁。 基于<code>MySql</code>的<code>InnoDB</code>引擎，可以使用以下方法来实现加锁操作：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200905-092752416.png" alt="mark"></p><ul><li>在查询语句后面增加<code>for update</code>，数据库会在查询过程中给数据库表增加排他锁</li><li>这里再多提一句，InnoDB引擎在加锁的时候，<strong>只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁</strong>。这里我们希望使用行级锁，就要给method_name添加索引，值得注意的是，这个索引一定要创建成唯一索引，否则会出现多个重载方法之间无法同时被访问的问题。重载方法的话建议把参数类型也加上。</li><li>当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。</li></ul><p>我们可以认为获得排它锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，再通过以下方法解锁：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200905-092938397.png" alt="mark"></p><p>通过<code>connection.commit()</code>操作来释放锁。</p><p>这种方法可以有效的解决上面提到的无法释放锁和阻塞锁的问题。</p><ul><li>阻塞锁？ <code>for update</code>语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。</li><li>锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉。</li></ul><p><strong>问题：</strong></p><ul><li>但是还是无法直接解决数据库单点和可重入问题。</li><li>这里还可能存在另外一个问题，虽然我们对<code>method_name</code> 使用了唯一索引，并且显示使用<code>for update</code>来使用行级锁。但是，MySql会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。如果发生这种情况就悲剧了。。。</li><li>还有一个问题，就是我们要使用排他锁来进行分布式锁的lock，那么一个排他锁长时间不提交，就会占用数据库连接。一旦类似的连接变得多了，就可能把数据库连接池撑爆</li></ul><p><strong>总结</strong>：</p><ul><li>这两种方式都是依赖数据库的一张表，一种是通过表中的记录的存在情况确定当前是否有锁存在，另外一种是通过数据库的排他锁来实现分布式锁。</li></ul><h3 id="1-3-乐观锁"><a href="#1-3-乐观锁" class="headerlink" title="1.3 乐观锁"></a>1.3 乐观锁</h3><ul><li>乐观锁假设认为数据一般情况下不会造成冲突，<strong>只有在进行数据的提交更新时</strong>，才会检测数据的冲突情况，如果发现冲突了，则返回错误信息</li></ul><p>实现方式：</p><ul><li><p><strong>时间戳</strong>（timestamp）记录机制实现：<strong>给数据库表增加一个时间戳字段类型的字段</strong>，当读取数据时，将<code>timestamp</code>字段的值一同读出，数据每更新一次，<strong>timestamp也同步更新</strong></p></li><li><p>当对数据做提交更新操作时，检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，若相等，则更新，否则认为是失效数据。</p></li><li><p><strong>同样也可以使用version的方式</strong></p></li></ul><p>性能对比</p><p>（1） 悲观锁实现方式是独占数据，其它线程需要等待，不会出现修改的冲突，能够保证数据的一致性，但是依赖数据库的实现，且在线程较多时出现等待造成效率降低的问题。一般情况下，对于数据很敏感且读取频率较低的场景，可以采用悲观锁的方式</p><p>（2） 乐观锁可以多线程同时读取数据，若出现冲突，也可以依赖上层逻辑修改，能够保证高并发下的读取，适用于读取频率很高而修改频率较少的场景</p><p>（3） 由于库存回写数据属于敏感数据且读取频率适中，所以建议使用悲观锁优化</p><h2 id="2-基于Redis来实现分布式锁"><a href="#2-基于Redis来实现分布式锁" class="headerlink" title="2. 基于Redis来实现分布式锁"></a>2. 基于Redis来实现分布式锁</h2><ul><li>相比较于基于数据库实现分布式锁的方案来说，基于缓存来实现在性能方面会表现的更好一点。而且很多缓存是可以集群部署的，可以解决单点问题。</li></ul><p>首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</p><ol><li><strong>互斥性。在任意时刻，只有一个客户端能持有锁。</strong></li><li><strong>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</strong></li><li><strong>具有容错性。只要大部分的<code>redis</code>节点正常运行，客户端就可以加锁和解锁。</strong></li><li><strong>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</strong></li></ol><p>可以看到，我们加锁就一行代码：<strong>jedis.set(String key, String value, String nxxx, String expx, int time)</strong>，这个set()方法一共有五个形参：</p><p>可以看到，我们加锁就一行代码：<strong>jedis.set(String key, String value, String nxxx, String expx, int time)</strong>，这个set()方法一共有五个形参：</p><ul><li>第一个为key，我们使用key来当锁，因为key是唯一的。</li><li>第二个为value，我们传的是<code>requestId</code>，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件<strong>解铃还须系铃人</strong>，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用<code>UUID.randomUUID().toString()</code>方法生成。</li><li>第三个为<code>nxxx</code>，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</li><li>第四个为<code>expx</code>，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。</li><li>第五个为<code>time</code>，与第四个参数相呼应，代表key的过期时间。</li></ul><p><strong>总的来说</strong></p><ul><li>执行上面的set() 方法就会导致两种结果<ul><li>当前没有锁（key不存在），那么就进行加锁的操作，并对锁设置有效期，同时<code>value</code>表示加锁的客户端</li><li>已有锁存在，不做任何操作。</li></ul></li></ul><ul><li><strong>首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性</strong></li><li><strong>其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。</strong></li><li><strong>最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。</strong></li></ul><p><strong>解锁操作：</strong></p><ul><li>首先获取锁对应的value值，检查是否与<code>requestId</code>相等，如果相等则删除锁（解锁）</li></ul><p><strong>总结：</strong></p><ul><li><p>可以使用缓存来代替数据库来实现分布式锁，这个可以提供更好的性能，</p></li><li><p>同时，很多缓存服务都是<strong>集群部署</strong>的，可以避免单点问题。</p></li><li><p>并且很多缓存服务都提供了可以用来实现分布式锁的方法，比如<code>redis</code>的<code>setnx</code>方法等。</p></li><li><p>并且，这些缓存服务也都提供了<strong>对数据的过期自动删除的支持</strong>，可以直接设置超时时间来控制锁的释放。</p></li></ul><h2 id="3-基于Zookeeper-实现分布式锁"><a href="#3-基于Zookeeper-实现分布式锁" class="headerlink" title="3. 基于Zookeeper 实现分布式锁"></a>3. 基于Zookeeper 实现分布式锁</h2><ul><li>基于<code>zookeeper</code><strong>临时有序节点</strong>可以实现的分布式锁。</li><li><strong>大致思想</strong><ul><li>每个客户端对某个方法加锁时，在<code>zookeeper</code>上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。</li><li><strong>判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。</strong></li><li><strong>当释放锁的时候，只需将这个瞬时节点删除即可。</strong></li><li>同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。</li></ul></li></ul><p>来看下Zookeeper能不能解决前面提到的问题。</p><ul><li><p><strong>锁无法释放？</strong>使用<code>Zookeeper</code>可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。</p></li><li><p><strong>非阻塞锁？</strong>  使用<code>Zookeeper</code>可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，<code>Zookeeper</code>会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。</p></li><li><p><strong>不可重入？</strong>使用<code>Zookeeper</code>也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。</p></li><li><p><strong>单点问题？</strong>使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。</p></li></ul><p>可以直接使用zookeeper第三方库<a href="https://curator.apache.org/" target="_blank" rel="noopener">Curator</a>客户端，这个客户端中封装了一个可重入的锁服务。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200905-094429707.png" alt="mark"></p><ul><li>Curator提供的InterProcessMutex是分布式锁的实现。acquire方法用户获取锁，release方法用于释放锁。</li><li>使用ZK实现的分布式锁好像完全符合了本文开头我们对一个分布式锁的所有期望。但是，其实并不是，Zookeeper实现的分布式锁其实存在一个缺点，那就是性能上可能并没有缓存服务那么高。</li><li>因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同步到所有的Follower机器上。</li></ul><p>其实，使用Zookeeper也有可能带来并发问题，只是并不常见而已。考虑这样的情况，由于网络抖动，客户端可ZK集群的session连接断了，那么zk以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了。就可能产生并发问题。</p><p>这个问题不常见是因为zk有重试机制，一旦zk集群检测不到客户端的心跳，就会重试，Curator客户端支持多种重试策略。多次重试之后还不行的话才会删除临时节点。（所以，选择一个合适的重试策略也比较重要，要在锁的粒度和并发之间找一个平衡。）</p><p><strong>总结</strong></p><ul><li><p>使用Zookeeper实现分布式锁的优点</p></li><li><p>有效的解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题。实现起来较为简单。</p></li><li><p>使用Zookeeper实现分布式锁的缺点</p></li><li><p>性能上不如使用缓存实现分布式锁。 需要对ZK的原理有所了解。</p></li></ul><h2 id="4-三种方案的比较"><a href="#4-三种方案的比较" class="headerlink" title="4. 三种方案的比较"></a>4. 三种方案的比较</h2><p>上面几种方式，哪种方式都无法做到完美。就像CAP一样，在复杂性、可靠性、性能等方面无法同时满足，所以，根据不同的应用场景选择最适合自己的才是王道。</p><h4 id="从理解的难易程度角度（从低到高）"><a href="#从理解的难易程度角度（从低到高）" class="headerlink" title="从理解的难易程度角度（从低到高）"></a>从理解的难易程度角度（从低到高）</h4><p>数据库 &gt; 缓存 &gt; Zookeeper</p><h4 id="从实现的复杂性角度（从低到高）"><a href="#从实现的复杂性角度（从低到高）" class="headerlink" title="从实现的复杂性角度（从低到高）"></a>从实现的复杂性角度（从低到高）</h4><p>Zookeeper &gt;= 缓存 &gt; 数据库</p><h4 id="从性能角度（从高到低）"><a href="#从性能角度（从高到低）" class="headerlink" title="从性能角度（从高到低）"></a>从性能角度（从高到低）</h4><p>缓存 &gt; Zookeeper &gt;= 数据库</p><h4 id="从可靠性角度（从高到低）"><a href="#从可靠性角度（从高到低）" class="headerlink" title="从可靠性角度（从高到低）"></a>从可靠性角度（从高到低）</h4><p>Zookeeper &gt; 缓存 &gt; 数据库</p><p><strong>参考博客：</strong> <a href="https://www.jianshu.com/p/a44c1c47bcee" target="_blank" rel="noopener">https://www.jianshu.com/p/a44c1c47bcee</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分布式锁&quot;&gt;&lt;a href=&quot;#分布式锁&quot; class=&quot;headerlink&quot; title=&quot;分布式锁&quot;&gt;&lt;/a&gt;分布式锁&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;为什么要使用分布式锁呢？&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Nginx&lt;/code&gt;实现负载均衡服务器集群时会产生很多问题，在提高并发的同时，服务器也会产生非常多的问题例如，这些问题应该一一的考虑到。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分布式Session一致性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分布式全局ID生成方案&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;分布式事务解决方案&lt;/li&gt;
&lt;li&gt;分布式任务调度平台&lt;/li&gt;
&lt;li&gt;分布式配置中心&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分布式锁多种实现方案&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;分布式日志收集系统&lt;/li&gt;
&lt;li&gt;各种网站跨域请求解决方案&lt;/li&gt;
&lt;li&gt;高并发下服务降级与限流实战&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本次就先以分布式锁来探讨一下分布式场景下的使用与注意事项，和为什么要使用分布式锁。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="http://zhuuu.work/tags/Redis/"/>
    
      <category term="分布式" scheme="http://zhuuu.work/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-14-MVCC实现</title>
    <link href="http://zhuuu.work/2020/09/04/Mysql/Mysql-14-MVCC%E5%AE%9E%E7%8E%B0/"/>
    <id>http://zhuuu.work/2020/09/04/Mysql/Mysql-14-MVCC%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-09-04T08:02:27.000Z</published>
    <updated>2020-09-21T11:02:34.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-14-MVCC实现"><a href="#Mysql-14-MVCC实现" class="headerlink" title="Mysql-14-MVCC实现"></a>Mysql-14-MVCC实现</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><code>MVCC (Multiversion Concurrency Control)</code> 中文叫<strong>多版本并发控制</strong>，是现代数据库（包括 <code>MySQL</code>、<code>Oracle</code>、<code>PostgreSQL</code> 等）引擎实现中常用的处理读写冲突的手段，<strong>目的在于提高数据库高并发场景下的吞吐性能</strong>。</li><li>如此一来不同的事务在并发过程中，<code>SELECT</code> 操作可以不加锁而是通过 <code>MVCC</code> 机制读取指定的版本历史记录，并通过一些手段保证保证读取的记录值符合事务所处的隔离级别，从而解决并发场景下的读写冲突。</li></ul><p>下面举一个多版本读的例子，例如两个事务 <code>A</code> 和 <code>B</code> 按照如下顺序进行更新和读取操作</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/164638522.png" alt="mark"></p><a id="more"></a><p>在事务 <code>A</code> 提交前后，事务 <code>B</code> 读取到的 <code>x</code> 的值是什么呢？答案是：事务 <code>B</code> 在不同的隔离级别下，读取到的值不一样。</p><ol><li>如果事务 <code>B</code> 的隔离级别是<strong>读未提交（RU）</strong>，那么两次读取均读取到 <code>x</code> 的最新值，即 <code>20</code>。</li><li>如果事务 <code>B</code> 的隔离级别是<strong>读已提交（RC）</strong>，那么第一次读取到旧值 <code>10</code>，第二次因为事务 <code>A</code> 已经提交，则读取到新值 20。</li><li>如果事务 <code>B</code> 的隔离级别是可重复读或者串行（RR，S），则两次均读到旧值 <code>10</code>，不论事务 <code>A</code> 是否已经提交。</li></ol><p>可见在不同的隔离级别下，数据库通过 <code>MVCC</code> 和隔离级别，让事务之间并行操作遵循了某种规则，来保证单个事务内前后数据的一致性。</p><h2 id="1-为什么需要MVCC"><a href="#1-为什么需要MVCC" class="headerlink" title="1. 为什么需要MVCC ?"></a>1. 为什么需要MVCC ?</h2><ul><li><code>InnoDB</code> 相比 <code>MyISAM</code> 有两大特点，一是支持事务 二是支持行级锁，事务的引入带来了一些新的挑战。相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持可以支持更多的用户。但并发事务处理也会带来一些问题，主要包括以下几种情况：<ul><li><strong>更新丢失（<code>Lost Update</code>）</strong>：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题 —— 最后的更新覆盖了其他事务所做的更新。如何避免这个问题呢，最好在一个事务对数据进行更改但还未提交时，其他事务不能访问修改同一个数据。</li><li><strong>脏读</strong>（<code>Dirty Reads</code>）：一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些尚未提交的脏数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做 <strong>“脏读”</strong>。</li><li><strong>不可重复读</strong>（<code>Non-Repeatable Reads</code>）：一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。</li><li><strong>幻读（<code>Phantom Reads</code>）</strong>：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为 <strong>“幻读”</strong>。</li></ul></li></ul><p>以上是并发事务过程中会存在的问题，解决更新丢失可以交给应用，但是后三者需要数据库提供事务间的隔离机制来解决。实现隔离机制的方法主要有两种：</p><ol><li><strong>加读写锁</strong></li><li><strong>一致性快照读，即 <code>MVCC</code></strong></li></ol><h2 id="2-InnoDB-中的-MVCC"><a href="#2-InnoDB-中的-MVCC" class="headerlink" title="2. InnoDB 中的 MVCC"></a>2. <strong>InnoDB 中的 MVCC</strong></h2><ul><li>本文聚焦于 <code>MySQL</code> 中的 <code>MVCC</code> 实现，从 <code>《高性能 MySQL》</code>一书中对 <code>MVCC</code> 的介绍可知：<ul><li><code>MySQL</code> 中 <code>InnoDB</code> 引擎支持 <code>MVCC</code></li><li>应对高并发事务, <code>MVCC</code> 比单纯的加行锁更有效, 开销更小</li><li><code>MVCC</code> 在读已提交<code>（Read Committed）</code>和可重复读<code>（Repeatable Read）</code>隔离级别下起作用</li><li><code>MVCC</code> 既可以基于<strong>乐观锁</strong>又可以基于<strong>悲观锁</strong>来实现</li></ul></li></ul><h3 id="2-1-实现原理"><a href="#2-1-实现原理" class="headerlink" title="2.1 实现原理"></a>2.1 实现原理</h3><ul><li><code>InnoDB</code> 中 <code>MVCC</code> 的实现方式为：每一行记录都有两个隐藏列：<code>DATA_TRX_ID</code>、<code>DATA_ROLL_PTR</code>（如果没有主键，则还会多一个隐藏的主键列）。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/165844142.png" alt="mark"></p><ol><li><h3 id="DATA-TRX-ID"><a href="#DATA-TRX-ID" class="headerlink" title="DATA_TRX_ID"></a><strong>DATA_TRX_ID</strong></h3></li></ol><ul><li>记录最近更新这条行记录的<code>事务 ID</code>，大小为 <code>6</code> 个字节</li></ul><ol start="2"><li><h3 id="DATA-ROLL-PTR"><a href="#DATA-ROLL-PTR" class="headerlink" title="DATA_ROLL_PTR"></a><strong>DATA_ROLL_PTR</strong></h3></li></ol><ul><li>表示指向该行回滚段<code>（rollback segment）</code>的指针，大小为 <code>7</code> 个字节</li><li><code>InnoDB</code> 便是通过这个指针找到之前版本的数据。该行记录上所有旧版本，在 <code>undo</code> 中都通过链表的形式组织。</li></ul><ol start="3"><li><h3 id="DB-ROW-ID"><a href="#DB-ROW-ID" class="headerlink" title="DB_ROW_ID"></a><strong>DB_ROW_ID</strong></h3></li></ol><ul><li>行标识（隐藏单调自增 <code>ID</code>），大小为 <code>6</code> 字节，如果表没有主键，<code>InnoDB</code> 会自动生成一个隐藏主键，因此会出现这个列。</li><li>另外，每条记录的头信息（<code>record header</code>）里都有一个专门的 <code>bit</code>（<code>deleted_flag</code>）来表示当前记录是否已经被删除。</li></ul><h3 id="2-2-Undo-Log-链"><a href="#2-2-Undo-Log-链" class="headerlink" title="2.2 Undo Log 链"></a>2.2 Undo Log 链</h3><p><strong>Undo Log 概念</strong></p><ul><li>Undo log 主要用于记录数据被修改之前的日志，在表信息修改之前先会把数据拷贝到undo log 里，当事务进行回滚时可以通过undo log 里的日志进行数据还原。</li></ul><p><strong>Undo log 的用途</strong></p><p>（1）保证事务进行rollback时的原子性和一致性，当事务进行回滚的时候可以用undo log的数据进行恢复。</p><p>（2）用于MVCC快照读的数据，在MVCC多版本控制中，通过读取undo log的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本。</p><ul><li>上文提到，在多个事务并行操作某行数据的情况下，不同事务对该行数据的 UPDATE 会产生多个版本，然后通过回滚指针组织成一条 <code>Undo Log</code> 链</li><li>这节我们通过一个简单的例子来看一下 <code>Undo Log</code> 链是如何组织的，<code>DATA_TRX_ID</code> 和 <code>DATA_ROLL_PTR</code> 两个参数在其中又起到什么样的作用。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/170245411.png" alt="mark"></p><p>事务 <code>A</code> 的操作过程为：</p><ul><li>对 <code>DB_ROW_ID = 1</code> 的这行记录加排他锁</li><li>把该行原本的值拷贝到 <code>undo log</code> 中，<code>DB_TRX_ID</code> 和 <code>DB_ROLL_PTR</code> 都不动</li><li>修改该行的值这时产生一个新版本，更新 <code>DATA_TRX_ID</code> 为修改记录的事务 <code>ID</code> ,将 <code>DATA_ROLL_PTR</code> 指向刚刚拷贝到 <code>undo log</code> 链中的旧版本记录，这样就能通过 <code>DB_ROLL_PTR</code> 找到这条记录的历史版本。</li><li>如果对同一行记录执行连续的 <code>UPDATE</code>，<code>Undo Log</code> 会组成一个链表，遍历这个链表可以看到这条记录的变迁</li><li>记录 <code>redo log</code>，包括 <code>undo log</code> 中的修改</li></ul><p>那么 <code>INSERT</code> 和 <code>DELETE</code> 会怎么做呢？</p><ul><li>其实相比 <code>UPDATE</code> 这二者很简单，</li><li><code>INSERT</code> 会产生一条新纪录，它的 <code>DATA_TRX_ID</code> 为当前插入记录的事务 <code>ID</code>；</li><li><code>DELETE</code> 某条记录时可看成是一种特殊的 <code>UPDATE</code>，其实是软删，真正执行删除操作会在 <code>commit</code> 时，<code>DATA_TRX_ID</code> 则记录下删除该记录的事务 <code>ID</code>。</li></ul><h3 id="2-3-一致性读"><a href="#2-3-一致性读" class="headerlink" title="2.3 一致性读"></a>2.3 一致性读</h3><ul><li>在 <code>RU</code> 隔离级别下，直接读取版本的最新记录就 OK，对于 <code>SERIALIZABLE</code> 隔离级别，则是通过加锁互斥来访问数据，因此不需要 <code>MVCC</code> 的帮助。</li><li>因此 <code>MVCC</code> 运行在 <code>RC</code> 和 <code>RR</code> 这两个隔离级别下，当 <code>InnoDB</code> 隔离级别设置为二者其一时，在 <code>SELECT</code> 数据时就会用到版本链</li></ul><blockquote><p>核心问题是版本链中哪些版本对当前事务可见？</p></blockquote><p><code>InnoDB</code> 为了解决这个问题，设计了 <code>ReadView</code>（可读视图）的概念。</p><h4 id="2-3-1-RR-下的-ReadView-生成"><a href="#2-3-1-RR-下的-ReadView-生成" class="headerlink" title="2.3.1 RR 下的 ReadView 生成"></a>2.3.1 <strong>RR 下的 ReadView 生成</strong></h4><ul><li>在 <code>RR</code> 隔离级别下，每个事务 <code>touch first read</code> 时（本质上就是执行第一个 <code>SELECT</code> 语句时，后续所有的 <code>SELECT</code> 都是复用这个 <code>ReadView</code>，其它 <code>update</code>, <code>delete</code>, <code>insert</code> 语句和一致性读 <code>snapshot</code> 的建立没有关系），会将当前系统中的所有的活跃事务拷贝到一个列表生成<code>ReadView</code>。</li><li>下图中事务 <code>A</code> 第一条 <code>SELECT</code> 语句在事务 <code>B</code> 更新数据前，因此生成的 <code>ReadView</code> 在事务 <code>A</code> 过程中不发生变化，即使事务 <code>B</code> 在事务 <code>A</code> 之前提交，但是事务 <code>A</code> 第二条查询语句依旧无法读到事务 <code>B</code> 的修改。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/170739614.png" alt="mark"></p><p>下图中，事务 <code>A</code> 的第一条 <code>SELECT</code> 语句在事务 <code>B</code> 的修改提交之后，因此可以读到事务 <code>B</code> 的修改。<strong>但是注意，如果事务 <code>A</code> 的第一条 <code>SELECT</code> 语句查询时，事务 <code>B</code> 还未提交，那么事务 <code>A</code> 也查不到事务 <code>B</code> 的修改。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/172156851.png" alt="mark"></p><h4 id="2-3-2-RC-下的-ReadView-生成"><a href="#2-3-2-RC-下的-ReadView-生成" class="headerlink" title="2.3.2 RC 下的 ReadView 生成"></a>2.3.2 <strong>RC 下的 ReadView 生成</strong></h4><ul><li>在 <code>RC</code> 隔离级别下，每个 <code>SELECT</code> 语句开始时，都会重新将当前系统中的所有的活跃事务拷贝到一个列表生成 <code>ReadView</code>。二者的区别就在于生成 <code>ReadView</code> 的时间点不同，一个是事务之后第一个 <code>SELECT</code> 语句开始、一个是事务中每条 <code>SELECT</code> 语句开始。<ul><li>如果被访问版本的 <code>trx_id</code> 小于 <code>m_ids</code> 中的最小值 <code>up_limit_id</code>，说明生成该版本的事务在 <code>ReadView</code> 生成前就已经提交了，所以该版本可以被当前事务访问。</li><li>如果被访问版本的 <code>trx_id</code> 大于 <code>m_ids</code> 列表中的最大值 <code>low_limit_id</code>，说明生成该版本的事务在生成 <code>ReadView</code> 后才生成，所以该版本不可以被当前事务访问。需要根据 <code>Undo Log</code> 链找到前一个版本，然后根据该版本的 DB_TRX_ID 重新判断可见性。</li><li>如果被访问版本的 <code>trx_id</code> 属性值在 <code>m_ids</code> 列表中最大值和最小值之间（包含），那就需要判断一下 <code>trx_id</code> 的值是不是在 <code>m_ids</code> 列表中。如果在，说明创建 <code>ReadView</code> 时生成该版本所属事务还是活跃的，因此该版本不可以被访问，需要查找 Undo Log 链得到上一个版本，然后根据该版本的 <code>DB_TRX_ID</code> 再从头计算一次可见性；如果不在，说明创建 <code>ReadView</code> 时生成该版本的事务已经被提交，该版本可以被访问。</li><li>此时经过一系列判断我们已经得到了这条记录相对 <code>ReadView</code> 来说的可见结果。此时，如果这条记录的 <code>delete_flag</code> 为 <code>true</code>，说明这条记录已被删除，不返回。否则说明此记录可以安全返回给客户端。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/172304901.png" alt="mark"></p><p><strong>举个例子</strong></p><p><strong>RC 下的 MVCC 判断流程</strong></p><ul><li>我们现在回看刚刚的查询过程，为什么事务 <code>B</code> 在 <code>RC</code> 隔离级别下，两次查询的 <code>x</code> 值不同。<code>RC</code> 下 <code>ReadView</code> 是在语句粒度上生成的。</li><li>当事务 <code>A</code> 未提交时，事务 <code>B</code> 进行查询，假设事务 <code>B</code> 的事务 <code>ID</code> 为 <code>300</code>，此时生成 <code>ReadView</code> 的 <code>m_ids</code> 为 [200，300]，而最新版本的 <code>trx_id</code> 为 <code>200</code>，处于 <code>m_ids</code> 中，则该版本记录不可被访问，查询版本链得到上一条记录的 trx_id 为 <code>100</code>，小于 <code>m_ids</code> 的最小值 <code>200</code>，因此可以被访问，此时事务 <code>B</code> 就查询到值 <code>10</code> 而非 <code>20</code>。</li><li>待事务 <code>A</code> 提交之后，事务 <code>B</code> 进行查询，此时生成的 <code>ReadView</code> 的 <code>m_ids</code> 为 [300]，而最新的版本记录中 <code>trx_id</code> 为 <code>200</code>，小于 <code>m_ids</code> 的最小值 <code>300</code>，因此可以被访问到，此时事务 <code>B</code> 就查询到 <code>20</code>。</li></ul><p><strong>RR 下的 MVCC 判断流程</strong></p><ul><li>如果在 <code>RR</code> 隔离级别下，为什么事务 <code>B</code> 前后两次均查询到 <code>10</code> 呢？</li><li><code>RR</code> 下生成 <code>ReadView</code> 是在事务开始时，m_ids 为 [200,300]，后面不发生变化，</li><li>因此即使事务 <code>A</code> 提交了，<code>trx_id</code> 为 <code>200</code> 的记录依旧处于 <code>m_ids</code> 中，不能被访问，只能访问版本链中的记录 <code>10</code>。</li></ul><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ul><li><code>RC</code>、<code>RR</code> 两种隔离级别的事务在执行普通的读操作时，通过访问版本链的方法，使得事务间的读写操作得以并发执行，从而提升系统性能。</li><li><code>RC</code>、<code>RR</code> 这两个隔离级别的一个很大不同就是生成 <code>ReadView</code> 的时间点不同，<code>RC</code> 在每一次 <code>SELECT</code> 语句前都会生成一个 <code>ReadView</code>，事务期间会更新，因此在其他事务提交前后所得到的 <code>m_ids</code> 列表可能发生变化，使得先前不可见的版本后续又突然可见了。</li><li>而 <code>RR</code> 只在事务的第一个 <code>SELECT</code> 语句时生成一个 <code>ReadView</code>，事务操作期间不更新。</li></ul><p>参考博客 ： <a href="https://zhuanlan.zhihu.com/p/52977862" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/52977862</a></p><p>​                 <a href="https://zhuanlan.zhihu.com/p/64576887" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/64576887</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mysql-14-MVCC实现&quot;&gt;&lt;a href=&quot;#Mysql-14-MVCC实现&quot; class=&quot;headerlink&quot; title=&quot;Mysql-14-MVCC实现&quot;&gt;&lt;/a&gt;Mysql-14-MVCC实现&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MVCC (Multiversion Concurrency Control)&lt;/code&gt; 中文叫&lt;strong&gt;多版本并发控制&lt;/strong&gt;，是现代数据库（包括 &lt;code&gt;MySQL&lt;/code&gt;、&lt;code&gt;Oracle&lt;/code&gt;、&lt;code&gt;PostgreSQL&lt;/code&gt; 等）引擎实现中常用的处理读写冲突的手段，&lt;strong&gt;目的在于提高数据库高并发场景下的吞吐性能&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如此一来不同的事务在并发过程中，&lt;code&gt;SELECT&lt;/code&gt; 操作可以不加锁而是通过 &lt;code&gt;MVCC&lt;/code&gt; 机制读取指定的版本历史记录，并通过一些手段保证保证读取的记录值符合事务所处的隔离级别，从而解决并发场景下的读写冲突。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面举一个多版本读的例子，例如两个事务 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 按照如下顺序进行更新和读取操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200918/164638522.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="分库分表" scheme="http://zhuuu.work/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-13-分库分表</title>
    <link href="http://zhuuu.work/2020/09/03/Mysql/Mysql-13-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <id>http://zhuuu.work/2020/09/03/Mysql/Mysql-13-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</id>
    <published>2020-09-03T08:02:27.000Z</published>
    <updated>2020-09-18T08:30:45.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-13-分库分表"><a href="#Mysql-13-分库分表" class="headerlink" title="Mysql-13-分库分表"></a>Mysql-13-分库分表</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>当一张表的数据达到几千万时，查询一次所花的时间会变长。业界公认MySQL单表容量在 <strong>1千万</strong> 以下是最佳状态，因为这时它的BTREE索引树高在3~5之间。</li><li>数据切分可以分为：<code>垂直切分</code>和<code>水平切分</code>。</li></ul><a id="more"></a><h2 id="1-垂直切分"><a href="#1-垂直切分" class="headerlink" title="1. 垂直切分"></a>1. 垂直切分</h2><ul><li>垂直切分又可以分为: <code>垂直分库</code>和<code>垂直分表</code>。</li></ul><h3 id="1-1-垂直分库"><a href="#1-1-垂直分库" class="headerlink" title="1.1 垂直分库"></a>1.1 垂直分库</h3><p><code>概念</code> 就是<strong>根据业务耦合性，将关联度低的不同表存储在不同的数据库</strong>。<strong>做法与大系统拆分为多个小系统类似，按业务分类进行独立划分。与”微服务治理”的做法相似，</strong></p><ul><li>每个微服务使用单独的一个数据库。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200913/164635785.png" alt="mark"></p><p><strong>说明：</strong></p><p>一开始我们是单体服务，所以只有一个数据库，所有的表都在这个库里。</p><p>后来因为业务需求,单体服务变成微服务治理。所以将之前的一个商品库，拆分成多个数据库。每个微服务对于一个数据库。</p><h3 id="1-2-垂直分表"><a href="#1-2-垂直分表" class="headerlink" title="1.2 垂直分表"></a>1.2 垂直分表</h3><ul><li><code>概念</code> 把一个表的多个字段分别拆成多个表，一般按字段的冷热拆分，热字段一个表，冷字段一个表。从而提升了数据库性能。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200913/164630656.png" alt="mark"></p><p>说明：</p><p>一开始商品表中包含商品的所有字段，但是我们发现:</p><p><code>1.商品详情和商品属性字段较长</code>。</p><p><code>2.商品列表的时候我们是不需要显示商品详情和商品属性信息，只有在点进商品商品的时候才会展示商品详情信息</code>。</p><p>所以可以考虑把商品详情和商品属性单独切分一张表，提高查询效率。</p><h3 id="1-3-垂直拆分优缺点"><a href="#1-3-垂直拆分优缺点" class="headerlink" title="1.3 垂直拆分优缺点"></a>1.3 垂直拆分优缺点</h3><p><strong>优点</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 解决业务系统层面的耦合，业务清晰</span><br><span class="line">- 与微服务的治理类似，也能对不同业务的数据进行分级管理、维护、监控、扩展等</span><br><span class="line">- 高并发场景下，垂直切分一定程度的提升IO、数据库连接数、单机硬件资源的瓶颈</span><br></pre></td></tr></table></figure><p><strong>缺点</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 分库后无法Join，只能通过接口聚合方式解决，提升了开发的复杂度</span><br><span class="line">- 分库后分布式事务处理复杂</span><br><span class="line">- 依然存在单表数据量过大的问题（需要水平切分）</span><br></pre></td></tr></table></figure><h2 id="2-水平切分"><a href="#2-水平切分" class="headerlink" title="2. 水平切分"></a>2. 水平切分</h2><p><strong>产生的原因：</strong></p><ul><li>当一个应用难以再细粒度的垂直切分或切分后数据量行数巨大,</li><li>存在单库读写、存储性能瓶颈，这时候就需要进行水平切分了。</li></ul><p><strong>这时候需要考虑水平切分了</strong></p><h3 id="2-1-水平切分"><a href="#2-1-水平切分" class="headerlink" title="2.1 水平切分"></a>2.1 水平切分</h3><p>原因： 上面虽然已经把商品库分成3个库，但是随着业务的增加一个订单库也出现QPS过高，数据库响应速度来不及,<strong>一般mysql单机也就1000左右的QPS</strong>，如果超过1000就要考虑分库。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200913/170142138.png" alt="mark"></p><h3 id="2-2-水平分表"><a href="#2-2-水平分表" class="headerlink" title="2.2 水平分表"></a>2.2 水平分表</h3><ul><li><code>概念</code> <strong>一般我们一张表的数据不要超过1千万,如果表数据超过1千万，并且还在不断增加数据，那就可以考虑分表。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200913/170553161.png" alt="mark"></p><h3 id="2-3-水平拆分优缺点"><a href="#2-3-水平拆分优缺点" class="headerlink" title="2.3 水平拆分优缺点"></a>2.3 水平拆分优缺点</h3><p><strong>优点</strong></p><ul><li><strong>不存在单库数据量过大、高并发的性能瓶颈，提升系统稳定性和负载能力</strong></li><li>应用端改造较小，不需要拆分业务模块</li></ul><p><strong>缺点</strong></p><ul><li>跨分片的事务一致性难以保证</li><li>跨库的Join关联查询性能较差</li><li>数据多次扩展难度和维护量极大</li></ul><h2 id="3-数据分片规则"><a href="#3-数据分片规则" class="headerlink" title="3. 数据分片规则"></a>3. 数据分片规则</h2><ul><li>我们我们考虑去水平切分表，将一张表水平切分成多张表，这就涉及到数据分片的规则，比较常见的有：<code>Hash取模分表</code>、<code>数值Range分表</code>、<code>一致性Hash算法分表</code>。</li></ul><h3 id="3-1-hash-取模分表"><a href="#3-1-hash-取模分表" class="headerlink" title="3.1 hash 取模分表"></a>3.1 hash 取模分表</h3><ul><li>一般采用Hash取模的切分方式，例如：假设按goods_id分4张表。（goods_id%4 取整确定表）</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200913/171007587.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">优点</span><br><span class="line"> - 数据分片相对比较均匀，不容易出现热点和并发访问的瓶颈。</span><br><span class="line">缺点</span><br><span class="line">- 后期分片集群扩容时，需要迁移旧的数据很难。</span><br><span class="line">- 容易面临跨分片查询的复杂问题。比如上例中，如果频繁用到的查询条件中不带goods_id时,将会导致无法定位数据库,从而需要同时向4个库发起查询，</span><br><span class="line">再在内存中合并数据，取最小集返回给应用，分库反而成为拖累。</span><br></pre></td></tr></table></figure><h3 id="3-2-范围-range分表"><a href="#3-2-范围-range分表" class="headerlink" title="3.2 范围 range分表"></a>3.2 范围 range分表</h3><p><code>概念</code> 按照时间区间或ID区间来切分。</p><p>​        例如：将goods_id为1 - 1000的记录分到第一个表，1001–2000的分到第二个表，以此类推。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200913/171123540.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">优点</span><br><span class="line">- 单表大小可控</span><br><span class="line">- 天然便于水平扩展，后期如果想对整个分片集群扩容时，只需要添加节点即可，无需对其他分片的数据进行迁移</span><br><span class="line">- 使用分片字段进行范围查找时，连续分片可快速定位分片进行快速查询，有效避免跨分片查询的问题。</span><br><span class="line">缺点</span><br><span class="line">- 热点数据成为性能瓶颈。</span><br><span class="line">例如按时间字段分片，有些分片存储最近时间段内的数据，可能会被频繁的读写，而有些分片存储的历史数据，则很少被查询</span><br></pre></td></tr></table></figure><h3 id="3-3-一致性-hash-算法"><a href="#3-3-一致性-hash-算法" class="headerlink" title="3.3 一致性 hash 算法"></a>3.3 一致性 hash 算法</h3><ul><li>一致性Hash算法能很好的<code>解决因为Hash取模而产生的分片集群扩容时，需要迁移旧的数据的难题</code>。至于具体原理这里就不详细说，</li></ul><h2 id="4-分库分表带来的问题"><a href="#4-分库分表带来的问题" class="headerlink" title="4. 分库分表带来的问题"></a>4. 分库分表带来的问题</h2><p>任何事情都有两面性，分库分表也不例外，如果采用分库分表，会引入新的的问题</p><h4 id="1、分布式事务问题"><a href="#1、分布式事务问题" class="headerlink" title="1、分布式事务问题"></a>1、分布式事务问题</h4><p>使用分布式事务中间件解决，具体是通过<strong>最终一致性还是强一致性分布式事务</strong>，看业务需求，这里就不多说。</p><h4 id="2、跨节点关联查询-Join-问题"><a href="#2、跨节点关联查询-Join-问题" class="headerlink" title="2、跨节点关联查询 Join 问题"></a>2、跨节点关联查询 Join 问题</h4><p>切分之前，我们可以通过Join来完成。而切分之后，数据可能分布在不同的节点上，此时Join带来的问题就比较麻烦了，考虑到性能，尽量避免使用Join查询。</p><p>解决这个问题的一些方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">全局表</span><br></pre></td></tr></table></figure><p>全局表，也可看做是 “<strong>数据字典表</strong>“，就是系统中所有模块都可能依赖的一些表，为了避免跨库Join查询，可以将 <strong>这类表在每个数据库中都保存一份</strong>。这些数据通常</p><p>很少会进行修改，所以也不担心一致性的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字段冗余</span><br></pre></td></tr></table></figure><p><strong>利用空间换时间，为了性能而避免join查询</strong>。例：订单表保存userId时候,也将userName冗余保存一份，这样查询订单详情时就不需要再去查询”买家user表”了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据组装</span><br></pre></td></tr></table></figure><p><strong>在系统层面，分两次查询</strong>。第一次查询的结果集中找出关联数据id，然后根据id发起第二次请求得到关联数据。最后将获得到的数据进行字段拼装。</p><h4 id="3、跨节点分页、排序、函数问题"><a href="#3、跨节点分页、排序、函数问题" class="headerlink" title="3、跨节点分页、排序、函数问题"></a>3、跨节点分页、排序、函数问题</h4><ul><li>跨节点多库进行查询时，会出现Limit分页、Order by排序等问题。分页需要按照指定字段进行排序，<strong>当排序字段就是分片字段时，通过分片规则就比较容易定位到指定的分片；</strong></li><li><strong>当排序字段非分片字段时，就变得比较复杂了。需要先在不同的分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序，最终返回给用户。</strong></li></ul><h4 id="4、全局主键避重问题"><a href="#4、全局主键避重问题" class="headerlink" title="4、全局主键避重问题"></a>4、全局主键避重问题</h4><p>如果都用<code>主键自增</code>肯定不合理，如果用<code>UUID</code>那么无法做到根据主键排序，所以我们可以考虑通过<code>雪花ID</code>来作为数据库的主键，</p><p>有关雪花ID可以参考博客：<a href="https://www.cnblogs.com/qdhxhz/p/11372658.html" target="_blank" rel="noopener">静态内部类单例模式实现雪花算法</a></p><h4 id="5、数据迁移问题"><a href="#5、数据迁移问题" class="headerlink" title="5、数据迁移问题"></a>5、数据迁移问题</h4><ul><li>采用<code>双写的方式</code>，修改代码，所有涉及到分库分表的表的增、删、改的代码，都要对新库进行增删改。同时，再有一个数据抽取服务，不断地从老库抽数据，往新库写，</li><li>边写边按时间比较数据是不是最新的。</li></ul><p><strong>参考博客 ：</strong> <a href="https://www.cnblogs.com/qdhxhz/p/11608222.html" target="_blank" rel="noopener">https://www.cnblogs.com/qdhxhz/p/11608222.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mysql-13-分库分表&quot;&gt;&lt;a href=&quot;#Mysql-13-分库分表&quot; class=&quot;headerlink&quot; title=&quot;Mysql-13-分库分表&quot;&gt;&lt;/a&gt;Mysql-13-分库分表&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;当一张表的数据达到几千万时，查询一次所花的时间会变长。业界公认MySQL单表容量在 &lt;strong&gt;1千万&lt;/strong&gt; 以下是最佳状态，因为这时它的BTREE索引树高在3~5之间。&lt;/li&gt;
&lt;li&gt;数据切分可以分为：&lt;code&gt;垂直切分&lt;/code&gt;和&lt;code&gt;水平切分&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Mysql" scheme="http://zhuuu.work/tags/Mysql/"/>
    
      <category term="数据库" scheme="http://zhuuu.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="分库分表" scheme="http://zhuuu.work/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-ClassLoader详解</title>
    <link href="http://zhuuu.work/2020/09/01/JavaInterview/Java-%E5%9F%BA%E7%A1%80-ClassLoader%E8%AF%A6%E8%A7%A3/"/>
    <id>http://zhuuu.work/2020/09/01/JavaInterview/Java-%E5%9F%BA%E7%A1%80-ClassLoader%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-09-01T06:34:38.000Z</published>
    <updated>2020-09-26T01:20:10.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-ClassLoader详解"><a href="#Java-基础-ClassLoader详解" class="headerlink" title="Java-基础-ClassLoader详解"></a>Java-基础-ClassLoader详解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p><code>ClassLoader</code>翻译过来就是类加载器，普通的java开发者其实用到的不多，但对于某些框架开发者来说却非常常见。</p></li><li><p>理解<code>ClassLoader</code>的加载机制，也有利于我们编写出更高效的代码。</p></li><li><p><code>ClassLoader</code>的具体作用就是将class文件加载到jvm虚拟机中去，程序就可以正确运行了。但是，<code>jvm</code>启动的时候，并不会一次性加载所有的class文件，而是根据需要去动态加载。</p></li><li><p>想想也是的，一次性加载那么多jar包那么多class，那内存不崩溃。本文的目的也是学习<code>ClassLoader</code>这种加载机制。</p></li></ul><a id="more"></a><h2 id="1-Class-文件"><a href="#1-Class-文件" class="headerlink" title="1. Class 文件"></a>1. Class 文件</h2><ul><li>我们都知道在Java中程序是运行在虚拟机中，我们平常用文本编辑器或者是IDE编写的程序都是.java格式的文件，这是最基础的源码，但这类文件是不能直接运行的。如我们编写一个简单的程序<code>HelloWorld.java</code></li></ul><p>如图：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200923/211656521.png" alt="mark"></p><ul><li>然后，我们需要在命令行中进行java文件的编译</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200923/211710053.png" alt="mark"></p><p>可以看到目录下生成了.class文件</p><p>我们再从命令行中执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java HelloWorld</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200923/212008863.png" alt="mark"></p><ul><li>上面是基本代码示例，是所有入门JAVA语言时都学过的东西，这里重新拿出来是想让大家将焦点回到class文件上，class文件是字节码格式文件，java虚拟机并不能直接识别我们平常编写的.java源文件，所以需要javac这个命令转换成.class文件。</li><li>另外，如果用C或者PYTHON编写的程序正确转换成.class文件后，java虚拟机也是可以识别运行的。更多信息大家可以参考<a href="http://blog.csdn.net/zhangjg_blog/article/details/21486985" target="_blank" rel="noopener">这篇</a>。</li></ul><h2 id="2-java环境变量"><a href="#2-java环境变量" class="headerlink" title="2. java环境变量"></a>2. java环境变量</h2><ul><li>初学java的时候，最害怕的就是下载JDK后要配置环境变量了，关键是当时不理解，所以战战兢兢地照着书籍上或者是网络上的介绍进行操作。然后下次再弄的时候，又忘记了而且是必忘。当时，心里的想法很气愤的，想着是–这东西一点也不人性化，为什么非要自己配置环境变量呢？太不照顾菜鸟和新手了，很多菜鸟就是因为卡在环境变量的配置上，遭受了太多的挫败感。</li><li>因为我是在Windows下编程的，所以只讲Window平台上的环境变量，主要有3个：<strong>JAVA_HOME</strong>、<strong>PATH</strong>、<strong>CLASSPATH</strong>。</li></ul><h3 id="2-1-JAVA-HOME"><a href="#2-1-JAVA-HOME" class="headerlink" title="2.1 JAVA_HOME"></a>2.1 JAVA_HOME</h3><ul><li>指的是你JDK安装的位置，一般默认安装在C盘，如</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_91</span></span></span><br></pre></td></tr></table></figure><h3 id="2-2-PATH"><a href="#2-2-PATH" class="headerlink" title="2.2 PATH"></a>2.2 PATH</h3><ul><li>将程序路径包含在PATH当中后，在命令行窗口就可以直接键入它的名字了，而不再需要键入它的全路径,比如上面代码中我用的到<code>javac</code>和<code>java</code>两个命令。</li><li>一般的</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PATH</span>=<span class="variable">%JAVA_HOME%</span>\bin;<span class="variable">%JAVA_HOME%</span>\jre\bin;<span class="variable">%PATH%</span>;</span><br></pre></td></tr></table></figure><h3 id="2-3-CLASSPATH"><a href="#2-3-CLASSPATH" class="headerlink" title="2.3 CLASSPATH"></a>2.3 CLASSPATH</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLASSPATH=.;<span class="variable">%JAVA_HOME%</span>\lib;<span class="variable">%JAVA_HOME%</span>\lib\tools.jar</span><br></pre></td></tr></table></figure><ul><li>一看就是指向jar包路径。<br>需要注意的是前面的<code>.;</code>，<code>.</code>代表当前目录。</li></ul><p>好了，扯远了，知道了环境变量，特别是CLASSPATH时，我们进入今天的主题Classloader.</p><h2 id="3-类加载的流程"><a href="#3-类加载的流程" class="headerlink" title="3. 类加载的流程"></a>3. 类加载的流程</h2><h3 id="3-1-双亲委派类加载器"><a href="#3-1-双亲委派类加载器" class="headerlink" title="3.1 双亲委派类加载器"></a>3.1 双亲委派类加载器</h3><ul><li><strong>Bootstrap ClassLoader</strong> 最顶层的加载类，主要加载核心类库，%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等。另外需要注意的是可以通过启动jvm时指定-Xbootclasspath和路径来改变Bootstrap ClassLoader的加载目录。比如<code>java -Xbootclasspath/a:path</code>被指定的文件追加到默认的bootstrap路径中。我们可以打开我的电脑，在上面的目录下查看，看看这些jar包是不是存在于这个目录。</li><li><strong>Extention ClassLoader</strong> 扩展的类加载器，加载目录%JRE_HOME%\lib\ext目录下的jar包和class文件。还可以加载<code>-D java.ext.dirs</code>选项指定的目录。</li><li><strong>Appclass Loader也称为SystemAppClass</strong> 加载当前应用的classpath的所有类。</li></ul><p>我们看到了系统的3个类加载器，但我们可能不知道具体哪个先行呢？<br>我可以先告诉你答案</p><ol><li><code>Bootstrap CLassloder</code></li><li><code>Extention ClassLoader</code></li><li><code>AppClassLoader</code></li></ol><p>为了更好的理解，我们可以查看源码。<br>看<a href="http://www.grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/sun/misc/Launcher.java" target="_blank" rel="noopener">sun.misc.Launcher</a>,它是一个java虚拟机的入口应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Launcher launcher = <span class="keyword">new</span> Launcher();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String bootClassPath =</span><br><span class="line">        System.getProperty(<span class="string">"sun.boot.class.path"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Launcher <span class="title">getLauncher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> launcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassLoader loader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create the extension class loader</span></span><br><span class="line">        ClassLoader extcl;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            extcl = ExtClassLoader.getExtClassLoader();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(</span><br><span class="line">                <span class="string">"Could not create extension class loader"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now create the class loader to use to launch the application</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            loader = AppClassLoader.getAppClassLoader(extcl);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(</span><br><span class="line">                <span class="string">"Could not create application class loader"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置AppClassLoader为线程上下文类加载器，这个文章后面部分讲解</span></span><br><span class="line">        Thread.currentThread().setContextClassLoader(loader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Returns the class loader used to launch the main application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loader;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The class loader used for loading installed extensions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The class loader used for loading from java.class.path.</span></span><br><span class="line"><span class="comment">     * runs in a restricted security context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>源码有精简，我们可以得到相关的信息。</p><ol><li><code>Launcher</code>初始化了<code>ExtClassLoader</code>和<code>AppClassLoader</code>。</li><li>Launcher中并没有看见<code>BootstrapClassLoader</code>，但通过<code>System.getProperty(&quot;sun.boot.class.path&quot;)</code>得到了字符串<code>bootClassPath</code>,这个应该就是<code>BootstrapClassLoader</code>加载的jar包路径。</li></ol><p>得到的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jre1.8.0_91\lib\resources.jar;</span><br><span class="line">C:\Program Files\Java\jre1.8.0_91\lib\rt.jar;</span><br><span class="line">C:\Program Files\Java\jre1.8.0_91\lib\sunrsasign.jar;</span><br><span class="line">C:\Program Files\Java\jre1.8.0_91\lib\jsse.jar;</span><br><span class="line">C:\Program Files\Java\jre1.8.0_91\lib\jce.jar;</span><br><span class="line">C:\Program Files\Java\jre1.8.0_91\lib\charsets.jar;</span><br><span class="line">C:\Program Files\Java\jre1.8.0_91\lib\jfr.jar;</span><br><span class="line">C:\Program Files\Java\jre1.8.0_91\classes</span><br></pre></td></tr></table></figure><p>可以看到，这些全是JRE目录下的jar包或者是class文件。</p><h3 id="3-2-ExtClassLoader-源码"><a href="#3-2-ExtClassLoader-源码" class="headerlink" title="3.2 ExtClassLoader 源码"></a>3.2 ExtClassLoader 源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The class loader used for loading installed extensions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            ClassLoader.registerAsParallelCapable();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * create an ExtClassLoader. The ExtClassLoader is created</span></span><br><span class="line"><span class="comment">         * within a context that limits which files it can read</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExtClassLoader <span class="title">getExtClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> File[] dirs = getExtDirs();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Prior implementations of this doPrivileged() block supplied</span></span><br><span class="line">                <span class="comment">// aa synthesized ACC via a call to the private method</span></span><br><span class="line">                <span class="comment">// ExtClassLoader.getContext().</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">                    <span class="keyword">new</span> PrivilegedExceptionAction&lt;ExtClassLoader&gt;() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> ExtClassLoader <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                            <span class="keyword">int</span> len = dirs.length;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                                MetaIndex.registerDirectory(dirs[i]);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> ExtClassLoader(dirs);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (IOException) e.getException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> File[] getExtDirs() &#123;</span><br><span class="line">            String s = System.getProperty(<span class="string">"java.ext.dirs"</span>);</span><br><span class="line">            File[] dirs;</span><br><span class="line">            <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">                StringTokenizer st =</span><br><span class="line">                    <span class="keyword">new</span> StringTokenizer(s, File.pathSeparator);</span><br><span class="line">                <span class="keyword">int</span> count = st.countTokens();</span><br><span class="line">                dirs = <span class="keyword">new</span> File[count];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                    dirs[i] = <span class="keyword">new</span> File(st.nextToken());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dirs = <span class="keyword">new</span> File[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dirs;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>我们先前的内容有说过，可以指定<code>-D java.ext.dirs</code>参数来添加和改变ExtClassLoader的加载路径。这里我们通过可以编写测试代码。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System.getProperty(<span class="string">"java.ext.dirs"</span>));</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jre1.8.0_91\lib\ext;C:\Windows\Sun\Java\lib\ext</span><br></pre></td></tr></table></figure><h3 id="3-3-AppClassLoader-源码"><a href="#3-3-AppClassLoader-源码" class="headerlink" title="3.3 AppClassLoader 源码"></a>3.3 AppClassLoader 源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The class loader used for loading from java.class.path.</span></span><br><span class="line"><span class="comment">     * runs in a restricted security context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getAppClassLoader</span><span class="params">(<span class="keyword">final</span> ClassLoader extcl)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> String s = System.getProperty(<span class="string">"java.class.path"</span>);</span><br><span class="line">            <span class="keyword">final</span> File[] path = (s == <span class="keyword">null</span>) ? <span class="keyword">new</span> File[<span class="number">0</span>] : getClassPath(s);</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">            <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> PrivilegedAction&lt;AppClassLoader&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> AppClassLoader <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    URL[] urls =</span><br><span class="line">                        (s == <span class="keyword">null</span>) ? <span class="keyword">new</span> URL[<span class="number">0</span>] : pathToURLs(path);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> AppClassLoader(urls, extcl);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到AppClassLoader加载的就是<code>java.class.path</code>下的路径。我们同样打印它的值。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System.getProperty(<span class="string">"java.class.path"</span>));</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\workspace\ClassLoaderDemo\bin</span><br></pre></td></tr></table></figure><p>这个路径其实就是当前java工程目录bin，里面存放的是编译生成的class文件。</p><p>好了，自此我们已经知道了<code>BootstrapClassLoader、ExtClassLoader、AppClassLoader</code>实际是查阅相应的环境属性<code>sun.boot.class.path</code>、<code>java.ext.dirs</code>和<code>java.class.path</code>来加载资源文件的。</p><h3 id="3-4-加载顺序"><a href="#3-4-加载顺序" class="headerlink" title="3.4 加载顺序"></a>3.4 加载顺序</h3><ul><li>接下来我们探讨它们的加载顺序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后，编写一个ClassLoaderTest.java文件。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">ClassLoader cl = Test<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"ClassLoader is:"</span>+cl.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们获取到了Test.class文件的类加载器，然后打印出来。结果是：</span></span><br><span class="line"><span class="comment">// ClassLoader is:sun.misc.Launcher$AppClassLoader@73d16e93</span></span><br></pre></td></tr></table></figure><p>也就是说明Test.class文件是由AppClassLoader加载的。</p><ul><li>这个Test类是我们自己编写的，那么int.class或者是String.class的加载是由谁完成的呢？<br>我们可以在代码中尝试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">ClassLoader cl = Test<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"ClassLoader is:"</span>+cl.toString());</span><br><span class="line"></span><br><span class="line">cl = <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"ClassLoader is:"</span>+cl.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下，却报错了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader is:sun.misc.Launcher<span class="variable">$AppClassLoader</span>@73d16e93</span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java.lang.NullPointerException</span><br><span class="line">at ClassLoaderTest.main(ClassLoaderTest.java:15)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提示的是空指针，意思是int.class这类基础类没有类加载器加载？</span><br><span class="line"></span><br><span class="line">当然不是！</span><br><span class="line">int.class是由Bootstrap ClassLoader加载的。要想弄明白这些，我们首先得知道一个前提。</span><br></pre></td></tr></table></figure><ul><li><strong>每个类加载其都有一个父类加载器</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个类加载器都有一个父加载器，比如加载Test.class是由AppClassLoader完成，那么AppClassLoader也有一个父加载器，怎么样获取呢？很简单，通过getParent方法。比如代码可以这样编写：</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader cl = Test<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"ClassLoader is:"</span>+cl.toString());</span><br><span class="line">System.out.println(<span class="string">"ClassLoader\'s parent is:"</span>+cl.getParent().toString());</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader is:sun.misc.Launcher$AppClassLoader@<span class="number">73</span>d16e93</span><br><span class="line">ClassLoader<span class="string">'s parent is:sun.misc.Launcher$ExtClassLoader@15db9742</span></span><br></pre></td></tr></table></figure><p>这个说明，AppClassLoader的父加载器是ExtClassLoader。那么ExtClassLoader的父加载器又是谁呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"ClassLoader is:"</span>+cl.toString());</span><br><span class="line">System.out.println(<span class="string">"ClassLoader\'s parent is:"</span>+cl.getParent().toString());</span><br><span class="line">System.out.println(<span class="string">"ClassLoader\'s grand father is:"</span>+cl.getParent().getParent().toString());</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p>运行如果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader is:sun.misc.Launcher$AppClassLoader@73d16e93</span><br><span class="line">Exception in thread &quot;main&quot; ClassLoader&#39;s parent is:sun.misc.Launcher$ExtClassLoader@15db9742</span><br><span class="line">java.lang.NullPointerException</span><br><span class="line">at ClassLoaderTest.main(ClassLoaderTest.java:13)</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><p>又是一个空指针异常，这表明ExtClassLoader也没有父加载器。那么，为什么标题又是每一个加载器都有一个父加载器呢？这不矛盾吗？为了解释这一点，我们还需要看下面的一个基础前提。</p><ul><li><strong>父类加载器不是父类</strong></li></ul><p>我们先前已经粘贴了ExtClassLoader和AppClassLoader的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>可以看见<code>ExtClassLoader</code>和<code>AppClassLoader</code>同样继承自<code>URLClassLoader</code>，但上面一小节代码中，为什么调用AppClassLoader的<code>getParent()</code>代码会得到ExtClassLoader的实例呢？先从URLClassLoader说起，这个类又是什么？</p><ul><li><code>URLClassLoader</code>的源码中并没有找到<code>getParent()</code>方法。这个方法在<code>ClassLoader.java</code>中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The parent class loader for delegation</span></span><br><span class="line"><span class="comment">// Note: VM hardcoded the offset of this field, thus all new fields</span></span><br><span class="line"><span class="comment">// must be added *after* it.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line"><span class="comment">// The class loader for the system</span></span><br><span class="line">    <span class="comment">// @GuardedBy("ClassLoader.class")</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ClassLoader scl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ClassLoader</span><span class="params">(Void unused, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(checkCreateClassLoader(), parent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(checkCreateClassLoader(), getSystemClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ClassLoader <span class="title">getParent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initSystemClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (scl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sclSet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (scl != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"recursive invocation"</span>);</span><br><span class="line">        sun.misc.Launcher l = sun.misc.Launcher.getLauncher();</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Throwable oops = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//通过Launcher获取ClassLoader</span></span><br><span class="line">            scl = l.getClassLoader();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                scl = AccessController.doPrivileged(</span><br><span class="line">                    <span class="keyword">new</span> SystemClassLoaderAction(scl));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">                oops = pae.getCause();</span><br><span class="line">                <span class="keyword">if</span> (oops <span class="keyword">instanceof</span> InvocationTargetException) &#123;</span><br><span class="line">                    oops = oops.getCause();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (oops != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (oops <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (Error) oops;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// wrap the exception</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(oops);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sclSet = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到<code>getParent()</code>实际上返回的就是一个<code>ClassLoader</code>对象<code>parent</code>，parent的赋值是在ClassLoader对象的构造方法中，它有两个情况：</p><ol><li>由外部类创建<code>ClassLoader</code>时直接指定一个<code>ClassLoader</code>为parent。</li><li>由<code>getSystemClassLoader()</code>方法生成，也就是在<code>sun.misc.Laucher</code>通过<code>getClassLoader()</code>获取，也就是<code>AppClassLoader</code>。直白的说，一个<code>ClassLoader</code>创建时如果没有指定parent，那么它的parent默认就是AppClassLoader。</li></ol><ul><li>我们主要研究的是ExtClassLoader与AppClassLoader的parent的来源，正好它们与Launcher类有关，我们上面已经粘贴过Launcher的部分代码。</li></ul><p>我们需要注意的是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader extcl;</span><br><span class="line">        </span><br><span class="line">extcl &#x3D; ExtClassLoader.getExtClassLoader();</span><br><span class="line"></span><br><span class="line">loader &#x3D; AppClassLoader.getAppClassLoader(extcl);</span><br></pre></td></tr></table></figure><p>代码已经说明了问题AppClassLoader的parent是一个ExtClassLoader实例。</p><p>ExtClassLoader并没有直接找到对parent的赋值。它调用了它的父类也就是URLClassLoder的构造方法并传递了3个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExtClassLoader</span><span class="params">(File[] dirs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(getExtURLs(dirs), <span class="keyword">null</span>, factory);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="title">URLClassLoader</span><span class="params">(URL[] urls, ClassLoader parent,</span></span></span><br><span class="line"><span class="function"><span class="params">                          URLStreamHandlerFactory factory)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>(parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>答案已经很明了了，ExtClassLoader的parent为null。</strong></p><p>上面张贴这么多代码也是为了说明<code>AppClassLoader</code>的parent是<code>ExtClassLoader</code>，<code>ExtClassLoader</code>的<code>parent</code>是<code>null</code>。这符合我们之前编写的测试代码。</p><p>不过，细心的同学发现，还是有疑问的我们只看到<code>ExtClassLoader</code>和<code>AppClassLoader</code>的创建，那么<code>BootstrapClassLoader</code>呢？</p><p>还有，<code>ExtClassLoader</code>的父加载器为null,但是<code>Bootstrap CLassLoader</code>却可以当成它的父加载器这又是为何呢？</p><ul><li>BootStrap ClassLoader 是由 C++编写的<ul><li><code>Bootstrap ClassLoader</code>是由C/C++编写的，它本身是虚拟机的一部分，所以它并不是一个JAVA类，也就是无法在<code>java</code>代码中获取它的引用，JVM启动时通过Bootstrap类加载器加载rt.jar等核心jar包中的class文件，之前的<code>int.class,String.class</code>都是由它加载。</li><li>然后呢，我们前面已经分析了，JVM初始化<code>sun.misc.Launcher</code>并创建Extension <code>ClassLoader``AppClassLoader</code>实例。并将<code>ExtClassLoader</code>设置为<code>AppClassLoader</code>的父加载器。Bootstrap没有父加载器，但是它却可以作用一个<code>ClassLoader</code>的父加载器。比如<code>ExtClassLoader</code>。这也可以解释之前通过<code>ExtClassLoader</code>的getParent方法获取为Null的现象。具体是什么原因，很快就知道答案了。</li></ul></li></ul><h2 id="4-双亲委派"><a href="#4-双亲委派" class="headerlink" title="4. 双亲委派"></a>4. 双亲委派</h2><ul><li>一个类加载器查找class和resource时，是通过“委托模式”进行的<ul><li>它首先判断这个class是不是已经加载成功，如果没有的话它并不是自己进行查找，而是先通过父加载器，然后递归下去，直到<code>Bootstrap ClassLoader</code></li><li>如果<code>Bootstrap classloader</code>找到了，直接返回</li><li>如果没有找到，则一级一级返回，最后到达自身去查找这些对象。这种机制就叫做双亲委托。</li></ul></li></ul><p>具体流程</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 一个AppClassLoader查找资源时，先看看缓存是否有，缓存有从缓存中获取，否则委托给父加载器。</span><br><span class="line">递归，重复第1部的操作。</span><br><span class="line">2. 如果ExtClassLoader也没有加载过，则由Bootstrap ClassLoader出面，它首先查找缓存，如果没有找到的话，就去找自己的规定的路径下，也就是sun.mic.boot.class下面的路径。找到就返回，没有找到，让子加载器自己去找。</span><br><span class="line">3. Bootstrap ClassLoader如果没有查找成功，则ExtClassLoader自己在java.ext.dirs路径中去查找，查找成功就返回，查找不成功，再向下让子加载器找。</span><br><span class="line">4. ExtClassLoader查找不成功，AppClassLoader就自己查找，在java.class.path路径下查找。找到就返回。如果没有找到就让子类找，如果没有子类会怎么样？抛出各种异常。</span><br></pre></td></tr></table></figure><p><strong>我们可以发现委托是从下向上，然后具体查找过程却是自上至下。</strong></p><h2 id="5-重要的方法"><a href="#5-重要的方法" class="headerlink" title="5. 重要的方法"></a>5. 重要的方法</h2><h3 id="5-1-loadClass"><a href="#5-1-loadClass" class="headerlink" title="5.1 loadClass()"></a>5.1 loadClass()</h3><ul><li>JDK文档中是这样写的，通过指定的全限定类名加载class，它通过同名的<code>loadClass(String,boolean)</code>方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name,</span><br><span class="line">                             <span class="keyword">boolean</span> resolve)</span><br><span class="line">                      <span class="keyword">throws</span> ClassNotFoundException</span><br></pre></td></tr></table></figure><p>上面是<strong>方法原型(说明我们可以打破双亲委派)</strong>，一般实现这个方法的步骤是</p><ol><li>执行<code>findLoadedClass(String)</code>去检测这个<code>class</code>是不是已经加载过了。</li><li>执行父加载器的<code>loadClass</code>方法。如果父加载器为<code>null</code>，则<code>jvm</code>内置的加载器去替代，也就是<code>Bootstrap ClassLoader</code>。这也解释了<code>ExtClassLoader</code>的<code>parent</code>为null,但仍然说<code>Bootstrap ClassLoader</code>是它的父加载器。</li><li>如果向上委托父加载器没有加载成功，则通过<code>findClass(String)</code>查找。</li></ol><ul><li>如果class在上面的步骤中找到了，参数resolve又是true的话，那么<code>loadClass()</code>又会调用<code>resolveClass(Class)</code>这个方法来生成最终的Class对象。 我们可以从源代码看出这个步骤。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先，检测是否已经加载</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//父加载器不为空则调用父加载器的loadClass</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//父加载器为空则调用Bootstrap Classloader</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    <span class="comment">//父加载器没有找到，则调用findclass</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            <span class="comment">//调用resolveClass()</span></span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>另外，要注意的是如果要编写一个classLoader的子类，也就是自定义一个classloader，建议覆盖<code>findClass()</code>方法，而不要直接改写<code>loadClass()</code>方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//父加载器不为空则调用父加载器的loadClass</span></span><br><span class="line">    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//父加载器为空则调用Bootstrap Classloader</span></span><br><span class="line">    c = findBootstrapClassOrNull(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-自定义ClassLoader"><a href="#6-自定义ClassLoader" class="headerlink" title="6. 自定义ClassLoader"></a>6. 自定义ClassLoader</h2><p>不知道大家有没有发现，不管是Bootstrap ClassLoader还是ExtClassLoader等，这些类加载器都只是加载指定的目录下的jar包或者资源。如果在某种情况下，我们需要动态加载一些东西呢？比如从D盘某个文件夹加载一个class文件，或者从网络上下载class主内容然后再进行加载，这样可以吗？</p><p>如果要这样做的话，需要我们自定义一个classloader。</p><p><strong>步骤</strong></p><ol><li>编写一个类继承自<code>ClassLoader</code>抽象类。</li><li>复写它的<code>findClass()</code>方法。</li><li>在<code>findClass()</code>方法中调用<code>defineClass()</code>。</li></ol><p>defineClass() 方法 ： 这个方法在编写自定义classloader的时候非常重要，它能将class二进制内容转换成Class对象，如果不符合要求的会抛出各种异常。</p><h3 id="6-1-自定义DiskClassLoader"><a href="#6-1-自定义DiskClassLoader" class="headerlink" title="6.1 自定义DiskClassLoader"></a>6.1 自定义DiskClassLoader</h3><p>假设我们需要一个自定义的classloader,默认加载路径为<code>D:\lib</code>下的jar包和资源。</p><p>我们写编写一个测试用的类文件，Test.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.frank.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Say Hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后将它编译过class文件Test.class放到<code>D:\lib</code>这个路径下。</li></ul><p><code>DiskClassLoader</code> 编写如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String mLibPath;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DiskClassLoader</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">mLibPath = path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">String fileName = getFileName(name);</span><br><span class="line"></span><br><span class="line">File file = <span class="keyword">new</span> File(mLibPath,fileName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">FileInputStream is = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"></span><br><span class="line">ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> ((len = is.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">byte</span>[] data = bos.toByteArray();</span><br><span class="line">        is.close();</span><br><span class="line">        bos.close();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> defineClass(name,data,<span class="number">0</span>,data.length);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.findClass(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取要加载 的class文件名</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getFileName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> index = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line"><span class="keyword">if</span>(index == -<span class="number">1</span>)&#123; </span><br><span class="line"><span class="keyword">return</span> name+<span class="string">".class"</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> name.substring(index+<span class="number">1</span>)+<span class="string">".class"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们在<code>findClass()</code>方法中定义了查找class的方法，然后数据通过<code>defineClass()</code>生成了Class对象。</li></ul><p>现在我们要编写测试代码。我们知道如果调用一个Test对象的say方法，它会输出”Say Hello”这条字符串。但现在是我们把Test.class放置在应用工程所有的目录之外，我们需要加载它，然后执行它的方法。具体效果如何呢？我们编写的DiskClassLoader能不能顺利完成任务呢？我们拭目以待。</p><p><strong>测试代码如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建自定义classloader对象。</span></span><br><span class="line">DiskClassLoader diskLoader = <span class="keyword">new</span> DiskClassLoader(<span class="string">"D:\\lib"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//加载class文件</span></span><br><span class="line">Class c = diskLoader.loadClass(<span class="string">"com.frank.test.Test"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(c != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object obj = c.newInstance();</span><br><span class="line">Method method = c.getDeclaredMethod(<span class="string">"say"</span>,<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//通过反射调用Test类的say方法</span></span><br><span class="line">method.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException </span><br><span class="line">| NoSuchMethodException</span><br><span class="line">| SecurityException | </span><br><span class="line">IllegalArgumentException | </span><br><span class="line">InvocationTargetException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考博客</strong> : <a href="https://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="noopener">https://blog.csdn.net/briblue/article/details/54973413</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-ClassLoader详解&quot;&gt;&lt;a href=&quot;#Java-基础-ClassLoader详解&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-ClassLoader详解&quot;&gt;&lt;/a&gt;Java-基础-ClassLoader详解&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;ClassLoader&lt;/code&gt;翻译过来就是类加载器，普通的java开发者其实用到的不多，但对于某些框架开发者来说却非常常见。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;理解&lt;code&gt;ClassLoader&lt;/code&gt;的加载机制，也有利于我们编写出更高效的代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;ClassLoader&lt;/code&gt;的具体作用就是将class文件加载到jvm虚拟机中去，程序就可以正确运行了。但是，&lt;code&gt;jvm&lt;/code&gt;启动的时候，并不会一次性加载所有的class文件，而是根据需要去动态加载。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;想想也是的，一次性加载那么多jar包那么多class，那内存不崩溃。本文的目的也是学习&lt;code&gt;ClassLoader&lt;/code&gt;这种加载机制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="JVM" scheme="http://zhuuu.work/tags/JVM/"/>
    
      <category term="ClassLoader" scheme="http://zhuuu.work/tags/ClassLoader/"/>
    
      <category term="双亲委派" scheme="http://zhuuu.work/tags/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>JUC-20-ThreadPoolExecutor</title>
    <link href="http://zhuuu.work/2020/08/31/JUC/JUC-20-ThreadPoolExecutor/"/>
    <id>http://zhuuu.work/2020/08/31/JUC/JUC-20-ThreadPoolExecutor/</id>
    <published>2020-08-31T08:02:24.000Z</published>
    <updated>2020-09-20T01:32:27.108Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JUC-20-ThreadPoolExecutor"><a href="#JUC-20-ThreadPoolExecutor" class="headerlink" title="JUC-20-ThreadPoolExecutor"></a>JUC-20-ThreadPoolExecutor</h2><h2 id="1-submit-和-execute"><a href="#1-submit-和-execute" class="headerlink" title="1. submit 和 execute"></a>1. submit 和 execute</h2><ol><li><strong>execute</strong></li></ol><ul><li>这个方法是在<code>Executor</code>接口中定义的，不会返回执行结果，在<code>ThreadPoolExecutor</code> 类中有具体的实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>submit方法</strong></li></ol><ul><li>这个方法是在<code>ExecutorService</code> 接口中定义的，在<code>AbstractExecutorService</code> 类中有具体的实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提交一个Callable</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交一个Runnable</span></span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交一个Runnable并默认值result，在任务执行完毕以后，调用&#123;Future.get()&#125;方法会返回这个默认值</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li><strong>其实最终调用的方法，都是execute方法</strong></li><li><strong>sumbit方法相当于把任务包装了一下，返回的是一个Future句柄，这个句柄其实就是FutureTask对象</strong></li></ul><p><strong>区别</strong></p><ul><li><strong>接收的参数不一样</strong></li><li><strong>submit有返回值，而execute没有</strong></li><li><strong>submit方便Exception处理</strong><ul><li>意思就是如果你在你的task里会抛出<code>checked</code>或者<code>unchecked exception</code>，而你又希望外面的调用者能够感知这些<code>exception</code>并做出及时的处理</li><li>那么就需要用到<code>submit</code>，通过捕获<code>Future.get</code>抛出的异常。</li></ul></li></ul><a id="more"></a><h2 id="2-Callable-和-Runnable"><a href="#2-Callable-和-Runnable" class="headerlink" title="2 . Callable 和 Runnable"></a>2 . Callable 和 Runnable</h2><h3 id="2-1-Runnable"><a href="#2-1-Runnable" class="headerlink" title="2.1 Runnable"></a>2.1 Runnable</h3><ul><li>先说一下<code>java.lang.Runnable</code>吧，它是一个接口，在它里面只声明了一个run()方法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Runnable &#123;</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>由于run()方法返回值为void类型</strong>，所以在执行完任务之后无法返回任何结果。</li></ul><h3 id="2-2-Callable"><a href="#2-2-Callable" class="headerlink" title="2.2 Callable"></a>2.2 Callable</h3><ul><li><code>Callable</code>位于<code>java.util.concurrent</code>包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做<code>call()：</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到，这是一个<strong>泛型接口</strong>，该接口声明了一个名称为call()的方法，同时这个方法可以有返回值V，也可以抛出异常。call()方法返回的类型就是传递进来的V类型。</li></ul><ul><li><strong>那么怎么使用Callable呢？一般情况下是配合ExecutorService来使用的</strong>，在ExecutorService接口中声明了若干个submit方法的重载版本：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个方法：submit提交一个实现Callable接口的任务，并且返回封装了异步计算结果的Future。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个方法：submit提交一个实现Runnable接口的任务，并且指定了在调用Future的get方法时返回的result对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个方法：submit提交一个实现Runnable接口的任务，并且返回封装了异步计算结果的Future。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因此我们只要创建好我们的线程对象（实现Callable接口或者Runnable接口），然后通过上面3个方法提交给线程池去执行即可。</span></span><br></pre></td></tr></table></figure><h2 id="3-Future"><a href="#3-Future" class="headerlink" title="3. Future"></a>3. Future</h2><ul><li><code>Future</code>就是对于具体的<code>Runnable</code>或者<code>Callable</code>任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</li><li><code>Future&lt;V&gt;</code>接口是用来<strong>获取异步计算结果</strong>的，说白了就是对具体的<code>Runnable</code>或者<code>Callable</code>对象任务执行的结果进行获取(get())，取消(<code>cancel()</code>)，判断是否完成等操作。我们看看Future接口的源码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在<strong>Future接口中声明了5个方法</strong>，下面依次解释每个方法的作用：</p><ul><li><p><strong>cancel方法</strong>用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</p></li><li><p><strong>isCancelled方法</strong>表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</p></li><li><p><strong>isDone方法</strong>表示任务是否已经完成，若任务完成，则返回true；</p></li><li><p><strong>get()方法</strong>用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</p></li><li><p><strong>get(long timeout, TimeUnit unit)</strong>用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。</p></li></ul></li></ul><ul><li>也就是说<strong>Future提供了三种功能：</strong></li></ul><p>1）判断任务是否完成；</p><p>2）能够中断任务；</p><p>3）能够获取任务执行结果。</p><p><strong>因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。</strong></p><h2 id="4-FutureTask"><a href="#4-FutureTask" class="headerlink" title="4. FutureTask"></a>4. FutureTask</h2><h3 id="4-1-FutureTask-的-状态"><a href="#4-1-FutureTask-的-状态" class="headerlink" title="4.1 FutureTask 的 状态"></a>4.1 FutureTask 的 状态</h3><ul><li>我们先来看一下FutureTask的实现：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;</span><br></pre></td></tr></table></figure><ul><li><code>FutureTask</code>类实现了<code>RunnableFuture</code>接口，我们看一下<code>RunnableFuture</code>接口的实现：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看出<code>RunnableFuture</code>继承了Runnable接口和Future接口，<ul><li>而FutureTask实现了RunnableFuture接口。所以它<strong>既可以作为Runnable被线程执行，</strong></li><li><strong>又可以作为Future得到Callable的返回值。</strong></li></ul></li></ul><p><strong>分析：</strong></p><ul><li>FutureTask除了实现了Future接口外还实现了Runnable接口，因此FutureTask也可以直接提交给Executor执行。 当然也可以调用线程直接执行（FutureTask.run()）。接下来我们根据FutureTask.run()的执行时机来分析其所处的3种状态：<ul><li><strong>未启动（NEW），</strong>FutureTask.run()方法还没有被执行之前，FutureTask处于未启动状态，当创建一个FutureTask，而且没有执行FutureTask.run()方法前，这个FutureTask也处于未启动状态。</li><li><strong>已启动(Completing)</strong>，<code>FutureTask.run()</code>被执行的过程中，<code>FutureTask</code>处于已启动状态。</li><li><strong>已完成(Normal)，</strong><code>FutureTask.run()</code>方法执行完正常结束，或者被取消或者抛出异常而结束，FutureTask都处于完成状态。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200915/103146074.png" alt="mark"></p><ul><li>下面我们再来看看<code>FutureTask</code>的方法执行示意图（方法和Future接口基本是一样的，这里就不过多描述了）</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200915/103203544.png" alt="mark"></p><p><strong>分析</strong></p><p><strong>get()逻辑</strong></p><ul><li>当FutureTask处于未启动或已启动状态时，如果此时我们执行FutureTask.get()方法将导致调用线程阻塞；</li><li>当FutureTask处于已完成状态时，执行FutureTask.get()方法将导致调用线程立即返回结果或者抛出异常。</li></ul><p><strong>cancel()逻辑</strong></p><ul><li>当FutureTask处于未启动状态时，执行FutureTask.cancel()方法将导致此任务永远不会执行。</li><li>当FutureTask处于已启动状态时，执行cancel(true)方法将以中断执行此任务线程的方式来试图停止任务，如果任务取消成功，cancel(…)返回true；但如果执行cancel(false)方法将不会对正在执行的任务线程产生影响(让线程正常执行到完成)，此时cancel(…)返回false</li><li>当任务已经完成，执行cancel(…)方法将返回false。</li></ul><p><strong>最后我们给出FutureTask的两种构造函数：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-FutureTask的使用"><a href="#4-2-FutureTask的使用" class="headerlink" title="4.2 FutureTask的使用"></a>4.2 FutureTask的使用</h3><ul><li><p>通过上面的介绍，我们对Callable，Future，FutureTask都有了比较清晰的了解了，那么它们到底有什么用呢？我们前面说过通过这样的方式去创建线程的话，<strong>最大的好处就是能够返回结果</strong></p></li><li><p>加入有这样的场景，我们现在需要计算一个数据，而这个数据的计算比较耗时，而我们后面的程序也要用到这个数据结果，那么这个时Callable岂不是最好的选择？</p></li><li><p>我们可以开设一个线程去执行计算，而主线程继续做其他事，而后面需要使用到这个数据时，我们再使用Future获取不就可以了吗？下面我们就来编写一个这样的实例。</p></li></ul><p><strong>1、使用Callable+Future获取执行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子线程在进行计算"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">            sum += i;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//创建Callable对象任务  </span></span><br><span class="line">        Task task = <span class="keyword">new</span> Task();</span><br><span class="line">        <span class="comment">//提交任务并获取执行结果  </span></span><br><span class="line">        Future&lt;Integer&gt; result = executor.submit(task);</span><br><span class="line">        <span class="comment">//关闭线程池  </span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">"主线程在执行任务"</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(result.get()!=<span class="keyword">null</span>)&#123;  </span><br><span class="line">                System.out.println(<span class="string">"task运行结果"</span>+result.get());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"未获取到结果"</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">"所有任务执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">子线程在进行计算</span><br><span class="line">主线程在执行任务</span><br><span class="line">task运行结果<span class="number">4950</span></span><br><span class="line">所有任务执行完毕</span><br></pre></td></tr></table></figure><p><strong>2、使用Callable+FutureTask获取执行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest1</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一种方式</span></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        Task task = <span class="keyword">new</span> Task();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(task);</span><br><span class="line">        executor.submit(futureTask);</span><br><span class="line">        executor.shutdown();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//第二种方式，注意这种方式和第一种方式效果是类似的，只不过一个使用的是ExecutorService，一个使用的是Thread</span></span><br><span class="line"><span class="comment">//        Task task = new Task();</span></span><br><span class="line"><span class="comment">//        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);</span></span><br><span class="line"><span class="comment">//        Thread thread = new Thread(futureTask);</span></span><br><span class="line"><span class="comment">//        thread.start();</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">"主线程在执行任务"</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(futureTask.get()!=<span class="keyword">null</span>)&#123;  </span><br><span class="line">                System.out.println(<span class="string">"task运行结果"</span>+futureTask.get());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"future.get()未获取到结果"</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">"所有任务执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果同上。</p><h3 id="4-3-补充"><a href="#4-3-补充" class="headerlink" title="4.3 补充"></a>4.3 补充</h3><ul><li>Runnable是自从java1.1就有了，而Callable是1.5之后才加上去的。</li><li>Callable规定的方法是call(),Runnable规定的方法是run()。</li><li><strong>Callable的任务执行后可返回值，而Runnable的任务是不能返回值(是void)。</strong></li><li><strong>call方法可以抛出异常，run方法不可以。</strong></li><li>运行Callable的 任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果</li><li><strong>加入线程池运行，Runnable使用Executor的execute方法，Callable使用submit方法。</strong></li></ul><p><a href="https://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3932921.html</a></p><p><strong>参考博客</strong> : <a href="https://blog.csdn.net/leilifengxingmw/article/details/79533006" target="_blank" rel="noopener">https://blog.csdn.net/leilifengxingmw/article/details/79533006</a></p><p>​                    <a href="https://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3932921.html</a></p><p>​                    <a href="https://www.cnblogs.com/xiaoxi/p/8303574.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoxi/p/8303574.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JUC-20-ThreadPoolExecutor&quot;&gt;&lt;a href=&quot;#JUC-20-ThreadPoolExecutor&quot; class=&quot;headerlink&quot; title=&quot;JUC-20-ThreadPoolExecutor&quot;&gt;&lt;/a&gt;JUC-20-ThreadPoolExecutor&lt;/h2&gt;&lt;h2 id=&quot;1-submit-和-execute&quot;&gt;&lt;a href=&quot;#1-submit-和-execute&quot; class=&quot;headerlink&quot; title=&quot;1. submit 和 execute&quot;&gt;&lt;/a&gt;1. submit 和 execute&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;execute&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;这个方法是在&lt;code&gt;Executor&lt;/code&gt;接口中定义的，不会返回执行结果，在&lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 类中有具体的实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Executor&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Runnable command)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;strong&gt;submit方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;这个方法是在&lt;code&gt;ExecutorService&lt;/code&gt; 接口中定义的，在&lt;code&gt;AbstractExecutorService&lt;/code&gt; 类中有具体的实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//提交一个Callable&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;T&amp;gt; &lt;span class=&quot;function&quot;&gt;Future&amp;lt;T&amp;gt; &lt;span class=&quot;title&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Callable&amp;lt;T&amp;gt; task)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//提交一个Runnable&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Future&amp;lt;?&amp;gt; submit(Runnable task);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//提交一个Runnable并默认值result，在任务执行完毕以后，调用&amp;#123;Future.get()&amp;#125;方法会返回这个默认值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;T&amp;gt; &lt;span class=&quot;function&quot;&gt;Future&amp;lt;T&amp;gt; &lt;span class=&quot;title&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Runnable task, T result)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;其实最终调用的方法，都是execute方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sumbit方法相当于把任务包装了一下，返回的是一个Future句柄，这个句柄其实就是FutureTask对象&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;区别&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;接收的参数不一样&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;submit有返回值，而execute没有&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;submit方便Exception处理&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;意思就是如果你在你的task里会抛出&lt;code&gt;checked&lt;/code&gt;或者&lt;code&gt;unchecked exception&lt;/code&gt;，而你又希望外面的调用者能够感知这些&lt;code&gt;exception&lt;/code&gt;并做出及时的处理&lt;/li&gt;
&lt;li&gt;那么就需要用到&lt;code&gt;submit&lt;/code&gt;，通过捕获&lt;code&gt;Future.get&lt;/code&gt;抛出的异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="JUC" scheme="http://zhuuu.work/tags/JUC/"/>
    
      <category term="多线程" scheme="http://zhuuu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程池" scheme="http://zhuuu.work/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>HTTP-HTTPS点开网页原理</title>
    <link href="http://zhuuu.work/2020/08/31/NetworkCoding/HTTP-HTTPS%E7%82%B9%E5%BC%80%E7%BD%91%E9%A1%B5%E5%8E%9F%E7%90%86/"/>
    <id>http://zhuuu.work/2020/08/31/NetworkCoding/HTTP-HTTPS%E7%82%B9%E5%BC%80%E7%BD%91%E9%A1%B5%E5%8E%9F%E7%90%86/</id>
    <published>2020-08-31T03:02:24.000Z</published>
    <updated>2020-09-21T01:01:17.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-HTTPS区别"><a href="#HTTP-HTTPS区别" class="headerlink" title="HTTP-HTTPS区别"></a>HTTP-HTTPS区别</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ul><li><p>安全性上，HTTPS是安全超文本协议，在HTTP基础上有更强的安全性。简单来说，HTTPS是使用TLS/SSL加密的HTTP协议</p></li><li><p>申请证书上，HTTPS需要使用ca申请证书</p></li><li><p>对于抓包而言 ，HTTP是超文本传输协议，明文传输；HTTPS是具有安全性的 SSL 加密传输协议</p></li><li><p>连接方式与端口上，http的连接简单，是无状态的，端口是 80； https 在http的基础上使用了ssl协议进行加密传输，端口是 443</p></li></ul><p><strong>HTTP通信过程</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200919/100535634.png" alt="mark"></p><a id="more"></a><h2 id="2-HTTPS的通信过程"><a href="#2-HTTPS的通信过程" class="headerlink" title="2. HTTPS的通信过程"></a>2. HTTPS的通信过程</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200828-105034140.png" alt="mark"></p><p>https通信时，首先建立ssl层的连接，客户端将ssl版本号和加密组件发到服务器端，服务器端收到后对ssl版本号和加密组件进行匹配，同时将CA证书及密钥发送到客户端。客户端对证书进行验证，验证通过后使用非对称加密对数据通信时的密钥进行协商。协商后得到一致的获得一致的对称加密密钥。然后使用对称加密算法进行TCP连接，后续的过程跟http的过程一致。三次握手，数据交换，四次挥手，通信结束。</p><p>过程如下 ：</p><ol><li>客户端和服务器端通过TCP建立连接。</li><li>客户端向服务器发送HTTPS请求。</li><li>服务器响应请求，并将数字证书发送给客户端，数字证书包括公共秘钥、域名、申请证书的公司。</li><li>客户端收到服务器端的数字证书之后，会验证数字证书的合法性。</li><li>如果公钥合格，那么客户端会生成一个用于进行对称加密的密钥client key，并用服务器的公钥对客户端密钥进行非对称加密。</li><li>客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。</li><li>服务器接收到客户端发来的密文之后，会用私钥对其进行非对称解密，得到客户端秘钥。并使用客户端秘钥进行对称加密，生成密文并发送。</li><li>客户端收到密文，并使用客户端秘钥进行解密，渲染网页。</li></ol><h2 id="3-HTTP的工作过程详解"><a href="#3-HTTP的工作过程详解" class="headerlink" title="3. HTTP的工作过程详解"></a>3. HTTP的工作过程详解</h2><p><strong>总结</strong></p><p>HTTP由请求和响应构成，是一个标准的客户端服务器模型（C/S）。HTTP协议永远都是客户端发起请求，服务器回送响应。</p><ol><li>地址解析。域名系统DNS解析域名得到主机的IP地址</li><li>封装HTTP请求数据包。封装的内容有以上部分结合本机自己的信息。</li><li>封装成TCP包，建立TCP连接（TCP的三次握手）</li><li>客户机发送请求命令。 建立连接后，客户机向服务器发送一个请求</li><li>服务器响应。服务器接到请求后，给予相应的响应信息</li><li>服务器关闭TCP连接。一般Web服务器向浏览器发送了请求数据，它要关闭TCP连接</li><li>客户端解析报文，解析HTML代码，并渲染</li></ol><h3 id="3-1-DNS过程（应用层）"><a href="#3-1-DNS过程（应用层）" class="headerlink" title="3.1 DNS过程（应用层）"></a>3.1 DNS过程（应用层）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">其实我们在浏览器中输入URL的时候，浏览器就会开始智能的匹配可能URL，浏览器会从历史记录，书签等地方，找到你已经输入的字符串可能对应的URL，然后给出智能提示</span><br><span class="line"></span><br><span class="line">在输好URL后我们会按下Enter键，浏览器会发起请求，如果URL是域名而不是IP地址，将进行域名解析，所谓域名解析是指什么呢？</span><br><span class="line"></span><br><span class="line">IP地址是网络上标识站点的数字地址，为了方便记忆，采用域名来代替IP地址标识站点地址，域名解析就是域名到IP地址的转换过程。</span><br><span class="line">域名解析按下面的步骤进行（部分内容涉及到计算机网络知识）：</span><br><span class="line"></span><br><span class="line">我们本地硬盘下有一个hosts(windows下路径为C:\Windows\System32\drivers\etc)文件，作用是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”。一般来说，系统会首先自动从hosts文件中寻找对应的IP地址，如果有的话就直接使用hosts文件里面的IP地址，然后直接进行端口确认</span><br><span class="line">如果上一步没有找到，浏览器将调用解析程序，并成为DNS服务器的一个客户，把待解析的域名放在DNS请求报文中，以UDP用户数据报的方式发给本地DNS服务器</span><br><span class="line">如果本地DNS服务器查找到相应的域名的IP地址，就把对应的IP地址放在回答报文中返回</span><br><span class="line">如果上一步没有找到，即本地DNS服务器不知道被查询域名的IP地址，由于主机向本地DNS服务器的查询是递归查询，所以此时，本地DNS服务器就会以DNS客户的身份向其他根DNS服务器继续发出查询请求报文。本地DNS服务器向根DNS服务器的查询是迭代查询，当找到相应域名的IP地址后，就会把这个结果返回给最初发起查询请求的浏览器</span><br><span class="line"></span><br><span class="line">递归查询：在该模式下DNS服务器接收到客户机请求，必须返回一个准确的查询结果给客户机。如果该DNS服务器本地没有存储被查询的DNS信息，那么该服务器会（替客户机）询问其他服务器，并将返回的查询结果再返回给客户机。</span><br><span class="line">迭代查询：在该模式下DNS服务器接收到客户机请求，如果该DNS服务器本地没有存储被查询的DNS信息，DNS服务器会向客户机提供其他能够解析查询请求的DNS服务器地址，让客户机再向这台DNS服务器提交请求，依次循环直到返回查询的结果为止。</span><br><span class="line">经过上面的步骤后，浏览器已经获得输入域名的IP地址，可以进行下一步了。</span><br></pre></td></tr></table></figure><h3 id="3-2-发起请求建立连接-传输层"><a href="#3-2-发起请求建立连接-传输层" class="headerlink" title="3.2 发起请求建立连接(传输层)"></a>3.2 发起请求建立连接(传输层)</h3><ul><li>浏览器得到<code>IP</code>地址并确认端口后，会向目标服务器发起<code>HTTP</code>请求，<code>HTTP</code>请求是通过<code>TCP</code>连接来发送的(如果是<code>HTTPS</code>则需要先建立SSL连接，再是<code>TCP</code>连接，下面的讨论基于<code>HTTP</code>)，具体如下<ul><li><strong>浏览器会生成目标服务器的<code>HTTP</code>请求报文</strong>，<strong>请求报文一般包含请求方法、请求<code>URI</code>、协议版本、请求首部字段等内容，<code>HTTP</code>请求准备好后，<code>HTTP</code>请求报文从应用层传到传输层后会被分割为报文段，并会发起一条到达目标服务器的<code>TCP</code>连接，开始<code>TCP</code>三次握手</strong>，过程如图所示：</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200919/101827387.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通俗的可以理解为：</span><br><span class="line"></span><br><span class="line">A主动向B打电话：嗨，能听到吗（SYN&#x3D;1，seq&#x3D;x），然后A就开始等待B的回答（SYN-SENT状态），此时A不知道B能不能听到</span><br><span class="line">B听到A的话之后，可以确认它能听到A，但是它还要确认一下A能不能听到他自己的声音，于是B说：我能听到你的声音（ACK&#x3D;1，ack&#x3D;x+1），你能听到我的声音吗（SYN&#x3D;1,seq&#x3D;y），然后B开始等待A的恢复（SYN-RECD状态）</span><br><span class="line">A听到B的话之后，A可以确认两件事，一是B能听到它说话，二是它也能听到B说话，A已经可以随时说话和倾听了（ESTABLISHED状态）。但是此时的B还在等待中，并不知道A能不能听到，所以此时A需要再回复B说：我可以听到你的声音（ACK&#x3D;1，ack&#x3D;y+1）,开始愉快的聊天吧~（seq&#x3D;x+1），B听到这句话后便也可以随时说话和倾听了（ESTABLISHED状态）</span><br><span class="line">之后两个人就可以balabalabala....</span><br></pre></td></tr></table></figure><ul><li><code>HTTP</code>请求的请求报文是直接附在第三次握手的消息中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">穿插补充小知识，为什么是三次握手，而不是两次四次？</span><br><span class="line"></span><br><span class="line">在《计算机网络》一书中也有讲过这个问题，给出的解释是：三次握手是为了防止失效的连接请求报文段被服务端接收，从而产生错误。具体例子如下所述：</span><br><span class="line">client发出的一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。</span><br><span class="line">假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。但是由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。而server却以为新的连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。</span><br><span class="line">采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接</span><br></pre></td></tr></table></figure><h3 id="3-3-封装成IP数据包（网络层）"><a href="#3-3-封装成IP数据包（网络层）" class="headerlink" title="3.3 封装成IP数据包（网络层）"></a>3.3 封装成IP数据包（网络层）</h3><ul><li>连接建立之后，开始进行数据传输，虽然浏览器知道目标服务器的<code>IP</code>和端口，但是数据总不可能飞过去吧？<code>HTTP</code>请求报文段会从传输层传到网络层，在网络层被封装成<code>IP</code>数据包，网络层规定了通过怎样的路径（所谓的传输路线）到达目标服务器，并把数据包传送给对方。</li></ul><h3 id="3-4-封装成帧-（数据链路层）"><a href="#3-4-封装成帧-（数据链路层）" class="headerlink" title="3.4 封装成帧 （数据链路层）"></a>3.4 封装成帧 （数据链路层）</h3><ul><li>网络层封装好的<code>IP</code>数据包会进一步传到下一层 — 数据链路层，然后会再次被封装到<code>MAC</code>数据帧结构中</li><li>由于<code>IP</code>地址间的通信依赖于<code>MAC</code>地址（网卡所属的固定地址），所以<code>MAC</code>数据帧结构中会有经过<code>ARP</code>协议解析后的<code>MAC</code>地址（不一定是目标服务器的<code>MAC</code>地址，因为实际上通信的双方在同一局域网（LAN）内的情况是很少的，一般都会经过路由中转）。</li></ul><h3 id="3-5-传输比特流-（物理层）"><a href="#3-5-传输比特流-（物理层）" class="headerlink" title="3.5 传输比特流 （物理层）"></a>3.5 传输比特流 （物理层）</h3><ul><li>数据链路层的<code>MAC</code>数据帧再向下传，便会到达物理层，这里要注意<strong><em>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体\</em></strong>。 物理层需要确保原始的数据可在各种物理媒体上传输，它规定了传输媒体的机械特性、电气特性、功能特性、过程特性</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200919/103108545.png" alt="mark"></p><ul><li>常见的传输媒体有双绞线、电缆、光缆、无线信道等，物理层的任务就是要让数据在这些传输媒体上都能能进行传输</li></ul><h3 id="3-6-服务端的逆操作"><a href="#3-6-服务端的逆操作" class="headerlink" title="3.6 服务端的逆操作"></a>3.6 服务端的逆操作</h3><ul><li><p>通过<code>MAC</code>地址匹配，数据通过传输媒体到达目标服务器的物理层，物理层接收数据比特流然后向上传送到服务器的数据链路层，在数据链路层<code>MAC</code>数据帧将进行封装的逆操作，还原成<code>IP</code>数据包之后向上传送到网络层，网络层也进行封装的逆操作还原成<code>HTTP</code>请求报文段（分割后的一小段一小段的），然后这些报文段向上传到传输层，在传输层按原来的序号重新组装成完整的<code>HTTP</code>请求报文，再向上传到应用层，应用层的<code>HTTP</code>协议便会开始对请求进行处理</p></li><li><p>这个处理可能是直接返回静态的资源，也可能经过<code>PHP</code>、<code>JAVA</code>等语言进行处理等，等处理完成后，会返回一个<code>HTTP</code>响应，它生成一个<code>HTTP</code>响应报文，与<code>HTTP</code>请求报文结构类似，然后这个响应报文会“走过”请求报文来时的路到达浏览器</p></li></ul><h3 id="3-7-客户端的释放链接"><a href="#3-7-客户端的释放链接" class="headerlink" title="3.7 客户端的释放链接"></a>3.7 客户端的释放链接</h3><ul><li>浏览器接收<code>HTTP</code>响应，<strong>然后有可能释放<code>TCP</code>连接，也有可能重新使用这个<code>TCP</code>连接发送新的请求（持久连接）</strong>，此处了解一下<code>TCP</code>连接的释放，不同于<code>TCP</code>连接建立的三次握手，<code>TCP</code>连接的释放是四次挥手，客户端和服务器端都可以发起关闭请求，也存在两者同时发起关闭请求的情况，图中为客户端A主动发起关闭请求：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200919/103323033.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">同样通俗的解释一波：</span><br><span class="line"></span><br><span class="line">A对B要传的文件已经传完了，于是他对B说：我要传的文件已经传完了，我要准备下线了（seq&#x3D;u，FIN&#x3D;1）。然后A就等待B的回复（FIN-WAIT-1状态）</span><br><span class="line"></span><br><span class="line">B看到A的消息后，回复A说：知道了，但是我还有文件给你（ACK&#x3D;1,ack&#x3D;u+1,seq&#x3D;v）。B进入等他文件传完的状态（CLOSE-WAIT状态）。</span><br><span class="line">A收到B的回复之后，下线不了了，于是继续等待着B的文件传完（FIN-WAIT-2状态）</span><br><span class="line"></span><br><span class="line">几分钟后，B的文件传完了，此时他对A说：我的文件传完了，我也要下线了（seq&#x3D;w,FIN&#x3D;1,ACK&#x3D;1,ack&#x3D;u+1），然后B等待A的回复来确认真的可以下线了（LAST-ACK状态）</span><br><span class="line"></span><br><span class="line">A收到B的回复后，便对A说：好的，那你下线吧（ACK&#x3D;1，seq&#x3D;u+1,ack&#x3D;w+1）。此时A会等待一段时间（2MSL，TIME-WAIT状态），B收到后就直接下线了（CLOSE状态），然后2MSL时间到了之后，A也下线（CLOSE状态）</span><br></pre></td></tr></table></figure><p><strong>几个小问题</strong></p><ul><li><strong>为什么服务器B在接到A的断开请求时不立即同意断开？</strong><ul><li>当服务器B收到断开连接的请求时，服务器可能仍然有数据未发送完毕，所以服务器先发送确认信号，等所有数据发送完毕后再同意断开</li></ul></li></ul><ul><li><strong>为什么是四次挥手，而不是像建立连接一样的三次</strong><ul><li>因为<code>TCP</code>连接是全双工模式，服务器B收到A的断开请求时，仅仅表明A没有东西传给服务器B了，但此时服务器B可能向A的传输还没结束，所以服务器B要先给A一个确认收到A的断开请求的<code>ACK</code>报文，然后继续向A把信息传完，等传完之后服务器B再向A发送断开请求的报文段，等A收到并回复<code>ACK</code>报文后再释放连接。</li><li>也就是说对于A来说他要发送请求给B并等待B确认，对于B来说也要发送请求给A并等待A确认，两者都经过这两个过程才能完全释放<code>TCP</code>连接，而非单方面的释放。<br>建立连接只需要建立，没有<strong>数据</strong>的影响，而释放连接还要考虑数据是否传输完，所以建立连接的时候B确认收到A的建立请求与B发送建立请求这一步可以合成一步成为<code>TCP</code>建立连接的第二次握手，而释放连接时却必须分开。</li></ul></li></ul><ul><li><strong>最后一次握手后A为什么要等<code>2MSL</code>？</strong><br><strong>首先解释一下<code>MSL</code>，<code>MSL</code>是指最长报文段寿命</strong>，RFC793建议为两分钟，但实际上可据实际情况而定，也就是说一个报文段最久可存在的时间是<code>MSL</code></li></ul><ol><li>这是为了保证A发送的最后一个<code>ACK</code>报文能够到达服务器B，如果这个<code>ACK</code>报文丢失了，服务器B没有收到，B会超时重传第三次握手的<code>FIN+ACK</code>报文给A，这个时候处于等待的A就可以收到这个重传的<code>FIN+ACK</code>报文，并再次发送<code>ACK</code>报文给服务器B，并且重新启动2MSL计时器，最终结果是A和B都正常进入CLOSE状态。如果A发完<code>ACK</code>报文后就直接释放了A–&gt;B的连接，那么A就收不到B重传的<code>FIN+ACK</code>报文，也不能重新发送ACK`报文，那么B就无法按正常步骤释放B–&gt;A的连接</li><li>防止“已失效的连接请求报文”出现在下一个新的连接中，因为一个报文段的寿命是<code>MSL</code>，所以A在发送完最后一个<code>ACK</code>报文段之后，再经过时间2<code>MSL</code>，本连接持续的时间内所产生的所有报文段都将在网络中消失，这样这些旧的报文段便不会出现在下一个新的连接中</li></ol><h3 id="3-8-浏览器的加载过程"><a href="#3-8-浏览器的加载过程" class="headerlink" title="3.8 浏览器的加载过程"></a>3.8 浏览器的加载过程</h3><p>浏览器之后会检查<code>HTTP</code>的响应状态，主要通过响应码来判断</p><blockquote><p>1xx: 表示通知信息的，比如请求收到了或正在处理<br>2xx：表示成功，操作被成功接收并处理<br>3xx：表示重定向，一般完成请求还必须采取进一步的行动<br>4xx：表示客户端的差错<br>5xx：表示服务器的差错</p></blockquote><ul><li><p>如果响应可缓存，浏览器将把响应存入缓存</p></li><li><p>浏览器根据<code>HTTP</code>报头信息解码响应，决定如何处理这些响应，并展现响应，以响应为一个<code>HTML</code>为例</p></li><li><p>浏览器开始自上而下，自左而右的加载<code>HTML</code>文档，最开始会遇到<code>&lt;!DOCTYPE&gt;</code>声明，然后根据<code>&lt;!DOCTYPE&gt;</code>声明浏览器就知道该用哪种规范来解析这个文档</p></li><li><p>再继续边加载边解析，边生成<code>DOM</code>树，加载过程中遇到外部<code>CSS</code>文件，浏览器便会另外发出一个请求，来获取<code>CSS</code>文件（过程和上面说的一样），获取<code>CSS</code>后会生成<code>CSS Rule</code>树。<code>DOM</code>树和<code>CSS Rule</code>树生成<code>Render</code>树，页面可以开始边加载边渲染了</p><ul><li>渲染树和<code>DOM</code>树的关系：那些不可见的<code>DOM</code>元素（如<code>&lt;head&gt;…&lt;/head&gt;</code>，<code>display=none</code>的元素）不会被插入渲染树中；还有像一些节点是绝对定位或浮动，这些节点会在文本流之外，因此他们会在渲染树和<code>DOM</code>树的不同位置，渲染树标识出真实的位置，并用一个占位结构标识出他们原来的位置，而<code>DOM</code>树上是他们原来的位置</li><li>渲染包含”布局”（<code>layout</code>）和”绘制”（<code>paint</code>）这两个步骤，所谓”布局”是指给出每个<code>DOM</code>节点在浏览器窗口中的准确位置，”绘制”是指遍历<code>Render</code>树将布局好的<code>DOM</code>节点绘制在屏幕上。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200919/105633907.png" alt="mark"></p><ul><li><p>浏览器继续加载渲染，如果遇到<code>＜script＞</code>标签，浏览器会立即执行（暂不考虑<code>defer</code>及<code>async</code>属性），此时会出现页面阻塞，不仅要等待文档中<code>JS</code>文件下载加载完毕，还要等待<code>JS</code>解析执行完毕，才可以恢复<code>HTML</code>文档的加载解析。</p><ul><li>这是浏览器为了防止出现<code>JS</code>修改<code>DOM</code>树，需要重新构建<code>DOM</code>树的情况，<code>DOM</code>树改变浏览器需要回过头来重新渲染这部分代码，所以浏览器希望通过阻塞其他内容的下载和呈现，来避免出现更多的不必要的<code>Reflow</code>（称为回流或者重排）</li><li>如果<code>&lt;script&gt;</code>放在的<code>&lt;head&gt;</code>中，则<code>&lt;body&gt;</code>标签无法被加载，那么页面自然就无法渲染了,因此这将导致在该<code>JS</code>代码完全执行完之前，页面都是一片空白，用户体验非常不好，一般我看到长时间的空白页面，我都非常想直接关闭它。因此会推荐将所有<code>&lt;script&gt;</code>标签尽可能放到<code>&lt;body&gt;</code>标签的底部，以尽量减少对整个页面下载的影响，此时虽然还会存在一个脚本阻塞另一个脚本的问题，但是用户体验比上面的好很多，因为用户看到了大部分内容，而不是空白</li><li><code>defer</code>属性相当于告诉浏览器立即下载，延迟执行。它使得加载后续文档元素的过程将和<code>JS</code>文件的<strong>加载</strong>并行进行（异步），但是<code>JS</code>文件的<strong>执行</strong>要在整个页面解析完成之后，<code>DOMContentLoaded</code>事件触发之前完成，执行顺序为出现的先后顺序。（高程中指出现实中不一定会按照顺序执行，也不一定会在<code>DOMContentLoaded</code>事件触发之前完成，因此最好只包含一个延迟脚本，这可能是与浏览器的实现有关，具体什么情况下会出现我还不知道？？？）</li><li><code>async</code>属性相当于告诉浏览器立即下载执行，并且页面的加载渲染不需要等待该脚本加载和执行，它们两者会异步进行。标记为<code>async</code>的脚本不会按照它们出现的先后顺序执行，而是谁先下载完了谁就先执行，它们一定会在页面的<code>load</code>事件触发之前执行，但可能会在<code>DOMContentLoaded</code>事件触发之前或之后执行。基于前面所说的一点原因，异步脚本最好不要修改<code>DOM</code>，如果由多个异步脚本，它们之间最好没有依赖关系</li></ul></li><li><p>浏览器继续加载渲染，如果遇到图片资源，浏览器也会另外发出一个请求，来获取图片资源，这是异步请求，所以不会等到图片下载完，而是继续渲染后面的<code>HTML</code>文档。</p></li><li><p>等到服务器返回图片文件，如果先前并没有为这个图片设定宽高，那么由于图片占用了一定面积，影响了后面段落的排布，浏览器会进行<code>Reflow</code></p></li><li><p>然后然后终于和<code>＜/html＞</code>碰面了，此次的页面加载渲染过程完成，浏览器也是很累了，然后会立即触发<code>DOMContentLoaded</code>事件，该事件是在形成完整的<code>DOM</code>树之后就会触发，而不会理会图像、<code>JS</code>文件、<code>CSS</code>文件或其他资源是否已经下载完毕</p></li><li><p>当页面完全加载后，也就是所有图像、<code>JS</code>文件、<code>CSS</code>文件等外部资源都加载完成后会触发<code>load</code>事件</p></li><li><p>用户在页面上进行交互时，可能会导致页面进行<code>Repaint</code>或<code>Reflow</code></p><ul><li><code>Repaint</code>：如果只是改变了某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的<code>Repaint</code>，重绘某一部分</li><li><code>Reflow</code>：如果某个部分发生了的变化影响了布局，那浏览器就需要倒回去重新渲染，每次<code>Reflow</code>必然会导致<code>Repaint</code></li></ul></li></ul><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><ul><li>看似简单的操作背后藏着数不清的小动作，文中也只是涉及了一部分，还有很多相关的过程没有涉及到，但是能力有限，还是慢慢来，暂时就先告一段落</li></ul><p><strong>参考博客 ：</strong> </p><p><a href="https://segmentfault.com/a/1190000014620172" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014620172</a></p><p><a href="https://www.cnblogs.com/chengxs/p/11039155.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxs/p/11039155.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTTP-HTTPS区别&quot;&gt;&lt;a href=&quot;#HTTP-HTTPS区别&quot; class=&quot;headerlink&quot; title=&quot;HTTP-HTTPS区别&quot;&gt;&lt;/a&gt;HTTP-HTTPS区别&lt;/h1&gt;&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安全性上，HTTPS是安全超文本协议，在HTTP基础上有更强的安全性。简单来说，HTTPS是使用TLS/SSL加密的HTTP协议&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;申请证书上，HTTPS需要使用ca申请证书&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于抓包而言 ，HTTP是超文本传输协议，明文传输；HTTPS是具有安全性的 SSL 加密传输协议&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;连接方式与端口上，http的连接简单，是无状态的，端口是 80； https 在http的基础上使用了ssl协议进行加密传输，端口是 443&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;HTTP通信过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200919/100535634.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="网络编程" scheme="http://zhuuu.work/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="网页原理" scheme="http://zhuuu.work/tags/%E7%BD%91%E9%A1%B5%E5%8E%9F%E7%90%86/"/>
    
      <category term="HTTP" scheme="http://zhuuu.work/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-347-前K个高频元素</title>
    <link href="http://zhuuu.work/2020/08/29/Leetcode/Leetcode-347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"/>
    <id>http://zhuuu.work/2020/08/29/Leetcode/Leetcode-347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</id>
    <published>2020-08-29T07:51:53.000Z</published>
    <updated>2020-09-26T08:29:18.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-347-Top-K-Frequent-Elements"><a href="#Leecode-347-Top-K-Frequent-Elements" class="headerlink" title="Leecode-347-Top K Frequent Elements"></a>Leecode-347-<a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">Top K Frequent Elements</a></h1><h2 id="思路：堆"><a href="#思路：堆" class="headerlink" title="思路：堆"></a>思路：堆</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非空的整数数组，返回其中出现频率前 <strong>k</strong>高的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</span><br><span class="line">输出: [1,2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [1], k &#x3D; 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure><ul><li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li><li>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</li><li>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</li><li>你可以按任意顺序返回答案。</li></ul><a id="more"></a><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>这里题目描述中对时间复杂度做出了要求 ，需要在 O(n log n)的限制。</li></ul><p><strong>Solution : 粗暴排序法</strong></p><ul><li>最简单粗暴的思路就是 <strong>使用排序算法对元素按照频率由高到低进行排序</strong>，然后再取前 k 个元素。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200530/150737778.png" alt="mark"></p><ul><li>可以发现，使用常规的诸如冒泡，选择，甚至快速排序都不满足要求，它们的时间复杂度要求必须优于O(nlogn)</li></ul><ul><li><p><strong>时间复杂度：O(nlogn)</strong>，n 表示数组长度。首先，遍历一遍数组统计元素的频率，这一系列操作的时间复杂度是 O(n)；接着，排序算法时间复杂度为 O(nlogn)；因此整体时间复杂度为 O(nlogn)。</p></li><li><p><strong>空间复杂度：O（n）</strong> ，需要Map来存储n个键值对</p></li></ul><p><strong>接下来我们介绍遇到TopK问题最常用的方法：最大堆或者最小堆</strong></p><p><strong>本题使用的是最小堆</strong></p><p><strong>Solution : 最小堆</strong></p><ul><li>题目最终需要返回的是前k个频率最大的元素。可以想到借助堆这种数据结构，对于k频率之后的元素不用再去处理，进一步优化时间复杂度</li><li>举个例子：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200530/151221418.png" alt="mark"></p><p>具体的操作流程为：</p><ul><li><p>借助<strong>哈希表</strong>来建立数字和其出现次数之间的映射，遍历一遍数组统计元素的频率</p></li><li><p>维护一个元素数目是 k 的最小堆</p></li><li><p>每次都将新的元素和堆顶元素（堆中频率最小的元素）进行比较</p></li><li><p>如果新的元素频率比堆顶的元素大，则弹出堆顶的元素，将新的元素添加进堆中</p></li><li><p>最终，堆中的K个元素就是前 k 个高频元素。</p></li></ul><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><strong>Solution :</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 统计每个元素出现的次数，元素为键，元素出现的次数为值</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计每个元素出现的次数，元素为键，元素出现的次数为值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(num))&#123;</span><br><span class="line">                map.put(num,map.get(num) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(num,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造最小堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a, Integer b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> map.get(a) - map.get(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次将新的元素和堆顶元素（堆中频率最小的元素）进行比较</span></span><br><span class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &lt; k)&#123;</span><br><span class="line">                pq.add(key);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (map.get(key) &gt; map.get(pq.peek()))&#123;</span><br><span class="line">                pq.remove();</span><br><span class="line">                pq.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出最小堆中的元素</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty())&#123;</span><br><span class="line">            res.add(pq.remove());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>简便写法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 1. 统计每个元素出现的次数，元素作为key，元素出现的次数作为值</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 构造一个k个元素的小顶堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b) -&gt; map.get(a) - map.get(b));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.每次将新的元素和堆顶的元素比较（堆中频率最小的元素进行比较）</span></span><br><span class="line">        <span class="keyword">for</span>(Integer key:map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &lt; k)&#123;</span><br><span class="line">                pq.offer(key);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(map.get(key) &gt; map.get(pq.peek()))&#123;</span><br><span class="line">                pq.remove();</span><br><span class="line">                pq.offer(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 取出最小堆的元素</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            res[index++] = pq.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度：O(nlogk)</strong>，n 表示数组的长度。首先，遍历一遍数组统计元素的频率，这一系列操作的时间复杂度是 O(n)；接着，遍历用于存储元素频率的 map，如果元素的频率大于最小堆中顶部的元素，则将顶部的元素删除并将该元素加入堆中，这里维护堆的数目是 k，所以这一系列操作的时间复杂度是O(nlogk) 的；因此，总的时间复杂度是 O(nlog⁡k)。</li><li><strong>空间复杂度：O(n)</strong>，最坏情况下（每个元素都不同），map 需要存储 n 个键值对，优先队列需要存储 k 个元素，因此，空间复杂度是 O(n)。</li></ul><p><strong>手动使用小顶堆实现TopK</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] tree,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        buildHeap(tree, n);<span class="comment">//第一步是将得到的数组构建成小顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            swap(tree, i, <span class="number">0</span>);<span class="comment">//第一次构建完小顶堆之后，要进行第一个数和最后一个树的交换</span></span><br><span class="line">            <span class="comment">//交换完之后，最上面的数就不是最小数了，因此只需要对最上面的数，进行一个树的调整即可</span></span><br><span class="line">            <span class="comment">//所以，我们使用的时adjustTree而不是buildHeap</span></span><br><span class="line">            adjustTree(tree, i, <span class="number">0</span>);<span class="comment">//这里解释一下，这参数的含义：之所以将i当做数组的长度，</span></span><br><span class="line">            <span class="comment">//是因为我们将第一个数和最后一个数交换之后，就已经把最小的数放在了数组最后，进行</span></span><br><span class="line">            <span class="comment">//树调整的时候，就不需要管最后一个数字了。而0就是因为交换之后需要进行节点调节的那个节点</span></span><br><span class="line">            <span class="comment">//换到了第一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这个函数写完之后，就可以将任意一个数组，构建成小顶堆了，构建完小顶堆之后，就要进行堆排序了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] tree,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = (n-<span class="number">1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--) &#123;<span class="comment">//i从最后一个子节点的父节点开始，所以i = (n-1)/2</span></span><br><span class="line">            adjustTree(tree, n, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用adjustTree和swap两个函数，可以针对某一个父节点，进行调节。接下来，解决当整个树是</span></span><br><span class="line">    <span class="comment">//乱序的，将一个树构建成一个小顶堆。思路是这样的：从最后一个子节点的父节点开始调节，往上走。</span></span><br><span class="line">    <span class="comment">//不断重复，每往上一个父节点，父节点的下标就减一，可以将adjustTree和swap函数放进一个for循环</span></span><br><span class="line">    <span class="comment">//就是上面的for循环</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 表示从某一个节点开始，调整一次树，使之成为堆，其中i表示某一个节点的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustTree</span><span class="params">(<span class="keyword">int</span>[] tree,<span class="keyword">int</span> n,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=n) &#123;<span class="comment">//这是递归头。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//首先确定i节点的左右两个孩子的下标</span></span><br><span class="line">        <span class="keyword">int</span> c1 = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c2 = <span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//接下来，在这三个值中，找出最小值</span></span><br><span class="line">        <span class="keyword">int</span> max = i;<span class="comment">//先假设最小值为这个父节点</span></span><br><span class="line">        <span class="keyword">if</span>(c1&lt;n &amp;&amp; tree[c1]&gt;tree[max]) &#123;<span class="comment">//要保证c1不会出界</span></span><br><span class="line">            max = c1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c2&lt;n &amp;&amp; tree[c2]&gt;tree[max]) &#123;<span class="comment">//保证c2不会出界  c2&lt;n</span></span><br><span class="line">            max = c2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//经过上面的条件判断，就可以将最小值的下标保存到max中了，如果最小值max就是i，也就是</span></span><br><span class="line">        <span class="comment">//父节点最小，就不用调整，但是如果父节点不是最小，就要进行交换了</span></span><br><span class="line">        <span class="keyword">if</span>(max!=i) &#123;</span><br><span class="line">            swap(tree,max,i);</span><br><span class="line">            adjustTree(tree,n,max);<span class="comment">//交换之后，将父节点下放一级，就有可能会破坏下一层结构，</span></span><br><span class="line">            <span class="comment">//所以，递归调用adjustTree.使用递归之后，就要添加递归头了</span></span><br><span class="line">        &#125;              </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] tree, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = tree[i];</span><br><span class="line">        tree[i] = tree[j];</span><br><span class="line">        tree[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopK</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">32</span>, <span class="number">56</span>, <span class="number">23</span>, <span class="number">87</span>, <span class="number">32</span>&#125;;<span class="comment">//原始数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] topk = topK(data, <span class="number">5</span>);<span class="comment">//调用topK方法，返回前k大的数组，返回的数组并不是有序的，而是一个小顶堆，如果想返回一个有序的，可以调用上面HeapSort类中的heapSort方法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; topk.length; i++) &#123;<span class="comment">//循环输出小顶堆</span></span><br><span class="line">            System.out.println(topk[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] topK(<span class="keyword">int</span>[] data, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] topk = <span class="keyword">new</span> <span class="keyword">int</span>[k];<span class="comment">//根据传进来的K创建长度为k的数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            topk[i] = data[i];<span class="comment">//先将源数据的前k个的数赋值给topK数组</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HeapSort.buildHeap(topk, k);<span class="comment">//对这个topK数组进行一次最小堆的构建。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; data.length; i++) &#123;<span class="comment">//从源数据的第K个数开始循环，如果循环的数比堆顶元素还小，直接pass，</span></span><br><span class="line">            <span class="comment">// 如果比堆顶元素要大，就将此数放在堆顶，同时进行一次以它为起始点的树的调整。</span></span><br><span class="line">            <span class="keyword">int</span> temp = data[i];</span><br><span class="line">            <span class="keyword">if</span> (topk[<span class="number">0</span>] &lt; temp) &#123;</span><br><span class="line">                topk[<span class="number">0</span>] = temp;</span><br><span class="line">                HeapSort.adjustTree(topk, k, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> topk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-347-Top-K-Frequent-Elements&quot;&gt;&lt;a href=&quot;#Leecode-347-Top-K-Frequent-Elements&quot; class=&quot;headerlink&quot; title=&quot;Leecode-347-Top K Frequent Elements&quot;&gt;&lt;/a&gt;Leecode-347-&lt;a href=&quot;https://leetcode-cn.com/problems/top-k-frequent-elements/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Top K Frequent Elements&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：堆&quot;&gt;&lt;a href=&quot;#思路：堆&quot; class=&quot;headerlink&quot; title=&quot;思路：堆&quot;&gt;&lt;/a&gt;思路：堆&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个非空的整数数组，返回其中出现频率前 &lt;strong&gt;k&lt;/strong&gt;高的元素。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: nums &amp;#x3D; [1,1,1,2,2,3], k &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: nums &amp;#x3D; [1], k &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [1]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ul&gt;
&lt;li&gt;你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。&lt;/li&gt;
&lt;li&gt;你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。&lt;/li&gt;
&lt;li&gt;题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。&lt;/li&gt;
&lt;li&gt;你可以按任意顺序返回答案。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="TopK算法题" scheme="http://zhuuu.work/tags/TopK%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Linux-11-磁盘调度算法</title>
    <link href="http://zhuuu.work/2020/08/29/Linux/Linux-11-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <id>http://zhuuu.work/2020/08/29/Linux/Linux-11-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</id>
    <published>2020-08-29T03:22:53.000Z</published>
    <updated>2020-11-01T03:20:55.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-11-磁盘调度算法"><a href="#Linux-11-磁盘调度算法" class="headerlink" title="Linux-11-磁盘调度算法"></a>Linux-11-磁盘调度算法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/144348215.png" alt="mark"></p><a id="more"></a><h2 id="1-磁盘结构"><a href="#1-磁盘结构" class="headerlink" title="1. 磁盘结构"></a>1. 磁盘结构</h2><ul><li>常见的机械磁盘是上图左边的样子，中间圆的部分是磁盘的盘片，一般会有多个盘片，每个盘面都有自己的磁头。</li><li>右边的图就是一个盘片的结构，盘片中的每一层分为多个磁道，每个磁道分多个扇区，每个扇区是 <code>512</code> 字节。</li><li>那么，<strong>多个具有相同编号的磁道形成一个圆柱</strong>，称之为磁盘的柱面，如上图里中间的样子。</li></ul><p>磁盘调度算法的目的很简单，就是为了提高磁盘的访问性能，一般是通过优化磁盘的访问请求顺序来做到的。</p><p>寻道的时间是磁盘访问最耗时的部分，如果请求顺序优化的得当，必然可以节省一些不必要的寻道时间，从而提高磁盘的访问性能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假设有下面一个请求序列，每个数字代表磁道的位置：</span><br><span class="line"></span><br><span class="line">98，183，37，122，14，124，65，67</span><br><span class="line"></span><br><span class="line">初始磁头当前的位置是在第 &#96;53&#96; 磁道。</span><br></pre></td></tr></table></figure><p>接下来，分别对以上的序列，作为每个调度算法的例子，那常见的磁盘调度算法有：</p><ul><li>先来先服务算法</li><li>最短寻道时间优先算法</li><li>扫描算法算法</li><li>循环扫描算法</li><li>LOOK 与 C-LOOK 算法</li></ul><h2 id="2-磁盘调度算法"><a href="#2-磁盘调度算法" class="headerlink" title="2. 磁盘调度算法"></a>2. 磁盘调度算法</h2><h3 id="2-1-先来先服务"><a href="#2-1-先来先服务" class="headerlink" title="2.1 先来先服务"></a>2.1 先来先服务</h3><ul><li><p>先来先服务（<em>First-Come，First-Served，FCFS</em>），顾名思义，先到来的请求，先被服务。</p></li><li><p>那按照这个序列的话：</p><p><code>98，183，37，122，14，124，65，67</code></p><p>那么，磁盘的写入顺序是从左到右，如下图：</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/144809106.png" alt="mark"></p><ul><li>先来先服务算法总共移动了 <code>640</code> 个磁道的距离，这么一看这种算法，比较简单粗暴，但是如果大量进程竞争使用磁盘，请求访问的磁道可能会很分散，那先来先服务算法在性能上就会显得很差，因为寻道时间过长。</li></ul><h3 id="2-2-最短寻道时间优先"><a href="#2-2-最短寻道时间优先" class="headerlink" title="2.2 最短寻道时间优先"></a>2.2 最短寻道时间优先</h3><ul><li>最短寻道时间优先（<em>Shortest Seek First，SSF</em>）算法的工作方式是，优先选择从当前磁头位置所需寻道时间最短的请求，还是以这个序列为例子：</li></ul><p><code>98，183，37，122，14，124，65，67</code></p><ul><li>那么，那么根据距离磁头（ 53 位置）最近的请求的算法，具体的请求则会是下列从左到右的顺序：</li></ul><p><code>65，67，37，14，98，122，124，183</code></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/144946962.png" alt="mark"></p><ul><li>磁头移动的总距离是 <code>236</code> 磁道，相比先来先服务性能提高了不少。<ul><li>但这个算法可能存在某些请求的<strong>饥饿</strong>，因为本次例子我们是静态的序列，看不出问题，</li><li>假设是一个动态的请求，如果后续来的请求都是小于 183 磁道的，那么 183 磁道可能永远不会被响应，于是就产生了饥饿现象，这里<strong>产生饥饿的原因是磁头在一小块区域来回移动</strong>。</li></ul></li></ul><h3 id="2-3-扫描算法"><a href="#2-3-扫描算法" class="headerlink" title="2.3 扫描算法"></a>2.3 扫描算法</h3><ul><li>最短寻道时间优先算法会产生饥饿的原因在于：磁头有可能再一个小区域内来回得移动。</li><li>为了防止这个问题，可以规定：<strong>磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后的磁道，才调换方向，这就是扫描（*Scan*）算法</strong>。</li><li>这种算法也叫做电梯算法，比如电梯保持按一个方向移动，直到在那个方向上没有请求为止，然后改变方向。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">还是以这个序列为例子，磁头的初始位置是 53：</span><br><span class="line"></span><br><span class="line">98，183，37，122，14，124，65，67</span><br><span class="line"></span><br><span class="line">那么，假设扫描调度算先朝磁道号减少的方向移动，具体请求则会是下列从左到右的顺序：</span><br><span class="line"></span><br><span class="line">37，14，0，65，67，98，122，124，183</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/145111421.png" alt="mark"></p><ul><li>磁头先响应左边的请求，直到到达最左端（ 0 磁道）后，才开始反向移动，响应右边的请求。</li><li>扫描调度算法性能较好，不会产生饥饿现象，但是存在这样的问题<ul><li>中间部分的磁道会比较占便宜，中间部分相比其他部分响应的频率会比较多，也就是说每个磁道的响应频率存在差异。</li></ul></li></ul><h3 id="2-4-循环扫描算法"><a href="#2-4-循环扫描算法" class="headerlink" title="2.4 循环扫描算法"></a>2.4 循环扫描算法</h3><ul><li><p>扫描算法使得每个磁道响应的频率存在差异，那么要优化这个问题的话，可以总是按相同的方向进行扫描，使得每个磁道的响应频率基本一致。</p></li><li><p>循环扫描（<em>Circular Scan, CSCAN</em> ）规定：只有磁头朝某个特定方向移动时，才处理磁道访问请求，而返回时直接快速移动至最靠边缘的磁道，也就是复位磁头，这个过程是很快的，并且<strong>返回中途不处理任何请求</strong>，该算法的特点，就是<strong>磁道只响应一个方向上的请求</strong>。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">还是以这个序列为例子，磁头的初始位置是 53：</span><br><span class="line"></span><br><span class="line">98，183，37，122，14，124，65，67</span><br><span class="line"></span><br><span class="line">那么，假设循环扫描调度算先朝磁道增加的方向移动，具体请求会是下列从左到右的顺序：</span><br><span class="line"></span><br><span class="line">65，67，98，122，124，183，199，0，14，37</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/145234782.png" alt="mark"></p><ul><li>磁头先响应了右边的请求，直到碰到了最右端的磁道 199，就立即回到磁盘的开始处（磁道 0），但这个返回的途中是不响应任何请求的，直到到达最开始的磁道后，才继续顺序响应右边的请求。</li><li>循环扫描算法相比于扫描算法，对于各个位置磁道响应频率相对比较平均。</li></ul><h3 id="2-5-LOOK-与-C-LOOK算法"><a href="#2-5-LOOK-与-C-LOOK算法" class="headerlink" title="2.5 LOOK 与 C-LOOK算法"></a>2.5 LOOK 与 C-LOOK算法</h3><ul><li>我们前面说到的扫描算法和循环扫描算法，都是磁头移动到磁盘「最始端或最末端」才开始调换方向。</li><li>那这其实是可以优化的，优化的思路就是<strong>磁头在移动到「最远的请求」位置，然后立即反向移动。</strong></li><li>那针对 SCAN 算法的优化则叫 LOOK 算法，它的工作方式，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，<strong>反向移动的途中会响应请求</strong>。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/145437467.png" alt="mark"></p><ul><li>而针 C-SCAN 算法的优化则叫 C-LOOK，它的工作方式，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，<strong>反向移动的途中不会响应请求</strong>。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/145453441.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-11-磁盘调度算法&quot;&gt;&lt;a href=&quot;#Linux-11-磁盘调度算法&quot; class=&quot;headerlink&quot; title=&quot;Linux-11-磁盘调度算法&quot;&gt;&lt;/a&gt;Linux-11-磁盘调度算法&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/144348215.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="磁盘调度算法" scheme="http://zhuuu.work/tags/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-try-catch</title>
    <link href="http://zhuuu.work/2020/08/28/JavaInterview/Java-%E5%9F%BA%E7%A1%80-try-catch/"/>
    <id>http://zhuuu.work/2020/08/28/JavaInterview/Java-%E5%9F%BA%E7%A1%80-try-catch/</id>
    <published>2020-08-28T08:39:38.000Z</published>
    <updated>2020-09-18T06:12:19.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-try-catch"><a href="#Java-基础-try-catch" class="headerlink" title="Java-基础-try-catch"></a>Java-基础-try-catch</h1><h2 id="1-总结"><a href="#1-总结" class="headerlink" title="1. 总结"></a>1. 总结</h2><p><strong>绕口令开始</strong></p><p><strong>1、不管有没有异常，<code>finally</code>中的代码都会执行</strong><br><strong>2、当<code>try、catch</code>中有<code>return</code>时，<code>finally</code>中的代码依然会继续执行</strong><br><strong>3、<code>finally</code>是在<code>return</code>后面的表达式运算之后执行的，此时并没有返回运算之后的值，而是把值保存起来，不管finally对该值做任何的改变，返回的值都不会改变，依然返回保存起来的值。也就是说方法的返回值是在finally运算之前就确定了的。</strong><br><strong>4、如果return的数据是引用数据类型，而在finally中对该引用数据类型的属性值的改变起作用，try中的return语句返回的就是在finally中改变后的该属性的值。</strong><br><strong>5、finally代码中最好不要包含return，程序会提前退出，也就是说返回的值不是try或catch中的值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 先执行try中的语句，包括return后面的表达式，</span><br><span class="line">2. 有异常时,先执行catch中的语句，包括return后面的表达式,</span><br><span class="line">3. 然后执行finally中的语句,如果finally里面有return语句，会提前退出，</span><br><span class="line">最后执行try中的return，有异常时执行catch中的return。</span><br><span class="line"></span><br><span class="line">4. 在执行try、catch中的return之前一定会执行finally中的代码（如果finally存在），如果finally中有return语句，就会直接执行finally中的return方法，所以finally中的return语句一定会被执行的。编译器把finally中的return语句标识为一个warning.</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-举例分析"><a href="#2-举例分析" class="headerlink" title="2. 举例分析"></a>2. 举例分析</h2><ol><li>案例一</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">trycatchTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        String a = a();</span><br><span class="line">        System.out.println(<span class="string">"主方法返回 ："</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"执行 try"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"try"</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"执行 catch"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"catch"</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"执行finally"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行 try</span><br><span class="line">执行 finally</span><br><span class="line">主方法返回 ：try</span><br></pre></td></tr></table></figure><p><strong>结论：执行try 到了return的时候会去检测finally。finally块存在会先执行finally块的内容，再return。</strong></p><p><strong>案例二：假设finally里面也有return呢？执行的是哪个return？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">trycatchTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        String a = a();</span><br><span class="line">        System.out.println(<span class="string">"主方法返回 ："</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">            System.out.println(<span class="string">"执行 try"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"try"</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"执行 catch"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"catch"</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"执行finally"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"finally"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行 <span class="keyword">try</span></span><br><span class="line">执行<span class="keyword">finally</span></span><br><span class="line">主方法返回 ：<span class="keyword">finally</span></span><br></pre></td></tr></table></figure><p><strong>结论：如果finally里面存在return，将直接返回。不再跳回try块的return。</strong></p><p><strong>案例三：catch也是一样的道理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">trycatchTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        String a = a();</span><br><span class="line">        System.out.println(<span class="string">"主方法返回 ："</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">            System.out.println(<span class="string">"执行 try"</span>);</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"try"</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"执行 catch"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"catch"</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"执行finally"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"finally"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行 <span class="keyword">try</span></span><br><span class="line">执行 <span class="keyword">catch</span></span><br><span class="line">执行<span class="keyword">finally</span></span><br><span class="line">主方法返回 ：<span class="keyword">finally</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-try-catch&quot;&gt;&lt;a href=&quot;#Java-基础-try-catch&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-try-catch&quot;&gt;&lt;/a&gt;Java-基础-try-catch&lt;/h1&gt;&lt;h2 id=&quot;1-总结&quot;&gt;&lt;a href=&quot;#1-总结&quot; class=&quot;headerlink&quot; title=&quot;1. 总结&quot;&gt;&lt;/a&gt;1. 总结&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;绕口令开始&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、不管有没有异常，&lt;code&gt;finally&lt;/code&gt;中的代码都会执行&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;2、当&lt;code&gt;try、catch&lt;/code&gt;中有&lt;code&gt;return&lt;/code&gt;时，&lt;code&gt;finally&lt;/code&gt;中的代码依然会继续执行&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;3、&lt;code&gt;finally&lt;/code&gt;是在&lt;code&gt;return&lt;/code&gt;后面的表达式运算之后执行的，此时并没有返回运算之后的值，而是把值保存起来，不管finally对该值做任何的改变，返回的值都不会改变，依然返回保存起来的值。也就是说方法的返回值是在finally运算之前就确定了的。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;4、如果return的数据是引用数据类型，而在finally中对该引用数据类型的属性值的改变起作用，try中的return语句返回的就是在finally中改变后的该属性的值。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;5、finally代码中最好不要包含return，程序会提前退出，也就是说返回的值不是try或catch中的值&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1. 先执行try中的语句，包括return后面的表达式，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. 有异常时,先执行catch中的语句，包括return后面的表达式,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. 然后执行finally中的语句,如果finally里面有return语句，会提前退出，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	最后执行try中的return，有异常时执行catch中的return。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4. 在执行try、catch中的return之前一定会执行finally中的代码（如果finally存在），如果finally中有return语句，就会直接执行finally中的return方法，所以finally中的return语句一定会被执行的。编译器把finally中的return语句标识为一个warning.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="try-catch-finally" scheme="http://zhuuu.work/tags/try-catch-finally/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-线程中断</title>
    <link href="http://zhuuu.work/2020/08/28/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/"/>
    <id>http://zhuuu.work/2020/08/28/JavaInterview/Java-%E5%9F%BA%E7%A1%80-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/</id>
    <published>2020-08-28T08:38:38.000Z</published>
    <updated>2020-08-28T14:19:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础-线程中断"><a href="#Java-基础-线程中断" class="headerlink" title="Java-基础-线程中断"></a>Java-基础-线程中断</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Thread提供了interrupt方法，中断线程的执行：</p><ul><li>如果线程堵塞在object.wait、Thread.join和Thread.sleep，将会抛出<code>InterruptedException</code>,同时清除线程的中断状态;</li><li>如果线程堵塞在java.nio.channels.InterruptibleChannel的IO上，Channel将会被关闭，线程被置为中断状态，并抛出java.nio.channels.ClosedByInterruptException；</li><li>如果线程堵塞在java.nio.channels.Selector上，线程被置为中断状态，select方法会马上返回，类似调用wakeup的效果；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心 interrupt 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread()) <span class="comment">// 非本线程，需要检查权限</span></span><br><span class="line">         checkAccess();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">         Interruptible b = blocker;</span><br><span class="line">         <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">             interrupt0();           <span class="comment">// 仅仅设置interrupt标志位</span></span><br><span class="line">             b.interrupt(<span class="keyword">this</span>);    <span class="comment">// 调用如 I/O 操作定义的中断方法</span></span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     interrupt0();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 静态方法，这个方法有点坑，调用该方法调用后会清除中断状态。</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 这个方法不会清除中断状态</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 上面两个方法会调用这个本地方法，参数代表是否清除中断状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-源码实现"><a href="#2-源码实现" class="headerlink" title="2. 源码实现"></a>2. 源码实现</h2><ul><li>之前在分析Thread.start的时候曾经提到，JavaThread有三个成员变量:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于synchronized同步块和Object.wait() </span></span><br><span class="line">ParkEvent * _ParkEvent ; </span><br><span class="line"><span class="comment">//用于Thread.sleep() </span></span><br><span class="line">ParkEvent * _SleepEvent ; </span><br><span class="line"><span class="comment">//用于unsafe.park()/unpark(),供java.util.concurrent.locks.LockSupport调用， </span></span><br><span class="line"><span class="comment">//因此它支持了java.util.concurrent的各种锁、条件变量等线程同步操作,是concurrent的实现基础 </span></span><br><span class="line">Parker* _parker;</span><br></pre></td></tr></table></figure><ul><li>初步猜测interrupt实现应该与此有关系；<br>interrupt方法的源码也在jvm.cpp文件:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_Interrupt(JNIEnv* env, jobject jthread))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_Interrupt"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure that the C++ Thread and OSThread structures aren't freed before we operate</span></span><br><span class="line">  oop java_thread = JNIHandles::resolve_non_null(jthread);</span><br><span class="line">  <span class="function">MutexLockerEx <span class="title">ml</span><span class="params">(thread-&gt;threadObj()</span> </span>== java_thread ? NULL : Threads_lock);</span><br><span class="line">  <span class="comment">// We need to re-resolve the java_thread, since a GC might have happened during the</span></span><br><span class="line">  <span class="comment">// acquire of the lock</span></span><br><span class="line">  JavaThread* thr = java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread));</span><br><span class="line">  <span class="keyword">if</span> (thr != NULL) &#123;</span><br><span class="line">    Thread::interrupt(thr);</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure><ul><li>JVM_Interrupt对参数进行了校验，然后直接调用Thread::interrupt:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::interrupt</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line">  trace(<span class="string">"interrupt"</span>, thread);</span><br><span class="line">  debug_only(check_for_dangling_thread_pointer(thread);)</span><br><span class="line">  os::interrupt(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Thread::interrupt调用os::interrupt方法实现,os::interrupt方法定义在os_linux.cpp:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">os::interrupt</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line">  assert(Thread::current() == thread || Threads_lock-&gt;owned_by_self(),</span><br><span class="line">    <span class="string">"possibility of dangling Thread pointer"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取系统native线程对象</span></span><br><span class="line">  OSThread* osthread = thread-&gt;osthread();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!osthread-&gt;interrupted()) &#123;</span><br><span class="line">    osthread-&gt;set_interrupted(<span class="literal">true</span>);</span><br><span class="line">   <span class="comment">//内存屏障，使osthread的interrupted状态对其它线程立即可见</span></span><br><span class="line">    OrderAccess::fence();</span><br><span class="line">    <span class="comment">//前文说过，_SleepEvent用于Thread.sleep,线程调用了sleep方法，则通过unpark唤醒</span></span><br><span class="line">    ParkEvent * <span class="keyword">const</span> slp = thread-&gt;_SleepEvent ;</span><br><span class="line">    <span class="keyword">if</span> (slp != <span class="literal">NULL</span>) slp-&gt;unpark() ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//_parker用于concurrent相关的锁，此处同样通过unpark唤醒</span></span><br><span class="line">  <span class="keyword">if</span> (thread-&gt;is_Java_thread())</span><br><span class="line">    ((JavaThread*)thread)-&gt;parker()-&gt;unpark();</span><br><span class="line">  <span class="comment">//synchronized同步块和Object.wait() 唤醒</span></span><br><span class="line">  ParkEvent * ev = thread-&gt;_ParkEvent ;</span><br><span class="line">  <span class="keyword">if</span> (ev != <span class="literal">NULL</span>) ev-&gt;unpark() ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>由此可见，interrupt其实就是通过ParkEvent的unpark方法唤醒对象；另外要注意：</strong></p><ul><li>object.wait、Thread.sleep和Thread.join会抛出InterruptedException并清除中断状态；</li><li>Lock.lock()方法不会响应中断，Lock.lockInterruptibly()方法则会响应中断并抛出异常，区别在于park()等待被唤醒时lock会继续执行park()来等待锁，而 lockInterruptibly会抛出异常；</li><li>synchronized被唤醒后会尝试获取锁，失败则会通过循环继续park()等待，因此实际上是不会被interrupt()中断的;</li><li>一般情况下，抛出异常时，会清空Thread的interrupt状态，在编程时需要注意；</li></ul><h2 id="3-网络中断相关"><a href="#3-网络中断相关" class="headerlink" title="3. 网络中断相关"></a>3. 网络中断相关</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Interruptible blocker;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object blockerLock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">            Interruptible b = blocker;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">                interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">                b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>其中blocker是Thread的成员变量,Thread提供了blockedOn方法可以设置blocker:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockedOn</span><span class="params">(Interruptible b)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">           blocker = b;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>如果一个nio通道实现了InterruptibleChannel接口，就可以响应interrupt()中断，其原理就在InterruptibleChannel接口的抽象实现类AbstractInterruptibleChannel的方法begin()中:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (interruptor == <span class="keyword">null</span>) &#123;</span><br><span class="line">           interruptor = <span class="keyword">new</span> Interruptible() &#123;</span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">(Thread target)</span> </span>&#123;</span><br><span class="line">                       <span class="keyword">synchronized</span> (closeLock) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (!open)</span><br><span class="line">                               <span class="keyword">return</span>;</span><br><span class="line">                           open = <span class="keyword">false</span>;</span><br><span class="line">                           interrupted = target;</span><br><span class="line">                           <span class="keyword">try</span> &#123;</span><br><span class="line">                               AbstractInterruptibleChannel.<span class="keyword">this</span>.implCloseChannel();</span><br><span class="line">                           &#125; <span class="keyword">catch</span> (IOException x) &#123; &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;&#125;;</span><br><span class="line">       &#125;</span><br><span class="line">       blockedOn(interruptor);<span class="comment">//设置当前线程的blocker为interruptor</span></span><br><span class="line">       Thread me = Thread.currentThread();</span><br><span class="line">       <span class="keyword">if</span> (me.isInterrupted())</span><br><span class="line">           interruptor.interrupt(me);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">(<span class="keyword">boolean</span> completed)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> AsynchronousCloseException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       blockedOn(<span class="keyword">null</span>);<span class="comment">//设置当前线程的blocker为null</span></span><br><span class="line">       Thread interrupted = <span class="keyword">this</span>.interrupted;</span><br><span class="line">      <span class="comment">//如果发生中断，Thread.interrupt方法会调用Interruptible的interrupt方法，</span></span><br><span class="line">     <span class="comment">//设置this.interrupted为当前线程</span></span><br><span class="line">       <span class="keyword">if</span> (interrupted != <span class="keyword">null</span> &amp;&amp; interrupted == Thread.currentThread()) &#123;</span><br><span class="line">           interrupted = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ClosedByInterruptException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (!completed &amp;&amp; !open)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> AsynchronousCloseException();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Class java.nio.channels.Channels.WritableByteChannelImpl</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ......    </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            begin();</span><br><span class="line">            out.write(buf, <span class="number">0</span>, bytesToWrite);</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            end(bytesToWrite &gt; <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Class java.nio.channels.Channels.ReadableByteChannelImpl</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ......    </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            begin();</span><br><span class="line">            bytesRead = in.read(buf, <span class="number">0</span>, bytesToRead);</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            end(bytesRead &gt; <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>以上述代码为例，nio通道的ReadableByteChannel每次执行阻塞方法read()前，都会执行begin()，把Interruptible回调接口注册到当前线程上。当线程中断时，Thread.interrupt()触发回调接口Interruptible关闭io通道,导致read方法返回，最后在finally块中执行end()方法检查中断标记，抛出ClosedByInterruptException;</li></ul><p><strong>Selector的实现类似：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.channels.spi.AbstractSelector</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (interruptor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            interruptor = <span class="keyword">new</span> Interruptible() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">(Thread ignore)</span> </span>&#123;</span><br><span class="line">                        AbstractSelector.<span class="keyword">this</span>.wakeup();</span><br><span class="line">                    &#125;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        AbstractInterruptibleChannel.blockedOn(interruptor);</span><br><span class="line">        Thread me = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (me.isInterrupted())</span><br><span class="line">            interruptor.interrupt(me);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AbstractInterruptibleChannel.blockedOn(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.nio.ch.class EPollSelectorImpl</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doSelect</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            begin();</span><br><span class="line">            pollWrapper.poll(timeout);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            end();</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到当发生中断时会调用wakeup方法唤醒poll方法，但并不会抛出中断异常；</p><h2 id="4-通过interrupted-关闭线程"><a href="#4-通过interrupted-关闭线程" class="headerlink" title="4. 通过interrupted()关闭线程"></a>4. 通过interrupted()关闭线程</h2><ul><li>总所周知，<code>Thread.stop, Thread.suspend, Thread.resume</code> 都已经被废弃了。因为它们太暴力了，是不安全的，这种暴力中断线程是一种不安全的操作，举个栗子来说明其可能造成的问题：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        StopThread thread = <span class="keyword">new</span> StopThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 休眠1秒，确保线程进入运行</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 暂停线程</span></span><br><span class="line">        thread.stop();</span><br><span class="line"><span class="comment">//      thread.interrupt();</span></span><br><span class="line">        <span class="comment">// 确保线程已经销毁</span></span><br><span class="line">        <span class="keyword">while</span> (thread.isAlive()) &#123; &#125;</span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        thread.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">private</span> <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 这是一个同步原子操作</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                ++x;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 休眠3秒,模拟耗时操作</span></span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                ++y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"x="</span> + x + <span class="string">" y="</span> + y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，run方法里是一个同步的原子操作，x和y必须要共同增加，然而这里如果调用thread.stop()方法强制中断线程，输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span> y=<span class="number">0</span></span><br></pre></td></tr></table></figure><p> 没有异常，也破坏了我们的预期。如果这种问题出现在我们的程序中，会引发难以预期的异常。因此这种不安全的方式很早就被废弃了。取而代之的是interrupt()，上述代码如果采用thread.interrupt()方法，输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span> y=<span class="number">1</span></span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at ThreadTest$StopThread.run(ThreadTest.java:<span class="number">28</span>)</span><br></pre></td></tr></table></figure><p> <strong>x=1,y=1 这个结果是符合我们的预期，同时还抛出了个异常，这个异常下文详说。</strong></p><p><strong>interrupt() 它基于「一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。」思想，是一个比较温柔的做法，它更类似一个标志位。其实作用不是中断线程，而是「通知线程应该中断了」，具体到底中断还是继续运行，应该由被通知的线程自己处理。</strong></p><p><strong>interrupt() 并不能真正的中断线程，这点要谨记。需要被调用的线程自己进行配合才行。也就是说，一个线程如果有被中断的需求，那么就需要这样做：</strong></p><ol><li>在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程。</li><li>在调用阻塞方法时正确处理InterruptedException异常。（例如：catch异常后就结束线程。）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心 interrupt 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread()) <span class="comment">// 非本线程，需要检查权限</span></span><br><span class="line">         checkAccess();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">         Interruptible b = blocker;</span><br><span class="line">         <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">             interrupt0();           <span class="comment">// 仅仅设置interrupt标志位</span></span><br><span class="line">             b.interrupt(<span class="keyword">this</span>);    <span class="comment">// 调用如 I/O 操作定义的中断方法</span></span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     interrupt0();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 静态方法，这个方法有点坑，调用该方法调用后会清除中断状态。</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 这个方法不会清除中断状态</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 上面两个方法会调用这个本地方法，参数代表是否清除中断状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>首先讲 interrupt() 方法：</strong></p><ol><li>interrupt 中断操作时，非自身打断需要先检测是否有中断权限，这由jvm的安全机制配置；</li><li>如果线程处于<code>sleep, wait, join</code>等状态，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常；</li><li>如果线程处于I/O阻塞状态，将会抛出ClosedByInterruptException（IOException的子类）异常；</li><li>如果线程在Selector上被阻塞，select方法将立即返回；</li><li>如果非以上情况，将直接标记 interrupt 状态；</li></ol><p><strong>注意：interrupt 操作不会打断所有阻塞，只有上述阻塞情况才在jvm的打断范围内，如处于锁阻塞的线程，不会受 interrupt 中断；</strong></p><p><strong>等待情况下中断，抛出异常后线程恢复非中断状态，即 interrupted = false</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(<span class="string">"1"</span>));</span><br><span class="line">        t.start();</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"thread has been interrupt!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"isInterrupted: "</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">            System.out.println(<span class="string">"task "</span> + name + <span class="string">" is over"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread has been interrupt!</span><br><span class="line">isInterrupted: <span class="keyword">false</span></span><br><span class="line">task <span class="number">1</span> is over</span><br></pre></td></tr></table></figure><p><strong>调用Thread.interrupted() 方法后线程恢复非中断状态</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(<span class="string">"1"</span>));</span><br><span class="line">        t.start();</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"first :"</span> + Thread.interrupted());</span><br><span class="line">            System.out.println(<span class="string">"second:"</span> + Thread.interrupted());</span><br><span class="line">            System.out.println(<span class="string">"task "</span> + name + <span class="string">" is over"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first :<span class="keyword">true</span></span><br><span class="line">second:<span class="keyword">false</span></span><br><span class="line">task <span class="number">1</span> is over</span><br></pre></td></tr></table></figure><p><strong>上述两种隐含的状态恢复操作，是符合常理的，因为线程标记为中断后，用户没有真正中断线程，必然将其恢复为false。理论上Thread.interrupted()调用后，如果已中断，应该执行退出操作，不会重复调用。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-基础-线程中断&quot;&gt;&lt;a href=&quot;#Java-基础-线程中断&quot; class=&quot;headerlink&quot; title=&quot;Java-基础-线程中断&quot;&gt;&lt;/a&gt;Java-基础-线程中断&lt;/h1&gt;&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;Thread提供了interrupt方法，中断线程的执行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果线程堵塞在object.wait、Thread.join和Thread.sleep，将会抛出&lt;code&gt;InterruptedException&lt;/code&gt;,同时清除线程的中断状态;&lt;/li&gt;
&lt;li&gt;如果线程堵塞在java.nio.channels.InterruptibleChannel的IO上，Channel将会被关闭，线程被置为中断状态，并抛出java.nio.channels.ClosedByInterruptException；&lt;/li&gt;
&lt;li&gt;如果线程堵塞在java.nio.channels.Selector上，线程被置为中断状态，select方法会马上返回，类似调用wakeup的效果；&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 核心 interrupt 方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; != Thread.currentThread()) &lt;span class=&quot;comment&quot;&gt;// 非本线程，需要检查权限&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         checkAccess();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (blockerLock) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         Interruptible b = blocker;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (b != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             interrupt0();           &lt;span class=&quot;comment&quot;&gt;// 仅仅设置interrupt标志位&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             b.interrupt(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);    &lt;span class=&quot;comment&quot;&gt;// 调用如 I/O 操作定义的中断方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     interrupt0();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;// 静态方法，这个方法有点坑，调用该方法调用后会清除中断状态。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;interrupted&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; currentThread().isInterrupted(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;// 这个方法不会清除中断状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isInterrupted&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; isInterrupted(&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 上面两个方法会调用这个本地方法，参数代表是否清除中断状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isInterrupted&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; ClearInterrupted)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="线程中断" scheme="http://zhuuu.work/tags/%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer--41-数据流中的中位数</title>
    <link href="http://zhuuu.work/2020/08/26/Leetcode/%E5%89%91%E6%8C%87offer--41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://zhuuu.work/2020/08/26/Leetcode/%E5%89%91%E6%8C%87offer--41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</id>
    <published>2020-08-26T07:15:53.000Z</published>
    <updated>2020-09-09T04:23:13.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指offer–41-数据流中的中位数"><a href="#剑指offer–41-数据流中的中位数" class="headerlink" title="剑指offer–41-数据流中的中位数"></a>剑指offer–41-<a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">数据流中的中位数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,2.00000,null,2.50000]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-两个堆"><a href="#思路-两个堆" class="headerlink" title="思路 : 两个堆"></a><strong>思路 : 两个堆</strong></h2><p><strong>待优化的思路1：快排</strong></p><ul><li>其中位数的计算方法：首先对数组执行排序（使用O<em>(</em>N<em>log</em>N) 时间），然后返回中间元素即可（使用 O(1)时间）。</li><li>针对本题，根据以上思路，可以将数据流保存在一个列表中，并在添加元素时 保持数组有序 。此方法的时间复杂度为 O(N)，其中包括： 查找元素插入位置O(logN) （二分查找）、向数组某位置插入元素 O(N) （插入位置之后的元素都需要向后移动一位）。</li></ul><p><strong>思路2： 两个堆</strong></p><ul><li>事实上，我们只关心在中间的那两个数（或者一个数），其它数没有必要进行 “比较” 和 “交换” 的操作。</li><li>在我们学习过的数据结构里，堆就有类似的性质，每次都从堆里得到一个 “最值” 而其它元素无需排序，这样就可以以O(logN) 的复杂度每次都从堆中取出最值。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200908-111604101.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200908-111617276.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200908-111821068.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200908-112110039.png" alt="mark"></p><p><strong>总结：</strong></p><ul><li><strong>为了找到添加新数据以后，数据流的中位数，我们让这个新数据在大顶堆和小顶堆中都走了一遍。而为了让大顶堆的元素多 1 个，我们让从小顶堆中又拿出一个元素“送回”给大顶堆；</strong></li><li>将元素放入优先队列以后，优先队列会以对数时间复杂度自行调整，把“最优值”放入堆顶，这是使用优先队列解决这个问题的原因。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前大顶堆和小顶堆的元素个数之和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; maxheap;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minheap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * initialize your data structure here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        maxheap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((x, y) -&gt; y - x);</span><br><span class="line">        minheap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        maxheap.offer(num);</span><br><span class="line">        minheap.add(maxheap.poll());</span><br><span class="line">        <span class="comment">// 如果两个堆合起来的元素个数是奇数，小顶堆要拿出堆顶元素给大顶堆</span></span><br><span class="line">        <span class="keyword">if</span> ((count &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            maxheap.add(minheap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((count &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果两个堆合起来的元素个数是偶数，数据流的中位数就是各自堆顶元素的平均值</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) (maxheap.peek() + minheap.peek()) / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果两个堆合起来的元素个数是奇数，数据流的中位数大顶堆的堆顶元素</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) maxheap.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li><strong>时间复杂度：</strong>O(logN) 优先队列的出队入队操作都是对数级别的，数据在两个堆中间来回操作是常数级别的，综上时间复杂度是 O(logN) 级别的。</li><li><strong>空间复杂度：</strong>O(N) 占用堆的大小</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;剑指offer–41-数据流中的中位数&quot;&gt;&lt;a href=&quot;#剑指offer–41-数据流中的中位数&quot; class=&quot;headerlink&quot; title=&quot;剑指offer–41-数据流中的中位数&quot;&gt;&lt;/a&gt;剑指offer–41-&lt;a href=&quot;https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数据流中的中位数&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。&lt;/p&gt;
&lt;p&gt;例如，&lt;/p&gt;
&lt;p&gt;[2,3,4] 的中位数是 3&lt;/p&gt;
&lt;p&gt;[2,3] 的中位数是 (2 + 3) / 2 = 2.5&lt;/p&gt;
&lt;p&gt;设计一个支持以下两种操作的数据结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;void addNum(int num) - 从数据流中添加一个整数到数据结构中。&lt;/li&gt;
&lt;li&gt;double findMedian() - 返回目前所有元素的中位数。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&amp;quot;MedianFinder&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[],[1],[2],[],[3],[]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[null,null,null,1.50000,null,2.00000]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&amp;quot;MedianFinder&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[],[2],[],[3],[]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[null,null,2.00000,null,2.50000]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="剑指offer" scheme="http://zhuuu.work/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer--40-最小的K个数</title>
    <link href="http://zhuuu.work/2020/08/26/offer/%E5%89%91%E6%8C%87offer--40-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/"/>
    <id>http://zhuuu.work/2020/08/26/offer/%E5%89%91%E6%8C%87offer--40-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/</id>
    <published>2020-08-26T07:15:53.000Z</published>
    <updated>2020-11-09T01:04:28.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指offer–40-最小的k个数"><a href="#剑指offer–40-最小的k个数" class="headerlink" title="剑指offer–40-最小的k个数"></a>剑指offer–40-<a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">最小的k个数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：arr &#x3D; [3,2,1], k &#x3D; 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：arr &#x3D; [0,1,2,1], k &#x3D; 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>0 &lt;= k &lt;= arr.length &lt;= 10000</code></li><li><code>0 &lt;= arr[i] &lt;= 10000</code></li></ul><a id="more"></a><h2 id="思路-1：利用堆-Java-gt-优先队列"><a href="#思路-1：利用堆-Java-gt-优先队列" class="headerlink" title="思路 1：利用堆(Java-&gt;优先队列)"></a>思路 1：利用堆(Java-&gt;优先队列)</h2><ul><li>保证堆的大小为k ，然后遍历数组中的数字，遍历的过程做如下判断<ul><li><ol><li>若目前堆中的<strong>大小小于 K</strong> , 那么将当前的数字加入堆中</li></ol></li><li><ol start="2"><li>否则 判断当前数字与<strong>大顶堆堆顶元素</strong>的大小关系，如果当前数字比大顶堆堆顶还大，这个数字就直接跳过</li><li>反之，如果当前数字比大顶堆堆顶小，先poll掉堆顶，再将该数字放入堆中</li></ol></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认是小根堆，实现大根堆需要重写一下比较器</span></span><br><span class="line">        Queue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((v1,v2) -&gt; v2 - v1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &lt; k)&#123;</span><br><span class="line">                pq.offer(num);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (num &lt; pq.peek())&#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">                pq.offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回堆中元素</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[pq.size()];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:pq)&#123;</span><br><span class="line">            res[idx++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p><strong>时间复杂度 ： O(N LogK)</strong> </p><ul><li>遍历一遍数组的开销O(N) + 堆插入的开销（Ologk）</li></ul></li><li><p><strong>空间复杂度 ：O(k)</strong>  </p><ul><li>使用了大小为k 的堆</li></ul></li></ul><p><strong>另外几种解法 ： 待学习</strong> </p><p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/3chong-jie-fa-miao-sha-topkkuai-pai-dui-er-cha-sou/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/3chong-jie-fa-miao-sha-topkkuai-pai-dui-er-cha-sou/</a></p><ol><li>二叉排序树</li><li>快速排序</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;剑指offer–40-最小的k个数&quot;&gt;&lt;a href=&quot;#剑指offer–40-最小的k个数&quot; class=&quot;headerlink&quot; title=&quot;剑指offer–40-最小的k个数&quot;&gt;&lt;/a&gt;剑指offer–40-&lt;a href=&quot;https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;最小的k个数&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;输入整数数组 &lt;code&gt;arr&lt;/code&gt; ，找出其中最小的 &lt;code&gt;k&lt;/code&gt; 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：arr &amp;#x3D; [3,2,1], k &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,2] 或者 [2,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：arr &amp;#x3D; [0,1,2,1], k &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[0]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;限制：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= k &amp;lt;= arr.length &amp;lt;= 10000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= arr[i] &amp;lt;= 10000&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="堆" scheme="http://zhuuu.work/tags/%E5%A0%86/"/>
    
      <category term="剑指offer" scheme="http://zhuuu.work/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="优先队列" scheme="http://zhuuu.work/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer--41-数据流中的中位数</title>
    <link href="http://zhuuu.work/2020/08/26/offer/%E5%89%91%E6%8C%87offer--41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://zhuuu.work/2020/08/26/offer/%E5%89%91%E6%8C%87offer--41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</id>
    <published>2020-08-26T07:15:53.000Z</published>
    <updated>2020-09-09T04:23:13.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指offer–41-数据流中的中位数"><a href="#剑指offer–41-数据流中的中位数" class="headerlink" title="剑指offer–41-数据流中的中位数"></a>剑指offer–41-<a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">数据流中的中位数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,2.00000,null,2.50000]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-两个堆"><a href="#思路-两个堆" class="headerlink" title="思路 : 两个堆"></a><strong>思路 : 两个堆</strong></h2><p><strong>待优化的思路1：快排</strong></p><ul><li>其中位数的计算方法：首先对数组执行排序（使用O<em>(</em>N<em>log</em>N) 时间），然后返回中间元素即可（使用 O(1)时间）。</li><li>针对本题，根据以上思路，可以将数据流保存在一个列表中，并在添加元素时 保持数组有序 。此方法的时间复杂度为 O(N)，其中包括： 查找元素插入位置O(logN) （二分查找）、向数组某位置插入元素 O(N) （插入位置之后的元素都需要向后移动一位）。</li></ul><p><strong>思路2： 两个堆</strong></p><ul><li>事实上，我们只关心在中间的那两个数（或者一个数），其它数没有必要进行 “比较” 和 “交换” 的操作。</li><li>在我们学习过的数据结构里，堆就有类似的性质，每次都从堆里得到一个 “最值” 而其它元素无需排序，这样就可以以O(logN) 的复杂度每次都从堆中取出最值。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200908-111604101.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200908-111617276.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200908-111821068.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200908-112110039.png" alt="mark"></p><p><strong>总结：</strong></p><ul><li><strong>为了找到添加新数据以后，数据流的中位数，我们让这个新数据在大顶堆和小顶堆中都走了一遍。而为了让大顶堆的元素多 1 个，我们让从小顶堆中又拿出一个元素“送回”给大顶堆；</strong></li><li>将元素放入优先队列以后，优先队列会以对数时间复杂度自行调整，把“最优值”放入堆顶，这是使用优先队列解决这个问题的原因。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前大顶堆和小顶堆的元素个数之和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; maxheap;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minheap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * initialize your data structure here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        maxheap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((x, y) -&gt; y - x);</span><br><span class="line">        minheap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        maxheap.offer(num);</span><br><span class="line">        minheap.add(maxheap.poll());</span><br><span class="line">        <span class="comment">// 如果两个堆合起来的元素个数是奇数，小顶堆要拿出堆顶元素给大顶堆</span></span><br><span class="line">        <span class="keyword">if</span> ((count &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            maxheap.add(minheap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((count &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果两个堆合起来的元素个数是偶数，数据流的中位数就是各自堆顶元素的平均值</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) (maxheap.peek() + minheap.peek()) / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果两个堆合起来的元素个数是奇数，数据流的中位数大顶堆的堆顶元素</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) maxheap.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li><strong>时间复杂度：</strong>O(logN) 优先队列的出队入队操作都是对数级别的，数据在两个堆中间来回操作是常数级别的，综上时间复杂度是 O(logN) 级别的。</li><li><strong>空间复杂度：</strong>O(N) 占用堆的大小</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;剑指offer–41-数据流中的中位数&quot;&gt;&lt;a href=&quot;#剑指offer–41-数据流中的中位数&quot; class=&quot;headerlink&quot; title=&quot;剑指offer–41-数据流中的中位数&quot;&gt;&lt;/a&gt;剑指offer–41-&lt;a href=&quot;https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数据流中的中位数&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。&lt;/p&gt;
&lt;p&gt;例如，&lt;/p&gt;
&lt;p&gt;[2,3,4] 的中位数是 3&lt;/p&gt;
&lt;p&gt;[2,3] 的中位数是 (2 + 3) / 2 = 2.5&lt;/p&gt;
&lt;p&gt;设计一个支持以下两种操作的数据结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;void addNum(int num) - 从数据流中添加一个整数到数据结构中。&lt;/li&gt;
&lt;li&gt;double findMedian() - 返回目前所有元素的中位数。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&amp;quot;MedianFinder&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[],[1],[2],[],[3],[]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[null,null,null,1.50000,null,2.00000]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&amp;quot;MedianFinder&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[],[2],[],[3],[]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[null,null,2.00000,null,2.50000]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="剑指offer" scheme="http://zhuuu.work/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer--52-两个链表的第一个公共节点</title>
    <link href="http://zhuuu.work/2020/08/26/Leetcode/%E5%89%91%E6%8C%87offer--56-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/"/>
    <id>http://zhuuu.work/2020/08/26/Leetcode/%E5%89%91%E6%8C%87offer--56-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</id>
    <published>2020-08-26T07:12:53.000Z</published>
    <updated>2020-08-26T11:34:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指offer–52-两个链表的第一个公共节点"><a href="#剑指offer–52-两个链表的第一个公共节点" class="headerlink" title="剑指offer–52-两个链表的第一个公共节点"></a>剑指offer–52-<a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/" target="_blank" rel="noopener">两个链表的第一个公共节点</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个链表，找出它们的第一个公共节点。</p><p>如下面的两个链表<strong>：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200826-191825466.png" alt="mark"></p><p>在节点 c1 开始相交。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200826-191838788.png" alt="mark"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Reference of the node with value &#x3D; 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200826-192018933.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Reference of the node with value &#x3D; 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200826-192115537.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>如果两个链表没有交点，返回 null.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>解题思路：</p><ul><li><p>我们使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。</p></li><li><p>这样，当它们相遇时，所指向的结点就是第一个公共结点。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode l1 = headA;</span><br><span class="line">        ListNode l2 = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1 != l2)&#123;</span><br><span class="line">            <span class="comment">// 我走过你走的路</span></span><br><span class="line">            l1 = l1 == <span class="keyword">null</span>? headB:l1.next;</span><br><span class="line">           <span class="comment">//  你走过我走的路</span></span><br><span class="line">            l2 = l2 == <span class="keyword">null</span>? headA:l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 所以我们才能相遇</span></span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度：O（n + m）</strong></li><li><strong>空间复杂度:O(1)</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;剑指offer–52-两个链表的第一个公共节点&quot;&gt;&lt;a href=&quot;#剑指offer–52-两个链表的第一个公共节点&quot; class=&quot;headerlink&quot; title=&quot;剑指offer–52-两个链表的第一个公共节点&quot;&gt;&lt;/a&gt;剑指offer–52-&lt;a href=&quot;https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;两个链表的第一个公共节点&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;输入两个链表，找出它们的第一个公共节点。&lt;/p&gt;
&lt;p&gt;如下面的两个链表&lt;strong&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200826-191825466.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;在节点 c1 开始相交。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200826-191838788.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="剑指offer" scheme="http://zhuuu.work/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
</feed>
