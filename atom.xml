<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>朱酱酱的学习博客</title>
  <icon>https://www.gravatar.com/avatar/336d255f627c733c7a50883547bcec06</icon>
  <subtitle>From Zero to Hero</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhuuu.work/"/>
  <updated>2021-05-17T02:18:58.303Z</updated>
  <id>http://zhuuu.work/</id>
  
  <author>
    <name>Zhuuu</name>
    <email>353446503@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode-993-二叉树的堂兄弟节点</title>
    <link href="http://zhuuu.work/2021/05/17/Leetcode/Leetcode-993-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9/"/>
    <id>http://zhuuu.work/2021/05/17/Leetcode/Leetcode-993-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9/</id>
    <published>2021-05-17T07:52:53.000Z</published>
    <updated>2021-05-17T02:18:58.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-993-二叉树的堂兄弟节点"><a href="#Leetcode-993-二叉树的堂兄弟节点" class="headerlink" title="Leetcode-993-二叉树的堂兄弟节点"></a>Leetcode-993-<a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/" target="_blank" rel="noopener">二叉树的堂兄弟节点</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><ul><li>在二叉树中，根节点位于深度 <code>0</code> 处，每个深度为 <code>k</code> 的节点的子节点位于深度 <code>k+1</code> 处。</li><li>如果二叉树的两个节点深度相同，但 <strong>父节点不同</strong> ，则它们是一对<em>堂兄弟节点</em>。</li><li>我们给出了具有唯一值的二叉树的根节点 <code>root</code> ，以及树中两个不同节点的值 <code>x</code> 和 <code>y</code> 。</li><li>只有与值 <code>x</code> 和 <code>y</code> 对应的节点是堂兄弟节点时，才返回 <code>true</code> 。否则，返回 <code>false</code>。</li></ul><p><strong>示例 1：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210517/094222942.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,4], x &#x3D; 4, y &#x3D; 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210517/094241324.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,null,4,null,5], x &#x3D; 5, y &#x3D; 4</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>二叉树的节点数介于 <code>2</code> 到 <code>100</code> 之间。</li><li>每个节点的值都是唯一的、范围为 <code>1</code> 到 <code>100</code> 的整数。</li></ul><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>要想判断两个节点 x 和 <em>y</em> 是否为堂兄弟节点，我们就需要求出这<strong>两个节点分别的「深度」以及「父节点」。</strong></li><li>因此，我们可以从根节点开始，对树进行一次遍历，在遍历的过程中维护「深度」以及「父节点」这两个信息。</li><li>当我们遍历到 x 或 y节点时，就将信息记录下来；当这两个节点都遍历完成了以后，我们就可以退出遍历的过程，判断它们是否为堂兄弟节点了。</li></ul><p>常见的遍历方法有两种：深度优先搜索和广度优先搜索。</p><h2 id="方法一-：-深度优先遍历"><a href="#方法一-：-深度优先遍历" class="headerlink" title="方法一 ： 深度优先遍历"></a>方法一 ： 深度优先遍历</h2><ul><li>我们只需要在深度优先搜索的递归函数中增加表示「深度」以及「父节点」的两个参数即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//DFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 记录x节点的信息</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    TreeNode xParent;</span><br><span class="line">    <span class="keyword">int</span> xDepth;</span><br><span class="line">    <span class="keyword">boolean</span> xFound = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 记录y节点的信息</span></span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    TreeNode yParent;</span><br><span class="line">    <span class="keyword">int</span> yDepth;</span><br><span class="line">    <span class="keyword">boolean</span> yFound = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 判断是否是堂兄弟节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCousins</span><span class="params">(TreeNode root, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;                                             <span class="comment">// 对x赋值</span></span><br><span class="line">        <span class="keyword">this</span>.y = y;                                             <span class="comment">// 对y赋值</span></span><br><span class="line">        dfs(root,<span class="number">0</span>,<span class="keyword">null</span>);                                       <span class="comment">// 从root节点开始遍历</span></span><br><span class="line">        <span class="keyword">return</span> xDepth == yDepth &amp;&amp; xParent != yParent;          <span class="comment">// 父节点不同 深度相同（堂兄弟）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 深度优先搜索</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node, <span class="keyword">int</span> depth,TreeNode parent)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 4.1 递归结束的条件</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.2 如果两个节点都找到了，就可以提前退出遍历</span></span><br><span class="line">        <span class="keyword">if</span>(node.val == x)&#123;</span><br><span class="line">            xParent = parent;</span><br><span class="line">            xDepth  = depth;</span><br><span class="line">            xFound  = <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.val == y)&#123;</span><br><span class="line">            yParent = parent;</span><br><span class="line">            yDepth  = depth;</span><br><span class="line">            yFound  = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(xFound &amp;&amp; yFound)&#123;                                 <span class="comment">// 即使不提前退出，对最坏情况下的时间复杂度也不会有影响</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.3 中序遍历</span></span><br><span class="line">        dfs(node.left,depth + <span class="number">1</span>,node);</span><br><span class="line">        <span class="keyword">if</span>(xFound &amp;&amp; yFound)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(node.right,depth + <span class="number">1</span>,node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li><strong>时间复杂度：</strong>O(n)，其中 n 是树中的节点个数。在最坏情况下，我们需要遍历整棵树，时间复杂度为 O(n)。</li><li><strong>空间复杂度</strong>：O(n)，即为深度优先搜索的过程中需要使用的栈空间。<strong>在最坏情况下，树呈现链状结构</strong>，递归的深度为 O(n）。</li></ul><h2 id="方法二-：-广度优先搜索"><a href="#方法二-：-广度优先搜索" class="headerlink" title="方法二 ： 广度优先搜索"></a>方法二 ： 广度优先搜索</h2><ul><li>在广度优先搜索的过程中，每当我们从队首取出一个节点，它就会作为「父节点」</li><li>它就会作为「父节点」，将最多两个子节点放入队尾。<strong>因此，除了节点以外，我们只需要在队列中额外存储「深度」的信息即可。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 记录x节点的信息</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    TreeNode xParent;</span><br><span class="line">    <span class="keyword">int</span> xDepth;</span><br><span class="line">    <span class="keyword">boolean</span> xFound = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 记录y节点的信息</span></span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    TreeNode yParent;</span><br><span class="line">    <span class="keyword">int</span> yDepth;</span><br><span class="line">    <span class="keyword">boolean</span> yFound = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. BFS逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCousins</span><span class="params">(TreeNode root, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.1 队列</span></span><br><span class="line">        Queue&lt;TreeNode&gt; nodeQueue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; depthQueue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        nodeQueue.offer(root);</span><br><span class="line">        depthQueue.offer(<span class="number">0</span>);</span><br><span class="line">        update(root, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.2 取出父节点，层序遍历判断是否满足条件</span></span><br><span class="line">        <span class="keyword">while</span> (!nodeQueue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = nodeQueue.poll();</span><br><span class="line">            <span class="keyword">int</span> depth = depthQueue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                nodeQueue.offer(node.left);</span><br><span class="line">                depthQueue.offer(depth + <span class="number">1</span>);</span><br><span class="line">                update(node.left, node, depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                nodeQueue.offer(node.right);</span><br><span class="line">                depthQueue.offer(depth + <span class="number">1</span>);</span><br><span class="line">                update(node.right, node, depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (xFound &amp;&amp; yFound) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> xDepth == yDepth &amp;&amp; xParent != yParent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 用来判断是否遍历到 x 或 y 的辅助函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(TreeNode node, TreeNode parent, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.val == x) &#123;</span><br><span class="line">            xParent = parent;</span><br><span class="line">            xDepth = depth;</span><br><span class="line">            xFound = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.val == y) &#123;</span><br><span class="line">            yParent = parent;</span><br><span class="line">            yDepth = depth;</span><br><span class="line">            yFound = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p><strong>时间复杂度</strong>：O(n)，其中 n是树中的节点个数。在最坏情况下，我们需要遍历整棵树，时间复杂度为 O(n)。</p></li><li><p><strong>空间复杂度</strong>：O(n)，即为广度优先搜索的过程中需要使用的队列空间。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-993-二叉树的堂兄弟节点&quot;&gt;&lt;a href=&quot;#Leetcode-993-二叉树的堂兄弟节点&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-993-二叉树的堂兄弟节点&quot;&gt;&lt;/a&gt;Leetcode-993-&lt;a href=&quot;https://leetcode-cn.com/problems/cousins-in-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二叉树的堂兄弟节点&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在二叉树中，根节点位于深度 &lt;code&gt;0&lt;/code&gt; 处，每个深度为 &lt;code&gt;k&lt;/code&gt; 的节点的子节点位于深度 &lt;code&gt;k+1&lt;/code&gt; 处。&lt;/li&gt;
&lt;li&gt;如果二叉树的两个节点深度相同，但 &lt;strong&gt;父节点不同&lt;/strong&gt; ，则它们是一对&lt;em&gt;堂兄弟节点&lt;/em&gt;。&lt;/li&gt;
&lt;li&gt;我们给出了具有唯一值的二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，以及树中两个不同节点的值 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;只有与值 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 对应的节点是堂兄弟节点时，才返回 &lt;code&gt;true&lt;/code&gt; 。否则，返回 &lt;code&gt;false&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210517/094222942.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：root &amp;#x3D; [1,2,3,4], x &amp;#x3D; 4, y &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210517/094241324.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：root &amp;#x3D; [1,2,3,null,4,null,5], x &amp;#x3D; 5, y &amp;#x3D; 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二叉树的节点数介于 &lt;code&gt;2&lt;/code&gt; 到 &lt;code&gt;100&lt;/code&gt; 之间。&lt;/li&gt;
&lt;li&gt;每个节点的值都是唯一的、范围为 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;100&lt;/code&gt; 的整数。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="深度优先搜索" scheme="http://zhuuu.work/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="广度优先搜索" scheme="http://zhuuu.work/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-LCP006-拿硬币</title>
    <link href="http://zhuuu.work/2021/05/17/Leetcode/Leetcode-LCP006-%E6%8B%BF%E7%A1%AC%E5%B8%81/"/>
    <id>http://zhuuu.work/2021/05/17/Leetcode/Leetcode-LCP006-%E6%8B%BF%E7%A1%AC%E5%B8%81/</id>
    <published>2021-05-17T03:02:24.000Z</published>
    <updated>2021-05-17T09:46:39.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-LCP006-拿硬币"><a href="#Leetcode-LCP006-拿硬币" class="headerlink" title="Leetcode-LCP006-拿硬币"></a>Leetcode-LCP006-<a href="https://leetcode-cn.com/problems/na-ying-bi/" target="_blank" rel="noopener">拿硬币</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>桌上有 <code>n</code> 堆力扣币，每堆的数量保存在数组 <code>coins</code> 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">连分数是形如上图的分式。在本题中，所有系数都是大于等于0的整数。</span><br><span class="line"></span><br><span class="line">输入的cont代表连分数的系数（cont[0]代表上图的a0，以此类推）。返回一个长度为2的数组[n, m]，使得连分数的值等于n &#x2F; m，且n, m最大公约数为1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：[4,2,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：[2,3,10]</span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure><ul><li><strong>提示：</strong><ul><li><code>1 &lt;= n &lt;= 4</code></li><li><code>1 &lt;= coins[i] &lt;= 10</code></li></ul></li></ul><a id="more"></a><h2 id="算法思路：模拟"><a href="#算法思路：模拟" class="headerlink" title="算法思路：模拟"></a>算法思路：模拟</h2><ul><li><p>有 n 堆硬币，每次从任意一堆拿走一枚或者两枚。问最少几次能够全部拿完。</p></li><li><p>题目中虽然给了 n 堆硬币，但是最终每一堆都是要拿完的。而每一堆拿的情况又不影响其他硬币堆，<strong>因此每一堆硬币的拿法实际上是互相独立的</strong>。</p></li><li><p>于是我们可以<strong>只考虑一堆的情况。</strong></p><ul><li><strong>假设一堆有 x 枚硬币，既然我们的目的是尽早拿完所有硬币堆，那么两枚两枚的拿显然是更快的。</strong></li><li>求单堆硬币最小次数：<code>(x+1)//2</code></li></ul></li><li><p>那么，拿完所有硬币堆只需要循环对所有硬币堆都计算一次，然后求和就可以了。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCount</span><span class="params">(<span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 统计需要的次数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 每堆硬币拿走的次数为(coin + 1) //2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> coin: coins)&#123;</span><br><span class="line">            count += (coin + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O<em>(</em>n)。</li><li>空间复杂度：O<em>(</em>n*)。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-LCP006-拿硬币&quot;&gt;&lt;a href=&quot;#Leetcode-LCP006-拿硬币&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-LCP006-拿硬币&quot;&gt;&lt;/a&gt;Leetcode-LCP006-&lt;a href=&quot;https://leetcode-cn.com/problems/na-ying-bi/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;拿硬币&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;桌上有 &lt;code&gt;n&lt;/code&gt; 堆力扣币，每堆的数量保存在数组 &lt;code&gt;coins&lt;/code&gt; 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;连分数是形如上图的分式。在本题中，所有系数都是大于等于0的整数。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入的cont代表连分数的系数（cont[0]代表上图的a0，以此类推）。返回一个长度为2的数组[n, m]，使得连分数的值等于n &amp;#x2F; m，且n, m最大公约数为1。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[4,2,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[2,3,10]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= n &amp;lt;= 4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= coins[i] &amp;lt;= 10&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>图像学-色彩空间</title>
    <link href="http://zhuuu.work/2021/05/16/cv/%E5%9B%BE%E5%83%8F%E5%AD%A6-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4/"/>
    <id>http://zhuuu.work/2021/05/16/cv/%E5%9B%BE%E5%83%8F%E5%AD%A6-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4/</id>
    <published>2021-05-16T09:38:38.000Z</published>
    <updated>2021-05-16T03:10:08.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图像学-色彩空间"><a href="#图像学-色彩空间" class="headerlink" title="图像学-色彩空间"></a>图像学-色彩空间</h1><ul><li>作为摄影师，你是不是遇到过这样的问题：相机设置里的色彩空间是什么意思？ sRGB 和 Adobe RGB 有什么不同？为什么我的图片在 Photoshop 里看着好好的，一保存发布到网上色彩就变了？</li><li>本篇文章将分为几个部分。首先从几个实验规律出发，借助线性代数相关的概念，定义色彩空间，然后介绍并推导几个重要的色彩空间之间的关系。</li></ul><h2 id="1-实验基础"><a href="#1-实验基础" class="headerlink" title="1. 实验基础"></a>1. 实验基础</h2><ul><li><p>相信大家都熟悉「三原色」理论，也知道现代显示器是按照 RGB 模式来显示色彩，不知道有没有想过，为什么是「三原色」？为什么是「三」这个数字？为什么一定要选择 RGB 红绿蓝三种颜色作为原色呢？选其他行不行？用四种颜色行不行？</p></li><li><p>知乎上有个问题 <a href="https://www.zhihu.com/question/24886171" target="_blank" rel="noopener">红绿蓝三色是（唯一的）正交基吗？</a> 就提出了这个疑问</p></li><li><p>追根溯源的话，得从我们人类的<strong>视网膜说起。大部分人类的视网膜上有三种感知颜色的感光细胞，叫做视锥细胞，分别对不同波长的光线敏感，称为 L/M/S 型细胞</strong>。三种视锥细胞最敏感的波长分别是橙红色（长波，Long），绿色（中波，Medium），蓝色（短波，Short）。这三种视锥细胞的归一化感光曲线如下图所示（图片数据来自 <a href="https://link.zhihu.com/?target=http%3A//cvrl.ioo.ucl.ac.uk/">CVLR</a> ）</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210110/154904307.png" alt="mark"></p><hr><p>可以看到 L 型视锥细胞与 M 型视锥细胞的感光曲线差别很小，实际上这两种视锥细胞起源于一次基因变异，在这之前人类可都是红绿色盲呢，多亏这个基因变异，让人类可以看到更加多彩的世界——这又是一个庞大的话题了，就此打住。</p><p>总之，大自然的这千千万万种颜色，在人类的眼里看到，最后传送到大脑里的信号，就只有这三种视锥细胞的电信号而已。根据这三种电信号的强弱，大脑解读成了不同的颜色。这就是三原色理论的生物学依据。</p><hr><ul><li><p>不仅如此，人类眼睛对不同颜色光线混合的反应还是 <strong>线性</strong> 的。</p></li><li><p>根据 <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Grassmann%27s_law_(optics)">格拉斯曼定律（Grassmann’s Law）</a>，两束不同颜色的光 <img src="https://www.zhihu.com/equation?tex=C_1" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=C_2" alt="[公式]">，假设某个视锥细胞对他们的反应分别是 <img src="https://www.zhihu.com/equation?tex=r_1" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=r_2" alt="[公式]">，现在将他们按照一个比例混合，得到第三种颜色 <img src="https://www.zhihu.com/equation?tex=C_3+%3D+%5Calpha+C_1+%2B+%5Cbeta+C_2" alt="[公式]">，那么视锥细胞对这个混合颜色的反应也将是前两个反应的线性叠加 <img src="https://www.zhihu.com/equation?tex=r_3+%3D+%5Calpha+r_1+%2B+%0A%5Cbeta+r_2" alt="[公式]">。</p></li><li><p>格拉斯曼定律是一个实验规律，并没有物理或者生物学上的依据。然而这个规律大大简化了我们对人类彩色视觉系统的建模，并且给我们使用线性代数理论分析人类彩色视觉系统提供了一个前提和基础。</p></li></ul><a id="more"></a><h2 id="2-色匹配函数"><a href="#2-色匹配函数" class="headerlink" title="2. 色匹配函数"></a>2. 色匹配函数</h2><ul><li>前面已经提到，人类视网膜上有三种感知色彩的视锥细胞，所以理论上我们用三种颜色的光就可以混合出自然界中任何一种颜色来。</li><li>在 20 世纪 20 年代，David Wright 和 John Guild 各自独立地领导了一些实验，通过三种颜色的光源进行匹配，得到了人眼对于不同颜色光的匹配函数。此后，多名科学家多次进行了类似的实验，加深了我们对人类彩色视觉的认识。</li></ul><p>实验过程大致是这样的，把一个屏幕用不透光的挡板分割成两个区域，左边照射某个被测试的颜色的光线，这里记为<img src="https://www.zhihu.com/equation?tex=C" alt="[公式]"> （以下用大写字母表明颜色，用小写字母表明分量大小），右边同时用三种颜色的光同时照射，这里记为<img src="https://www.zhihu.com/equation?tex=R" alt="[公式]">)，<img src="https://www.zhihu.com/equation?tex=G" alt="[公式]">)，<img src="https://www.zhihu.com/equation?tex=B" alt="[公式]">)。然后，调节右边三种颜色光源的强度，直到左右两边的颜色看上去一样为止。假设这个时候三种颜色的光源强度分别为<img src="https://www.zhihu.com/equation?tex=r" alt="[公式]">)，<img src="https://www.zhihu.com/equation?tex=g" alt="[公式]">)，<img src="https://www.zhihu.com/equation?tex=b" alt="[公式]">，那么根据光色叠加的线性性质，我们可以写出</p><p><img src="https://www.zhihu.com/equation?tex=C+%3D+rR+%2B+gG+%2B+bB" alt="[公式]"></p><p>也就是说，只要按照 (r,g,b) 的分量来混合 (R,G,B) 三种颜色的光，就可以得到 C 这个颜色的光。</p><hr><ul><li><p>于是在这一系列实验里，科学家们把左边的颜色按着光谱顺序，挨个测试了一遍，得到了纯光谱色的混合叠加的数据，这就是 <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/CIE_1931_color_space%23/Color_matching_functions">色匹配函数（Color Matching Function）</a> ，并且在这个基准下定义的色彩空间，就是 CIE RGB 色彩空间。</p></li><li><p>图是 CIE RGB 的色匹配函数曲线，数据来自 <a href="https://link.zhihu.com/?target=http%3A//cvrl.ioo.ucl.ac.uk">CVLR</a>。浅色的细线代表实验中不同参与者个人的色匹配函数曲线，中间深色的粗线代表数据的平均值。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210110/161352290.png" alt="mark"></p><ul><li><p>可以看到，曲线上出现了负数，这是怎么回事？</p><ul><li>回想一下前面描述的实验过程，左边是被测试的光色，右边是可调节的三色光的混合。如果碰到一种情况，右边三色光无论如何调节比例，都不能混合出左边的颜色</li><li>比如某种颜色的光强度已经减小为 0 了，然而看趋势还需要继续减小才能与左边的光色相匹配，怎么办？</li><li>这时候需要往左边的光色中混入三色光中的一种或者几种，继续调节，直到两边的颜色匹配。</li><li>在左边（被测试）的色光中添加，那就是相当于在右边的混合光中减去，这就导致了色匹配函数曲线上出现了负数。实际上，这相当于就是光线的「减法」了。</li></ul></li><li><p>比如，对于 555nm 的黄色光，色匹配函数的值是 (1.30, 0.97, -0.01)，意味着将 1.30 份的红光与 0.97 份的绿光混合放在右边，左边放上 1 份的 555nm 的黄光，以及 0.01 份的蓝光，这样左右两边的光色看上去就一样了。</p></li></ul><hr><ul><li>因为有部分出现了负数，在使用和计算上都有不方便，因此就对这个匹配函数进行了一下线性变换，变换到一个所有分量都是正的空间中。</li><li>变换后的色彩空间就是 CIE XYZ 色彩空间。 图片数据来自 <a href="https://link.zhihu.com/?target=http%3A//cvrl.ioo.ucl.ac.uk">CVLR</a>，</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210110/161910992.png" alt="mark"></p><ul><li>CIE RGB 色彩空间和 CIE XYZ 色彩空间是完全等价的，两者只是差了一个线性变换。由于允许「减法」的存在，因此 CIE RGB 空间是能够表示所有颜色的；同样的，CIE XYZ 空间也能。</li></ul><h2 id="3-从线性空间的角度理解色彩空间"><a href="#3-从线性空间的角度理解色彩空间" class="headerlink" title="3. 从线性空间的角度理解色彩空间"></a>3. 从线性空间的角度理解色彩空间</h2><ul><li>以上的实验基础提示我们，色彩空间和线性代数中的线性空间之间具有某种相似性。我们可以看到，由于人类有三种感知色彩的视锥细胞，自然界千千万万的色彩被眼睛接收后，可以用三个数值来表征。</li><li>而格拉斯曼定律也揭示了色彩叠加的线性性质。<strong>这似乎意味着，色彩空间就是一个 3 维的线性空间。事实上也的确如此</strong>（详细的论证参见末尾小节）。</li></ul><hr><ul><li><p>自然界本身是没有「颜色」这个属性的，只有对不同波长光线的反射率/透过率，到达人眼中的，显然是一个连续的光谱分布函数。数学上，这是一个无穷维的函数空间（巴拿赫空间）。</p><ul><li>而人眼内的三种视锥细胞，它们的感光特性曲线相当于是在这个无穷维的函数空间中建立了三个基底。任何一个光谱分布进来，三种视锥细胞被激发。由于色视觉响应的线性性，这一过程相当于光谱分布函数与三个基底做内积，或者说，「投影」到这三个基底上。</li></ul></li><li><p><strong>从这个观点看，人类的色视觉，是相当于在自然界所有颜色的无穷维函数空间中取了一个三维的投影。这个三维空间的基底，既可以是视锥细胞的感光特性曲线（我们的大脑就用的是这套），当然也可以是选取三种颜色的光进行组合（CIE RGB 空间），甚至还可以是用实际中不存在的「光线」进行组合 （CIE XYZ 空间）。</strong></p><ul><li><strong>既然这几个空间实际上是同一个线性空间，只不过由于选择了不同的基底而有不同的表达形式，那么根据线性代数的结论，这几个空间的表述形式之间，只需要通过矩阵乘法就可以完成转换，这是完全的线性变换。</strong></li><li>当然，色彩空间并不是真正数学意义上的三维线性空间。由于不存在真正数学意义的「减法」，在实际应用中是有所限制的。数学中的「线性组合」在这里就要被替换为「锥组合」，也就是每个分量都必须是大于等于 0 的。</li></ul></li></ul><hr><ul><li>至此我们终于可以回答开头的部分问题了，<strong>为什么是三原色？因为人类对色彩的感知结果位于一个三维的线性空间中。最少需要三种颜色的光才能有足够的表达能力来表现各种颜色。</strong></li><li>为什么选 RGB 作为三原色？因为色彩空间不是真正数学意义上的线性空间，从工程角度考虑，以 RGB 作为三原色，能让显示器能够显示更多的颜色（此外，最初测试人眼对 RGB 三色光的色匹配曲线，也是希望能尽量单独地刺激三种视锥细胞）。</li></ul><h2 id="4-设备相关的RGB色彩空间"><a href="#4-设备相关的RGB色彩空间" class="headerlink" title="4. 设备相关的RGB色彩空间"></a>4. 设备相关的RGB色彩空间</h2><ul><li><p>如前文所述，色彩空间的基底的选择有一定的任意性。事实上，如果允许真正的减法存在，那么选择哪三种颜色作为基底是无关紧要的。不过由于实际中我们不能对色光采用减法，只能使用「锥组合」而非「线性组合」，这时候到底如何选取基底就显得重要了。好的基底不仅能表达的颜色更丰富，而且工程上也易于稳定地实现。</p></li><li><p>由于 CIE XYZ 空间是一个很方便的线性空间，与具体设备无关，因此常用来做各种颜色空间转换的中间媒介。设想某个颜色的光，经过色匹配函数的计算，得到了三个 XYZ 的值，如果直接将这三个值作为 RGB 颜色显示到屏幕上，显然是不对的。我们必须把 XYZ 的值转换到屏幕的 RGB 空间中的值。</p><p><img src="https://www.zhihu.com/equation?tex=%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A++++++++R_%7B%5Ctext%7Blin%7D%7D+%5C%5C+G_%7B%5Ctext%7Blin%7D%7D+%5C%5C+B_%7B%5Ctext%7Blin%7D%7D%0A++++%5Cend%7Barray%7D%5Cright%5D+%3D+%0A++++%5Cboldsymbol%7BM%7D%0A++++%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A++++++++X+%5C%5C+Y+%5C%5C+Z%0A++++%5Cend%7Barray%7D%5Cright%5D" alt="[公式]"></p></li></ul><p>这里下标 lin 代表线性空间，<img src="https://www.zhihu.com/equation?tex=%5Cboldsymbol%7BM%7D" alt="[公式]"> 是转换矩阵。得到线性 RGB 空间的表达之后，还需要经过 gamma 校正，才是最终在屏幕上显示的 RGB 的值。一般的 gamma 校正过程为 <img src="https://www.zhihu.com/equation?tex=C+%3D+%5Ctextstyle+C%5E%7B1%2F%5Cgamma%7D_%7B%5Ctext%7Blin%7D%7D" alt="[公式]">，其中 <img src="https://www.zhihu.com/equation?tex=C" alt="[公式]"> 代表 RGB 的某个分量，<img src="https://www.zhihu.com/equation?tex=%5Cgamma" alt="[公式]"> 值通常为 2.2。对于如何计算的细节，我希望在 <a href="https://zhuanlan.zhihu.com/p/24281841" target="_blank" rel="noopener">下一篇文章</a> 中进行详细说明。</p><ul><li>对于 RGB 色彩空间来说，关键点在于两个：<ul><li><strong>如何选择三个作为基底的颜色；</strong></li><li><strong>如何定义白色</strong>。一旦选好这两个关键参数，那么从 CIE XYZ 空间到设备的 RGB 空间的转换就完全确定了。我们平时常说的 sRGB 空间和 Adobe RGB 空间，他们的区别就在于这两个关键参数的定义不同。常用的的 RGB 空间的转换矩阵如下表：</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210110/164118772.png" alt="mark"></p><p>不同的 RGB 空间能表示的范围如下图所示（这个图在 <a href="https://zhuanlan.zhihu.com/p/24281841" target="_blank" rel="noopener">以后的文章</a> 中再详细解释），</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210110/164151141.png" alt="mark"></p><ul><li><p>可以看到，不同的 RGB 空间所能表示的颜色范围是不一样的，并且我们可以推断出，即使是同样的 RGB 分量，在不同的 RGB 空间中所代表的颜色也是不一样的。所以我们在描述一个 RGB 颜色的时候，<strong>不仅需要描述它的 RGB 三个分量，还要说明是在哪个空间，这就是 ICC 文件的作用。</strong></p></li><li><p><strong>很多数码相机都可以设置色彩空间，常见的有 sRGB 和 Adobe RGB</strong></p><ul><li>从上面的图中我们可以看到， Adobe RGB 所能表达的色彩比 sRGB 要丰富很多。然而常见的网络环境下图片的色彩空间是 sRGB，有很多浏览器不能正确地解析图片自带的色彩空间说明，默认按照 sRGB 来进行解析。</li><li>如果使用相机直出的 JPG 文件直接上传，或者说在后期处理过程中没有进行色彩空间转换，保留了相机设置的 Adobe RGB 空间，那么在浏览器中看到的图片很可能与 Photoshop 中看到的不一样。</li><li>浏览器很可能会将一张 Adobe RGB 空间中的图片解释为 sRGB 空间下的图片，引起颜色偏差。<strong>由于 sRGB 是目前屏幕显示的「事实标准」</strong>，大多数屏幕空间都在 sRGB 内（这是颜色复现设备本身决定的），所以我的建议是，对用于网络交流目的的图片，统一转换到 sRGB 中进行保存。</li></ul></li></ul><h2 id="5-数学论证"><a href="#5-数学论证" class="headerlink" title="5. 数学论证"></a>5. 数学论证</h2><p>回顾一下线性代数中构成线性空间的几个要素：</p><blockquote><p>交换律：<img src="https://www.zhihu.com/equation?tex=%5Cboldsymbol%7Bx%7D%2B%5Cboldsymbol%7By%7D+%3D+%5Cboldsymbol%7By%7D%2B%5Cboldsymbol%7Bx%7D" alt="[公式]"></p><p>结合律：<img src="https://www.zhihu.com/equation?tex=%28%5Cboldsymbol%7Bx%7D%2B%5Cboldsymbol%7By%7D%29%2B%5Cboldsymbol%7Bz%7D+%3D+%0A%5Cboldsymbol%7Bx%7D%2B%28%5Cboldsymbol%7By%7D%2B%5Cboldsymbol%7Bz%7D%29" alt="[公式]"></p></blockquote><p>这两条容易理解，显然，交换不同色光叠加的顺序并不会改变叠加的结果。</p><blockquote><p>加法零元：<img src="https://www.zhihu.com/equation?tex=%5Cexists+%5C%3A+%5Cboldsymbol%7B0%7D%2C%5C%3B+%5Cforall+%5C%2C+%5Cboldsymbol%7Bx%7D%2C+%5C%3B%0A%5Cmbox%7Bs.t.%7D%5C%3B+%5Cboldsymbol%7Bx%7D+%2B+%5Cboldsymbol%7B0%7D+%3D+%5Cboldsymbol%7Bx%7D" alt="[公式]"></p></blockquote><p>这一点也很好理解，加法零元就是全黑，什么光都没有。任何一种色光叠加一个全黑那还是它自身。</p><blockquote><p>加法逆元：<img src="https://www.zhihu.com/equation?tex=%5Cforall+%5C%2C+%5Cboldsymbol%7Bx%7D%2C+%5C%3B%5Cexists+%5C%3A+%28-%5Cboldsymbol%7Bx%7D%29%2C%5C%3B+%0A%5Cboldsymbol%7Bx%7D+%2B+%28-%5Cboldsymbol%7Bx%7D%29+%3D+%5Cboldsymbol%7B0%7D" alt="[公式]"></p></blockquote><p>回想前文对实验中需要「负数」数量的光的处理手法，我们可以在左边叠加光线，这就相当于在右边减去光线。如果承认这种形式的「减法」，那么加法逆元也是顺理成章了：在另一边加入自身。</p><blockquote><p>乘法幺元：<img src="https://www.zhihu.com/equation?tex=%5Cexists+%5C%3A+1%2C%5C%3B+%5Cforall+%5C%2C+%5Cboldsymbol%7Bx%7D%2C+%5C%3B%0A1%5Ccdot%5Cboldsymbol%7Bx%7D+%3D+%5Cboldsymbol%7Bx%7D" alt="[公式]"></p></blockquote><p>这也很明显，数字 1 就可以作为乘法幺元。</p><blockquote><p>乘法分配率：<br><img src="https://www.zhihu.com/equation?tex=%5Cforall+%5Cboldsymbol%7Bx%7D%2C+%5C%3A+%5Cboldsymbol%7By%7D%2C+%5C%3A+%5Calpha%2C%5C%3B%0A%5Cmbox%7Bs.t.%7D%5C%3B%5Calpha%5C%2C%28%5Cboldsymbol%7Bx%7D+%2B+%5Cboldsymbol%7By%7D%29+%3D+%5Calpha+%5Cboldsymbol%7Bx%7D+%2B+%0A%5Calpha+%5Cboldsymbol%7By%7D" alt="[公式]"><br><img src="https://www.zhihu.com/equation?tex=%5Cforall+%5Calpha%2C%5C%3A%5Cbeta%2C%5C%3A%5Cboldsymbol%7Bx%7D%2C%5C%3B%0A%5Cmbox%7Bs.t.%7D%5C%3B+%28%5Calpha%2B%5Cbeta%29%5C%2C%5Cboldsymbol%7Bx%7D+%3D+%0A%5Calpha+%5Cboldsymbol%7Bx%7D+%2B+%5Cbeta+%5Cboldsymbol%7Bx%7D" alt="[公式]"></p></blockquote><p>根据格拉斯曼定律，这一点也是实际上成立的。</p><p>综上所述，人类对色彩的感知在实验层面满足线性性质，人眼感知的色彩空间是一个 3 维线性空间。当然，容易想见，通常我们选取的基底（比如 CIE XYZ 空间的色匹配函数），是不正交的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;图像学-色彩空间&quot;&gt;&lt;a href=&quot;#图像学-色彩空间&quot; class=&quot;headerlink&quot; title=&quot;图像学-色彩空间&quot;&gt;&lt;/a&gt;图像学-色彩空间&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;作为摄影师，你是不是遇到过这样的问题：相机设置里的色彩空间是什么意思？ sRGB 和 Adobe RGB 有什么不同？为什么我的图片在 Photoshop 里看着好好的，一保存发布到网上色彩就变了？&lt;/li&gt;
&lt;li&gt;本篇文章将分为几个部分。首先从几个实验规律出发，借助线性代数相关的概念，定义色彩空间，然后介绍并推导几个重要的色彩空间之间的关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-实验基础&quot;&gt;&lt;a href=&quot;#1-实验基础&quot; class=&quot;headerlink&quot; title=&quot;1. 实验基础&quot;&gt;&lt;/a&gt;1. 实验基础&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;相信大家都熟悉「三原色」理论，也知道现代显示器是按照 RGB 模式来显示色彩，不知道有没有想过，为什么是「三原色」？为什么是「三」这个数字？为什么一定要选择 RGB 红绿蓝三种颜色作为原色呢？选其他行不行？用四种颜色行不行？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎上有个问题 &lt;a href=&quot;https://www.zhihu.com/question/24886171&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;红绿蓝三色是（唯一的）正交基吗？&lt;/a&gt; 就提出了这个疑问&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;追根溯源的话，得从我们人类的&lt;strong&gt;视网膜说起。大部分人类的视网膜上有三种感知颜色的感光细胞，叫做视锥细胞，分别对不同波长的光线敏感，称为 L/M/S 型细胞&lt;/strong&gt;。三种视锥细胞最敏感的波长分别是橙红色（长波，Long），绿色（中波，Medium），蓝色（短波，Short）。这三种视锥细胞的归一化感光曲线如下图所示（图片数据来自 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//cvrl.ioo.ucl.ac.uk/&quot;&gt;CVLR&lt;/a&gt; ）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210110/154904307.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;可以看到 L 型视锥细胞与 M 型视锥细胞的感光曲线差别很小，实际上这两种视锥细胞起源于一次基因变异，在这之前人类可都是红绿色盲呢，多亏这个基因变异，让人类可以看到更加多彩的世界——这又是一个庞大的话题了，就此打住。&lt;/p&gt;
&lt;p&gt;总之，大自然的这千千万万种颜色，在人类的眼里看到，最后传送到大脑里的信号，就只有这三种视锥细胞的电信号而已。根据这三种电信号的强弱，大脑解读成了不同的颜色。这就是三原色理论的生物学依据。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不仅如此，人类眼睛对不同颜色光线混合的反应还是 &lt;strong&gt;线性&lt;/strong&gt; 的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;根据 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Grassmann%27s_law_(optics)&quot;&gt;格拉斯曼定律（Grassmann’s Law）&lt;/a&gt;，两束不同颜色的光 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C_1&quot; alt=&quot;[公式]&quot;&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C_2&quot; alt=&quot;[公式]&quot;&gt;，假设某个视锥细胞对他们的反应分别是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_1&quot; alt=&quot;[公式]&quot;&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_2&quot; alt=&quot;[公式]&quot;&gt;，现在将他们按照一个比例混合，得到第三种颜色 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C_3+%3D+%5Calpha+C_1+%2B+%5Cbeta+C_2&quot; alt=&quot;[公式]&quot;&gt;，那么视锥细胞对这个混合颜色的反应也将是前两个反应的线性叠加 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_3+%3D+%5Calpha+r_1+%2B+%0A%5Cbeta+r_2&quot; alt=&quot;[公式]&quot;&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;格拉斯曼定律是一个实验规律，并没有物理或者生物学上的依据。然而这个规律大大简化了我们对人类彩色视觉系统的建模，并且给我们使用线性代数理论分析人类彩色视觉系统提供了一个前提和基础。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="计算机图形学" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-690-员工的重要性</title>
    <link href="http://zhuuu.work/2021/05/16/Leetcode/Leetcode-690-%E5%91%98%E5%B7%A5%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/"/>
    <id>http://zhuuu.work/2021/05/16/Leetcode/Leetcode-690-%E5%91%98%E5%B7%A5%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</id>
    <published>2021-05-16T08:22:53.000Z</published>
    <updated>2021-05-16T03:47:08.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-690-员工的重要性"><a href="#Leetcode-690-员工的重要性" class="headerlink" title="Leetcode-690-员工的重要性"></a>Leetcode-690-<a href="https://leetcode-cn.com/problems/employee-importance/" target="_blank" rel="noopener">员工的重要性</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个保存员工信息的数据结构，它包含了员工 <strong>唯一的 id</strong> ，<strong>重要度</strong> 和 <strong>直系下属的 id</strong> 。</p><p>比如，员工 1 是员工 2 的领导，员工 2 是员工 3 的领导。他们相应的重要度为 15 , 10 , 5 。</p><p>那么员工 1 的数据结构是 [1, 15, [2]] ，员工 2的 数据结构是 [2, 10, [3]] ，员工 3 的数据结构是 [3, 5, []] 。</p><p>注意虽然员工 3 也是员工 1 的一个下属，但是由于 <strong>并不是直系</strong> 下属，因此没有体现在员工 1 的数据结构中。</p><ul><li>现在输入一个公司的所有员工信息，以及单个员工 id ，返回这个员工和他所有下属的重要度之和。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1</span><br><span class="line">输出：11</span><br><span class="line">解释：</span><br><span class="line">员工 1 自身的重要度是 5 ，他有两个直系下属 2 和 3 ，而且 2 和 3 的重要度均为 3 。因此员工 1 的总重要度是 5 + 3 + 3 &#x3D; 11 。</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-690-员工的重要性&quot;&gt;&lt;a href=&quot;#Leetcode-690-员工的重要性&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-690-员工的重要性&quot;&gt;&lt;/a&gt;Leetcode-690-&lt;a href=&quot;https://leetcode-cn.com/problems/employee-importance/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;员工的重要性&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个保存员工信息的数据结构，它包含了员工 &lt;strong&gt;唯一的 id&lt;/strong&gt; ，&lt;strong&gt;重要度&lt;/strong&gt; 和 &lt;strong&gt;直系下属的 id&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;比如，员工 1 是员工 2 的领导，员工 2 是员工 3 的领导。他们相应的重要度为 15 , 10 , 5 。&lt;/p&gt;
&lt;p&gt;那么员工 1 的数据结构是 [1, 15, [2]] ，员工 2的 数据结构是 [2, 10, [3]] ，员工 3 的数据结构是 [3, 5, []] 。&lt;/p&gt;
&lt;p&gt;注意虽然员工 3 也是员工 1 的一个下属，但是由于 &lt;strong&gt;并不是直系&lt;/strong&gt; 下属，因此没有体现在员工 1 的数据结构中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;现在输入一个公司的所有员工信息，以及单个员工 id ，返回这个员工和他所有下属的重要度之和。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：[[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;员工 1 自身的重要度是 5 ，他有两个直系下属 2 和 3 ，而且 2 和 3 的重要度均为 3 。因此员工 1 的总重要度是 5 + 3 + 3 &amp;#x3D; 11 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="BFS" scheme="http://zhuuu.work/tags/BFS/"/>
    
      <category term="DFS" scheme="http://zhuuu.work/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-012-整数转罗马数字</title>
    <link href="http://zhuuu.work/2021/05/14/Leetcode/Leetcode-012-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <id>http://zhuuu.work/2021/05/14/Leetcode/Leetcode-012-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</id>
    <published>2021-05-14T03:02:24.000Z</published>
    <updated>2021-05-14T01:21:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-012-整数转罗马数字"><a href="#Leetcode-012-整数转罗马数字" class="headerlink" title="Leetcode-012-整数转罗马数字"></a>Leetcode-012-<a href="https://leetcode-cn.com/problems/integer-to-roman/" target="_blank" rel="noopener">整数转罗马数字</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</span><br><span class="line"></span><br><span class="line">通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</span><br><span class="line"></span><br><span class="line">I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</span><br><span class="line">X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </span><br><span class="line">C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</span><br></pre></td></tr></table></figure><ul><li>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 3</span><br><span class="line">输出: &quot;III&quot;</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 4</span><br><span class="line">输出: &quot;IV&quot;</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: 9</span><br><span class="line">输出: &quot;IX&quot;</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">输入: 58</span><br><span class="line">输出: &quot;LVIII&quot;</span><br><span class="line">解释: L &#x3D; 50, V &#x3D; 5, III &#x3D; 3.</span><br><span class="line"></span><br><span class="line">示例 5:</span><br><span class="line"></span><br><span class="line">输入: 1994</span><br><span class="line">输出: &quot;MCMXCIV&quot;</span><br><span class="line">解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= num &lt;= 3999</code></li></ul><a id="more"></a><h2 id="方法一-：-贪心算法"><a href="#方法一-：-贪心算法" class="headerlink" title="方法一 ： 贪心算法"></a>方法一 ： 贪心算法</h2><ul><li>罗马数字由 7 个不同的单字母符号组成，每个符号对应一个具体的数值。此外，减法规则（如问题描述中所述）给出了额外的 6 个复合符号。</li><li>这给了我们总共 13 个独特的符号（每个符号由 1 个或 2 个字母组成），如下图所示。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-091632912.png" alt="mark"></p><p><strong>罗马数字的唯一表示法</strong></p><ul><li>从一个例子入手。考虑 140 的罗马数字表示，下面哪一个是正确的？</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-091654117.png" alt="mark"></p><ul><li>确定罗马数字的规则是：对于罗马数字从左到右的每一位，选择尽可能大的符号值。<ul><li>对于 140，最大可以选择的符号值为 C=100。</li><li>接下来，对于剩余的数字 40，最大可以选择的符号值为 XL=40</li><li>因此，140 的对应的罗马数字为 <code>C+XL=CXL</code></li></ul></li></ul><p><strong>算法实现</strong></p><ul><li>根据罗马数字的唯一表示法，为了表示一个给定的整数 num，我们寻找不超过 num 的最大符号值，<ul><li>将 num 减去该符号值，然后继续寻找不超过 num 的最大符号值，</li><li>将该符号拼接在上一个找到的符号之后，</li><li>循环直至 num 为 0。</li><li>最后得到的字符串即为 num 的罗马数字表示。</li></ul></li><li>编程时，可以建立一个数值-符号对的列表 <em>valueSymbols</em>，按数值从大到小排列。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 编程时，可以建立一个数值-符号对的列表 valueSymbols，按数值从大到小排列。</span><br><span class="line">int[] values &#x3D; &#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;;</span><br><span class="line">String[] symbols &#x3D; &#123;&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>遍历<em>valueSymbols</em> 中的每个数值-符号对，</p></li><li><p>若当前数值value 不超过 num，则从 num 中不断减去 value，直至num 小于 value</p></li><li><p>然后遍历下一个数值-符号对。若遍历中 num为 0 则跳出循环。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 编程时，可以建立一个数值-符号对的列表 valueSymbols，按数值从大到小排列。</span></span><br><span class="line">    <span class="keyword">int</span>[] values = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    String[] symbols = &#123;<span class="string">"M"</span>, <span class="string">"CM"</span>, <span class="string">"D"</span>, <span class="string">"CD"</span>, <span class="string">"C"</span>, <span class="string">"XC"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>, <span class="string">"X"</span>, <span class="string">"IX"</span>, <span class="string">"V"</span>, <span class="string">"IV"</span>, <span class="string">"I"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 寻找罗马数字的唯一表示法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        StringBuffer roman = <span class="keyword">new</span> StringBuffer();            <span class="comment">// 用于返回结果</span></span><br><span class="line">        <span class="comment">// 2.1 寻找不超过num 的最大符号值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; values.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> value = values[i];</span><br><span class="line">            String symbol = symbols[i];</span><br><span class="line">            <span class="comment">// 2.2 将 num 减去该符号值，然后继续寻找不超过 num 的最大符号值</span></span><br><span class="line">            <span class="keyword">while</span>(num &gt;= value)&#123;</span><br><span class="line">                num -= value;</span><br><span class="line">                roman.append(symbol);                       <span class="comment">// 将该符号拼接在上一个找到的符号之后</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2.3 判断循环直至 num 为 0。最后得到的字符串即为num 的罗马数字表示。</span></span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> roman.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(1)。由于 valueSymbols 长度是固定的，且这 13 字符中的每个字符的出现次数均不会超过 3，因此循环次数有一个确定的上限。对于本题给出的数据范围，循环次数不会超过 15 次。</p></li><li><p>空间复杂度：O(1)</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-012-整数转罗马数字&quot;&gt;&lt;a href=&quot;#Leetcode-012-整数转罗马数字&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-012-整数转罗马数字&quot;&gt;&lt;/a&gt;Leetcode-012-&lt;a href=&quot;https://leetcode-cn.com/problems/integer-to-roman/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;整数转罗马数字&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;罗马数字包含以下七种字符： &lt;code&gt;I&lt;/code&gt;， &lt;code&gt;V&lt;/code&gt;， &lt;code&gt;X&lt;/code&gt;， &lt;code&gt;L&lt;/code&gt;，&lt;code&gt;C&lt;/code&gt;，&lt;code&gt;D&lt;/code&gt; 和 &lt;code&gt;M&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;字符          数值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;I             1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;V             5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X             10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;L             50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;C             100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;D             500&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;M             1000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;III&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;IV&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: 9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;IX&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 4:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: 58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;LVIII&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: L &amp;#x3D; 50, V &amp;#x3D; 5, III &amp;#x3D; 3.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 5:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: 1994&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;MCMXCIV&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: M &amp;#x3D; 1000, CM &amp;#x3D; 900, XC &amp;#x3D; 90, IV &amp;#x3D; 4.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= num &amp;lt;= 3999&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="贪心算法" scheme="http://zhuuu.work/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1310-子数组异或查询</title>
    <link href="http://zhuuu.work/2021/05/12/Leetcode/Leetcode-1310-%E5%AD%90%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%9F%A5%E8%AF%A2/"/>
    <id>http://zhuuu.work/2021/05/12/Leetcode/Leetcode-1310-%E5%AD%90%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%9F%A5%E8%AF%A2/</id>
    <published>2021-05-12T03:02:24.000Z</published>
    <updated>2021-05-12T01:37:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-1310-子数组异或查询"><a href="#Leetcode-1310-子数组异或查询" class="headerlink" title="Leetcode-1310-子数组异或查询"></a>Leetcode-1310-<a href="https://leetcode-cn.com/problems/xor-queries-of-a-subarray/" target="_blank" rel="noopener">子数组异或查询</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>有一个正整数数组 <code>arr</code>，现给你一个对应的查询数组 <code>queries</code>，其中 <code>queries[i] = [Li, Ri]</code>。</p></li><li><p>对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 <code>arr[Li] xor arr[Li+1] xor ... xor arr[Ri]</code>）作为本次查询的结果。</p></li><li><p>并返回一个包含给定查询 <code>queries</code> 所有结果的数组。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [1,3,4,8], queries &#x3D; [[0,1],[1,2],[0,3],[3,3]]</span><br><span class="line">输出：[2,7,14,8] </span><br><span class="line">解释：</span><br><span class="line">数组中元素的二进制表示形式是：</span><br><span class="line">1 &#x3D; 0001 </span><br><span class="line">3 &#x3D; 0011 </span><br><span class="line">4 &#x3D; 0100 </span><br><span class="line">8 &#x3D; 1000 </span><br><span class="line">查询的 XOR 值为：</span><br><span class="line">[0,1] &#x3D; 1 xor 3 &#x3D; 2 </span><br><span class="line">[1,2] &#x3D; 3 xor 4 &#x3D; 7 </span><br><span class="line">[0,3] &#x3D; 1 xor 3 xor 4 xor 8 &#x3D; 14 </span><br><span class="line">[3,3] &#x3D; 8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：arr &#x3D; [4,8,2,10], queries &#x3D; [[2,3],[1,3],[0,0],[0,3]]</span><br><span class="line">输出：[8,0,4,4]</span><br></pre></td></tr></table></figure><ul><li><strong>提示：</strong><ul><li><code>1 &lt;= arr[i] &lt;= 10^9</code></li><li><code>1 &lt;= arr.length &lt;= 3 * 10^4</code></li><li><code>encoded.length == n - 1</code></li><li><code>1 &lt;= queries.length &lt;= 3 * 10^4</code></li><li><code>0 &lt;= queries[i][0] &lt;= queries[i][1] &lt; arr.length</code></li></ul></li></ul><a id="more"></a><h2 id="算法思路：异或性质-前缀和"><a href="#算法思路：异或性质-前缀和" class="headerlink" title="算法思路：异或性质/前缀和"></a>算法思路：异或性质/前缀和</h2><p><strong>异或运算具有如下性质：</strong></p><ul><li><p>异或运算满足交换律和结合律；</p></li><li><p>任意整数和自身做异或运算的结果都等于 0，即<code>x⊕x=0；</code></p></li><li><p>任意整数和 0 做异或运算的结果都等于其自身，即<code>x⊕0=0⊕x=x。</code></p></li></ul><p>依然可以考虑能否使用<code>前缀和</code>的思想解决本题：</p><ul><li>假设有数组<code>arr = [A, B, C, D, E],</code>将异或运算<code>A XOR B</code>简记为<code>AB</code>，那么前缀和<code>preXOR = [0, A, AB, ABC, ABCD, ABCDE](preXOR的第一个数值0可以认为是初始化)；</code></li><li>假设我们求 <code>[1, 2]</code> 区间上的区间异或，那么结果为<code>arr[1] XOR arr[2] = BC = preXOR[2 + 1] XOR preXOR[1] = ABC XOR A = BC</code>，至此，我们使用前缀和<code>preXOR</code>得到了区间异或结果。</li></ul><p><strong>具体来说：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210512-092119417.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210512-092142117.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] xorQueries(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[][] queries) &#123;</span><br><span class="line">        <span class="comment">// 1. 计算异或前缀和</span></span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">int</span>[] xors = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];                <span class="comment">// 前缀和数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;                   <span class="comment">// 计算前缀和</span></span><br><span class="line">            xors[i + <span class="number">1</span>] = xors[i] ^ arr[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 计算前缀和区间查询数组</span></span><br><span class="line">        <span class="keyword">int</span> m = queries.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;                   <span class="comment">// 区间[left,right]的前缀和</span></span><br><span class="line">            ans[i] = xors[queries[i][<span class="number">0</span>]] ^ xors[queries[i][<span class="number">1</span>] + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 返回结果数组</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ：<code>O(n + m)</code> , 其中n是arr的长度, m是queries的长度</li><li>空间复杂度 ：<code>O(1)</code>  注意空间复杂度不考虑返回值。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-1310-子数组异或查询&quot;&gt;&lt;a href=&quot;#Leetcode-1310-子数组异或查询&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-1310-子数组异或查询&quot;&gt;&lt;/a&gt;Leetcode-1310-&lt;a href=&quot;https://leetcode-cn.com/problems/xor-queries-of-a-subarray/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;子数组异或查询&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;有一个正整数数组 &lt;code&gt;arr&lt;/code&gt;，现给你一个对应的查询数组 &lt;code&gt;queries&lt;/code&gt;，其中 &lt;code&gt;queries[i] = [Li, Ri]&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 &lt;code&gt;arr[Li] xor arr[Li+1] xor ... xor arr[Ri]&lt;/code&gt;）作为本次查询的结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;并返回一个包含给定查询 &lt;code&gt;queries&lt;/code&gt; 所有结果的数组。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：arr &amp;#x3D; [1,3,4,8], queries &amp;#x3D; [[0,1],[1,2],[0,3],[3,3]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[2,7,14,8] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;数组中元素的二进制表示形式是：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;#x3D; 0001 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3 &amp;#x3D; 0011 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4 &amp;#x3D; 0100 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8 &amp;#x3D; 1000 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;查询的 XOR 值为：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[0,1] &amp;#x3D; 1 xor 3 &amp;#x3D; 2 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[1,2] &amp;#x3D; 3 xor 4 &amp;#x3D; 7 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[0,3] &amp;#x3D; 1 xor 3 xor 4 xor 8 &amp;#x3D; 14 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[3,3] &amp;#x3D; 8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：arr &amp;#x3D; [4,8,2,10], queries &amp;#x3D; [[2,3],[1,3],[0,0],[0,3]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[8,0,4,4]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= arr[i] &amp;lt;= 10^9&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= arr.length &amp;lt;= 3 * 10^4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;encoded.length == n - 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= queries.length &amp;lt;= 3 * 10^4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= queries[i][0] &amp;lt;= queries[i][1] &amp;lt; arr.length&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="异或" scheme="http://zhuuu.work/tags/%E5%BC%82%E6%88%96/"/>
    
      <category term="前缀和" scheme="http://zhuuu.work/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-303- 区域和检索 - 数组不可变</title>
    <link href="http://zhuuu.work/2021/05/12/Leetcode/Leetcode-303-%20%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/"/>
    <id>http://zhuuu.work/2021/05/12/Leetcode/Leetcode-303-%20%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/</id>
    <published>2021-05-12T03:02:24.000Z</published>
    <updated>2021-05-12T01:03:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-303-区域和检索-数组不可变"><a href="#Leetcode-303-区域和检索-数组不可变" class="headerlink" title="Leetcode-303- 区域和检索 - 数组不可变"></a>Leetcode-303- <a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">区域和检索 - 数组不可变</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>给定一个整数数组  <code>nums</code>，求出数组从索引 <code>i</code> 到 <code>j</code>（<code>i ≤ j</code>）范围内元素的总和，包含 <code>i</code>、<code>j</code>两点。</p></li><li><p>实现 <code>NumArray</code> 类：</p><ul><li><p><code>NumArray(int[] nums)</code> 使用数组 <code>nums</code> 初始化对象</p></li><li><p><code>int sumRange(int i, int j)</code>返回数组<code>nums</code>从索引<code>i</code>到 j（i ≤ j）范围内元素的总和，包含<code>i、j</code>两点（也就是 <code>sum(nums[i], nums[i + 1], ... , nums[j])）</code></p></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]</span><br><span class="line">[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]</span><br><span class="line">输出：</span><br><span class="line">[null, 1, -1, -3]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">NumArray numArray &#x3D; new NumArray([-2, 0, 3, -5, 2, -1]);</span><br><span class="line">numArray.sumRange(0, 2); &#x2F;&#x2F; return 1 ((-2) + 0 + 3)</span><br><span class="line">numArray.sumRange(2, 5); &#x2F;&#x2F; return -1 (3 + (-5) + 2 + (-1)) </span><br><span class="line">numArray.sumRange(0, 5); &#x2F;&#x2F; return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))</span><br></pre></td></tr></table></figure><ul><li><p><strong>提示：</strong></p><ul><li><p><code>0 &lt;= nums.length &lt;= 10^4</code></p></li><li><p><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></p></li><li><p><code>0 &lt;= i &lt;= j &lt; nums.length</code></p></li><li><p>最多调用<code>10^4 次 sumRange</code> 方法</p></li></ul></li></ul><a id="more"></a><h2 id="算法思路：前缀和"><a href="#算法思路：前缀和" class="headerlink" title="算法思路：前缀和"></a>算法思路：前缀和</h2><ul><li><p>关于<code>区间求和</code>，常用手段是<code>前缀和</code>。（如果学过GRE数学，那么可以将<code>前缀和</code>和<code>百分位数（percentile）</code>的定义放在一起）</p></li><li><p>我们举一个简单的例子：</p><ul><li>假如需要对<code>nums = [1, 2, 3, 4, 5]</code>进行处理，我们先得到前缀和。所谓前缀和就是从数组的0位置开始到当前位置的和值，比如nums的前缀和是<code>preSum = [0, 1, 1 + 2, 1 + 2 + 3, 1 + 2 + 3 + 4, 1 + 2 + 3 + 4 + 5]</code>，即<code>preSum = [0, 1, 3, 6, 10, 15](preSum[0] = 0 可以认为是初始化)；</code></li><li>得到前缀和之后，可以求区间的和值。比如说求 [2 , 4] 区间的和值，那么就是<code>3 + 4 + 5 = preSum[4 + 1] - preSum[2] = 15 - 3 = 12。</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.提前计算出前缀和</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        sum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++)&#123;</span><br><span class="line">            sum[i + <span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 计算出这段数组的和</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum[j + <span class="number">1</span>] - sum[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ：<code>O(n)</code> , 其中n是原数组的长度，原因是要遍历encoded数组一次</li><li>空间复杂度 ：<code>O(1)</code> </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-303-区域和检索-数组不可变&quot;&gt;&lt;a href=&quot;#Leetcode-303-区域和检索-数组不可变&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-303- 区域和检索 - 数组不可变&quot;&gt;&lt;/a&gt;Leetcode-303- &lt;a href=&quot;https://leetcode-cn.com/problems/range-sum-query-immutable/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;区域和检索 - 数组不可变&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;给定一个整数数组  &lt;code&gt;nums&lt;/code&gt;，求出数组从索引 &lt;code&gt;i&lt;/code&gt; 到 &lt;code&gt;j&lt;/code&gt;（&lt;code&gt;i ≤ j&lt;/code&gt;）范围内元素的总和，包含 &lt;code&gt;i&lt;/code&gt;、&lt;code&gt;j&lt;/code&gt;两点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现 &lt;code&gt;NumArray&lt;/code&gt; 类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;NumArray(int[] nums)&lt;/code&gt; 使用数组 &lt;code&gt;nums&lt;/code&gt; 初始化对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;int sumRange(int i, int j)&lt;/code&gt;返回数组&lt;code&gt;nums&lt;/code&gt;从索引&lt;code&gt;i&lt;/code&gt;到 j（i ≤ j）范围内元素的总和，包含&lt;code&gt;i、j&lt;/code&gt;两点（也就是 &lt;code&gt;sum(nums[i], nums[i + 1], ... , nums[j])）&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&amp;quot;NumArray&amp;quot;, &amp;quot;sumRange&amp;quot;, &amp;quot;sumRange&amp;quot;, &amp;quot;sumRange&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[null, 1, -1, -3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NumArray numArray &amp;#x3D; new NumArray([-2, 0, 3, -5, 2, -1]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;numArray.sumRange(0, 2); &amp;#x2F;&amp;#x2F; return 1 ((-2) + 0 + 3)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;numArray.sumRange(2, 5); &amp;#x2F;&amp;#x2F; return -1 (3 + (-5) + 2 + (-1)) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;numArray.sumRange(0, 5); &amp;#x2F;&amp;#x2F; return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;0 &amp;lt;= nums.length &amp;lt;= 10^4&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;-10^5 &amp;lt;= nums[i] &amp;lt;= 10^5&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;0 &amp;lt;= i &amp;lt;= j &amp;lt; nums.length&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最多调用&lt;code&gt;10^4 次 sumRange&lt;/code&gt; 方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="前缀和" scheme="http://zhuuu.work/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1734-解码异或后的排列</title>
    <link href="http://zhuuu.work/2021/05/11/Leetcode/Leetcode-1734-%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <id>http://zhuuu.work/2021/05/11/Leetcode/Leetcode-1734-%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%8E%92%E5%88%97/</id>
    <published>2021-05-11T03:02:24.000Z</published>
    <updated>2021-05-11T02:27:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-1734-解码异或后的排列"><a href="#Leetcode-1734-解码异或后的排列" class="headerlink" title="Leetcode-1734-解码异或后的排列"></a>Leetcode-1734-<a href="https://leetcode-cn.com/problems/decode-xored-permutation/" target="_blank" rel="noopener">解码异或后的排列</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>给你一个整数数组 <code>perm</code>，它是前 n 个正整数的排列，且 n 是个 奇数 。</p></li><li><p>它被加密成另一个长度为<code>n - 1</code>的整数数组 <code>encoded</code>，满足 <code>encoded[i] = perm[i] XOR perm[i + 1]</code>。比方说，如果 <code>perm = [1,3,2] ，那么 encoded = [2,1] 。</code></p></li><li><p>给你 <code>encoded</code>数组，请你返回原始数组 <code>perm</code>。题目保证答案存在且唯一。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：encoded &#x3D; [3,1]</span><br><span class="line">输出：[1,2,3]</span><br><span class="line">解释：如果 perm &#x3D; [1,2,3] ，那么 encoded &#x3D; [1 XOR 2,2 XOR 3] &#x3D; [3,1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：encoded &#x3D; [6,5,4,6]</span><br><span class="line">输出：[2,4,1,5,3]</span><br></pre></td></tr></table></figure><ul><li><strong>提示：</strong><ul><li><code>3 &lt;= n &lt; 10^5</code></li><li><code>n</code> 是奇数。</li><li><code>encoded.length == n - 1</code></li></ul></li></ul><a id="more"></a><h2 id="算法思路：异或性质"><a href="#算法思路：异或性质" class="headerlink" title="算法思路：异或性质"></a>算法思路：异或性质</h2><p><strong>异或运算具有如下性质：</strong></p><ul><li><p>异或运算满足交换律和结合律；</p></li><li><p>任意整数和自身做异或运算的结果都等于 0，即<code>x⊕x=0；</code></p></li><li><p>任意整数和 0 做异或运算的结果都等于其自身，即<code>x⊕0=0⊕x=x。</code></p></li></ul><p><strong>实现算法分析：</strong></p><ul><li><p>这道题规定了数组<em>perm</em> 是前 <em>n</em> 个正整数的排列，其中 <em>n</em> 是<strong>奇数</strong>，只有充分利用给定的条件，才能得到答案。</p></li><li><p><strong>为了得到原始数组perm，应首先得到数组 perm 的第一个元素（即下标为 0 的元素），这也是最容易得到的</strong>。</p><ul><li><p>如果能得到数组 <strong>perm 的全部元素的异或运算结果</strong>，<strong>以及数组 perm 除了 perm[0] 以外的全部元素的异或运算结果</strong>，即可得到perm[0] 的值。</p><ul><li>由于数组 perm 是前 n 个正整数的排列，因此数组 perm 的全部元素的异或运算结果即为从 1 到 n 的全部正整数的异或运算结果。用total 表示数组 perm 的全部元素的异或运算结果，则有</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-093040171.png" alt="mark"></p></li></ul></li><li><p>如何得到数组 perm 除了 <code>perm[0]</code> 以外的全部元素的异或运算结果？</p><ul><li><p>由于 n 是奇数，除了 perm[0] 以外，数组 perm 还有 n−1 个其他元素，<code>n−1</code> 是偶数，又由于数组<code>encoded</code>的每个元素都是数组<code>perm</code> 的两个元素异或运算的结果，因此数组 encoded 中存在 <code>n-1/2</code>个元素，这些元素的异或运算结果为数组perm除了<code>perm[0]</code>以外所有元素的异或和</p></li><li><p>具体而言，数组 encoded 的所有下标为奇数的元素的异或运算结果即为数组 perm 除了 perm[0] 以外的全部元素的异或运算结果。用 odd 表示数组encoded 的所有下标为奇数的元素的异或运算结果，则有</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-102254529.png" alt="mark"></p></li></ul></li><li><p>根据 total 和 odd<em>的值，即可计算得到 perm</em>[0] 的值：</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-102354157.png" alt="mark"></p><ul><li><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-102640805.png" alt="mark"></p></li><li><p>由于perm[0] 已知，因此对 i 从 1 到 n−1 依次计算 perm[i] 的值，即可得到原始数组perm。</p></li></ul><p>计算过程见「<a href="https://leetcode-cn.com/problems/decode-xored-array/solution/jie-ma-yi-huo-hou-de-shu-zu-by-leetcode-yp0mg/" target="_blank" rel="noopener">1720. 解码异或后的数组的官方题解</a>」。</p><p><strong>性质分析</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210506-093611704.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] decode(<span class="keyword">int</span>[] encoded) &#123;</span><br><span class="line">        <span class="comment">// 1. 计算出perm[0]</span></span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;                                  <span class="comment">// 1-n内所有数字的异或和</span></span><br><span class="line">        <span class="keyword">int</span> odd   = <span class="number">0</span>;                                  <span class="comment">// encoded中所有奇数下标的异或和</span></span><br><span class="line">        <span class="keyword">int</span> n = encoded.length + <span class="number">1</span>;                     <span class="comment">// perm 的数组长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;                      <span class="comment">// 计算1-n内所有数字的异或和</span></span><br><span class="line">            total ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n - <span class="number">1</span>;i += <span class="number">2</span>)&#123;                <span class="comment">// 计算除了perm[0]以外的异或和</span></span><br><span class="line">            odd ^= encoded[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] perm = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        perm[<span class="number">0</span>] = total ^ odd;                          <span class="comment">// perm [0]的值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 力扣题号1720的逻辑：利用异或性质</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;++i)&#123;</span><br><span class="line">            perm[i] = perm[i - <span class="number">1</span>] ^ encoded[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> perm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ：<code>O(n)</code> , 其中n是原数组的长度，原因是要遍历encoded数组一次</li><li>空间复杂度 ：<code>O(1)</code>  注意空间复杂度不考虑返回值。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-1734-解码异或后的排列&quot;&gt;&lt;a href=&quot;#Leetcode-1734-解码异或后的排列&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-1734-解码异或后的排列&quot;&gt;&lt;/a&gt;Leetcode-1734-&lt;a href=&quot;https://leetcode-cn.com/problems/decode-xored-permutation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;解码异或后的排列&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;perm&lt;/code&gt;，它是前 n 个正整数的排列，且 n 是个 奇数 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;它被加密成另一个长度为&lt;code&gt;n - 1&lt;/code&gt;的整数数组 &lt;code&gt;encoded&lt;/code&gt;，满足 &lt;code&gt;encoded[i] = perm[i] XOR perm[i + 1]&lt;/code&gt;。比方说，如果 &lt;code&gt;perm = [1,3,2] ，那么 encoded = [2,1] 。&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;给你 &lt;code&gt;encoded&lt;/code&gt;数组，请你返回原始数组 &lt;code&gt;perm&lt;/code&gt;。题目保证答案存在且唯一。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：encoded &amp;#x3D; [3,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,2,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：如果 perm &amp;#x3D; [1,2,3] ，那么 encoded &amp;#x3D; [1 XOR 2,2 XOR 3] &amp;#x3D; [3,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：encoded &amp;#x3D; [6,5,4,6]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[2,4,1,5,3]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;3 &amp;lt;= n &amp;lt; 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt; 是奇数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;encoded.length == n - 1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="异或" scheme="http://zhuuu.work/tags/%E5%BC%82%E6%88%96/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1720-解码异或后的数组</title>
    <link href="http://zhuuu.work/2021/05/06/Leetcode/Leetcode-1720-%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%95%B0%E7%BB%84/"/>
    <id>http://zhuuu.work/2021/05/06/Leetcode/Leetcode-1720-%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%95%B0%E7%BB%84/</id>
    <published>2021-05-06T03:02:24.000Z</published>
    <updated>2021-05-06T01:36:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-1720-解码异或后的数组"><a href="#Leetcode-1720-解码异或后的数组" class="headerlink" title="Leetcode-1720-解码异或后的数组"></a>Leetcode-1720-<a href="https://leetcode-cn.com/problems/decode-xored-array/" target="_blank" rel="noopener">解码异或后的数组</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>未知 整数数组 arr 由 n 个非负整数组成。</li><li>经编码后变为长度为 <code>n - 1</code>的另一个整数数组 <code>encoded</code>，其中 <code>encoded[i] = arr[i] XOR arr[i + 1]</code> 。例如，<code>arr = [1,0,2,1]</code> 经编码后得到<code>encoded = [1,2,3]</code>。</li><li>给你编码后的数组 <code>encoded</code>和原数组<code>arr</code>的第一个元素 <code>first（arr[0]）</code>。</li><li>请解码返回原数组<code>arr</code>。可以证明答案存在并且是唯一的。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：encoded &#x3D; [1,2,3], first &#x3D; 1</span><br><span class="line">输出：[1,0,2,1]</span><br><span class="line">解释：若 arr &#x3D; [1,0,2,1] ，那么 first &#x3D; 1 且 encoded &#x3D; [1 XOR 0, 0 XOR 2, 2 XOR 1] &#x3D; [1,2,3]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：encoded &#x3D; [6,2,7,3], first &#x3D; 4</span><br><span class="line">输出：[4,2,0,7,4]</span><br></pre></td></tr></table></figure><ul><li><strong>提示：</strong><ul><li><code>2 &lt;= n &lt;= 10^4</code></li><li><code>encoded.length == n - 1</code></li><li><code>0 &lt;= encoded[i] &lt;= 10^5</code></li><li><code>0 &lt;= first &lt;= 10^5</code></li></ul></li></ul><a id="more"></a><h2 id="算法思路：异或性质"><a href="#算法思路：异或性质" class="headerlink" title="算法思路：异或性质"></a>算法思路：异或性质</h2><p><strong>异或运算具有如下性质：</strong></p><ul><li><p>异或运算满足交换律和结合律；</p></li><li><p>任意整数和自身做异或运算的结果都等于 0，即<code>x⊕x=0；</code></p></li><li><p>任意整数和 0 做异或运算的结果都等于其自身，即<code>x⊕0=0⊕x=x。</code></p></li></ul><p><strong>题目要求：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210506-093511909.png" alt="mark"></p><p><strong>性质分析</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210506-093611704.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] decode(<span class="keyword">int</span>[] encoded, <span class="keyword">int</span> first) &#123;</span><br><span class="line">        <span class="comment">// 1. 创建arr数组</span></span><br><span class="line">        <span class="keyword">int</span> n = encoded.length;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 异或还原</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)&#123;</span><br><span class="line">            arr[i] = arr[i - <span class="number">1</span>] ^ encoded[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 返回结果数组</span></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ：<code>O(n)</code> , 其中n是原数组的长度，原因是要遍历encoded数组一次</li><li>空间复杂度 ：<code>O(1)</code>  注意空间复杂度不考虑返回值。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-1720-解码异或后的数组&quot;&gt;&lt;a href=&quot;#Leetcode-1720-解码异或后的数组&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-1720-解码异或后的数组&quot;&gt;&lt;/a&gt;Leetcode-1720-&lt;a href=&quot;https://leetcode-cn.com/problems/decode-xored-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;解码异或后的数组&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;未知 整数数组 arr 由 n 个非负整数组成。&lt;/li&gt;
&lt;li&gt;经编码后变为长度为 &lt;code&gt;n - 1&lt;/code&gt;的另一个整数数组 &lt;code&gt;encoded&lt;/code&gt;，其中 &lt;code&gt;encoded[i] = arr[i] XOR arr[i + 1]&lt;/code&gt; 。例如，&lt;code&gt;arr = [1,0,2,1]&lt;/code&gt; 经编码后得到&lt;code&gt;encoded = [1,2,3]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;给你编码后的数组 &lt;code&gt;encoded&lt;/code&gt;和原数组&lt;code&gt;arr&lt;/code&gt;的第一个元素 &lt;code&gt;first（arr[0]）&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;请解码返回原数组&lt;code&gt;arr&lt;/code&gt;。可以证明答案存在并且是唯一的。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：encoded &amp;#x3D; [1,2,3], first &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,0,2,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：若 arr &amp;#x3D; [1,0,2,1] ，那么 first &amp;#x3D; 1 且 encoded &amp;#x3D; [1 XOR 0, 0 XOR 2, 2 XOR 1] &amp;#x3D; [1,2,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：encoded &amp;#x3D; [6,2,7,3], first &amp;#x3D; 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[4,2,0,7,4]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;2 &amp;lt;= n &amp;lt;= 10^4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;encoded.length == n - 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= encoded[i] &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= first &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="异或" scheme="http://zhuuu.work/tags/%E5%BC%82%E6%88%96/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-554-砖墙</title>
    <link href="http://zhuuu.work/2021/05/02/Leetcode/Leetcode-554-%E7%A0%96%E5%A2%99/"/>
    <id>http://zhuuu.work/2021/05/02/Leetcode/Leetcode-554-%E7%A0%96%E5%A2%99/</id>
    <published>2021-05-02T03:02:24.000Z</published>
    <updated>2021-05-14T00:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-554-砖墙"><a href="#Leetcode-554-砖墙" class="headerlink" title="Leetcode-554-砖墙"></a>Leetcode-554-<a href="https://leetcode-cn.com/problems/brick-wall/" target="_blank" rel="noopener">砖墙</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>你的面前有一堵矩形的、由 n 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和相等。</li><li><strong>你现在要画一条 自顶向下 的、穿过 最少 砖块的垂线。</strong>如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。</li><li>给你一个二维数组 wall ，该数组包含这堵墙的相关信息。其中，<code>wall[i]</code>是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 穿过的砖块数量最少 ，并且返回 穿过的砖块数量 。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-084009075.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：wall &#x3D; [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：wall &#x3D; [[1],[1],[1]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li><p><strong>提示：</strong></p><ul><li><p><code>n == wall.length</code></p></li><li><p>``1 &lt;= n &lt;= 10^4`</p></li><li><p><code>1 &lt;= wall[i].length &lt;= 10^4</code></p></li><li><p><code>1 &lt;= sum(wall[i].length) &lt;= 2 * 10^4</code></p></li><li><p><code>对于每一行 i ，sum(wall[i]) 是相同的1 &lt;= wall[i][j] &lt;= 2^31 - 1</code></p></li></ul></li></ul><h2 id="算法思路：哈希表"><a href="#算法思路：哈希表" class="headerlink" title="算法思路：哈希表"></a>算法思路：哈希表</h2><p><strong>思路</strong></p><ul><li><p><strong>题目要求穿过的砖块数量最少，等效于通过的间隙最多</strong></p></li><li><p><strong>可以使用「哈希表」记录每个间隙的出现次数，最终统计所有行中哪些间隙出现得最多，使用「总行数」减去「间隙出现的最多次数」即是答案。</strong></p></li></ul><p><strong>实现：</strong></p><ul><li>如何记录间隙呢？直接使用行前缀记录即可。</li><li>就用示例数据来举 🌰 ：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-084009075.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第 1 行的间隙有 [1,3,5]</span><br><span class="line">第 2 行的间隙有 [3,4]</span><br><span class="line">第 3 行的间隙有 [1,4]</span><br><span class="line">第 4 行的间隙有 [2]</span><br><span class="line">第 5 行的间隙有 [3,4]</span><br><span class="line">第 6 行的间隙有 [1,4,5]</span><br></pre></td></tr></table></figure><ul><li>对间隙计数完成后，遍历「哈希表」找出出现次数最多间隙 <code>4</code>，根据同一个间隙编号只会在单行内被统计一次，用总行数减去出现次数，即得到「最少穿过的砖块数」。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastBricks</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; wall)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 哈希表统计所有的砖块间隙</span></span><br><span class="line">        <span class="keyword">int</span> n = wall.size();</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;                                    <span class="comment">// 每次统计用来清0</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> brick_width:wall.get(i))&#123;</span><br><span class="line">                sum += brick_width;                         <span class="comment">// 统计每行的砖块间隔位置</span></span><br><span class="line">                map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>); <span class="comment">// 间隔出现的次数放入哈希表中</span></span><br><span class="line">            &#125;</span><br><span class="line">            map.remove(sum);                                <span class="comment">// 不能从两边穿过，需要 remove 掉最后一个</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 比较最小通过的砖块数量</span></span><br><span class="line">        <span class="keyword">int</span> ans = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = map.get(u);                           <span class="comment">// 拿到砖块的间隔数</span></span><br><span class="line">            ans = Math.min(ans, n - cnt);                   <span class="comment">// 最少的穿越：最多的间隔出现</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：记所有砖块数量为 <code>n</code>，所有砖块都会被扫描。复杂度为 O<em>(</em>n)</li><li>空间复杂度：O<em>(</em>n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-554-砖墙&quot;&gt;&lt;a href=&quot;#Leetcode-554-砖墙&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-554-砖墙&quot;&gt;&lt;/a&gt;Leetcode-554-&lt;a href=&quot;https://leetcode-cn.com/problems/brick-wall/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;砖墙&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;你的面前有一堵矩形的、由 n 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和相等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;你现在要画一条 自顶向下 的、穿过 最少 砖块的垂线。&lt;/strong&gt;如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。&lt;/li&gt;
&lt;li&gt;给你一个二维数组 wall ，该数组包含这堵墙的相关信息。其中，&lt;code&gt;wall[i]&lt;/code&gt;是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 穿过的砖块数量最少 ，并且返回 穿过的砖块数量 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-084009075.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：wall &amp;#x3D; [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：wall &amp;#x3D; [[1],[1],[1]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="哈希表" scheme="http://zhuuu.work/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-137-只出现一次的数字II</title>
    <link href="http://zhuuu.work/2021/04/30/Leetcode/Leetcode-137-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97II/"/>
    <id>http://zhuuu.work/2021/04/30/Leetcode/Leetcode-137-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97II/</id>
    <published>2021-04-30T03:02:24.000Z</published>
    <updated>2021-04-30T01:39:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-137-只出现一次的数字-II"><a href="#Leetcode-137-只出现一次的数字-II" class="headerlink" title="Leetcode-137-只出现一次的数字 II"></a>Leetcode-137-<a href="https://leetcode-cn.com/problems/single-number-ii/" target="_blank" rel="noopener">只出现一次的数字 II</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 <code>nums</code> ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次 。</strong>请你找出并返回那个只出现了一次的元素。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,2,3,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1,0,1,0,1,99]</span><br><span class="line">输出：99</span><br></pre></td></tr></table></figure><p>提示：</p><p><code>1 &lt;= nums.length &lt;= 3 * 10^4</code><br><code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code><br><code>nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次</code></p><a id="more"></a><h2 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h2><ul><li>可以使用哈希映射统计数组中每个元素的出现次数。对于哈希映射中的每个键值对，键表示一个元素，值表示其出现的次数。</li><li>在统计完成后，遍历哈希映射即可找出只出现一次的元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建哈希表并把元素都放在内</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 检查出现一次的数字并统计结果</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">int</span> num = entry.getKey();</span><br><span class="line">            <span class="keyword">int</span> occ = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span>(occ == <span class="number">1</span>)&#123;</span><br><span class="line">                ans = num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 ： O(n)</li><li>空间复杂度 ： O(n)</li></ul><h2 id="方法二：二进制位"><a href="#方法二：二进制位" class="headerlink" title="方法二：二进制位"></a>方法二：二进制位</h2><ul><li>为了方便叙述，我们称「只出现了一次的元素」为「答案」。</li><li>由于数组中的元素都在 int（即 32位整数）范围内，因此我们可以依次计算答案的每一个二进制位是 0 还是 1。</li></ul><hr><ul><li><p><strong>具体地，考虑答案的第 i个二进制位（i 从 0 开始编号），它可能为 0 或 1。对于数组中非答案的元素，每一个元素都出现了 3 次，对应着第 i 个二进制位的 3 个 0 或 3 个 1，无论是哪一种情况，它们的和都是 3 的倍数（即和为 0 或 3）。</strong></p></li><li><p><strong>因此：答案的第 i个二进制位就是数组中所有元素的第 i个二进制位之和除以 3 的余数。</strong></p></li><li><p>这样一来，对于数组中的每一个元素<code>x</code>，使用位运算<code>(x &gt;&gt; i) &amp; 1</code> 得到 <code>x</code>的第<code>i</code>个二进制位，并将他们相加再对3取余，得到的结果一定为0或者1，即答案的第i个二进制位</p></li></ul><p><strong>注意：</strong></p><ul><li><strong>需要注意的是，如果使用的语言对「有符号整数类型」和「无符号整数类型」没有区分，那么可能会得到错误的答案。</strong><ul><li>这是因为「有符号整数类型」(int 类型)的第31个二进制位补码对应的是符号位对应着 <code>-2^{31}</code></li><li>而「无符号整数类型」由于没有符号，第 31 个二进制位对应着 2^{31}</li><li>因此在某些语言（Python）中需要对最高位进行特殊判断。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 初始化变量</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 对32位依次进行二进制累和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">                total += (num &gt;&gt; i) &amp; <span class="number">1</span>;                    <span class="comment">// (num &gt;&gt; i) &amp; 1 拿到二进制位</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 对累和进行求余数判断</span></span><br><span class="line">            <span class="keyword">if</span>(total % <span class="number">3</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                ans |= (<span class="number">1</span> &lt;&lt; i);                            <span class="comment">// 说明ans这位应该取1                </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(nlogC)，其中 n 是数组的长度，C 是元素的数据范围，在本题中 logC=log2 32=32，也就是我们需要遍历第 0∼31 个二进制位。</p></li><li><p>空间复杂度：O(1)。</p></li></ul><h2 id="方法三：-数字电路"><a href="#方法三：-数字电路" class="headerlink" title="方法三： 数字电路"></a>方法三： 数字电路</h2><ul><li>待后续</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-137-只出现一次的数字-II&quot;&gt;&lt;a href=&quot;#Leetcode-137-只出现一次的数字-II&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-137-只出现一次的数字 II&quot;&gt;&lt;/a&gt;Leetcode-137-&lt;a href=&quot;https://leetcode-cn.com/problems/single-number-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;只出现一次的数字 II&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，除某个元素仅出现 &lt;strong&gt;一次&lt;/strong&gt; 外，其余每个元素都恰出现 &lt;strong&gt;三次 。&lt;/strong&gt;请你找出并返回那个只出现了一次的元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [2,2,3,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [0,1,0,1,0,1,99]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：99&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;提示：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1 &amp;lt;= nums.length &amp;lt;= 3 * 10^4&lt;/code&gt;&lt;br&gt;&lt;code&gt;-2^31 &amp;lt;= nums[i] &amp;lt;= 2^31 - 1&lt;/code&gt;&lt;br&gt;&lt;code&gt;nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-14-消息的可靠性保证</title>
    <link href="http://zhuuu.work/2021/04/30/RabbitMQ/RabbitMQ-14-%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E8%AF%81/"/>
    <id>http://zhuuu.work/2021/04/30/RabbitMQ/RabbitMQ-14-%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E8%AF%81/</id>
    <published>2021-04-30T02:02:24.000Z</published>
    <updated>2021-04-30T03:06:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-14-消息的可靠性保证"><a href="#RabbitMQ-14-消息的可靠性保证" class="headerlink" title="RabbitMQ-14-消息的可靠性保证"></a>RabbitMQ-14-消息的可靠性保证</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><ul><li><p>RabbitMQ如何确保消息可靠？很多时候，笔者的回答都是：说来话长的事情何来长话短说。的确，要确保消息可靠不只是单单几句就能够叙述明白的，包括Kafka也是如此。</p></li><li><p>可靠并不是一个绝对的概念，曾经有人也留言说过类似全部磁盘损毁也会导致消息丢失，笔者戏答：还有机房被炸了也会导致消息丢失。</p></li><li><p>可靠性是一个相对的概念，在条件合理的范围内系统所能确保的多少个9的可靠性。一切尽可能的趋于完美而无法企及于完美。</p></li><li><p>我们可以尽可能的确保RabbitMQ的消息可靠。在详细论述RabbitMQ的消息可靠性之前，我们先来回顾下消息在RabbitMQ中的经由之路。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210430-094238362.png" alt="mark"></p><p>如图所示，从AMQP协议层面上来说：</p><ul><li><p>消息先从生产者<code>Producer</code> 出发到达交换器 <code>Exchange</code></p></li><li><p>交换器<code>Exchange</code> 根据路由规则将消息转发到对应的<code>Queue</code> 上</p></li><li><p>消息在队列<code>Queue</code> 上进行存储</p></li><li><p>消费者Consumer订阅队列Queue并进行消费。</p></li></ul><p>接下来 ： 我们对于消息可靠性的分析也从这四个阶段来一一探讨。</p><a id="more"></a><h3 id="2-生产者到交换机"><a href="#2-生产者到交换机" class="headerlink" title="2. 生产者到交换机"></a>2. 生产者到交换机</h3><ul><li><p>消息从生产者发出到达交换器<code>Exchange</code>，在这个过程中可以发生各种情况，生产者客户端发送出去之后可以发生网络丢包、网络故障等造成消息丢失。一般情况下如果不采取措施，生产者无法感知消息是否已经正确无误的发送到交换器中。</p></li><li><p>如果消息在传输到<code>Exchange</code>的过程中发生失败而可以让生产者感知的话，生产者可以进行进一步的处理动作，比如重新投递相关消息以确保消息的可靠性。</p></li><li><p>为此AMQP协议在建立之初就考虑到这种情况而提供了事务机制。</p><ul><li>RabbitMQ客户端中与事务机制相关的方法有三个：<code>channel.txSelect、channel.txCommit以及channel.txRollback。</code></li><li><code>channel.txSelect</code>用于将当前的信道设置成事务模式，<code>channel.txCommit</code>用于提交事务，而<code>channel.txRollback</code>用于事务回滚。</li><li>在通过<code>channel.txSelect</code>方法开启事务之后，我们便可以发布消息给<code>RabbitMQ</code>了，如果事务提交成功，则消息一定到达了<code>RabbitMQ</code>中，如果在事务提交执行之前由于<code>RabbitMQ</code>异常崩溃或者其他原因抛出异常，这个时候我们便可以将其捕获，进而通过执行<code>channel.txRollback</code>方法来实现事务回滚。</li><li><strong>注意这里的RabbitMQ中的事务机制与大多数数据库中的事务概念并不相同，需要注意区分。</strong></li></ul></li><li><p>事务确实能够解决消息发送方和<code>RabbitMQ</code>之间消息确认的问题，只有消息成功被<code>RabbitMQ</code>接收，事务才能提交成功，否则我们便可在捕获异常之后进行事务回滚，与此同时可以进行消息重发。</p></li></ul><hr><ul><li><strong>但是使用事务机制的话会“吸干”RabbitMQ的性能，那么有没有更好的方法既能保证消息发送方确认消息已经正确送达，又能基本上不带来性能上的损失呢？</strong><ul><li>从AMQP协议层面来看并没有更好的办法，但是RabbitMQ提供了一个改进方案，即<strong>发送方确认机制（publisher confirm）。</strong></li><li>生产者将信道设置成<code>confirm</code>（确认）模式，一旦信道进入<code>confirm</code>模式，所有在该信道上面发布的消息都会被指派一个唯一的<code>ID</code>（从1开始），一旦消息被投递到所有匹配的队列之后，<code>RabbitMQ</code>就会发送一个确认<code>（Basic.Ack）</code>给生产者（包含消息的唯一<code>ID</code>）,这就使得生产者知晓消息已经正确到达了目的地了。</li><li><code>RabbitMQ</code>回传给生产者的确认消息中的<code>deliveryTag</code>包含了确认消息的序号，此外RabbitMQ也可以设置channel.basicAck方法中的<strong>multiple参数</strong>，表示到这个序号之前的所有消息都已经得到了处理。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210430-103912395.png" alt="mark"></p><p><strong>对比小结：</strong></p><ul><li><strong>事务机制在一条消息发送之后会使发送端阻塞</strong>，以等待RabbitMQ的回应，之后才能继续发送下一条消息。<ul><li>相比之下，<strong>发送方确认机制最大的好处在于它是异步的</strong>，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息</li><li>如果<code>RabbitMQ</code>因为自身内部错误导致消息丢失，就会发送一条<code>nack（Basic.Nack</code>）命令，生产者应用程序同样可以在回调方法中处理该<code>nack</code>命令。</li><li>生产者通过调用<code>channel.confirmSelect</code>方法（即<code>Confirm.Select</code>命令）将信道设置为<code>confirm</code>模式，之后<code>RabbitMQ</code>会返回<code>Confirm.Select-Ok</code>命令表示同意生产者将当前信道设置为<code>confirm</code>模式。所有被发送的后续消息都被ack或者nack一次，不会出现一条消息即被ack又被nack的情况。并且RabbitMQ也并没有对消息被confirm的快慢做任何保证。</li></ul></li><li>事务机制和<code>publisher confirm</code>机制两者是互斥的，不能共存。<ul><li>如果企图将已开启事务模式的信道再设置为<code>publisher confirm</code>模式，RabbitMQ会报错：<code>{amqp_error, precondition_failed, “cannot switch from tx to confirm mode”, ‘confirm.select’}</code></li><li>或者如果企图将已开启<code>publisher confirm</code>模式的信道在设置为事务模式的话，RabbitMQ也会报错：<code>{amqp_error, precondition_failed, “cannot switch from confirm to tx mode”, ‘tx.select’ }。</code></li></ul></li><li>事务机制和<code>publisher confirm</code>机制确保的是消息能够正确的发送至<code>RabbitMQ</code>，这里的“发送至RabbitMQ”的含义是指消息被正确的发往至<code>RabbitMQ</code>的交换器，<strong>如果此交换器没有匹配的队列的话，那么消息也将会丢失。</strong><ul><li>所以在使用这两种机制的时候要确保所涉及的交换器能够有匹配的队列。<strong>更进一步的讲，发送方要配合<code>mandatory</code>参数或者备份交换器一起使用来提高消息传输的可靠性。</strong></li></ul></li></ul><h3 id="3-交换机"><a href="#3-交换机" class="headerlink" title="3. 交换机"></a>3. 交换机</h3><ul><li><code>mandatory</code>和<code>immediate</code>是<code>channel.basicPublish</code>方法中的两个参数，它们都有当消息传递过程中不可达目的地时将消息返回给生产者的功能。</li><li>而RabbitMQ提供的备份交换器<code>（Alternate Exchange）</code>可以将未能被交换器路由的消息（没有绑定队列或者没有匹配的绑定）存储起来，而不用返回给客户端。<ul><li>RabbitMQ 3.0版本开始去掉了对于immediate参数的支持，对此RabbitMQ官方解释是：immediate参数会影响镜像队列的性能，增加代码复杂性，建议采用TTL和DLX的方法替代。所以<strong>本文只简单介绍mandatory和备份交换器。</strong></li></ul></li></ul><ol><li><code>mandatory</code> 参数</li></ol><ul><li><p>当<code>mandatory</code>参数设为<code>true</code>时，交换器无法根据自身的类型和路由键找到一个符合条件的队列的话，那么<code>RabbitMQ</code>会调用<code>Basic.Return</code>命令将消息返回给生产者。</p></li><li><p>当<code>mandatory</code>参数设置为<code>false</code>时，出现上述情形的话，消息直接被丢弃。 </p></li><li><p><strong>那么生产者如何获取到没有被正确路由到合适队列的消息呢？</strong>这时候可以通过调用<code>channel.addReturnListener</code>来添加<code>ReturnListener</code>监听器实现。使用<code>mandatory</code>参数的关键代码如下所示：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, <span class="keyword">true</span>, MessageProperties.PERSISTENT_TEXT_PLAIN, <span class="string">"mandatory test"</span>.getBytes());</span><br><span class="line">channel.addReturnListener(<span class="keyword">new</span> ReturnListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturn</span><span class="params">(<span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey, AMQP</span></span></span><br><span class="line"><span class="function"><span class="params">            .BasicProperties basicProperties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String message = <span class="keyword">new</span> String(body);</span><br><span class="line">        System.out.println(<span class="string">"Basic.Return返回的结果是："</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">上面代码中生产者没有成功的将消息路由到队列，此时RabbitMQ会通过Basic.Return返回“mandatory test”这条消息，之后生产者客户端通过ReturnListener监听到了这个事件，上面代码的最后输出应该是“Basic.Return返回的结果是：mandatory test”。</span><br></pre></td></tr></table></figure><ul><li>生产者可以通过ReturnListener中返回的消息来重新投递或者其它方案来提高消息的可靠性。</li></ul><ol start="2"><li><strong>备份交换机</strong></li></ol><ul><li>备份交换器，英文名称<code>Alternate Exchange</code>，简称AE，或者更直白的可以称之为“备胎交换器”。</li><li>生产者在发送消息的时候如果不设置mandatory参数，那么消息在未被路由的情况下将会丢失，如果设置了mandatory参数，那么需要添加ReturnListener的编程逻辑，生产者的代码将变得复杂化。</li><li><strong>如果你不想复杂化生产者的编程逻辑，又不想消息丢失</strong>，那么可以使用备份交换器，这样可以将未被路由的消息存储在RabbitMQ中，再在需要的时候去处理这些消息。<ul><li>可以通过在声明交换器（调用<code>channel.exchangeDeclare</code>方法）的时候添加<code>alternate-exchange</code>参数来实现，也可以通过策略的方式实现。如果两者同时使用的话，前者的优先级更高，会覆盖掉<code>Policy</code>的设置。</li></ul></li></ul><p><strong>举个例子</strong></p><ul><li>参考下图，如果此时我们发送一条消息到<code>normalExchange</code>上<ul><li>当路由键等于<code>“normalKey”</code>的时候，消息能正确路由到<code>normalQueue</code>这个队列中。</li><li>如果路由键设为其他值，比如<code>“errorKey”</code>，即消息不能被正确的路由到与<code>normalExchange</code>绑定的任何队列上，此时就会发送给myAe, 进而发送到<code>unroutedQueue</code>这个队列。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210430-105341541.png" alt="mark"></p><ul><li><strong>备份交换器其实和普通的交换器没有太大的区别，为了方便使用，建议设置为fanout类型</strong><ul><li>如若读者想设置为direct或者topic的类型也没有什么不妥。<strong>需要注意的是消息被重新发送到备份交换器时的路由键和从生产者发出的路由键是一样的。</strong></li><li>备份交换器的实质就是原有交换器的一个“备胎”，所有无法正确路由的消息都发往这个备份交换器中，可以为所有的交换器设置同一个AE，不过这里需要提前确保的是AE已经正确的绑定了队列</li><li>最好类型也是<code>fanout</code>的。如果备份交换器和<code>mandatory</code>参数一起使用，那么<code>mandatory</code>参数无效。</li></ul></li></ul><h3 id="4-消息存入队列后"><a href="#4-消息存入队列后" class="headerlink" title="4. 消息存入队列后"></a>4. 消息存入队列后</h3><ul><li>mandatory或者AE可以让消息在路由到队列之前得到极大的可靠性保障，但是消息存入队列之后的可靠性又如何保证？</li></ul><ol><li><strong>首先是持久化。持久化可以提高队列的可靠性，以防在异常情况（重启、关闭、宕机等）下的数据丢失。</strong><ul><li><strong>队列的持久化</strong>是通过在声明队列时将durable参数置为true实现的，如果队列不设置持久化，那么在RabbitMQ服务重启之后，相关队列的元数据将会丢失，此时数据也会丢失。</li><li>正所谓“皮之不存，毛将焉附”，队列都没有了，消息又能存在哪里呢？</li><li>队列的持久化能保证其本身的元数据不会因异常情况而丢失，但是并不能保证内部所存储的消息不会丢失。</li><li>要确保<strong>消息不会丢失，需要将其设置为持久化</strong>。通过将消息的投递模式（BasicProperties中的deliveryMode属性）设置为2即可实现消息的持久化。</li></ul></li></ol><p><strong>设置了队列和消息的持久化，当RabbitMQ服务重启之后，消息依旧存在</strong>。单单只设置队列持久化，重启之后消息会丢失；单单只设置消息的持久化，重启之后队列消失，既而消息也丢失。单单设置消息持久化而不设置队列的持久化显得毫无意义。</p><hr><ul><li>在持久化的消息正确存入RabbitMQ之后，还需要有一段时间（虽然很短，但是不可忽视）才能存入磁盘之中。</li><li><strong>RabbitMQ并不会为每条消息都做同步存盘（调用内核的fsync6方法）的处理</strong>，可能仅仅保存到操作系统缓存之中而不是物理磁盘之中。</li><li>如果在这段时间内RabbitMQ服务节点发生了宕机、重启等异常情况，消息保存还没来得及落盘，那么这些消息将会丢失。</li></ul><ol start="2"><li><strong>如果在前面步骤中采用了事务机制或者publisher confirm机制的话</strong>，服务端的返回是在消息落盘之后执行的，这样可以进一步的提高了消息的可靠性。<ul><li>但是即便如此也无法避免单机故障且无法修复（比如磁盘损毁）而引起的消息丢失，<strong>这里就需要引入镜像队列。</strong></li><li><strong>镜像队列相当于配置了副本</strong>，绝大多数分布式的东西都有多副本的概念来确保HA。</li><li>在镜像队列中，如果主节点（master）在此特殊时间内挂掉，可以自动切换到从节点（slave），这样有效的保证了高可用性，除非整个集群都挂掉。</li></ul></li></ol><p>虽然这样也不能完全的保证RabbitMQ消息不丢失（比如机房被炸。。。），但是配置了镜像队列要比没有配置镜像队列的可靠性要高很多，<strong>在实际生产环境中的关键业务队列一般都会设置镜像队列。</strong></p><h3 id="5-消费者"><a href="#5-消费者" class="headerlink" title="5. 消费者"></a>5. 消费者</h3><ul><li>进一步的从消费者的角度来说，如果在消费者接收到相关消息之后，还没来得及处理就宕机了，这样也算数据丢失。</li><li>为了保证消息从队列可靠地达到消费者，RabbitMQ提供了<strong>消息确认机制</strong>（<code>message acknowledgement</code>）。<ul><li>消费者在订阅队列时，可以指定<code>autoAck</code>参数，<strong>当autoAck等于false时</strong>，RabbitMQ会等待消费者显式地回复确认信号后才从内存（或者磁盘）中移去消息（实质上是先打上删除标记，之后再删除）。</li><li><strong>当autoAck等于true时</strong>，RabbitMQ会自动把发送出去的消息置为确认，然后从内存（或者磁盘）中删除，而不管消费者是否真正的消费到了这些消息。</li></ul></li></ul><p><strong>采用消息确认机制后，只要设置autoAck参数为false，消费者就有足够的时间处理消息（任务），不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为RabbitMQ会一直等待持有消息直到消费者显式调用Basic.Ack命令为止。</strong></p><hr><ul><li><p><strong>当autoAck参数置为false，对于RabbitMQ服务端而言，队列中的消息分成了两个部分:</strong></p><ul><li>一部分是等待投递给消费者的消息；一部分是已经投递给消费者，但是还没有收到消费者确认信号的消息。</li><li>如果RabbitMQ一直没有收到消费者的确认信号，并且消费此消息的消费者已经断开连接，则RabbitMQ会安排该消息重新进入队列，等待投递给下一个消费者，当然也有可能还是原来的那个消费者。</li><li><strong>RabbitMQ不会为未确认的消息设置过期时间</strong>，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的<strong>消费者连接是否已经断开</strong>，这么设计的原因是RabbitMQ允许消费者消费一条消息的时间可以很久很久。</li></ul></li><li><p><strong>如果消息消费失败，也可以调用Basic.Reject或者Basic.Nack来拒绝当前消息而不是确认</strong></p><ul><li>如果只是简单的拒绝那么消息会丢失，需要将相应的requeue参数设置为true，那么RabbitMQ会重新将这条消息存入队列，以便可以发送给下一个订阅的消费者。</li><li>如果requeue参数设置为false的话，RabbitMQ立即会把消息从队列中移除，而不会把它发送给新的消费者。</li></ul></li><li><p><strong>还有一种情况需要考虑：<code>requeue</code> 的消息是存入队列头部的，即可以快速的又被发送给消费</strong>，如果此时消费者又不能正确的消费而又requeue的话就会进入一个无尽的循环之中</p><ul><li>对于这种情况，笔者的建议是在出现无法正确消费的消息时<strong>不要采用requeue的方式来确保消息可靠性，而是重新投递到新的队列中</strong></li><li>比如设定的死信队列中，以此可以避免前面所说的死循环而又可以确保相应的消息不丢失。对于死信队列中的消息可以用另外的方式来消费分析，以便找出问题的根本。</li></ul></li></ul><p><strong>参考博客 ：</strong> </p><p><a href="https://blog.csdn.net/u013256816/article/details/79147591" target="_blank" rel="noopener">https://blog.csdn.net/u013256816/article/details/79147591</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-14-消息的可靠性保证&quot;&gt;&lt;a href=&quot;#RabbitMQ-14-消息的可靠性保证&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-14-消息的可靠性保证&quot;&gt;&lt;/a&gt;RabbitMQ-14-消息的可靠性保证&lt;/h2&gt;&lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;RabbitMQ如何确保消息可靠？很多时候，笔者的回答都是：说来话长的事情何来长话短说。的确，要确保消息可靠不只是单单几句就能够叙述明白的，包括Kafka也是如此。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可靠并不是一个绝对的概念，曾经有人也留言说过类似全部磁盘损毁也会导致消息丢失，笔者戏答：还有机房被炸了也会导致消息丢失。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可靠性是一个相对的概念，在条件合理的范围内系统所能确保的多少个9的可靠性。一切尽可能的趋于完美而无法企及于完美。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我们可以尽可能的确保RabbitMQ的消息可靠。在详细论述RabbitMQ的消息可靠性之前，我们先来回顾下消息在RabbitMQ中的经由之路。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210430-094238362.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图所示，从AMQP协议层面上来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;消息先从生产者&lt;code&gt;Producer&lt;/code&gt; 出发到达交换器 &lt;code&gt;Exchange&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;交换器&lt;code&gt;Exchange&lt;/code&gt; 根据路由规则将消息转发到对应的&lt;code&gt;Queue&lt;/code&gt; 上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消息在队列&lt;code&gt;Queue&lt;/code&gt; 上进行存储&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消费者Consumer订阅队列Queue并进行消费。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来 ： 我们对于消息可靠性的分析也从这四个阶段来一一探讨。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>计组-07-存储器</title>
    <link href="http://zhuuu.work/2021/04/29/Compute_Organization/%E8%AE%A1%E7%BB%84-07-%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <id>http://zhuuu.work/2021/04/29/Compute_Organization/%E8%AE%A1%E7%BB%84-07-%E5%AD%98%E5%82%A8%E5%99%A8/</id>
    <published>2021-04-29T03:02:24.000Z</published>
    <updated>2021-05-14T06:42:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机组成原理-07-存储器"><a href="#计算机组成原理-07-存储器" class="headerlink" title="计算机组成原理-07-存储器"></a>计算机组成原理-07-存储器</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-224820865.png" alt="mark"></p><a id="more"></a><h2 id="1-主存储器"><a href="#1-主存储器" class="headerlink" title="1. 主存储器"></a>1. 主存储器</h2><h3 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><ul><li><strong>回忆主存储器</strong><ul><li>逻辑结果如下所示</li><li>物理结果如下所示</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-225215817.png" alt="mark"></p><p><strong>读写操作流程：</strong></p><ul><li>指令执行的过程中需要访问主存的时候，<ul><li><strong>CPU首先把被访问单元的地址放入到MAR 中，然后通过地址线（注意是单向的）将主存地址送到主存的地址寄存器中</strong>，</li><li>以便地址译码器进行译码相应的单元，</li><li>同时CPU将读写信号通过控制先送到主存的读写控制电路</li></ul></li><li><strong>如果是写操作</strong>，那么CPU同时将要写的信息送到MDR中，在读写电路的控制下，经数据线（注意是双向的）将信号写入选中的单元</li><li><strong>如果是读操作</strong>，那么主存读出选中选中单元的内容送到数据线，然后送到MDR中</li><li><strong>需要注意的是：数据线的宽度和MDR的宽度是相同的，地址线的宽度和MAR的宽度是相同的</strong><ul><li>若采用64位的数据线，那么在按照字节编址的方式下，每次最多可以存取8个单元的内容<strong>（存储体的列数）</strong></li><li>地址线决定了主存地址空间的最大寻址范围，如36位的地址最大寻址范围是<code>0-(2^36)-1</code>（<strong>存储体的行数</strong>）</li><li>数据线和地址线数量共同反映了存储体的大小，若采用以上的存储方式，那么芯片的容量是<code>(2^36)*64位</code><strong>（行*列）</strong></li></ul></li></ul><p><strong>存储体容量计算：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210430-114712759.png" alt="mark"></p><p><strong>具体存储如下所示：</strong></p><ul><li>存储元：存储0或1的记忆单元（电容和开关组成）</li><li>存储单元：由一行存储元组成</li><li>存储字：一行存储元的位数</li><li>存储矩阵：也叫存储体，是存储器的核心</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-225425551.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210430-113850632.png" alt="mark"></p><ul><li>存储器和存储字长的关系</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210430-114145627.png" alt="mark"></p><p><strong>上图存储体的缺点</strong>：</p><ul><li><strong>一次只能进行一次读写（只有一行的控制线起作用）</strong></li><li><strong>优化是加入译码器 （n位地址 -&gt; 2^n 的存储单元）</strong><ul><li>本质是通过映射去实现</li><li>（n位地址 -&gt; 2^n 的存储单元）</li><li>（n位地址 -&gt; 2^n 的行数）</li></ul></li></ul><h3 id="1-2-主存的简单模型"><a href="#1-2-主存的简单模型" class="headerlink" title="1.2 主存的简单模型"></a>1.2 主存的简单模型</h3><ul><li>存储器芯片电路如下所示</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210506-150206423.png" alt="mark"></p><ul><li><strong>逻辑结构如下所示</strong><ul><li>片选线：控制开关</li><li>读写控制线：控制读写操作</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210506-150346258.png" alt="mark"></p><h3 id="1-3-寻址"><a href="#1-3-寻址" class="headerlink" title="1.3 寻址"></a>1.3 寻址</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210506-151155672.png" alt="mark"></p><p>对于上图结构而言：<strong>寻址</strong></p><ul><li><p><strong>如果存储的总容量为1KB,按字节寻址</strong></p><ul><li>那么就有1K个存储单元</li><li>每个存储单元的大小为1B = 8bit</li></ul></li><li><p><strong>如果存储的总容量为1KB,按字寻址</strong></p><ul><li>那么就有256个存储单元</li><li>每个存储单元的大小为4B</li></ul></li><li><p><strong>如果存储的总容量为1KB,按半字寻址</strong></p><ul><li>那么就有512个存储单元</li><li>每个存储单元的大小为2B</li></ul></li><li><p><strong>如果存储的总容量为1KB,按双字寻址</strong></p><ul><li>那么就有1024个存储单元</li><li>每个存储单元的大小为8B=64bit</li></ul></li></ul><p><strong>编址的概念如下所示：</strong></p><ul><li><strong>如果存储的总容量为1KB,按字节寻址</strong><ul><li>那么就有1K个存储单元</li><li>每个存储单元的大小为1B = 8bit</li><li><strong>需要地址线为10根数，地址为（0-1023）</strong></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210506-151653135.png" alt="mark"></p><p><strong>若按字进行编址</strong></p><ul><li>也就是4个字节为一组</li><li>通过高位来分辨组与组之间的不同</li><li>具体编址如下所示：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210506-151915587.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210506-151926752.png" alt="mark"></p><p><strong>但是按字编址带来的问题：如何存储数据</strong></p><ul><li>大端存储：按照人的阅读模式存放（先放高位地址）</li><li>小端存储：与上面相反（先放低位字节）</li></ul><h3 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210506-152245524.png" alt="mark"></p><h2 id="2-半导体存储器"><a href="#2-半导体存储器" class="headerlink" title="2. 半导体存储器"></a>2. 半导体存储器</h2><h3 id="2-1-半导体存储器的基本结构"><a href="#2-1-半导体存储器的基本结构" class="headerlink" title="2.1 半导体存储器的基本结构"></a>2.1 半导体存储器的基本结构</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210506-152648433.png" alt="mark"></p><h3 id="2-2-RAM"><a href="#2-2-RAM" class="headerlink" title="2.2 RAM"></a>2.2 RAM</h3><h4 id="2-2-1-RAM"><a href="#2-2-1-RAM" class="headerlink" title="2.2.1 RAM"></a>2.2.1 RAM</h4><ol><li><strong>半导体随机存储器</strong>（RAM）<ul><li>访问的内存位置与存放的地址无关</li><li>只和电流的速度有关</li></ul></li><li><strong>RAM分为以下两种类别</strong><ul><li>SRAM : 静态存储器</li><li>DRAM : 动态存储器</li></ul></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210506-152912848.png" alt="mark"></p><ul><li>对比如下</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210507-085756413.png" alt="mark"></p><h4 id="2-2-2-DRAM的刷新问题"><a href="#2-2-2-DRAM的刷新问题" class="headerlink" title="2.2.2 DRAM的刷新问题"></a>2.2.2 DRAM的刷新问题</h4><ul><li>DRAM的刷新是以行为单位的（减少了选通线的数量）</li><li>刷新的周期为2ms</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210507-090312139.png" alt="mark"></p><ul><li>如何进行刷新的问题？</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210507-090917502.png" alt="mark"></p><h4 id="2-2-3-SRAM读写周期"><a href="#2-2-3-SRAM读写周期" class="headerlink" title="2.2.3 SRAM读写周期"></a>2.2.3 SRAM读写周期</h4><ol><li><strong>读周期</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210507-091259166.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210507-091322746.png" alt="mark"></p><ol start="2"><li><strong>写周期</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210507-091414747.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210507-091427862.png" alt="mark"></p><h4 id="2-2-4-小结"><a href="#2-2-4-小结" class="headerlink" title="2.2.4 小结"></a>2.2.4 小结</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210507-091452293.png" alt="mark"></p><h3 id="2-3-ROM"><a href="#2-3-ROM" class="headerlink" title="2.3 ROM"></a>2.3 ROM</h3><ul><li><strong>ROM只读存储器</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210507-092216039.png" alt="mark"></p><h3 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210507-092328735.png" alt="mark"></p><h2 id="3-存储器的概念"><a href="#3-存储器的概念" class="headerlink" title="3. 存储器的概念"></a>3. 存储器的概念</h2><h3 id="3-1-分类"><a href="#3-1-分类" class="headerlink" title="3.1 分类"></a>3.1 分类</h3><ul><li>层次的角度来分<ul><li>高速缓冲存储器（cache）</li><li>主存储器（主存，内存）</li><li>辅助存储器（辅存，外存）</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210507-092639214.png" alt="mark"></p><ul><li>存储介质来分类<ul><li>磁盘 磁带</li><li>磁芯存储器</li><li>半导体存储器</li></ul></li><li>存储方式来分类<ul><li>随机存储器（RAM） : 存储时间与存储的物理位置无关</li><li>只读存储器（ROM）: 只能随机读出而不能写入</li><li>串行访问存储器<ul><li>顺序存取存储器（磁带）</li><li>直接存取存储器（磁盘）</li></ul></li></ul></li></ul><h3 id="3-2-性能指标"><a href="#3-2-性能指标" class="headerlink" title="3.2 性能指标"></a>3.2 性能指标</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210507-095819701.png" alt="mark"></p><h3 id="3-3-层次化结构"><a href="#3-3-层次化结构" class="headerlink" title="3.3 层次化结构"></a>3.3 层次化结构</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210507-100220243.png" alt="mark"></p><h2 id="4-主存和CPU的连接"><a href="#4-主存和CPU的连接" class="headerlink" title="4. 主存和CPU的连接"></a>4. 主存和CPU的连接</h2><h3 id="4-1-主存容量的扩展"><a href="#4-1-主存容量的扩展" class="headerlink" title="4.1 主存容量的扩展"></a>4.1 主存容量的扩展</h3><h4 id="4-1-1-位扩展"><a href="#4-1-1-位扩展" class="headerlink" title="4.1.1 位扩展"></a>4.1.1 位扩展</h4><ul><li>当CPU的数据线与存储芯片的数据位数不相等时，需要对存储芯片进行位扩展，假设使用<code>8K*1位</code>的RAM芯片和<code>8K*8位</code>的CPU,使得数据位数和CPU的数据线位数相等。</li><li><strong>如下图所示：</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210509-114456994.png" alt="mark"></p><ul><li>扩展后如下所示：<ul><li>地址并行的送至地址线</li><li>数据进行位扩展送到CPU</li><li>相当于合并为一个8K*8位的存储器</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210509-114644768.png" alt="mark"></p><h4 id="4-1-2-字扩展"><a href="#4-1-2-字扩展" class="headerlink" title="4.1.2 字扩展"></a>4.1.2 字扩展</h4><ul><li><p>字扩展是指增加存储器中字的数量，而位数不变</p></li><li><p>共用地址线 出现的问题：使得两个芯片同时开始工作 </p></li></ul><p><strong>如下图所示</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210509-115156837.png" alt="mark"></p><ul><li>解决方法：如下节所示<ul><li>线选法 ： n条线 产生n个片选信号</li><li>译码片选法 ：  n条线 产生<code>2^n</code>个片选信号</li></ul></li></ul><p><strong>线选法结果：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210509-115559709.png" alt="mark"></p><p><strong>译码片选法 ：</strong></p><ol><li><strong>单位二进制片选</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210509-120116732.png" alt="mark"></p><ol start="2"><li><strong>多位二进制位的片选</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210509-120541363.png" alt="mark"></p><p><strong>译码片选法结果 ：</strong></p><p>地址空间分布</p><ul><li><code>00XX</code></li><li><code>01XX</code></li><li><code>10XX</code></li><li><code>11XX</code></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210509-120847165.png" alt="mark"></p><p><strong>小结：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210509-121236593.png" alt="mark"></p><h4 id="4-1-3-字和位同时扩展"><a href="#4-1-3-字和位同时扩展" class="headerlink" title="4.1.3 字和位同时扩展"></a>4.1.3 字和位同时扩展</h4><ul><li>先进行位扩展</li><li>再进行字扩展</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210509-121512269.png" alt="mark"></p><h2 id="5-双端口RAM和多模块存储器"><a href="#5-双端口RAM和多模块存储器" class="headerlink" title="5. 双端口RAM和多模块存储器"></a>5. 双端口RAM和多模块存储器</h2><h3 id="5-1-双端口RAM"><a href="#5-1-双端口RAM" class="headerlink" title="5.1 双端口RAM"></a>5.1 双端口RAM</h3><ul><li>双端口RAM 设计思路：同一个存储器有左右两个独立的端口，分别具有两组相互独立的地址线，数据线和读写控制线</li><li>允许两个独立的CPU同时异步的访问存储单元</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-150306478.png" alt="mark"></p><ul><li>缺点：CPU可能再对同一地址单元，会因数据的冲突造成数据存储或者读取错误<ul><li>解决方法：使用忙信号</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-150540636.png" alt="mark"></p><h3 id="5-2-多模块存储器"><a href="#5-2-多模块存储器" class="headerlink" title="5.2 多模块存储器"></a>5.2 多模块存储器</h3><ol><li>单体多字存储器：只有一个存储体，每个存储单元存储m个字，总线的宽度也为m个字</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-154813168.png" alt="mark"></p><ol start="2"><li>利用存储周期中：存储体需要对电信号进行恢复的特点可以分为：</li></ol><ul><li>高位交叉编址</li><li>低位交叉编址</li></ul><p><strong>对于连续访问地址而言：</strong></p><ul><li><strong>高位交叉编址：不能提高存储的吞吐率</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-155646155.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-155723417.png" alt="mark"></p><ul><li><strong>低位交叉编址：可以提高存储的吞吐率</strong><ul><li>采用流水线的存取方式</li><li>连续存储m个字的存储时间为：<code>t = T + （m - 1）r</code><ul><li>T 是一个存储周期</li><li>m是存储字</li><li>r是总线的传输周期</li></ul></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-155748495.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-155805199.png" alt="mark"></p><p><strong>小结：</strong></p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-160643563.png" alt="mark" style="zoom:80%;" /><h3 id="5-3-小结"><a href="#5-3-小结" class="headerlink" title="5.3 小结"></a>5.3 小结</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-160830950.png" alt="mark"></p><h2 id="6-高速缓冲存储器"><a href="#6-高速缓冲存储器" class="headerlink" title="6. 高速缓冲存储器"></a>6. 高速缓冲存储器</h2><p><strong>前言：使用高速缓存的原因</strong></p><ul><li>使用并行的多模块存储器之后 ： CPU和存储器的速度差距依旧很大</li><li>这就必须改变存储的体系：Cache（SRAM）-主存(DRAM)</li><li>高速缓存的原理是利用<strong>程序访问的局部性原理来实现的</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-161143553.png" alt="mark"></p><h3 id="6-1-程序访问的局部性原理分析"><a href="#6-1-程序访问的局部性原理分析" class="headerlink" title="6.1 程序访问的局部性原理分析"></a>6.1 程序访问的局部性原理分析</h3><ul><li>程序访问的局部性原理包括<ul><li><strong>时间局部性 ：</strong> 最近未来要使用到的信息，很可能是现在使用的信息</li><li><strong>空间局部性 ：</strong> 最近的未来用到的信息，很可能是现在正在使用信息在存储空间上邻近的，因为指令通常是顺序存放的</li></ul></li></ul><p><strong>举个例子：看下面两段代码来判断谁的性能更好？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">### 程序A</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumarrayrow</span><span class="params">(<span class="keyword">int</span> a[M][N])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,i &lt; M,i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### 程序B</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumarrayrow</span><span class="params">(<span class="keyword">int</span> a[M][N])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>,j &lt; N,i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;j++)&#123;</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;，</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设M和N都是2048，按字节编址的话，每个元素占用4个字节</span></span><br><span class="line">对于程序A来说 ，对数组的访问是a[<span class="number">0</span>][<span class="number">0</span>],a[<span class="number">0</span>][<span class="number">1</span>]...a[<span class="number">0</span>][<span class="number">2047</span>],a[<span class="number">1</span>][<span class="number">0</span>]...a[<span class="number">1</span>][<span class="number">2047</span>]，访问顺序和存放的顺序是一致的，因此空间局部性较好</span><br><span class="line">    </span><br><span class="line">对于程序B来说，对数组的访问是a[<span class="number">0</span>][<span class="number">0</span>],a[<span class="number">1</span>][<span class="number">0</span>]...a[<span class="number">2047</span>][<span class="number">0</span>],a[<span class="number">0</span>][<span class="number">1</span>],a[<span class="number">1</span>][<span class="number">1</span>]...a[<span class="number">2047</span>][<span class="number">1</span>],若主存与Cache的交换单位小于<span class="number">8</span>KB，则访问每一个元素都需要装入一个主存块到Cache中，因此没有空间局部性</span><br><span class="line">    </span><br><span class="line">对于时间局部性来说，两个数组的元素都只被访问了一次，因此时间局部性较差。</span><br><span class="line">    </span><br><span class="line">对于<span class="keyword">for</span>循环来说，程序A和程序B的时间局部性和空间局部性都较好，都被执行了<span class="number">2048</span>*<span class="number">2048</span>次</span><br><span class="line">    </span><br><span class="line">在电脑上进行试验，两个程序的所需的时钟周期相差了<span class="number">21</span>倍</span><br></pre></td></tr></table></figure><h3 id="6-2-Cache-的工作原理"><a href="#6-2-Cache-的工作原理" class="headerlink" title="6.2 Cache 的工作原理"></a>6.2 Cache 的工作原理</h3><ul><li>Cache 位于存储器结构的顶层，通常是由SRAM组成</li><li>Cache 块又被叫做Cache 行，每块由若干字节组成，块的长度叫做行长</li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210513-114230905.png" alt="mark" style="zoom:67%;" /><p><strong>工作过程</strong></p><ul><li><strong>当发出读请求时</strong><ul><li>若访问的地址在<strong>Cache 命中</strong>，就将地址转换成Cache 地址，直接对Cache 进行操作，与主存无关</li><li>若访问的地址在<strong>Cache 未命中</strong>，就访问主存，同时将此字所在的块一次调入到Cache 中</li><li>若此时<strong>Cache 已满</strong>，则需要使用你<strong>某种替换算法</strong>，用这个块替换Cache 中原来的某块信息</li></ul></li><li><strong>当发出写请求时</strong><ul><li>若<strong>Cache 命中</strong>，有可能遇到的Cache 与主存中的内容不一致的问题<ul><li>由于CPU写Cache 。把Cache 中的内容从X改为了Y,而主存中的数据依旧是X</li></ul></li><li>若<strong>Cache没有命中</strong>，按照一定的写策略处理，常用的方法是<strong>全写法和写回法</strong></li></ul></li></ul><p><strong>注意：</strong></p><ul><li>Cache 和CPU交换数据是使用字节为单位</li><li>而Cache 和主存之间的交换数据是使用Cache 块为单位</li></ul><p><strong>举个例子：</strong></p><ul><li>未命中的时候: 从主存拉数据</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-165551926.png" alt="mark"></p><ul><li>未命中的时候：从cache拉数据，再访问主存</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-165732376.png" alt="mark"></p><p><strong>小结：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-165921629.png" alt="mark"></p><h3 id="6-3-Cache和主存的映射方式"><a href="#6-3-Cache和主存的映射方式" class="headerlink" title="6.3 Cache和主存的映射方式"></a>6.3 Cache和主存的映射方式</h3><ul><li><strong>Cache 会有如下问题的存在</strong></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-171822672.png" alt="mark" style="zoom:67%;" /><ul><li><strong>首先我们来看如何将主存的内容存入到Cache中</strong><ul><li>直接映射 ： 对号入座</li><li>全相联映射 ：全相联映射</li><li>组相联映射 ：组内随意放，按号分组</li></ul></li></ul><p><strong>举个例子：待后续具体分析</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210511-173101476.png" alt="mark"></p><h4 id="6-3-1-全相联映射"><a href="#6-3-1-全相联映射" class="headerlink" title="6.3.1 全相联映射"></a>6.3.1 全相联映射</h4><ul><li>主存中的每一块放到Cache 中的任意位置</li><li>优点：空间命中率高，利用率也高</li><li>缺点：标记速度慢，成本高</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210513-115645043.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210513-115754961.png" alt="mark"></p><h4 id="6-3-2-直接映射"><a href="#6-3-2-直接映射" class="headerlink" title="6.3.2 直接映射"></a>6.3.2 直接映射</h4><ul><li>主存中的每一块只能装入Cache 中的唯一位置</li><li>若这个位置已经有内容，那么产生块冲突，原来的块将无条件的被替换出去（无须替换算法）</li><li>直接映射的关系为 <code>j = i mod 2^c</code></li><li>标记不需要标记行号</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210513-120113134.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210513-120137931.png" alt="mark"></p><h4 id="6-3-3-组相联映射"><a href="#6-3-3-组相联映射" class="headerlink" title="6.3.3 组相联映射"></a>6.3.3 组相联映射</h4><ul><li>将Cache 空间分成大小相同的组</li><li>主存的一个数据块可以装入一组内的任何位置<ul><li>组间采用直接映射</li><li>组内采用全相联映射</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210513-120609488.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210513-120620998.png" alt="mark"></p><p><strong>小结：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210513-120847780.png" alt="mark"></p><h3 id="6-4-Cache-的替换算法"><a href="#6-4-Cache-的替换算法" class="headerlink" title="6.4 Cache 的替换算法"></a>6.4 Cache 的替换算法</h3><ul><li>四种算法预览：</li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-105724247.png" alt="mark" style="zoom:67%;" /><p><strong>举个例子：</strong></p><ol><li><strong>使用全相联映射</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-110044764.png" alt="mark"></p><ol start="2"><li><strong>FIFO 内存置换</strong></li></ol><ul><li>最先调入的是4号块，替换Cache 的第0块</li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-110231983.png" alt="mark" style="zoom:80%;" /><ol start="3"><li><strong>LRU 内存置换</strong></li></ol><ul><li>最近最少使用的是12号块，替换Cache的第二块</li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-110327966.png" alt="mark" style="zoom:80%;" /><ol start="4"><li><strong>LFU 内存置换</strong></li></ol><ul><li>4号块使用了3次，6号块使用了两次，其他几块均使用了1次，需要更多的依据</li></ul><p><strong>小结：</strong></p><ul><li><strong>具体的Cache命中率需要考虑</strong><ul><li><strong>Cache的映射算法</strong></li><li><strong>Cache的替换算法</strong></li></ul></li></ul><h3 id="6-5-Cache-体系结构"><a href="#6-5-Cache-体系结构" class="headerlink" title="6.5 Cache 体系结构"></a>6.5 Cache 体系结构</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-111225347.png" alt="mark"></p><h3 id="6-6-Cache-与主存的-数据不一致"><a href="#6-6-Cache-与主存的-数据不一致" class="headerlink" title="6.6 Cache 与主存的 数据不一致"></a>6.6 Cache 与主存的 数据不一致</h3><ol><li><strong>写策略 - 命中的情形</strong></li></ol><ul><li><strong>写回法：</strong>当CPU对Cache 写命中的时候，只修改Cache 的内容，而不立即写回到主存中，只有当此块被换出的时候才写回主存。这种方法减少了访存的次数，但存在数据不一致的隐患。<ul><li>采用这种策略，每个Cache行需要设置一个（脏位），以反映是否被CPU修改过</li></ul></li><li><strong>全写法：</strong>当CPU对Cache 写命中的时候，将数据同时写入到Cache 和主存中，当某一块需要替换的时候，不必把这一块写回主存，用新调入的块直接覆盖即可。<ul><li>优点：实现简单，能随时保证主存数据的正确性</li><li>缺点：增加了访存的次数，降低了Cache的效率</li><li><strong>一般要设置 ： 写缓冲（减少主存和CPU之间的损耗）</strong></li><li>写缓冲有可能会溢出</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-111841954.png" alt="mark"></p><ol start="2"><li><strong>写策略：不命中的情形</strong></li></ol><ul><li><strong>写分配法</strong>：未命中时，将主存数据调入到Cache中，然后更新这个Cache块，同时搭配写回法</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-112012818.png" alt="mark"></p><ul><li><strong>非写分配法 ：</strong>  直接改写主存，搭配全写法</li></ul><p><strong>小结：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-112226661.png" alt="mark"></p><ul><li><strong>现代计算机一般使用多级Cache</strong>, 如下图所示：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-112335719.png" alt="mark"></p><ul><li>L1 Cache 和 L2 Cache 之间使用全写法，L2 Cache 对主存使用写回法</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-112511651.png" alt="mark"></p><h3 id="6-7-虚拟存储器"><a href="#6-7-虚拟存储器" class="headerlink" title="6.7 虚拟存储器"></a>6.7 虚拟存储器</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-113029730.png" alt="mark"></p><ul><li><p><strong>主存和辅存共同构成了虚拟存储器</strong></p><ul><li>对于程序员而言，虚拟存储器是透明的</li><li>相当于对实体存储器进行了一层封装</li></ul></li><li><p><strong>虚拟存储器将主存和辅存的地址空间统一编制</strong>，形成一个庞大的地址空间</p><ul><li><strong>用户</strong>编程允许的地址位：虚地址或者<strong>逻辑地址</strong></li><li><strong>实际</strong>的主存单元被称为：是地址或者<strong>物理地址</strong></li><li>实地址对应的是主存空间地址</li></ul></li><li><p>CPU使用虚地址时，由辅助硬件找出虚地址和实地址之间的对应关系，并判断这个虚地址对应的存储的那元是否已装入到主存中</p><ul><li>若已在主存中，则通过地址变换，CPU可以直接的访问主存的实际存储单元</li><li>若不在主存中，则把对应的一页或者一段调入到主存后再由CPU访问</li><li>若主存已满，则采用替换算法替换主存中的一页或者一段</li></ul></li></ul><p><strong>以下只是简单介绍，具体看操作系统的博客内容</strong></p><h4 id="6-7-1-页式虚拟存储器"><a href="#6-7-1-页式虚拟存储器" class="headerlink" title="6.7.1 页式虚拟存储器"></a>6.7.1 页式虚拟存储器</h4><ul><li>虚拟空间和主存空间都被分为大小相同的页，主存的页叫做实页，虚拟的页叫做虚页</li><li>虚拟地址分为两个字段：<ul><li>虚页号</li><li>页内地址</li></ul></li><li>虚拟地址和物理地址的转换通过页表来实现</li><li>页面的大小是固定的</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-114120279.png" alt="mark"></p><p><strong>例题：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-144149727.png" alt="mark"></p><h4 id="6-7-2-段式虚拟存储器"><a href="#6-7-2-段式虚拟存储器" class="headerlink" title="6.7.2 段式虚拟存储器"></a>6.7.2 段式虚拟存储器</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-114259563.png" alt="mark"></p><ul><li>段的长度是可变的，段表只需要给出各段的起始地址和段的长度</li><li>优点：段的分解与程序的自然分界相对应，易于编译</li><li>缺点 ：长度可变</li></ul><h4 id="6-7-3-段页式虚拟存储器"><a href="#6-7-3-段页式虚拟存储器" class="headerlink" title="6.7.3 段页式虚拟存储器"></a>6.7.3 段页式虚拟存储器</h4><ul><li>先将程序按逻辑分段，每段再划分称为固定大小的页</li><li>虚地址分为 段号 + 段内页号 + 页内地址</li><li>缺点是：变换过程中需要多次查表，系统开销较大</li></ul><h4 id="6-7-4-快表"><a href="#6-7-4-快表" class="headerlink" title="6.7.4 快表"></a>6.7.4 快表</h4><ul><li>页表，段表存放在主存中，收到虚拟地址后需要先访问主存，查询主存中的页表，段表叫做<strong>慢表</strong></li><li><strong>快表的思想：利用高速缓存存放页表项</strong></li><li>利用局部性原理存入Cache</li></ul><h4 id="6-7-5-小结"><a href="#6-7-5-小结" class="headerlink" title="6.7.5 小结"></a>6.7.5 小结</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210514-143817051.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;计算机组成原理-07-存储器&quot;&gt;&lt;a href=&quot;#计算机组成原理-07-存储器&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理-07-存储器&quot;&gt;&lt;/a&gt;计算机组成原理-07-存储器&lt;/h2&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-224820865.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
      <category term="计算机组成原理" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计组-06-算数逻辑单元ALU</title>
    <link href="http://zhuuu.work/2021/04/27/Compute_Organization/%E8%AE%A1%E7%BB%84-06-%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83ALU/"/>
    <id>http://zhuuu.work/2021/04/27/Compute_Organization/%E8%AE%A1%E7%BB%84-06-%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83ALU/</id>
    <published>2021-04-27T03:02:24.000Z</published>
    <updated>2021-04-29T14:38:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机组成原理-06-算数逻辑单元ALU"><a href="#计算机组成原理-06-算数逻辑单元ALU" class="headerlink" title="计算机组成原理-06-算数逻辑单元ALU"></a>计算机组成原理-06-算数逻辑单元ALU</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-102318501.png" alt="mark"></p><ul><li><p>回顾 ALU (<code>Arithmetic and Logic Unit</code>)</p><ul><li><strong>功能</strong><ul><li>算数运算：加减乘除</li><li>逻辑运算：与或非 异或</li><li>辅助功能：移位 求补</li></ul></li><li><strong>逻辑结构</strong>如下所示</li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-104120309.png" alt="mark" style="zoom:50%;" /></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-104639469.png" alt="mark"></p><ul><li><strong>本节概览</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-202659398.png" alt="mark"></p><a id="more"></a><h2 id="1-逻辑运算-电路表示"><a href="#1-逻辑运算-电路表示" class="headerlink" title="1. 逻辑运算 电路表示"></a>1. 逻辑运算 电路表示</h2><ul><li><strong>门电路的本质：高低电平</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-105015935.png" alt="mark"></p><ul><li><strong>门电路的运算优先级：离散数学</strong><ul><li>与运算 &gt; 或运算</li></ul></li></ul><ul><li><strong>门电路的复合逻辑运算</strong><ul><li>与或</li><li>或非</li><li>异或</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-110322606.png" alt="mark"></p><ul><li><strong>异或门的具体实现</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-110705700.png" alt="mark"></p><ul><li><strong>同或： 对异或的结果进行取反</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-110853101.png" alt="mark"></p><h2 id="2-门电路求-奇偶校验位"><a href="#2-门电路求-奇偶校验位" class="headerlink" title="2. 门电路求 奇偶校验位"></a>2. 门电路求 奇偶校验位</h2><ul><li><strong>偶校验位</strong></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-200647575.png" alt="mark" style="zoom:80%;" /><h2 id="3-加法器原理"><a href="#3-加法器原理" class="headerlink" title="3. 加法器原理"></a>3. 加法器原理</h2><h3 id="3-1-一位全加器"><a href="#3-1-一位全加器" class="headerlink" title="3.1 一位全加器"></a>3.1 一位全加器</h3><ul><li><strong>一位全加器</strong><ul><li>加数A</li><li>加数B</li><li>低位传来的进位</li></ul></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-201729375.png" alt="mark" style="zoom: 67%;" /><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-201806615.png" alt="mark" style="zoom:67%;" /><p><strong>复杂电路图如下所示：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-201828538.png" alt="mark"></p><p><strong>简略电路图如下所示：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-201858175.png" alt="mark"></p><h3 id="3-2-串行加法器"><a href="#3-2-串行加法器" class="headerlink" title="3.2 串行加法器"></a>3.2 串行加法器</h3><ul><li><strong>本质在一位加法器上保存了进位位</strong><ul><li>如果操作数长n位，加法分n次进行，每次产生一位和，并且串行的送回寄存器中</li></ul></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-202122450.png" alt="mark" style="zoom: 80%;" /><h3 id="3-3-并行加法器"><a href="#3-3-并行加法器" class="headerlink" title="3.3 并行加法器"></a>3.3 并行加法器</h3><h4 id="3-3-1-串行进位"><a href="#3-3-1-串行进位" class="headerlink" title="3.3.1 串行进位"></a>3.3.1 串行进位</h4><ul><li>电路图所下所示：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-202532894.png" alt="mark"></p><ul><li>缺点 ： 低位运算产生所需要的时间影响最高位运算产生的时间</li></ul><h4 id="3-3-2-并行进位"><a href="#3-3-2-并行进位" class="headerlink" title="3.3.2 并行进位"></a>3.3.2 并行进位</h4><ul><li><strong>优化思路：递归展开到C0(第一个进位)</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-203247645.png" alt="mark"></p><p><strong>方式一：单级先行进位方式：组内并行，组间串行</strong></p><ul><li>4位进位电路的CLA加法器</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-204123677.png" alt="mark"></p><p><strong>方式二 ： 多级先行进位方式</strong></p><ul><li><strong>组内并行，组件并行</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-222306836.png" alt="mark"></p><h4 id="3-3-3-ALU优化"><a href="#3-3-3-ALU优化" class="headerlink" title="3.3.3 ALU优化"></a>3.3.3 ALU优化</h4><ul><li>16位的组内并行，组间串行</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-223254793.png" alt="mark"></p><ul><li>16位的组内并行，组间并行</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-223351779.png" alt="mark"></p><ul><li><strong>小结</strong> </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">串行加法器 -&gt; 串行进位的并行加法器 -&gt; 组内并行，组间串行 -&gt;组内并行，组间并行</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;计算机组成原理-06-算数逻辑单元ALU&quot;&gt;&lt;a href=&quot;#计算机组成原理-06-算数逻辑单元ALU&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理-06-算数逻辑单元ALU&quot;&gt;&lt;/a&gt;计算机组成原理-06-算数逻辑单元ALU&lt;/h2&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-102318501.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;回顾 ALU (&lt;code&gt;Arithmetic and Logic Unit&lt;/code&gt;)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;算数运算：加减乘除&lt;/li&gt;
&lt;li&gt;逻辑运算：与或非 异或&lt;/li&gt;
&lt;li&gt;辅助功能：移位 求补&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;逻辑结构&lt;/strong&gt;如下所示&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-104120309.png&quot; alt=&quot;mark&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-104639469.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;本节概览&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210429-202659398.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
      <category term="计算机组成原理" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-091-编码方案</title>
    <link href="http://zhuuu.work/2021/04/21/Leetcode/Leetcode-091-%E7%BC%96%E7%A0%81%E6%96%B9%E6%A1%88/"/>
    <id>http://zhuuu.work/2021/04/21/Leetcode/Leetcode-091-%E7%BC%96%E7%A0%81%E6%96%B9%E6%A1%88/</id>
    <published>2021-04-21T03:02:24.000Z</published>
    <updated>2021-04-21T01:50:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-091-解码方法"><a href="#Leetcode-091-解码方法" class="headerlink" title="Leetcode-091-解码方法"></a>Leetcode-091-<a href="https://leetcode-cn.com/problems/decode-ways/" target="_blank" rel="noopener">解码方法</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#39;A&#39; -&gt; 1</span><br><span class="line">&#39;B&#39; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; 26</span><br></pre></td></tr></table></figure><p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>&quot;11106&quot;</code> 可以映射为：</p><ul><li><code>&quot;AAJF&quot;</code> ，将消息分组为 <code>(1 1 10 6)</code></li><li><code>&quot;KJF&quot;</code> ，将消息分组为 <code>(11 10 6)</code></li></ul><p><strong>说明:</strong></p><ul><li><strong>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</strong></li><li>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</li><li>题目数据保证答案肯定是一个 32 位 的整数。</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;12&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;226&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;0&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：没有字符映射到以 0 开头的数字。</span><br><span class="line">含有 0 的有效映射是 &#39;J&#39; -&gt; &quot;10&quot; 和 &#39;T&#39;-&gt; &quot;20&quot; 。</span><br><span class="line">由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。</span><br></pre></td></tr></table></figure><h2 id="方案思路：动态规划"><a href="#方案思路：动态规划" class="headerlink" title="方案思路：动态规划"></a>方案思路：动态规划</h2><ul><li><p>对于给定的字符串 s，设它的长度为 n，其中的字符从左到右依次为<code>s[n]s[1],s[2],⋯,s[n]</code>。可以使用动态规划的方法计算出字符串 s 的解码方法数。</p></li><li><p>具体地，<code>f[i]</code>定义：代表的是最后解码方案的个数</p><ul><li>表示字符串 s 的前 i 个字符<code>s[1..i]</code>的解码方法数。</li></ul></li><li><p>在进行状态转移时，可以考虑最后一次解码使用了 s 中的哪些字符，那么会有下面的两种情况：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-094552918.png" alt="mark"></p><ul><li>需要注意的是，只有当 <code>i&gt;1</code>时才能进行转移，否则 <code>s[i-2]</code>不存在。</li></ul></li></ul><ul><li>边界条件：<code>f[0] = 1</code>即<strong>空字符串可以有 1 种解码方法，解码出一个空字符串</strong>。</li></ul><p><strong>注意：</strong></p><ul><li>同时，由于在大部分语言中，字符串的下标是从 0 而不是 1 开始的，因此在代码的编写过程中，我们需要将所有字符串的下标减去 1，与使用的语言保持一致。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. dp定义：dp代表的是最后解码方案的个数</span></span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 边界条件：空字符串也是一种编码结果</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 转移逻辑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="comment">// 3.1 从数组末尾向前进行动态规划，统计所有的单字符编码方式</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) != <span class="string">'0'</span>)&#123;                                     <span class="comment">// 判断条件为s[i - 1] != '0'</span></span><br><span class="line">                dp[i] += dp[i - <span class="number">1</span>];                                         <span class="comment">// 统计所有的单字符编码方式          </span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2 从数组末尾向前进行动态规划，统计所有的双字符编码方式</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span> &amp;&amp; s.charAt(i - <span class="number">2</span>) != <span class="string">'0'</span> &amp;&amp; ((s.charAt(i - <span class="number">2</span>) - <span class="string">'0'</span>) * <span class="number">10</span> + (s.charAt(i - <span class="number">1</span>) - <span class="string">'0'</span>) &lt;= <span class="number">26</span>))&#123;</span><br><span class="line">                dp[i] += dp[i - <span class="number">2</span>];                                         <span class="comment">// 统计所有的双字符编码方式 </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 返回最后的方案数</span></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 ： O(n) , 遍历一遍数组</li><li>空间复杂度 ： O(n) , dp使用的额外空间</li></ul><h2 id="优化：滚动数组"><a href="#优化：滚动数组" class="headerlink" title="优化：滚动数组"></a>优化：滚动数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划（滚动数组）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="comment">// a = f[i-2], b = f[i-1], c=f[i]</span></span><br><span class="line">        <span class="comment">// 1. 定义：三种状态</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>, c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 转移逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            c = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 2.2 统计所有单字符的方案数</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) != <span class="string">'0'</span>) &#123;</span><br><span class="line">                c += b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2.3 统计所有双字符的方案数</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; s.charAt(i - <span class="number">2</span>) != <span class="string">'0'</span> &amp;&amp; ((s.charAt(i - <span class="number">2</span>) - <span class="string">'0'</span>) * <span class="number">10</span> + (s.charAt(i - <span class="number">1</span>) - <span class="string">'0'</span>) &lt;= <span class="number">26</span>)) &#123;</span><br><span class="line">                c += a;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4. 滚动数组</span></span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 ： O(n) , 遍历一遍数组</li><li>空间复杂度 ： O(1) , 滚动数组仅仅设置三个变量</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-091-解码方法&quot;&gt;&lt;a href=&quot;#Leetcode-091-解码方法&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-091-解码方法&quot;&gt;&lt;/a&gt;Leetcode-091-&lt;a href=&quot;https://leetcode-cn.com/problems/decode-ways/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;解码方法&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一条包含字母 &lt;code&gt;A-Z&lt;/code&gt; 的消息通过以下映射进行了 &lt;strong&gt;编码&lt;/strong&gt; ：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#39;A&amp;#39; -&amp;gt; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#39;B&amp;#39; -&amp;gt; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#39;Z&amp;#39; -&amp;gt; 26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;要 &lt;strong&gt;解码&lt;/strong&gt; 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，&lt;code&gt;&amp;quot;11106&amp;quot;&lt;/code&gt; 可以映射为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;AAJF&amp;quot;&lt;/code&gt; ，将消息分组为 &lt;code&gt;(1 1 10 6)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;KJF&amp;quot;&lt;/code&gt; ，将消息分组为 &lt;code&gt;(11 10 6)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。&lt;/li&gt;
&lt;li&gt;题目数据保证答案肯定是一个 32 位 的整数。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://zhuuu.work/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>计组-05-数据的表示(浮点数)</title>
    <link href="http://zhuuu.work/2021/04/20/Compute_Organization/%E8%AE%A1%E7%BB%84-05-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA(%E6%B5%AE%E7%82%B9%E6%95%B0)/"/>
    <id>http://zhuuu.work/2021/04/20/Compute_Organization/%E8%AE%A1%E7%BB%84-05-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA(%E6%B5%AE%E7%82%B9%E6%95%B0)/</id>
    <published>2021-04-20T03:02:24.000Z</published>
    <updated>2021-04-28T02:18:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计组-05-数据的表示-浮点数"><a href="#计组-05-数据的表示-浮点数" class="headerlink" title="计组-05-数据的表示(浮点数)"></a>计组-05-数据的表示(浮点数)</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-151330497.png" alt="mark"></p><ul><li><p><strong>定点数的局限性</strong></p><ul><li>在位数有限的情况下，无法增加数的表示范围</li></ul></li><li><p><strong>浮点数</strong></p><ul><li>在位数有限的情况下，既扩大了数的表示范围，又保持了数的有效精度</li></ul></li><li><p><strong>本章节基本要点</strong></p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-152244855.png" alt="mark"></p><h2 id="1-浮点数的表示形式"><a href="#1-浮点数的表示形式" class="headerlink" title="1. 浮点数的表示形式"></a>1. 浮点数的表示形式</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-151907866.png" alt="mark"></p><a id="more"></a><ul><li><strong>从科学计数法来理解浮点数的意义</strong><ul><li>r 为阶码的底 ： 浮点数的底，一般<code>r = 2</code></li><li>E 为阶码 :  通常用补码或者移码表示</li><li>M 称为尾数 ： 通常用补码或者原码表示</li><li>数字表示 <code>N = r^E * M</code></li></ul></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-152149842.png" alt="mark" style="zoom:67%;" /><ul><li><strong>定点数和浮点数的区别比较</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-152547010.png" alt="mark"></p><p><strong>小结：</strong></p><ul><li>尾数给出了一个小数，阶码指明了小数点要向前/向后移动多少位</li><li>尾数M的数值部分的位数n反映了浮点数的精度</li><li>阶码E反映了浮点数的表示范围以及小数点的实际位置</li></ul><p><strong>举个例子</strong></p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-193430512.png" alt="mark" style="zoom:67%;" /><h2 id="2-浮点数尾数的规格化"><a href="#2-浮点数尾数的规格化" class="headerlink" title="2. 浮点数尾数的规格化"></a>2. 浮点数尾数的规格化</h2><ul><li><strong>首先来看个问题</strong><ul><li>尾数的最高位不是一个有效位，会造成精度的损失</li></ul></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-193547925.png" alt="mark" style="zoom:67%;" /><ul><li><strong>解决问题的方案：</strong><ul><li>规定尾数的最高位数值一定是个有效值</li><li>左规：将尾数算数左移一位，阶码减一</li><li>右规：将尾数算数右移一位，阶码加一<ul><li>右规：当使用双符号位的时候，同时有溢出发生时，可以进行挽救</li></ul></li></ul></li></ul><p><strong>举个例子：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-194840202.png" alt="mark"></p><p><strong>规格化的特点：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-195251237.png" alt="mark"></p><p><strong>小结：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-200659972.png" alt="mark"></p><h2 id="3-IEEE-754"><a href="#3-IEEE-754" class="headerlink" title="3. IEEE 754"></a>3. IEEE 754</h2><h3 id="3-1-IEEE-754-移码"><a href="#3-1-IEEE-754-移码" class="headerlink" title="3.1 IEEE 754 移码"></a>3.1 IEEE 754 移码</h3><ul><li>之前所说的移码：补码的基础上将符号位取反<ul><li>这里偏置值是<code>128 = 2^（n-1）</code></li></ul></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-201020345.png" alt="mark" style="zoom:67%;" /><ul><li><strong>移码的定义：移码 = 真值+偏置值</strong></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-201255878.png" alt="mark" style="zoom:67%;" /><ul><li><strong>IEEE 754 标准的移码</strong></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-201541486.png" alt="mark" style="zoom:67%;" /><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-201606628.png" alt="mark"></p><h3 id="3-2-IEEE-754-浮点数表示"><a href="#3-2-IEEE-754-浮点数表示" class="headerlink" title="3.2 IEEE 754 浮点数表示"></a>3.2 IEEE 754 浮点数表示</h3><ul><li><strong>IEEE 754 标准的浮点数</strong><ul><li><strong>尾数采取隐藏位策略的原码表示</strong></li><li><strong>阶码用移码表示的浮点数</strong><ul><li>阶码的全0 和 全1  用作特殊用途</li><li>阶码的真值 = 移码 - 偏置值</li></ul></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-201918766.png" alt="mark"></p><p><strong>举个例子：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-202741226.png" alt="mark"></p><hr><ul><li>将十进制转换为单精度浮点数</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-203101005.png" alt="mark"></p><ul><li>将单精度浮点数转换为十进制数</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-203410684.png" alt="mark"></p><h3 id="3-3-IEEE-754-表示范围"><a href="#3-3-IEEE-754-表示范围" class="headerlink" title="3.3 IEEE 754 表示范围"></a>3.3 IEEE 754 表示范围</h3><ul><li><strong>单精度浮点数表示范围</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-204358929.png" alt="mark"></p><ul><li><strong>双精度浮点数表示范围</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-204619375.png" alt="mark"></p><ul><li><p><strong>阶码全0 和 全1的作用</strong></p><ul><li><strong>阶码全0 ： 可以表示比原来最小值还要小的数</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-205014557.png" alt="mark"></p><ul><li><strong>阶码全1 ：可以表示比原来最大数还要大的数</strong></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-205315986.png" alt="mark"></p><h3 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4 小结"></a>3.4 小结</h3><ul><li>由浮点数如何确定真值？<ul><li>根据 ”某浮点数“ 确定数符，阶码，尾数</li><li>确定尾数 1.M (注意补充最高的隐含位)</li><li>确定阶码的真值 = 移码 - 偏置值（可将移码看作无符号数，用无符号数的值减去偏置值）</li><li><code>（-1）^s * 1.M * 2^(E - 偏置值)</code></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210427-210207046.png" alt="mark"></p><h2 id="4-浮点数的计算"><a href="#4-浮点数的计算" class="headerlink" title="4. 浮点数的计算"></a>4. 浮点数的计算</h2><ul><li>首先还是从10进制浮点数原理开始说起<ul><li>分为几个步骤<ul><li>对阶 ： 小阶向大阶看齐</li><li>尾数加减 ：通常使用双符号位，拯救溢出</li><li>规格化 ： 左规和右规操作</li><li>舍入</li><li>判断溢出</li></ul></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-092736401.png" alt="mark"></p><h3 id="4-1-二进制浮点数计算"><a href="#4-1-二进制浮点数计算" class="headerlink" title="4.1 二进制浮点数计算"></a>4.1 二进制浮点数计算</h3><ul><li><strong>二进制举个例子</strong><ul><li>无需舍入的例子如下：</li></ul></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-094057128.png" alt="mark" style="zoom:67%;" /><p><img src="C:%5CUsers%5CZhuuu%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210428095730353.png" alt="image-20210428095730353"></p><h3 id="4-2-舍入的方法"><a href="#4-2-舍入的方法" class="headerlink" title="4.2 舍入的方法"></a>4.2 舍入的方法</h3><ul><li><p><strong>舍入的方式</strong></p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-100153984.png" alt="mark" style="zoom:67%;" /><ul><li>0 舍 1 入 法 ： 当舍弃的数字是1的时候，给末尾的数字加1</li><li>恒 置 1 法：无论舍弃的值为什么，把最后一位改为1</li></ul></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-100405431.png" alt="mark" style="zoom:67%;" /><h2 id="5-浮点数-强制类型转换"><a href="#5-浮点数-强制类型转换" class="headerlink" title="5. 浮点数 强制类型转换"></a>5. 浮点数 强制类型转换</h2><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-100930859.png" alt="mark" style="zoom:67%;" /><ul><li><strong>无损的转换类型(32 位 情况下)</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char -&gt; int -&gt; long -&gt; double</span><br><span class="line">float -&gt; double</span><br><span class="line"></span><br><span class="line">## 注意 ： 在64位的情况下 long -&gt; double 有精度损失</span><br><span class="line"></span><br><span class="line">1. </span><br><span class="line">int -&gt; float : int有效位32 float有效位24 会有精度的损失</span><br><span class="line">float -&gt; int ： 可能会溢出也可能会有精度损失（int 没有小数部分）</span><br></pre></td></tr></table></figure><h2 id="6-浮点数小结"><a href="#6-浮点数小结" class="headerlink" title="6. 浮点数小结"></a>6. 浮点数小结</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210428-101726149.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;计组-05-数据的表示-浮点数&quot;&gt;&lt;a href=&quot;#计组-05-数据的表示-浮点数&quot; class=&quot;headerlink&quot; title=&quot;计组-05-数据的表示(浮点数)&quot;&gt;&lt;/a&gt;计组-05-数据的表示(浮点数)&lt;/h2&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-151330497.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;定点数的局限性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在位数有限的情况下，无法增加数的表示范围&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;浮点数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在位数有限的情况下，既扩大了数的表示范围，又保持了数的有效精度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;本章节基本要点&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-152244855.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-浮点数的表示形式&quot;&gt;&lt;a href=&quot;#1-浮点数的表示形式&quot; class=&quot;headerlink&quot; title=&quot;1. 浮点数的表示形式&quot;&gt;&lt;/a&gt;1. 浮点数的表示形式&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-151907866.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
      <category term="计算机组成原理" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-027-移除元素</title>
    <link href="http://zhuuu.work/2021/04/19/Leetcode/Leetcode-027-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <id>http://zhuuu.work/2021/04/19/Leetcode/Leetcode-027-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</id>
    <published>2021-04-19T03:02:24.000Z</published>
    <updated>2021-04-19T03:05:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-027-移除元素"><a href="#Leetcode-027-移除元素" class="headerlink" title="Leetcode-027-移除元素"></a>Leetcode-027-移除元素</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</li><li>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</li><li>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</li></ul><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len &#x3D; removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [3,2,2,3], val &#x3D; 3</span><br><span class="line">输出：2, nums &#x3D; [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2</span><br><span class="line">输出：5, nums &#x3D; [0,1,4,0,3]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><h2 id="方法一-：-双指针"><a href="#方法一-：-双指针" class="headerlink" title="方法一 ： 双指针"></a>方法一 ： 双指针</h2><ul><li>由于题目要求删除数组中等于<code>val</code> 的元素，因此输出数组的长度一定小于等于输入数组的长度，可以把输出的数组直接写在输入数组上。可以使用双指针：右指针<code>fast</code> 指向当前将要处理的元素，左指针<code>slow</code>指向下一个将要赋值的位置。<ul><li>如果右指针指向的元素不等于val，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移；</li><li>如果右指针指向的元素等于 val，它不能在输出数组里，此时左指针不动，右指针右移一位。</li></ul></li><li>整个过程保持不变的性质是：区间<code>[0,slow)</code> 中的元素都不等于 val。当左右指针遍历完输入数组以后，<code>slow</code>的值就是输出数组的长度。</li><li>这样的算法在最坏情况下（输入数组中没有元素等于 <em>val</em>），左右指针各遍历了数组一次。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 变量初始化及特判</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;                                   <span class="comment">// 慢指针</span></span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>;                                   <span class="comment">// 快指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 处理逻辑</span></span><br><span class="line">        <span class="keyword">while</span>(fast &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(val != nums[fast])&#123;                      <span class="comment">// 这种情况说明该快指针指向的元素需要被保留</span></span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;                                     <span class="comment">// 说明元素需要删除的，跳过该元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 返回处理后的末尾元素</span></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n) ，遍历一遍数组</li><li>空间复杂度：O(1) ， 原地修改</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Leetcode-027-移除元素&quot;&gt;&lt;a href=&quot;#Leetcode-027-移除元素&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-027-移除元素&quot;&gt;&lt;/a&gt;Leetcode-027-移除元素&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;
      
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-220-存在重复元素III</title>
    <link href="http://zhuuu.work/2021/04/17/Leetcode/Leetcode-220-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0III/"/>
    <id>http://zhuuu.work/2021/04/17/Leetcode/Leetcode-220-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0III/</id>
    <published>2021-04-17T01:02:24.000Z</published>
    <updated>2021-04-17T02:15:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-220-存在重复元素-III"><a href="#Leetcode-220-存在重复元素-III" class="headerlink" title="Leetcode-220-存在重复元素 III"></a>Leetcode-220-<a href="https://leetcode-cn.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener">存在重复元素 III</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在两个下标 i 和 j，使得 <code>abs(nums[i] - nums[j]) &lt;= t</code>，同时又满足 <code>abs(i - j) &lt;= k</code> 。</li><li>如果存在则返回<code>true</code>，不存在返回<code>false。</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [1,2,3,1], k &#x3D; 3, t &#x3D; 0</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [1,0,1,1], k &#x3D; 1, t &#x3D; 2</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [1,5,9,1,5,9], k &#x3D; 2, t &#x3D; 3</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">0 &lt;&#x3D; nums.length &lt;&#x3D; 2 * 10^4</span><br><span class="line">-2^31 &lt;&#x3D; nums[i] &lt;&#x3D; 2^31 - 1</span><br><span class="line">0 &lt;&#x3D; k &lt;&#x3D; 10^4</span><br><span class="line">0 &lt;&#x3D; t &lt;&#x3D; 2^31 - 1</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="算法思路：滑动窗口"><a href="#算法思路：滑动窗口" class="headerlink" title="算法思路：滑动窗口"></a>算法思路：滑动窗口</h2><ul><li>对于序列中每一个元素 x 左侧的至多 k 个元素，如果这 k 个元素中存在一个元素落在区间<code>[x - t, x + t]</code>中，我们就找到了一对符合条件的元素。</li><li><strong>注意到对于两个相邻的元素，它们各自的左侧的 <em>k</em> 个元素中有 k−1 个是重合的。</strong><ul><li>于是我们可以使用滑动窗口的思路，维护一个大小为 <em>k</em> 的滑动窗口</li><li>每次遍历到元素 <em>x</em> 时，滑动窗口中包含元素 <em>x</em> 前面的最多 <em>k</em> 个元素</li><li>检查窗口中是否存在一个元素落在区间<code>[x - t, x + t]</code>中，我们就找到了一对符合条件的元素。</li></ul></li></ul><p><strong>注意：</strong></p><ul><li><p>如果使用<strong>队列维护滑动窗口内的元素，由于元素是无序的</strong>，我们只能对于每个元素都遍历一次队列来检查是否有元素符合条件。</p><ul><li><strong>如果数组的长度为 <em>n</em>，则使用队列的时间复杂度为 O(nk)，会超出时间限制。</strong></li><li>因此我们希望能够找到一个数据结构维护滑动窗口内的元素，该数据结构需要满足以下操作：<ul><li><strong>支持添加和删除指定元素的操作</strong>，否则我们无法维护滑动窗口；</li><li>内部元素有序，支持二分查找的操作，这样我们可以<strong>快速判断滑动窗口中是否存在元素满足条件</strong></li><li>具体而言，对于元素 x，当我们希望判断滑动窗口中是否存在某个数 y 落在区间<code>[x - t, x + t]</code>中，只需要判断滑动窗口中所有大于等于<code>x - t</code>的元素中的最小元素是否小于等于<code>x + t</code>即可。</li></ul></li></ul></li></ul><p><strong>具体实现：</strong></p><ul><li><p>实现方面，我们在有序集合中查找大于等于 <code>x - t</code>的最小的元素<code>y</code>，如果 y 存在，且 <code>y ≤ x+t</code>，我们就找到了一对符合条件的元素。</p></li><li><p>完成检查后，我们将 <em>x</em> 插入到有序集合中，如果有序集合中元素数量超过了 <em>k</em>，我们将有序集合中最早被插入的元素删除即可。</p></li><li><p>如果当前有序集合中存在相同元素，那么此时程序将直接返回true。因此本题中的有序集合无需处理相同元素的情况。</p></li><li><p>为防止整型 int 溢出，我们既可以使用长整型 long，也可以对查找区间<code>[x - t, x + t]</code>进行限制，使其落在 int 范围内。</p></li></ul><ul><li></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 使用有序集合来维护大小为k的滑动窗口</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        TreeSet&lt;Long&gt; set = <span class="keyword">new</span> TreeSet&lt;Long&gt;();                            <span class="comment">// long为了防止溢出</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 处理逻辑：遍历每个元素，滑动窗口包含了nums[i]的前k个元素，检查是否落在了[nums[i] - t,nums[i] + t]的区间内</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 2.1 判断有序集合中是否存在符合条件的元素</span></span><br><span class="line">            Long ceiling = set.ceiling((<span class="keyword">long</span>) nums[i] - (<span class="keyword">long</span>) t);          <span class="comment">// ceiling()：方法返回在这个集合中大于或者等于给定元素的最小元素，如果不存在这样的元素,返回null.</span></span><br><span class="line">            <span class="keyword">if</span> (ceiling != <span class="keyword">null</span> &amp;&amp; ceiling &lt;= (<span class="keyword">long</span>) nums[i] + (<span class="keyword">long</span>) t) &#123;  <span class="comment">// 存在这样一对元素就直接返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.2 不存在的话暂时添加到有序集合中</span></span><br><span class="line">            set.add((<span class="keyword">long</span>) nums[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.3 维护大小为k的滑动窗口，删除超出范围的最早的元素</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">                set.remove((<span class="keyword">long</span>) nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 都不满足返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(nlog(min(<em>n</em>,<em>k</em>))) , n 是遍历一遍数组，log(min(<em>n</em>,<em>k</em>)) 是对集合的插入和删除操作</li><li>空间复杂度：O((min(<em>n</em>,<em>k</em>))) , 使用大小为k的滑动窗口，最差情况下是数组的大小</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-220-存在重复元素-III&quot;&gt;&lt;a href=&quot;#Leetcode-220-存在重复元素-III&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-220-存在重复元素 III&quot;&gt;&lt;/a&gt;Leetcode-220-&lt;a href=&quot;https://leetcode-cn.com/problems/contains-duplicate-iii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;存在重复元素 III&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在两个下标 i 和 j，使得 &lt;code&gt;abs(nums[i] - nums[j]) &amp;lt;= t&lt;/code&gt;，同时又满足 &lt;code&gt;abs(i - j) &amp;lt;= k&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;如果存在则返回&lt;code&gt;true&lt;/code&gt;，不存在返回&lt;code&gt;false。&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [1,2,3,1], k &amp;#x3D; 3, t &amp;#x3D; 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [1,0,1,1], k &amp;#x3D; 1, t &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [1,5,9,1,5,9], k &amp;#x3D; 2, t &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0 &amp;lt;&amp;#x3D; nums.length &amp;lt;&amp;#x3D; 2 * 10^4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-2^31 &amp;lt;&amp;#x3D; nums[i] &amp;lt;&amp;#x3D; 2^31 - 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0 &amp;lt;&amp;#x3D; k &amp;lt;&amp;#x3D; 10^4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0 &amp;lt;&amp;#x3D; t &amp;lt;&amp;#x3D; 2^31 - 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-13-分布式事务</title>
    <link href="http://zhuuu.work/2021/04/11/RabbitMQ/RabbitMQ-13-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>http://zhuuu.work/2021/04/11/RabbitMQ/RabbitMQ-13-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</id>
    <published>2021-04-11T10:02:24.000Z</published>
    <updated>2021-04-11T08:08:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-13-分布式事务"><a href="#RabbitMQ-13-分布式事务" class="headerlink" title="RabbitMQ-13-分布式事务"></a>RabbitMQ-13-分布式事务</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><ul><li><p>分布式事务指事务的操作位于不同的节点上，需要保证事务的<code>AICD</code> 特性。</p></li><li><p>例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。</p></li><li><p>在分布式系统中，要实现分布式事务，无外乎那几种解决方案。</p></li></ul><a id="more"></a><h3 id="2-生产者确认机制"><a href="#2-生产者确认机制" class="headerlink" title="2. 生产者确认机制"></a>2. 生产者确认机制</h3><ul><li>在使用<code>RabbitMQ</code>的时候，可以通过消息持久化操作来解决因为服务器的异常奔溃导致的消息丢失，除此之外我们还会遇到一个问题，当消息的发布者在将消息发送出去之后，消息到底有没有正确到达<code>broker</code>代理服务器呢？<ul><li>如果不进行特殊配置的话，默认情况下发布操作是不会返回任何信息给生产者的，也就是默认情况下我们的生产者是不知道消息有没有正确到达<code>broker</code>的，如果在消息到达<code>broker</code>之前已经丢失的话，持久化操作也解决不了这个问题，因为消息根本就没到达代理服务器</li></ul></li></ul><p><strong>RabbitMQ为我们提供了两种方式：</strong></p><ol><li>通过AMQP<strong>事务机制</strong>实现，这也是AMQP协议层面提供的解决方案；</li><li>通过<strong>将channel设置成confirm模式来实现；</strong></li></ol><h4 id="2-1-事务机制"><a href="#2-1-事务机制" class="headerlink" title="2.1 事务机制"></a>2.1 事务机制</h4><ul><li>这里首先探讨下<code>RabbitMQ</code>事务机制。<ul><li><code>RabbitMQ</code>中与事务机制有关的方法有三个：<code>txSelect(), txCommit()以及txRollback(),</code> <code>txSelect</code>用于将当前<code>channel</code>设置成<code>transaction</code>模式，<code>txCommit</code>用于提交事务，txRollback用于回滚事务</li><li>在通过<code>txSelect</code>开启事务之后，我们便可以发布消息给<code>broker</code>代理服务器了</li><li>如果<code>txCommit</code>提交成功了，则消息一定到达了broker了，如果在<code>txCommit</code>执行之前<code>broker</code>异常崩溃或者由于其他原因抛出异常，这个时候我们便可以捕获异常通过<code>txRollback</code>回滚事务了。</li></ul></li></ul><p><strong>关键代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.txSelect();</span><br><span class="line">channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes());</span><br><span class="line">channel.txCommit();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过wirkshark抓包（ip.addr&#x3D;&#x3D;xxx.xxx.xxx.xxx &amp;&amp; amqp），可以看到：</span><br><span class="line">（注意这里的Tx.Commit与Tx.Commit-Ok之间的时间间隔294ms，由此可见事务还是很耗时的。）</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-105719190.png" alt="mark"></p><ul><li>我们先来看看没有事务的通信过程是什么样的：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-105815820.png" alt="mark"></p><p><strong>可以看到带事务的多了四个步骤：</strong></p><ul><li>client发送<code>Tx.Select</code></li><li>broker发送<code>Tx.Select-Ok(之后publish)</code></li><li>client发送<code>Tx.Commit</code></li><li>broker发送<code>Tx.Commit-Ok</code></li></ul><ul><li>下面我们来看下<strong>事务回滚</strong>是什么样子的。关键代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    channel.txSelect();</span><br><span class="line">    channel.basicPublish(exchange, routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, msg.getBytes());</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    channel.txCommit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    channel.txRollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-110143319.png" alt="mark"></p><p>代码中先是发送了消息至<code>broker</code>中但是这时候发生了异常，之后在捕获异常的过程中进行事务回滚。</p><p><strong>注意：</strong></p><ul><li><p>事务确实能够解决<code>producer</code>与<code>broker</code>之间消息确认的问题，只有消息成功被<code>broker</code>接受，事务提交才能成功，否则我们便可以在捕获异常进行事务回滚操作同时进行消息重发</p></li><li><p>但是使用事务机制的话会降低RabbitMQ的性能，<strong>那么有没有更好的方法既能保障producer知道消息已经正确送到，又能基本上不带来性能上的损失呢？</strong></p><ul><li><strong>从AMQP协议的层面看是没有更好的方法，但是RabbitMQ提供了一个更好的方案，即将channel信道设置成confirm模式。</strong></li></ul></li></ul><h4 id="2-2-Confirm-机制"><a href="#2-2-Confirm-机制" class="headerlink" title="2.2 Confirm 机制"></a>2.2 Confirm 机制</h4><ul><li>上面我们介绍了RabbitMQ可能会遇到的一个问题，即生成者不知道消息是否真正到达broker，随后通过AMQP协议层面为我们提供了事务机制解决了这个问题，但是采用事务机制实现会降低RabbitMQ的消息吞吐量，那么有没有更加高效的解决方式呢？答案是采用Confirm模式。</li><li><strong>实现原理</strong><ul><li>生产者将信道设置成<code>confirm</code>模式，一旦信道进入<code>confirm</code>模式，所有在该信道上面发布的消息都会被指派一个唯一的<code>ID</code>(从1开始)，一旦消息被投递到所有匹配的队列之后，<code>broker</code>就会发送一个确认给生产者（包含消息的唯一<code>ID</code>）,这就使得生产者知道消息已经正确到达目的队列了</li><li>如果消息和队列是可持久化的，那么确认消息会将消息写入磁盘之后发出，<strong>broker回传给生产者的确认消息中deliver-tag域包含了确认消息的序列号</strong>，此外broker也可以设置basic.ack的<code>multiple</code>域，表示到这个序列号之前的所有消息都已经得到了处理。</li><li><strong>confirm模式最大的好处在于他是异步的</strong>，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息</li><li><strong>如果RabbitMQ因为自身内部错误导致消息丢失，就会发送一条nack消息</strong>，生产者应用程序同样可以在回调方法中处理该nack消息。</li><li>在<code>channel</code>被设置成<code>confirm</code>模式之后，所有被 <code>publish</code>的后续消息都将被<code>confirm</code>（即 ack） 或者被nack一次。</li><li>但是没有对消息被 confirm 的快慢做任何保证，并且同一条消息不会既被 confirm又被nack 。</li></ul></li></ul><p><strong>开启confirm 模式的方式</strong></p><ul><li><strong>生产者通过调用channel的confirmSelect方法将channel设置为confirm模式，如果没有设置no-wait标志的话，broker会返回confirm.select-ok表示同意发送者将当前channel信道设置为confirm模式</strong></li><li>(从目前RabbitMQ最新版本3.6来看，如果调用了channel.confirmSelect方法，默认情况下是直接将no-wait设置成false的，也就是默认情况下broker是必须回传confirm.select-ok的)。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-111340430.png" alt="mark"></p><p><strong>注意：</strong></p><ul><li>已经在<code>transaction</code>事务模式的channel是不能再设置成<code>confirm</code>模式的，<strong>即这两种模式是不能共存的。</strong></li><li>事务机制和<code>publisher confirm</code> 机制作用都是确保消息能够正确的发送到<code>rabbitMQ</code></li></ul><h4 id="2-3-Confirm-编程"><a href="#2-3-Confirm-编程" class="headerlink" title="2.3 Confirm 编程"></a>2.3 Confirm 编程</h4><ul><li>对于固定消息体大小和线程数，<strong>如果消息持久化，生产者confirm(或者采用事务机制)，消费者ack那么对性能有很大的影响.</strong></li><li>消息持久化的优化没有太好方法，用更好的物理存储（SAS, SSD, RAID卡）总会带来改善。</li><li>生产者confirm这一环节的优化则主要在于客户端程序的优化之上。归纳起来，客户端实现生产者confirm有三种编程方式：<ul><li><strong>普通confirm模式：</strong>每发送一条消息后，调用waitForConfirms()方法，等待服务器端confirm。实际上是一种串行confirm了。</li><li><strong>批量confirm模式</strong>：每发送一批消息后，调用waitForConfirms()方法，等待服务器端confirm。</li><li><strong>异步confirm模式：</strong>提供一个回调方法，服务端confirm了一条或者多条消息后Client端会回调这个方法。</li></ul></li></ul><p><strong>从编程实现的复杂度上来看：</strong></p><p><strong>第一种：普通confirm 机制</strong></p><ul><li>普通confirm模式最简单，publish一条消息后，等待服务器端confirm,如果服务端返回false或者超时时间内未返回，客户端进行消息重传。</li></ul><p>关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes());</span><br><span class="line"><span class="keyword">if</span>(!channel.waitForConfirms())&#123;</span><br><span class="line">System.out.println(<span class="string">"send message failed."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wirkShark抓包可以看到如下：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-113556012.png" alt="mark"></p><p>(注意这里的Publish与Ack的时间间隔：305ms 4ms 4ms 15ms 5ms… )</p><p><strong>第二种：批量 confirm模式</strong></p><ul><li>批量<code>confirm</code>模式稍微复杂一点，<strong>客户端程序需要定期（每隔多少秒）或者定量（达到多少条）</strong>或者两则结合起来<code>publish</code>消息，然后等待服务器端<code>confirm</code>, 相比普通<code>confirm</code>模式，批量极大提升<code>confirm</code>效率</li><li>是问题在于一旦出现<code>confirm</code>返回<code>false</code>或者超时的情况时，客户端需要将这一批次的消息全部重发，这会带来明显的重复消息数量，并且，当消息经常丢失时，批量<code>confirm</code>性能应该是不升反降的。</li></ul><p>关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">channel.confirmSelect();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;batchCount;i++)&#123;</span><br><span class="line">channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!channel.waitForConfirms())&#123;</span><br><span class="line">System.out.println(<span class="string">"send message failed."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三种：异步 Confirm机制</strong></p><ul><li>异步<code>confirm</code>模式的编程实现最复杂，<strong>Channel对象提供的ConfirmListener()回调方法只包含deliveryTag</strong>（当前<code>Channel</code>发出的消息序号）<ul><li><strong>我们需要自己为每一个Channel维护一个<code>unconfirm</code>的消息序号集合，每<code>publish</code>一条数据，集合中元素加1，每回调一次<code>handleAck</code>方法，<code>unconfirm</code>集合删掉相应的一条（<code>multiple=false</code>）或多条（<code>multiple=true</code>）记录</strong></li><li>从程序运行效率上看，这个<code>unconfirm</code>集合最好采用有序集合<code>SortedSet</code>存储结构。实际上，SDK中的<code>waitForConfirms()</code>方法也是通过<code>SortedSet</code>维护消息序号的。</li></ul></li></ul><p>关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">SortedSet&lt;Long&gt; confirmSet = Collections.synchronizedSortedSet(<span class="keyword">new</span> TreeSet&lt;Long&gt;());</span><br><span class="line">channel.confirmSelect();</span><br><span class="line">       channel.addConfirmListener(<span class="keyword">new</span> ConfirmListener() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAck</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">                   confirmSet.headSet(deliveryTag + <span class="number">1</span>).clear();</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   confirmSet.remove(deliveryTag);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">           System.out.println(<span class="string">"Nack, SeqNo: "</span> + deliveryTag + <span class="string">", multiple: "</span> + multiple);</span><br><span class="line">               <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">                   confirmSet.headSet(deliveryTag + <span class="number">1</span>).clear();</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   confirmSet.remove(deliveryTag);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">           <span class="keyword">long</span> nextSeqNo = channel.getNextPublishSeqNo();</span><br><span class="line">           channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes());</span><br><span class="line">           confirmSet.add(nextSeqNo);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><code>SDK</code>中<code>waitForConfirms</code>方法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Set of currently unconfirmed messages (i.e. messages that have</span></span><br><span class="line"><span class="comment"> *  not been ack'd or nack'd by the server yet. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SortedSet&lt;Long&gt; unconfirmedSet =</span><br><span class="line">        Collections.synchronizedSortedSet(<span class="keyword">new</span> TreeSet&lt;Long&gt;());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">waitForConfirms</span><span class="params">(<span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nextPublishSeqNo == <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Confirms not selected"</span>);</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">synchronized</span> (unconfirmedSet) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getCloseReason() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> Utility.fixStackTrace(getCloseReason());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (unconfirmedSet.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> aux = onlyAcksReceived;</span><br><span class="line">                onlyAcksReceived = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> aux;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (timeout == <span class="number">0L</span>) &#123;</span><br><span class="line">                unconfirmedSet.wait();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> elapsed = System.currentTimeMillis() - startTime;</span><br><span class="line">                <span class="keyword">if</span> (timeout &gt; elapsed) &#123;</span><br><span class="line">                    unconfirmedSet.wait(timeout - elapsed);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>性能测试</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参数</span><br><span class="line">Client端机器和RabbitMQ机器配置：CPU:24核，2600MHZ, 64G内存，1TB硬盘。</span><br><span class="line">Client端发送消息体大小10B，线程数为1即单线程，消息都持久化处理（deliveryMode:2）。</span><br><span class="line">分别采用事务模式、普通confirm模式，批量confirm模式和异步confirm模式进行producer实验，比对各个模式下的发送性能。</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-150253989.png" alt="mark"></p><p>发送平均速率：</p><ul><li>事务模式（tx）：1637.484</li><li>普通confirm模式(common)：1936.032</li><li>批量confirm模式(batch)：10432.45</li><li>异步confirm模式(async)：10542.06</li></ul><p><strong>小结：</strong></p><ul><li>可以看到事务模式性能是最差的，普通<code>confirm</code>模式性能比事务模式稍微好点，但是和批量<code>confirm</code>模式还有异步<code>confirm</code>模式相比，还是小巫见大巫。</li><li>批量<code>confirm</code>模式的问题在于<code>confirm</code>之后返回<code>false</code>之后进行重发这样会使性能降低，异步<code>confirm</code>模式(async)编程模型较为复杂，至于采用哪种方式，那是仁者见仁智者见智了。</li></ul><h3 id="3-消费端的消息确认"><a href="#3-消费端的消息确认" class="headerlink" title="3. 消费端的消息确认"></a>3. 消费端的消息确认</h3><ul><li><p>为了保证消息从队列可靠地到达消费者，RabbitMQ提供消息确认机制(<code>message acknowledgment</code>)。</p></li><li><p>消费者在声明队列时，可以指定noAck参数，当<code>noAck=false</code>时，RabbitMQ会等待消费者显式发回ack信号后才从内存(和磁盘，如果是持久化消息的话)中移去消息。</p><ul><li>否则，RabbitMQ会在队列中消息被消费后立即删除它。</li></ul></li><li><p>采用消息确认机制后，只要令<code>noAck=false</code>，消费者就有足够的时间处理消息(任务)，不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为<code>RabbitMQ</code>会一直持有消息直到消费者显式调用<code>basicAck</code>为止。</p></li></ul><hr><ul><li>当<code>noAck=false</code>时，对于RabbitMQ服务器端而言，队列中的消息分成了两部分：一部分是等待投递给消费者的消息；<strong>一部分是已经投递给消费者，但是还没有收到消费者ack信号的消息。</strong><ul><li>如果<strong>服务器端一直没有收到消费者的ack信号</strong>，并且消费此消息的消费者已经断开连接，则服务器端会安排该消息重新进入队列，等待投递给下一个消费者（也可能还是原来的那个消费者）。</li><li>RabbitMQ不会为未ack的消息设置超时时间，它判断此消息是否需要<strong>重新投递给消费者的唯一依据是消费该消息的消费者连接是否已经断开。这么设计的原因是RabbitMQ允许消费者消费一条消息的时间可以很久很久。</strong></li></ul></li><li><code>RabbitMQ</code>管理平台界面上可以看到当前队列中<code>Ready状态和Unacknowledged</code>状态的消息数<ul><li>分别对应上文中的等待投递给消费者的消息数和已经投递给消费者但是未收到ack信号的消息数</li><li>也可以通过命令行来查看上述信息：</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-151011828.png" alt="mark"></p><p><strong>代码示例（关闭自动消息确认，进行手动ack）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line">   channel.basicConsume(ConfirmConfig.queueName, <span class="keyword">false</span>, consumer);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">       QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">       String msg = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line"><span class="comment">// do something with msg. </span></span><br><span class="line">       channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">broker将在下面的情况中对消息进行confirm：</span><br><span class="line"></span><br><span class="line">1. broker发现当前消息无法被路由到指定的queues中（如果设置了mandatory属性，则broker会发送basic.return）</span><br><span class="line">2. 非持久属性的消息到达了其所应该到达的所有queue中（和镜像queue中）</span><br><span class="line">3. 持久消息到达了其所应该到达的所有queue中（和镜像中），并被持久化到了磁盘（fsync）</span><br><span class="line">4. 持久消息从其所在的所有queue中被consume了（如果必要则会被ack）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">basicRecover：是路由不成功的消息可以使用recovery重新发送到队列中。</span><br><span class="line">basicReject：是接收端告诉服务器这个消息我拒绝接收,不处理,可以设置是否放回到队列中还是丢掉，而且只能一次拒绝一个消息,官网中有明确说明不能批量拒绝消息，为解决批量拒绝消息才有了basicNack。</span><br><span class="line">basicNack：可以一次拒绝N条消息，客户端可以设置basicNack方法的multiple参数为true，服务器会拒绝指定了delivery_tag的所有未确认的消息(tag是一个64位的long值，最大值是9223372036854775807)。</span><br></pre></td></tr></table></figure><h3 id="4-分布式事务解决方案"><a href="#4-分布式事务解决方案" class="headerlink" title="4. 分布式事务解决方案"></a>4. 分布式事务解决方案</h3><h4 id="4-1-2PC"><a href="#4-1-2PC" class="headerlink" title="4.1 2PC"></a>4.1 2PC</h4><ul><li><p>两段式提交(2PC) 需要数据库产商的支持，java组件有atomikos等</p></li><li><p>两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。</p></li></ul><ol><li><strong>准备阶段</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210410-215343359.png" alt="mark"></p><ol start="2"><li>提交阶段</li></ol><ul><li>如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。</li><li>需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210410-220518513.png" alt="mark"></p><p><strong>存在的问题</strong></p><ul><li><p>2.1 同步阻塞 所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。</p></li><li><p>2.2 单点问题 协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在阶段二发生故障，所有参与者会一直等待状态，无法完成其它操作。</p></li><li><p>2.3 数据不一致 在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</p></li><li><p>2.4 太过保守 任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</p></li></ul><h4 id="4-2-TCC"><a href="#4-2-TCC" class="headerlink" title="4.2 TCC"></a>4.2 TCC</h4><ul><li><code>TCC</code> 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：<ul><li><code>Try</code> 阶段主要是对业务系统做检测及资源预留</li><li><code>Confirm</code>阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行<code>Confirm</code>阶段时，默认 - - - <code>Confirm</code>阶段是不会出错的。即：只要Try成功，Confirm一定成功。</li><li>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">举个例子，假入 Bob 要向 Smith 转账，思路大概是： 我们有一个本地方法，里面依次调用</span><br><span class="line">1：首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。</span><br><span class="line">2：在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。</span><br><span class="line">3：如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。</span><br></pre></td></tr></table></figure><ul><li>优点： 跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些</li><li>缺点： 缺点还是比较明显的，在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。</li></ul><h4 id="4-3-本地消息表"><a href="#4-3-本地消息表" class="headerlink" title="4.3 本地消息表"></a>4.3 本地消息表</h4><ul><li><p>（异步确保）比如：支付宝、微信支付主动查询支付状态，对账单的形式</p></li><li><p><strong>本地消息表与业务数据表处于同一个数据库中</strong>，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，<strong>并且使用了消息队列来保证最终一致性。</strong></p><ul><li>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。</li><li>之后将本地消息表中的消息转发到 Kafka 等消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。</li><li>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210410-221109158.png" alt="mark"></p><ul><li>优点： 一种非常经典的实现，避免了分布式事务，实现了最终一致性。</li><li>缺点： 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。</li></ul><h4 id="4-4-MQ事务"><a href="#4-4-MQ事务" class="headerlink" title="4.4 MQ事务"></a>4.4 MQ事务</h4><ul><li>有一些第三方的MQ是支持事务消息的，比如<code>RocketMQ</code>，他们支持事务消息的方式也是类似于采用的二阶段提交，但是市面上一些主流的MQ都是不支持事务消息的，比如 Kafka 不支持。</li><li>以阿里的 <code>RocketMQ</code>中间件为例，其思路大致为：<ul><li>第一阶段<code>Prepared</code>消息，会拿到消息的地址。 第二阶段执行本地事务，第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。</li><li>也就是说在业务方法内要向消息队列提交两次请求，一次发送消息和一次确认消息。<ul><li>如果确认消息发送失败了.<code>RocketMQ</code>会定期扫描消息集群中的事务消息，这时候发现了Prepared消息，它会向消息发送者确认</li><li>所以生产方需要实现一个check接口，<code>RocketMQ</code>会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。</li></ul></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210410-221710984.png" alt="mark"></p><p><strong>优缺点分析</strong></p><ul><li>优点： 实现了最终一致性，不需要依赖本地数据库事务。</li><li>缺点： 实现难度大，主流MQ不支持，RocketMQ事务消息部分代码也未开源。</li></ul><h3 id="5-rabbitMQ-实现可靠生产与消费"><a href="#5-rabbitMQ-实现可靠生产与消费" class="headerlink" title="5. rabbitMQ 实现可靠生产与消费"></a>5. rabbitMQ 实现可靠生产与消费</h3><ol><li><strong>可靠生产</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210410-224418881.png" alt="mark"></p><ul><li>所谓的MQ可靠生产：就是利用<strong>消息冗余</strong>的方式（增加一个status的状态）<ul><li>如果成功：修改状态</li><li>如果失败：定时器重新执行</li><li><strong>本质利用的是消息队列的ack应答机制</strong></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210410-223012091.png" alt="mark"></p><ol start="2"><li><strong>可靠消费</strong></li></ol><ul><li>需要注意的是：消费者在消费过程中出现异常，rabbitMQ会一直进行不停的重试（即代码进入死循环）</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210410-224513979.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210410-225012520.png" alt="mark"></p><ul><li><strong>解决方案</strong><ul><li>控制重发的次数 + 死信队列</li><li>用<code>try catch</code> 和 手动<code>ack</code> <ul><li>注意这里无法再设置重发次数，如果设置了重发，那么还是会进入死循环</li><li>这里<code>try catch</code> 和 手动<code>ack</code> 会造成消息的丢失</li><li>解决方法是方案三：用<code>try catch</code>和 手动<code>ack</code> + 死信队列</li></ul></li><li>用<code>try catch</code>和 手动<code>ack</code> + 死信队列</li></ul></li></ul><ul><li>注意事项<ul><li>要考虑数据的<strong>幂等性</strong>：若死信消费者和普通消费者同时保存订单，那么就不满足幂等性了<ul><li>如下订单的方式：可以使用<strong>订单id作为一个唯一主键来保证幂等性</strong></li><li><strong>分布式锁来解决这个问题</strong></li></ul></li></ul></li></ul><h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h3><ul><li>通过本文我们总结并对比了几种分布式分解方案的优缺点，分布式事务本身是一个技术难题，是没有一种完美的方案应对所有场景的，具体还是要根据业务场景去抉择吧。</li><li>阿里<code>RocketMQ</code>去实现的分布式事务，现在也有除了很多分布式事务的协调器，比如<code>LCN</code>等，大家可以多去尝试。</li></ul><p><strong>基于MQ的优点</strong></p><p>1、通用性强<br>2、拓展方便<br>3、耦合度低，方案也比较成熟</p><p><strong>基于MQ分布式事务的缺点</strong></p><p>1、基于消息中间件，只适合异步场景<br>2、消息会延迟处理，需要业务上能够容忍</p><p><strong>建议</strong></p><p>1、尽量去避免分布式事务<br>2、尽量将非核心业务做成异步</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-13-分布式事务&quot;&gt;&lt;a href=&quot;#RabbitMQ-13-分布式事务&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-13-分布式事务&quot;&gt;&lt;/a&gt;RabbitMQ-13-分布式事务&lt;/h2&gt;&lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;分布式事务指事务的操作位于不同的节点上，需要保证事务的&lt;code&gt;AICD&lt;/code&gt; 特性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在分布式系统中，要实现分布式事务，无外乎那几种解决方案。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-12-集群搭建</title>
    <link href="http://zhuuu.work/2021/04/10/RabbitMQ/RabbitMQ-12-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>http://zhuuu.work/2021/04/10/RabbitMQ/RabbitMQ-12-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</id>
    <published>2021-04-10T08:02:24.000Z</published>
    <updated>2021-04-10T14:04:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-12-集群搭建"><a href="#RabbitMQ-12-集群搭建" class="headerlink" title="RabbitMQ-12-集群搭建"></a>RabbitMQ-12-集群搭建</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><ul><li><code>RabbitMQ</code>这款消息队列中间件产品本身是基于Erlang编写，Erlang语言天生具备分布式特性（通过同步Erlang集群各节点的magic cookie来实现）。因此，<code>RabbitMQ天然支持Clustering</code>。这使得RabbitMQ本身不需要像ActiveMQ、Kafka那样通过ZooKeeper分别来实现HA方案和保存集群的元数据。</li><li>集群是保证可靠性的一种方式，同时可以通过水平扩展以达到增加消息吞吐量能力的目的。</li><li>在<strong>实际使用过程中多采取多机多实例部署方式</strong>，为了便于同学们练习搭建，有时候你不得不在一台机器上去搭建一个rabbitmq集群，<strong>本章主要针对单机多实例这种方式来进行开展。</strong></li></ul><p><strong>注意：</strong></p><ul><li>主要参考官方文档：<a href="https://www.rabbitmq.com/clustering.html" target="_blank" rel="noopener">https://www.rabbitmq.com/clustering.html</a></li></ul><a id="more"></a><h3 id="2-单机多实例搭建演示"><a href="#2-单机多实例搭建演示" class="headerlink" title="2. 单机多实例搭建演示"></a>2. 单机多实例搭建演示</h3><h4 id="2-1-前提准备"><a href="#2-1-前提准备" class="headerlink" title="2.1 前提准备"></a>2.1 前提准备</h4><ul><li>配置的前提是你的rabbitmq可以运行起来，比如<code>”ps aux|grep rabbitmq”</code>你能看到相关进程，又比如运行<code>“rabbitmqctl status”</code>你可以看到类似如下信息，而不报错：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep rabbitmq</span><br><span class="line">systemctl status rabbitmq-server</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210410-201101022.png" alt="mark"></p><ul><li>注意：确保RabbitMQ可以运行的，确保完成之后，把单机版的RabbitMQ服务停止，后台看不到RabbitMQ的进程为止</li></ul><h4 id="2-2-单机多实例搭建"><a href="#2-2-单机多实例搭建" class="headerlink" title="2.2 单机多实例搭建"></a>2.2 单机多实例搭建</h4><ul><li><strong>场景：</strong>假设有两个rabbitmq节点，分别为rabbit-1, rabbit-2，rabbit-1作为主节点，rabbit-2作为从节点。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">启动命令：RABBITMQ_NODE_PORT=5672 RABBITMQ_NODENAME=rabbit-1 rabbitmq-server -detached</span><br><span class="line">结束命令：rabbitmqctl -n rabbit-1 stop</span><br></pre></td></tr></table></figure><ol><li><strong>启动第一个节点</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; sudo RABBITMQ_NODE_PORT=5672 RABBITMQ_NODENAME=rabbit-1 rabbitmq-server start &amp;</span><br><span class="line">...............省略...................</span><br><span class="line">  <span class="comment">##########  Logs: /var/log/rabbitmq/rabbit-1.log</span></span><br><span class="line">  <span class="comment">######  ##        /var/log/rabbitmq/rabbit-1-sasl.log</span></span><br><span class="line">  <span class="comment">##########</span></span><br><span class="line">              Starting broker...</span><br><span class="line"> completed with 7 plugins.</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>启动第二个节点</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">注意：web管理插件端口占用,所以还要指定其web插件占用的端口号</span><br><span class="line">RABBITMQ_SERVER_START_ARGS=”-rabbitmq_management listener [&#123;port,15673&#125;]”</span><br><span class="line"></span><br><span class="line">sudo RABBITMQ_NODE_PORT=5673 RABBITMQ_SERVER_START_ARGS=<span class="string">"-rabbitmq_management listener [&#123;port,15673&#125;]"</span> RABBITMQ_NODENAME=rabbit-2 rabbitmq-server start &amp;</span><br><span class="line">..............省略..................</span><br><span class="line">  <span class="comment">##########  Logs: /var/log/rabbitmq/rabbit-2.log</span></span><br><span class="line">  <span class="comment">######  ##        /var/log/rabbitmq/rabbit-2-sasl.log</span></span><br><span class="line">  <span class="comment">##########</span></span><br><span class="line">              Starting broker...</span><br><span class="line"> completed with 7 plugins.</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>检查是否启动成功</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq  2022  2.7  0.4 5349380 77020 ?       Sl   11:03   0:06 /usr/lib/erlang/erts-9.2/bin/beam.smp -W w -A 128 -P 1048576 -t 5000000 -stbt db -zdbbl 128000 -K <span class="literal">true</span> -B i -- -root /usr/lib/erlang -progname erl -- -home /var/lib/rabbitmq -- -pa /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.15/ebin -noshell -noinput -s rabbit boot -sname rabbit-1 -boot start_sasl -kernel inet_default_connect_options [&#123;nodelay,<span class="literal">true</span>&#125;] -rabbit tcp_listeners [&#123;<span class="string">"auto"</span>,5672&#125;] -sasl errlog_type error -sasl sasl_error_logger <span class="literal">false</span> -rabbit error_logger &#123;file,<span class="string">"/var/log/rabbitmq/rabbit-1.log"</span>&#125; -rabbit sasl_error_logger &#123;file,<span class="string">"/var/log/rabbitmq/rabbit-1-sasl.log"</span>&#125; -rabbit enabled_plugins_file <span class="string">"/etc/rabbitmq/enabled_plugins"</span> -rabbit plugins_dir <span class="string">"/usr/lib/rabbitmq/plugins:/usr/lib/rabbitmq/lib/rabbitmq_server-3.6.15/plugins"</span> -rabbit plugins_expand_dir <span class="string">"/var/lib/rabbitmq/mnesia/rabbit-1-plugins-expand"</span> -os_mon start_cpu_sup <span class="literal">false</span> -os_mon start_disksup <span class="literal">false</span> -os_mon start_memsup <span class="literal">false</span> -mnesia dir <span class="string">"/var/lib/rabbitmq/mnesia/rabbit-1"</span> -kernel inet_dist_listen_min 25672 -kernel inet_dist_listen_max 25672 start</span><br><span class="line">rabbitmq  2402  4.2  0.4 5352196 77196 ?       Sl   11:05   0:05 /usr/lib/erlang/erts-9.2/bin/beam.smp -W w -A 128 -P 1048576 -t 5000000 -stbt db -zdbbl 128000 -K <span class="literal">true</span> -B i -- -root /usr/lib/erlang -progname erl -- -home /var/lib/rabbitmq -- -pa /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.15/ebin -noshell -noinput -s rabbit boot -sname rabbit-2 -boot start_sasl -kernel inet_default_connect_options [&#123;nodelay,<span class="literal">true</span>&#125;] -rabbit tcp_listeners [&#123;<span class="string">"auto"</span>,5673&#125;] -sasl errlog_type error -sasl sasl_error_logger <span class="literal">false</span> -rabbit error_logger &#123;file,<span class="string">"/var/log/rabbitmq/rabbit-2.log"</span>&#125; -rabbit sasl_error_logger &#123;file,<span class="string">"/var/log/rabbitmq/rabbit-2-sasl.log"</span>&#125; -rabbit enabled_plugins_file <span class="string">"/etc/rabbitmq/enabled_plugins"</span> -rabbit plugins_dir <span class="string">"/usr/lib/rabbitmq/plugins:/usr/lib/rabbitmq/lib/rabbitmq_server-3.6.15/plugins"</span> -rabbit plugins_expand_dir <span class="string">"/var/lib/rabbitmq/mnesia/rabbit-2-plugins-expand"</span> -os_mon start_cpu_sup <span class="literal">false</span> -os_mon start_disksup <span class="literal">false</span> -os_mon start_memsup <span class="literal">false</span> -mnesia dir <span class="string">"/var/lib/rabbitmq/mnesia/rabbit-2"</span> -rabbitmq_management listener [&#123;port,15673&#125;] -kernel inet_dist_listen_min 25673 -kernel inet_dist_listen_max 25673 start</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>rabbit-1作为主节点</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#停止应用</span></span><br><span class="line">&gt; sudo rabbitmqctl -n rabbit-1 stop_app</span><br><span class="line"><span class="comment">#目的是清除节点上的历史数据（如果不清除，无法将节点加入到集群）</span></span><br><span class="line">&gt; sudo rabbitmqctl -n rabbit-1 reset</span><br><span class="line"><span class="comment">#启动应用</span></span><br><span class="line">&gt; sudo rabbitmqctl -n rabbit-1 start_app</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>rabbit-2作为从节点</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止应用</span></span><br><span class="line">&gt; sudo rabbitmqctl -n rabbit-2 stop_app</span><br><span class="line"><span class="comment"># 目的是清除节点上的历史数据（如果不清除，无法将节点加入到集群）</span></span><br><span class="line">&gt; sudo rabbitmqctl -n rabbit-2 reset</span><br><span class="line"><span class="comment"># 将rabbit2节点加入到rabbit1（主节点）集群当中【Server-node服务器的主机名】</span></span><br><span class="line">&gt; sudo rabbitmqctl -n rabbit-2 join_cluster rabbit-1@<span class="string">'Server-node'</span></span><br><span class="line"><span class="comment"># 启动应用</span></span><br><span class="line">&gt; sudo rabbitmqctl -n rabbit-2 start_app</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>查看集群的状态</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; sudo rabbitmqctl cluster_status -n rabbit-1</span><br><span class="line">//集群有两个节点：rabbit-1@Server-node、rabbit-2@Server-node</span><br><span class="line">[&#123;nodes,[&#123;disc,[<span class="string">'rabbit-1@Server-node'</span>,<span class="string">'rabbit-2@Server-node'</span>]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[<span class="string">'rabbit-2@Server-node'</span>,<span class="string">'rabbit-1@Server-node'</span>]&#125;,</span><br><span class="line"> &#123;cluster_name,&lt;&lt;<span class="string">"rabbit-1@Server-node.localdomain"</span>&gt;&gt;&#125;,</span><br><span class="line"> &#123;partitions,[]&#125;,</span><br><span class="line"> &#123;alarms,[&#123;<span class="string">'rabbit-2@Server-node'</span>,[]&#125;,&#123;<span class="string">'rabbit-1@Server-node'</span>,[]&#125;]&#125;]</span><br></pre></td></tr></table></figure><h4 id="2-3-启动Web-监控"><a href="#2-3-启动Web-监控" class="headerlink" title="2.3 启动Web 监控"></a>2.3 启动Web 监控</h4><ul><li>注意在访问的时候：web结面的管理需要给15672 node-1 和15673的node-2 设置用户名和密码。如下:</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl -n rabbit-1 add_user admin admin</span><br><span class="line">rabbitmqctl -n rabbit-1 set_user_tags admin administrator</span><br><span class="line">rabbitmqctl -n rabbit-1 set_permissions -p / admin <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span><br><span class="line">rabbitmqctl -n rabbit-2 add_user admin admin</span><br><span class="line">rabbitmqctl -n rabbit-2 set_user_tags admin administrator</span><br><span class="line">rabbitmqctl -n rabbit-2 set_permissions -p / admin <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210410-201712378.png" alt="mark"></p><h4 id="2-4-多机部署的注意事项"><a href="#2-4-多机部署的注意事项" class="headerlink" title="2.4 多机部署的注意事项"></a>2.4 多机部署的注意事项</h4><ul><li><p>如果采用多机部署方式，需读取其中一个节点的cookie, 并复制到其他节点（节点之间通过cookie确定相互是否可通信）。</p></li><li><p>cookie存放在<code>/var/lib/rabbitmq/.erlang.cookie</code></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例如：主机名分别为rabbit-1、rabbit-2</span><br><span class="line">1、逐个启动各节点</span><br><span class="line">2、配置各节点的hosts文件( vim &#x2F;etc&#x2F;hosts)</span><br><span class="line">​ ip1：rabbit-1</span><br><span class="line">​ ip2：rabbit-2</span><br><span class="line">其它步骤雷同单机部署方式</span><br></pre></td></tr></table></figure><p><strong>参考博客 ：</strong> <a href="https://honeypps.com/mq/rabbitmq-multiple-instances-in-one-machine/" target="_blank" rel="noopener">https://honeypps.com/mq/rabbitmq-multiple-instances-in-one-machine/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-12-集群搭建&quot;&gt;&lt;a href=&quot;#RabbitMQ-12-集群搭建&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-12-集群搭建&quot;&gt;&lt;/a&gt;RabbitMQ-12-集群搭建&lt;/h2&gt;&lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RabbitMQ&lt;/code&gt;这款消息队列中间件产品本身是基于Erlang编写，Erlang语言天生具备分布式特性（通过同步Erlang集群各节点的magic cookie来实现）。因此，&lt;code&gt;RabbitMQ天然支持Clustering&lt;/code&gt;。这使得RabbitMQ本身不需要像ActiveMQ、Kafka那样通过ZooKeeper分别来实现HA方案和保存集群的元数据。&lt;/li&gt;
&lt;li&gt;集群是保证可靠性的一种方式，同时可以通过水平扩展以达到增加消息吞吐量能力的目的。&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;实际使用过程中多采取多机多实例部署方式&lt;/strong&gt;，为了便于同学们练习搭建，有时候你不得不在一台机器上去搭建一个rabbitmq集群，&lt;strong&gt;本章主要针对单机多实例这种方式来进行开展。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要参考官方文档：&lt;a href=&quot;https://www.rabbitmq.com/clustering.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.rabbitmq.com/clustering.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-11-存储机制</title>
    <link href="http://zhuuu.work/2021/04/09/RabbitMQ/RabbitMQ-11-%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6/"/>
    <id>http://zhuuu.work/2021/04/09/RabbitMQ/RabbitMQ-11-%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6/</id>
    <published>2021-04-09T08:02:24.000Z</published>
    <updated>2021-04-10T09:15:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-11-存储机制"><a href="#RabbitMQ-11-存储机制" class="headerlink" title="RabbitMQ-11-存储机制"></a>RabbitMQ-11-存储机制</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210409-102548246.png" alt="mark"></p><h3 id="1-存储机制"><a href="#1-存储机制" class="headerlink" title="1. 存储机制"></a>1. 存储机制</h3><ul><li><strong>持久化消息</strong><ul><li>RabbitMQ的持久化队列分为：<br>1：队列持久化<br>2：消息持久化<br>3：交换机持久化</li></ul></li><li><strong>非持久消息：</strong>是指当内存不够用的时候，会把消息和数据转移到磁盘，但是重启以后非持久化队列消息就丢失。</li></ul><a id="more"></a><ul><li>不论是持久化的消息还是非持久化的消息都可以写入到磁盘中，只不过非持久的是等内存不足的情况下才会被写入到磁盘中。<ul><li>持久化的消息在到达队列的时候就被写入到磁盘，并且如果可以，持久化的消息会在内存中保存一份备份，这样就可以提高一定的性能，当内存吃紧的时候就会从内存中清除</li><li>非持久化的消息一般只保存在内存中，当内存吃紧的时候就会被换入到磁盘中，以节省空间</li><li>这两种类型的消息落盘处都是RabbitMQ的持久层完成的。</li></ul></li></ul><h4 id="1-1-队列的持久化"><a href="#1-1-队列的持久化" class="headerlink" title="1.1 队列的持久化"></a>1.1 队列的持久化</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210409-110401035.png" alt="mark"></p><ul><li>queue的持久化是通过<code>durable=true</code>来实现的。</li><li>一般程序中这么使用：关键的是第二个参数设置为<code>true,即durable=true.</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = connectionFactory.newConnection();</span><br><span class="line">Channel channel = connection.createChannel();</span><br><span class="line">channel.queueDeclare(<span class="string">"queue.persistent.name"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><ul><li>Channel类中<code>queueDeclare</code>的完整定义如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Declare a queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.rabbitmq.client.AMQP.Queue.Declare</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.rabbitmq.client.AMQP.Queue.DeclareOk</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queue the name of the queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> durable true if we are declaring a durable queue (the queue will survive a server restart)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exclusive true if we are declaring an exclusive queue (restricted to this connection)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> autoDelete true if we are declaring an autodelete queue (server will delete it when no longer in use)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arguments other properties (construction arguments) for the queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a declaration-confirm method to indicate the queue was successfully declared</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> java.io.IOException if an error is encountered</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Queue.<span class="function">DeclareOk <span class="title">queueDeclare</span><span class="params">(String queue, <span class="keyword">boolean</span> durable, <span class="keyword">boolean</span> exclusive, <span class="keyword">boolean</span> autoDelete,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">参数说明：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">queue：queue的名称</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">exclusive：排他队列，如果一个队列被声明为排他队列，该队列仅对首次申明它的连接可见，并在连接断开时自动删除。这里需要注意三点：1. 排他队列是基于连接可见的，同一连接的不同信道是可以同时访问同一连接创建的排他队列；2.“首次”，如果一个连接已经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同；3.即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除的，这种队列适用于一个客户端发送读取消息的应用场景。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">autoDelete：自动删除，如果该队列没有任何订阅的消费者的话，该队列会被自动删除。这种队列适用于临时队列。</span></span><br></pre></td></tr></table></figure><ul><li><code>queueDeclare</code>相关的有4种方法，分别是：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Queue.<span class="function">DeclareOk <span class="title">queueDeclare</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">Queue.<span class="function">DeclareOk <span class="title">queueDeclare</span><span class="params">(String queue, <span class="keyword">boolean</span> durable, <span class="keyword">boolean</span> exclusive, <span class="keyword">boolean</span> autoDelete,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queueDeclareNoWait</span><span class="params">(String queue, <span class="keyword">boolean</span> durable, <span class="keyword">boolean</span> exclusive, <span class="keyword">boolean</span> autoDelete,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">Queue.<span class="function">DeclareOk <span class="title">queueDeclarePassive</span><span class="params">(String queue)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">其中需要说明的是queueDeclarePassive(String queue)可以用来检测一个queue是否已经存在。如果该队列存在，则会返回true；如果不存在，就会返回异常，但是不会创建新的队列。</span></span><br></pre></td></tr></table></figure><h4 id="1-2-消息的持久化"><a href="#1-2-消息的持久化" class="headerlink" title="1.2 消息的持久化"></a>1.2 消息的持久化</h4><ul><li><p>如过将queue的持久化标识durable设置为true,则代表是一个持久的队列，那么在服务重启之后，也会存在，因为服务会把持久化的queue存放在硬盘上，当服务重启的时候，会重置被持久化的queue。</p></li><li><p><strong>队列是可以被持久化，但是里面的消息是否为持久化那还要看消息的持久化设置。</strong></p><ul><li>也就是说，重启之前那个queue里面还没有发出去的消息的话，重启之后那队列里面是不是还存在原来的消息，这个就要取决于发生着在发送消息时对消息的设置了。</li></ul></li><li><p>如果要在重启后保持消息的持久化必须设置消息是持久化的标识。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">"exchange.persistent"</span>, <span class="string">"persistent"</span>, MessageProperties.PERSISTENT_TEXT_PLAIN, <span class="string">"persistent_test_message"</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的关键是：MessageProperties.PERSISTENT_TEXT_PLAIN</span></span><br></pre></td></tr></table></figure><ul><li>首先看一下<code>basicPublish</code>的方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicPublish</span><span class="params">(String exchange, String routingKey, BasicProperties props, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicPublish</span><span class="params">(String exchange, String routingKey, <span class="keyword">boolean</span> mandatory, BasicProperties props, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicPublish</span><span class="params">(String exchange, String routingKey, <span class="keyword">boolean</span> mandatory, <span class="keyword">boolean</span> immediate, BasicProperties props, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">exchange表示exchange的名称</span></span><br><span class="line"><span class="comment">routingKey表示routingKey的名称</span></span><br><span class="line"><span class="comment">body代表发送的消息体</span></span><br></pre></td></tr></table></figure><ul><li>这里关键的是<code>BasicProperties props</code>这个参数了，这里看下<code>BasicProperties</code>的定义：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BasicProperties</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            String contentType,//消息类型如：text/plain</span></span></span><br><span class="line"><span class="function"><span class="params">            String contentEncoding,//编码</span></span></span><br><span class="line"><span class="function"><span class="params">            Map&lt;String,Object&gt; headers,</span></span></span><br><span class="line"><span class="function"><span class="params">            Integer deliveryMode,//<span class="number">1</span>:nonpersistent <span class="number">2</span>:persistent</span></span></span><br><span class="line"><span class="function"><span class="params">            Integer priority,//优先级</span></span></span><br><span class="line"><span class="function"><span class="params">            String correlationId,</span></span></span><br><span class="line"><span class="function"><span class="params">            String replyTo,//反馈队列</span></span></span><br><span class="line"><span class="function"><span class="params">            String expiration,//expiration到期时间</span></span></span><br><span class="line"><span class="function"><span class="params">            String messageId,</span></span></span><br><span class="line"><span class="function"><span class="params">            Date timestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">            String type,</span></span></span><br><span class="line"><span class="function"><span class="params">            String userId,</span></span></span><br><span class="line"><span class="function"><span class="params">            String appId,</span></span></span><br><span class="line"><span class="function"><span class="params">            String clusterId)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">//这里的deliveryMode=1代表不持久化，deliveryMode=2代表持久化。</span></span></span><br></pre></td></tr></table></figure><ul><li>上面的实现代码使用的是<code>MessageProperties.PERSISTENT_TEXT_PLAIN</code>，那么这个又是什么呢？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BasicProperties PERSISTENT_TEXT_PLAIN =</span><br><span class="line">    <span class="keyword">new</span> BasicProperties(<span class="string">"text/plain"</span>,</span><br><span class="line">                        <span class="keyword">null</span>,</span><br><span class="line">                        <span class="keyword">null</span>,</span><br><span class="line">                        <span class="number">2</span>,</span><br><span class="line">                        <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">                        <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">                        <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//可以看到这其实就是讲deliveryMode设置为2的BasicProperties的对象，为了方便编程而出现的一个东东。</span></span><br></pre></td></tr></table></figure><ul><li>换一种实现方式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties.Builder builder = <span class="keyword">new</span> AMQP.BasicProperties.Builder();</span><br><span class="line">builder.deliveryMode(<span class="number">2</span>);</span><br><span class="line">AMQP.BasicProperties properties = builder.build();</span><br><span class="line">channel.basicPublish(<span class="string">"exchange.persistent"</span>, <span class="string">"persistent"</span>,properties, <span class="string">"persistent_test_message"</span>.getBytes());</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><strong>设置了队列和消息的持久化之后，当broker服务重启的之后，消息依旧存在。</strong></li><li>单只设置队列持久化，重启之后消息会丢失；单只设置消息的持久化，重启之后队列消失，既而消息也丢失。单单设置消息持久化而不设置队列的持久化显得毫无意义。</li></ul><h4 id="1-3-交换机的持久化"><a href="#1-3-交换机的持久化" class="headerlink" title="1.3 交换机的持久化"></a>1.3 交换机的持久化</h4><ul><li><p>上面阐述了队列的持久化和消息的持久化，如果不设置exchange的持久化对消息的可靠性来说没有什么影响，<strong>但是同样如果exchange不设置持久化，那么当broker服务重启之后，exchange将不复存在</strong>，那么既而发送方rabbitmq producer就无法正常发送消息。</p></li><li><p>这里博主建议，同样设置exchange的持久化。exchange的持久化设置也特别简单，方法如下：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Exchange.<span class="function">DeclareOk <span class="title">exchangeDeclare</span><span class="params">(String exchange, String type, <span class="keyword">boolean</span> durable)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">Exchange.<span class="function">DeclareOk <span class="title">exchangeDeclare</span><span class="params">(String exchange, String type, <span class="keyword">boolean</span> durable, <span class="keyword">boolean</span> autoDelete,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">Exchange.<span class="function">DeclareOk <span class="title">exchangeDeclare</span><span class="params">(String exchange, String type)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">Exchange.<span class="function">DeclareOk <span class="title">exchangeDeclare</span><span class="params">(String exchange,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          String type,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">boolean</span> durable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">boolean</span> autoDelete,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">boolean</span> internal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchangeDeclareNoWait</span><span class="params">(String exchange,</span></span></span><br><span class="line"><span class="function"><span class="params">                           String type,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> durable,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> autoDelete,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> internal,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">Exchange.<span class="function">DeclareOk <span class="title">exchangeDeclarePassive</span><span class="params">(String name)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般只需要：channel.exchangeDeclare(exchangeName, “direct/topic/header/fanout”, true);即在声明的时候讲durable字段设置为true即可。</span></span><br></pre></td></tr></table></figure><h4 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h4><ul><li><strong>将queue，exchange, message等都设置了持久化之后就能保证100%保证数据不丢失了嚒？</strong><br><strong>答案是否定的。</strong></li></ul><ol><li><p>首先，从consumer端来说，如果这时<code>autoAck=true</code>，那么当consumer接收到相关消息之后，还没来得及处理就crash掉了，那么这样也算数据丢失，这种情况也好处理，只需将autoAck设置为false(方法定义如下)，然后在正确处理完消息之后进行手动ack（<code>channel.basicAck</code>）.</p></li><li><p>其次，关键的问题是消息在正确存入RabbitMQ之后，还需要有一段时间（这个时间很短，但不可忽视）才能存入磁盘之中，RabbitMQ并不是为每条消息都做fsync的处理，可能仅仅保存到cache中而不是物理磁盘上，在这段时间内<code>RabbitMQ broker</code>发生<code>crash</code>, 消息保存到cache但是还没来得及落盘，那么这些消息将会丢失。</p></li></ol><ul><li>那么这个怎么解决呢？<ul><li>首先可以引入RabbitMQ的mirrored-queue即镜像队列，这个相当于配置了副本，当master在此特殊时间内crash掉，可以自动切换到slave，这样有效的保障了HA, 除非整个集群都挂掉，这样也不能完全的100%保障RabbitMQ不丢消息，但比没有mirrored-queue的要好很多，很多现实生产环境下都是配置了mirrored-queue的。</li><li>还有要在<code>producer</code>引入事务机制或者<code>Confirm</code>机制来确保消息已经正确的发送至broker端，有关RabbitMQ的事务机制或者<code>Confirm</code>机制.<code>RabbitMQ</code>的可靠性涉及producer端的确认机制、broker端的镜像队列的配置以及consumer端的确认机制，要想确保消息的可靠性越高，那么性能也会随之而降，鱼和熊掌不可兼得，关键在于选择和取舍。</li></ul></li></ul><ul><li><strong>消息什么时候刷到磁盘？</strong></li></ul><ol><li><p>写入文件前会有一个Buffer,大小为1M,数据在写入文件时，首先会写入到这个Buffer，如果Buffer已满，则会将Buffer写入到文件（未必刷到磁盘）。</p></li><li><p>有个固定的刷盘时间：25ms,也就是不管Buffer满不满，每个25ms，Buffer里的数据及未刷新到磁盘的文件内容必定会刷到磁盘。</p></li><li><p>每次消息写入后，如果没有后续写入请求，则会直接将已写入的消息刷到磁盘：使用Erlang的<code>receive x after 0</code>实现，只要进程的信箱里没有消息，则产生一个timeout消息，而timeout会触发刷盘操作。</p></li></ol><h3 id="2-内存磁盘告警"><a href="#2-内存磁盘告警" class="headerlink" title="2. 内存磁盘告警"></a>2. 内存磁盘告警</h3><ul><li>当内存使用超过配置的阈值或者磁盘空间剩余空间对于配置的阈值时，RabbitMQ会暂时阻塞客户端的连接，并且停止接收从客户端发来的消息，以此避免服务器的崩溃，客户端与服务端的心态检测机制也会失效。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210409-111715431.png" alt="mark"></p><ul><li>当出现<code>blocking</code>或<code>blocked</code>话说明到达了阈值和以及高负荷运行了。<ul><li><code>blocking :</code>并不试图关闭发送消息的Connection,比如消费者的Connection。这种情况下Connection可以继续运行</li><li><code>blocked :</code>对应于一直有消息发送的Connection。这种情况下Connection会停止发送消息</li><li>如果一个Broker的内存或者磁盘受限，都会引起所有的Connection被阻塞。</li></ul></li><li>理想的情况是当发生阻塞的时候可以阻止生产者的同时而又不影响消费者，但是在AMQP协议中，一个channel 上可以同时承载生产者和消费者，同一个Connection 中也可以同时承载若干个生产者和消费者的信道和消费者信道，这样就会使得逻辑错乱。<ul><li>这里建议生产和消费的逻辑可以分摊到独立的Connection 中而不发生任何的交集。</li></ul></li></ul><p><strong>注意：</strong></p><ul><li><p><strong>当出现警告的时候，可以通过配置去修改和调整</strong></p></li><li><p>参考帮助文档：<a href="https://www.rabbitmq.com/configure.html" target="_blank" rel="noopener">https://www.rabbitmq.com/configure.html</a></p></li></ul><h4 id="2-1-内存告警"><a href="#2-1-内存告警" class="headerlink" title="2.1 内存告警"></a>2.1 内存告警</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210410-165736223.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210410-165751461.png" alt="mark"></p><ul><li><p><code>rabbitMQ</code>执行<code>rabbitmqctl set_vm_memory_high_watermarkfraction</code> 可以设置<strong>内存的阈值，默认是0.4</strong></p><ul><li>表示当内存使用超过40%的时候，就会产生内存告警并且阻塞当前所有生产者的连接。</li><li>在最坏的情况下，Erlang 的垃圾回收机制会导致两倍的内存消耗，也就是80%的占用比</li></ul></li><li><p>内存的阈值可以通过以下两种方式来设置（百分比，绝对内存大小）</p><ul><li><p><strong>百分比方式</strong></p><ul><li>配置文件：重启才会生效 。当前配置文件：<code>/etc/rabbitmq/rabbitmq.conf</code></li><li>命令行： 重启会失效  <code>rabbitmqctl set_vm_memory_high_watermark &lt;fraction&gt;</code></li><li>大小设置在0.4到0.66之间，不建议超过0.7</li></ul></li><li><p><strong>绝对内存大小</strong></p><ul><li>配置文件：重启才会生效。当前配置文件：<code>/etc/rabbitmq/rabbitmq.conf</code></li><li>命令行：重启会失效 <code>rabbitmqctl set_vm_memory_high_watermark absolute 50MB</code></li></ul></li><li><p>fraction/value 为内存阈值。默认情况是：0.4/2GB。代表的含义是：当RabbitMQ的内存超过40%时，就会产生警告并且阻塞所有生产者的连接。通过此命令修改阈值在Broker重启以后将会失效，通过修改配置文件方式设置的阈值则不会随着重启而消失，但修改了配置文件一样要重启broker才会生效。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#默认</span><br><span class="line">#vm_memory_high_watermark.relative = 0.4</span><br><span class="line"># 使用relative相对值进行设置fraction,建议取值在04~0.7之间，不建议超过0.7.</span><br><span class="line">vm_memory_high_watermark.relative = 0.6</span><br><span class="line"># 使用absolute的绝对值的方式，但是是KB,MB,GB对应的命令如下</span><br><span class="line">vm_memory_high_watermark.absolute = 2GB</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-2-换页"><a href="#2-2-换页" class="headerlink" title="2.2 换页"></a>2.2 换页</h4><ul><li><p><strong>默认情况下，在内存达到阈值的50%的时候会进行换页的操作</strong></p><ul><li>在某个Broker节点及内存阻塞生产者之前，它会尝试将队列中的消息换页到磁盘以释放内存空间，持久化和非持久化的消息都会写入磁盘中，其中持久化的消息本身就在磁盘中有一个副本，所以在转移的过程中持久化的消息会先从内存中清除掉。</li><li>也就是说，在默认情况下该内存的阈值是0.4的情况下，当内存超过<code>0.4*0.5=0.2</code>时，会进行换页动作。</li><li>比如有<code>1000MB</code>内存，当内存的使用率达到了<code>400MB</code>,已经达到了极限，但是因为配置的换页内存0.5，这个时候会在达到极限<code>400mb</code>之前，会把内存中的<code>200MB</code>进行转移到磁盘中。从而达到稳健的运行。</li></ul></li><li><p>可以通过设置 <code>vm_memory_high_watermark_paging_ratio</code> 来进行调整</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vm_memory_high_watermark.relative = 0.4</span><br><span class="line">vm_memory_high_watermark_paging_ratio = 0.7（设置小于1的值）</span><br></pre></td></tr></table></figure><ul><li>此时，如果将<code>vm_memory_high_watermark_paging_ratio</code> 设置为大于1的浮点数的话，这种配置相当于仅用了换页的功能</li></ul><h4 id="2-3-磁盘预警"><a href="#2-3-磁盘预警" class="headerlink" title="2.3 磁盘预警"></a>2.3 磁盘预警</h4><ul><li><p>当剩余磁盘空间低于确定阈值的时候，RabbitMQ同样会阻塞生产者，这样可以避免因非持久化消息持续换页而耗尽磁盘空间导致服务崩溃</p><ul><li><strong>默认情况下，磁盘阈值为50MB</strong></li><li>这个阈值可以减小，但是不能完全的消除因磁盘耗尽而导致崩溃的可能性。比如在两次磁盘空间的检查空隙内，第一次检查是：60MB ，第二检查可能就是1MB,就会出现警告。</li></ul></li><li><p><strong>通过命令方式</strong>修改如下：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_disk_free_limit  &lt;disk_limit&gt;</span><br><span class="line">rabbitmqctl set_disk_free_limit memory_limit  &lt;fraction&gt;</span><br><span class="line">disk_limit：固定单位 KB MB GB</span><br><span class="line">fraction ：是相对阈值，建议范围在:1.0~2.0之间。（相对于内存）</span><br></pre></td></tr></table></figure><ul><li><strong>通过配置文件</strong>配置如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">disk_free_limit.relative = 3.0</span><br><span class="line">disk_free_limit.absolute = 50mb</span><br></pre></td></tr></table></figure><h3 id="3-惰性队列"><a href="#3-惰性队列" class="headerlink" title="3. 惰性队列"></a>3. 惰性队列</h3><ul><li><p><code>RabbitMQ从3.6.0</code>版本开始引入了惰性队列（<code>Lazy Queue</code>）的概念。<strong>惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。</strong>当消费者由于各种各样的原因（比如消费者下线、宕机亦或者是由于维护而关闭等）而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。</p></li><li><p>默认情况下，当生产者将消息发送到RabbitMQ的时候，队列中的消息会尽可能的存储在内存之中，这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份</p><ul><li>当RabbitMQ需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。</li><li>虽然RabbitMQ的开发者们一直在升级相关的算法，但是效果始终不太理想，尤其是在消息量特别大的时候。</li></ul></li><li><p>惰性队列会将接收到的消息直接存入文件系统中，而不管是持久化的或者是非持久化的，这样可以减少了内存的消耗，但是会增加I/O的使用，</p><ul><li>如果消息是持久化的，那么这样的I/O操作不可避免，惰性队列和持久化消息可谓是“最佳拍档”。</li><li>注意如果惰性队列中存储的是非持久化的消息，内存的使用率会一直很稳定，但是重启之后消息一样会丢失。</li></ul></li><li><p>队列具备两种模式：default和lazy。默认的为default模式，在3.6.0之前的版本无需做任何变更。lazy模式即为惰性队列的模式，可以通过调用<code>channel.queueDeclare</code>方法的时候在参数中设置，也可以通过Policy的方式设置</p><ul><li>如果一个队列同时使用这两种方式设置的话，那么Policy的方式具备更高的优先级。如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。</li><li>在队列声明的时候可以通过<strong>“x-queue-mode”</strong>参数来设置队列的模式，取值为“default”和“lazy”。下面示例中演示了一个惰性队列的声明细节：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">"x-queue-mode"</span>, <span class="string">"lazy"</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">"myqueue"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对应的Policy设置方式为：</span><br><span class="line">    rabbitmqctl set_policy Lazy <span class="string">"^myqueue$"</span> <span class="string">'&#123;"queue-mode":"lazy"&#125;'</span> --apply-to queues</span><br></pre></td></tr></table></figure><ul><li>惰性队列和普通队列相比，只有很小的内存开销。这里很难对每种情况给出一个具体的数值，但是我们可以类比一下：当发送1千万条消息，每条消息的大小为1KB，并且此时没有任何的消费者，那么普通队列会消耗1.2GB的内存，而惰性队列只消耗1.5MB的内存。<ul><li>据官网测试数据显示，<ul><li><strong>对于普通队列</strong>，如果要发送1千万条消息，需要耗费801秒，平均发送速度约为13000条/秒。</li><li><strong>如果使用惰性队列</strong>，那么发送同样多的消息时，耗时是421秒，平均发送速度约为24000条/秒。出现性能偏差的原因是普通队列会由于内存不足而不得不将消息换页至磁盘。如果有消费者消费时，惰性队列会耗费将近40MB的空间来发送消息，对于一个消费者的情况，平均的消费速度约为14000条/秒。</li></ul></li><li><strong>如果要将普通队列转变为惰性队列，那么我们需要忍受同样的性能损耗。</strong><ul><li>当转变为惰性队列的时候，首先需要将缓存中的消息换页至磁盘中，然后才能接收新的消息。</li><li>反之，当将一个惰性队列转变为普通队列的时候，和恢复一个队列执行同样的操作，会将磁盘中的消息批量的导入到内存中。</li></ul></li></ul></li></ul><p><strong>参考博客系列</strong> ： <a href="https://blog.csdn.net/u013256816/article/details/54743481" target="_blank" rel="noopener">https://blog.csdn.net/u013256816/article/details/54743481</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-11-存储机制&quot;&gt;&lt;a href=&quot;#RabbitMQ-11-存储机制&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-11-存储机制&quot;&gt;&lt;/a&gt;RabbitMQ-11-存储机制&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210409-102548246.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-存储机制&quot;&gt;&lt;a href=&quot;#1-存储机制&quot; class=&quot;headerlink&quot; title=&quot;1. 存储机制&quot;&gt;&lt;/a&gt;1. 存储机制&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;持久化消息&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;RabbitMQ的持久化队列分为：&lt;br&gt;1：队列持久化&lt;br&gt;2：消息持久化&lt;br&gt;3：交换机持久化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非持久消息：&lt;/strong&gt;是指当内存不够用的时候，会把消息和数据转移到磁盘，但是重启以后非持久化队列消息就丢失。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-LCP002-分式化简</title>
    <link href="http://zhuuu.work/2021/04/09/Leetcode/Leetcode-LCP002-%E5%88%86%E5%BC%8F%E5%8C%96%E7%AE%80/"/>
    <id>http://zhuuu.work/2021/04/09/Leetcode/Leetcode-LCP002-%E5%88%86%E5%BC%8F%E5%8C%96%E7%AE%80/</id>
    <published>2021-04-09T03:02:24.000Z</published>
    <updated>2021-04-09T01:53:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-LCP002-分式化简"><a href="#Leetcode-LCP002-分式化简" class="headerlink" title="Leetcode-LCP002-分式化简"></a>Leetcode-LCP002-<a href="https://leetcode-cn.com/problems/deep-dark-fraction/" target="_blank" rel="noopener">分式化简</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>有一个同学在学习分式。他需要将一个连分数化成最简分数，你能帮助他吗？</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210409-093002540.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">连分数是形如上图的分式。在本题中，所有系数都是大于等于0的整数。</span><br><span class="line"></span><br><span class="line">输入的cont代表连分数的系数（cont[0]代表上图的a0，以此类推）。返回一个长度为2的数组[n, m]，使得连分数的值等于n &#x2F; m，且n, m最大公约数为1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：cont &#x3D; [3, 2, 0, 2]</span><br><span class="line">输出：[13, 4]</span><br><span class="line">解释：原连分数等价于3 + (1 &#x2F; (2 + (1 &#x2F; (0 + 1 &#x2F; 2))))。注意[26, 8], [-13, -4]都不是正确答案。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：cont &#x3D; [0, 0, 3]</span><br><span class="line">输出：[3, 1]</span><br><span class="line">解释：如果答案是整数，令分母为1即可。</span><br></pre></td></tr></table></figure><ul><li><p><strong>提示：</strong></p><ul><li><p><code>cont[i] &gt;=</code>0<br><code>1 &lt;= cont的长度 &lt;= 10</code><br><code>cont最后一个元素不等于0</code></p></li><li><p>答案的n, m的取值都能被32位int整型存下（即不超过2 ^ 31 - 1）。</p></li></ul></li></ul><a id="more"></a><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p><strong>思路</strong></p><ul><li><strong>找规律</strong><ul><li>从后往前，分子分母交替计算。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] fraction(<span class="keyword">int</span>[] cont) &#123;</span><br><span class="line">        <span class="comment">// 1. 初始化条件</span></span><br><span class="line">        <span class="keyword">int</span> n = cont[cont.length - <span class="number">1</span>],</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. for循环处理逻辑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = cont.length - <span class="number">1</span>;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">// 2.1 上下交换</span></span><br><span class="line">            <span class="keyword">int</span> temp = m;</span><br><span class="line">            m = n;</span><br><span class="line">            n = temp;</span><br><span class="line">            <span class="comment">// 2.2 乘法操作</span></span><br><span class="line">            n += cont[i - <span class="number">1</span>]*m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;n,m&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-LCP002-分式化简&quot;&gt;&lt;a href=&quot;#Leetcode-LCP002-分式化简&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-LCP002-分式化简&quot;&gt;&lt;/a&gt;Leetcode-LCP002-&lt;a href=&quot;https://leetcode-cn.com/problems/deep-dark-fraction/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;分式化简&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;有一个同学在学习分式。他需要将一个连分数化成最简分数，你能帮助他吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210409-093002540.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;连分数是形如上图的分式。在本题中，所有系数都是大于等于0的整数。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入的cont代表连分数的系数（cont[0]代表上图的a0，以此类推）。返回一个长度为2的数组[n, m]，使得连分数的值等于n &amp;#x2F; m，且n, m最大公约数为1。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：cont &amp;#x3D; [3, 2, 0, 2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[13, 4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：原连分数等价于3 + (1 &amp;#x2F; (2 + (1 &amp;#x2F; (0 + 1 &amp;#x2F; 2))))。注意[26, 8], [-13, -4]都不是正确答案。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：cont &amp;#x3D; [0, 0, 3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[3, 1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：如果答案是整数，令分母为1即可。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;cont[i] &amp;gt;=&lt;/code&gt;0&lt;br&gt;&lt;code&gt;1 &amp;lt;= cont的长度 &amp;lt;= 10&lt;/code&gt;&lt;br&gt;&lt;code&gt;cont最后一个元素不等于0&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;答案的n, m的取值都能被32位int整型存下（即不超过2 ^ 31 - 1）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://zhuuu.work/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-10-死信队列</title>
    <link href="http://zhuuu.work/2021/04/07/RabbitMQ/RabbitMQ-10-%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/"/>
    <id>http://zhuuu.work/2021/04/07/RabbitMQ/RabbitMQ-10-%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/</id>
    <published>2021-04-07T08:02:24.000Z</published>
    <updated>2021-04-09T00:56:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-10-死信队列"><a href="#RabbitMQ-10-死信队列" class="headerlink" title="RabbitMQ-10-死信队列"></a>RabbitMQ-10-死信队列</h2><h3 id="1-死信产生的原因"><a href="#1-死信产生的原因" class="headerlink" title="1. 死信产生的原因"></a>1. 死信产生的原因</h3><ul><li><p><code>DLX</code>，全称为<code>Dead-Letter-Exchange</code> , 可以称之为死信交换机，也有人称之为死信邮箱。</p></li><li><p>当消息在一个队列中变成死信(<code>dead message</code>)之后，<strong>它能被重新发送到另一个交换机中，这个交换机就是DLX ，绑定DLX的队列就称之为死信队列。</strong></p></li><li><p><strong>消息变成死信，可能是由于以下的原因：</strong></p><ul><li><strong>消息被拒绝</strong></li><li><strong>消息过期</strong></li><li><strong>队列达到最大长度</strong></li></ul></li><li><p><strong>DLX也是一个正常的交换机，和一般的交换机没有区别</strong>，它能在任何的队列上被指定，实际上就是设置某一个队列的属性。</p><ul><li><strong>当这个队列中存在死信时，Rabbitmq就会自动地将这个消息重新发布到设置的DLX上去，进而被路由到另一个队列，即死信队列。</strong></li><li>要想使用死信队列，只需要在定义队列的时候设置队列参数 <code>x-dead-letter-exchange</code> 指定交换机即可。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210407-160554479.png" alt="mark"></p><a id="more"></a><h3 id="2-代码演示"><a href="#2-代码演示" class="headerlink" title="2. 代码演示"></a>2. 代码演示</h3><ol><li>首先需要设置死信队列的<code>exchange和queue</code>，然后进行绑定：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exchange: dlx.exchange</span><br><span class="line">Queue: dlx.queue</span><br><span class="line">RoutingKey: <span class="comment">#</span></span><br><span class="line"><span class="comment">#表示只要有消息到达了Exchange，那么都会路由到这个queue上</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>然后需要有一个监听，去监听这个队列进行处理</p></li><li><p>然后我们进行正常声明交换机、队列、绑定，只不过我们需要在队列加上一个参数即可：<code>arguments.put(&quot; x-dead-letter-exchange&quot;，&quot;dlx.exchange&quot;);</code>，这样消息在过期、<code>requeue</code>、 队列在达到最大长度时，消息就可以直接路由到死信队列！</p></li></ol><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1 创建ConnectionFactory</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"ip"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line">        <span class="comment">//2 获取Connection</span></span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">//3 通过Connection创建一个新的Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        </span><br><span class="line">        String exchange = <span class="string">"test_dlx_exchange"</span>;</span><br><span class="line">        String routingKey = <span class="string">"dlx.save"</span>;</span><br><span class="line">        </span><br><span class="line">        String msg = <span class="string">"Hello RabbitMQ DLX Message"</span>;</span><br><span class="line">        </span><br><span class="line">        AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">                .deliveryMode(<span class="number">2</span>)</span><br><span class="line">                .contentEncoding(<span class="string">"UTF-8"</span>)</span><br><span class="line">                .expiration(<span class="string">"10000"</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        channel.basicPublish(exchange, routingKey, <span class="keyword">true</span>, properties, msg.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者</strong></p><ul><li>声明正常处理消息的交换机、队列及绑定规则</li><li><strong>在正常交换机上指定死信发送的Exchange</strong></li><li><strong>声明死信交换机、队列及绑定规则</strong></li><li><strong>监听死信队列，进行后续处理，这里省略</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"192.168.43.157"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line">        </span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 声明一个普通的交换机 和 队列 以及路由</span></span><br><span class="line">        String exchangeName = <span class="string">"test_dlx_exchange"</span>;</span><br><span class="line">        String routingKey = <span class="string">"dlx.#"</span>;</span><br><span class="line">        String queueName = <span class="string">"test_dlx_queue"</span>;</span><br><span class="line">        </span><br><span class="line">        channel.exchangeDeclare(exchangeName, <span class="string">"topic"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//指定死信发送的Exchange</span></span><br><span class="line">        Map&lt;String, Object&gt; agruments = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        agruments.put(<span class="string">"x-dead-letter-exchange"</span>, <span class="string">"dlx.exchange"</span>);</span><br><span class="line">        <span class="comment">//这个agruments属性，要设置到声明队列上</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, agruments);</span><br><span class="line">        channel.queueBind(queueName, exchangeName, routingKey);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//要进行死信队列的声明</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">"dlx.exchange"</span>, <span class="string">"topic"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueDeclare(<span class="string">"dlx.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(<span class="string">"dlx.queue"</span>, <span class="string">"dlx.exchange"</span>, <span class="string">"#"</span>);</span><br><span class="line">        </span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, <span class="keyword">new</span> MyConsumer(channel));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果演示</strong></p><ul><li>启动消费端，此时查看管控台，新增了两个Exchange，两个Queue。在<code>test_dlx_queue</code>上我们设置了DLX，也就代表死信消息会发送到指定的Exchange上，最终其实会路由到<code>dlx.queue</code>上。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210407-161354031.png" alt="mark"></p><ul><li>此时关闭消费端，然后启动生产端，查看管控台队列的消息情况，<code>test_dlx_queue</code>的值为1，而<code>dlx_queue</code>的值为0。<br> 10s后的队列结果如图，由于生产端发送消息时指定了消息的过期时间为10s，而此时没有消费端进行消费，消息便被路由到死信队列中。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210407-161417816.png" alt="mark"></p><ul><li>实际环境我们还需要对死信队列进行一个监听和处理，当然具体的处理逻辑和业务相关，这里只是简单演示死信队列是否生效。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-10-死信队列&quot;&gt;&lt;a href=&quot;#RabbitMQ-10-死信队列&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-10-死信队列&quot;&gt;&lt;/a&gt;RabbitMQ-10-死信队列&lt;/h2&gt;&lt;h3 id=&quot;1-死信产生的原因&quot;&gt;&lt;a href=&quot;#1-死信产生的原因&quot; class=&quot;headerlink&quot; title=&quot;1. 死信产生的原因&quot;&gt;&lt;/a&gt;1. 死信产生的原因&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;DLX&lt;/code&gt;，全称为&lt;code&gt;Dead-Letter-Exchange&lt;/code&gt; , 可以称之为死信交换机，也有人称之为死信邮箱。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当消息在一个队列中变成死信(&lt;code&gt;dead message&lt;/code&gt;)之后，&lt;strong&gt;它能被重新发送到另一个交换机中，这个交换机就是DLX ，绑定DLX的队列就称之为死信队列。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;消息变成死信，可能是由于以下的原因：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;消息被拒绝&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消息过期&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;队列达到最大长度&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;DLX也是一个正常的交换机，和一般的交换机没有区别&lt;/strong&gt;，它能在任何的队列上被指定，实际上就是设置某一个队列的属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;当这个队列中存在死信时，Rabbitmq就会自动地将这个消息重新发布到设置的DLX上去，进而被路由到另一个队列，即死信队列。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;要想使用死信队列，只需要在定义队列的时候设置队列参数 &lt;code&gt;x-dead-letter-exchange&lt;/code&gt; 指定交换机即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210407-160554479.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-09-过期时间TTL</title>
    <link href="http://zhuuu.work/2021/04/07/RabbitMQ/RabbitMQ-09-%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4TTL/"/>
    <id>http://zhuuu.work/2021/04/07/RabbitMQ/RabbitMQ-09-%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4TTL/</id>
    <published>2021-04-07T06:02:24.000Z</published>
    <updated>2021-04-07T08:02:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-09-过期时间TTL"><a href="#RabbitMQ-09-过期时间TTL" class="headerlink" title="RabbitMQ-09-过期时间TTL"></a>RabbitMQ-09-过期时间TTL</h2><h3 id="1-TTL的概念"><a href="#1-TTL的概念" class="headerlink" title="1. TTL的概念"></a>1. TTL的概念</h3><ul><li><p>过期时间<code>TTL</code>表示可以对消息设置预期的时间，在这个时间内都可以被消费者接收获取；过了之后消息将自动被删除。</p></li><li><p>RabbitMQ可以对<strong>消息和队列</strong>设置TTL。目前有两种方法可以设置。</p><ul><li><strong>第一种方法是通过队列属性设置</strong>，队列中所有消息都有相同的过期时间。</li><li><strong>第二种方法是对消息进行单独设置</strong>，每条消息TTL可以不同。</li></ul></li><li><p>如果上述两种方法同时使用，则消息的过期时间以两者之间TTL较小的那个数值为准。</p></li><li><p>消息在队列的生存时间一旦超过设置的TTL值，就称为dead message被投递到死信队列， 消费者将无法再收到该消息。</p></li></ul><p><strong>TTL的标识</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210407-154021368.png" alt="mark"></p><a id="more"></a><h4 id="1-1-方式一：通过队列设置TTL"><a href="#1-1-方式一：通过队列设置TTL" class="headerlink" title="1.1 方式一：通过队列设置TTL"></a>1.1 方式一：通过队列设置TTL</h4><ul><li><p><strong>参数</strong>：<code>x-message-ttl</code></p></li><li><p>通过在<code>channel.queueDeclare</code>设置参数</p></li><li><p><strong>核心代码</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Object&gt; args2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args2.put(<span class="string">"x-message-ttl"</span>,<span class="number">5000</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">"ttl.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args2);</span><br></pre></td></tr></table></figure><h4 id="1-2-方式二：通过设置单条消息的TTL"><a href="#1-2-方式二：通过设置单条消息的TTL" class="headerlink" title="1.2 方式二：通过设置单条消息的TTL"></a>1.2 方式二：通过设置单条消息的TTL</h4><ul><li><p>通过设置每条消息的TTL 是在 <code>channel.basicPublish</code> 方法中加入<code>expiration</code>的属性参数</p></li><li><p><strong>核心代码</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6： 准备发送消息的内容</span></span><br><span class="line">String message = <span class="string">"你好，学相伴！！！"</span>;</span><br><span class="line">Map&lt;String, Object&gt; headers = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">headers.put(<span class="string">"x"</span>, <span class="string">"1"</span>);</span><br><span class="line">headers.put(<span class="string">"y"</span>, <span class="string">"1"</span>);</span><br><span class="line">AMQP.BasicProperties basicProperties = <span class="keyword">new</span> AMQP.BasicProperties().builder()</span><br><span class="line">    .deliveryMode(<span class="number">2</span>) <span class="comment">// 传送方式</span></span><br><span class="line">    .priority(<span class="number">1</span>)</span><br><span class="line">    .contentEncoding(<span class="string">"UTF-8"</span>) <span class="comment">// 编码方式</span></span><br><span class="line">    .expiration(<span class="string">"5000"</span>) <span class="comment">// 过期时间</span></span><br><span class="line">    .headers(headers).build(); <span class="comment">//自定义属性</span></span><br><span class="line"><span class="comment">// 7: 发送消息给中间件rabbitmq-server</span></span><br><span class="line"><span class="comment">// @params1: 交换机exchange</span></span><br><span class="line"><span class="comment">// @params2: 队列名称/routing</span></span><br><span class="line"><span class="comment">// @params3: 属性配置</span></span><br><span class="line"><span class="comment">// @params4: 发送消息的内容</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">    channel.basicPublish(<span class="string">""</span>, <span class="string">"ttl.queue2"</span>, basicProperties, message.getBytes());</span><br><span class="line">    System.out.println(<span class="string">"消息发送成功!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-两种方式的区别"><a href="#1-3-两种方式的区别" class="headerlink" title="1.3 两种方式的区别"></a>1.3 两种方式的区别</h4><ul><li>第一种方法里，队列已过期的消息肯定在队列的头部，RabbitMQ 只要定期扫描从队列的头部扫描是否有过期消息即可</li><li>第二种方式，每条消息的国企时间不同，如果要删除所有的过期消息势必要扫描整个队列，所以步入等到此消息即将被消息时再判定是否过期，如果过期再进行删除即可。</li></ul><h3 id="2-队列的TTL"><a href="#2-队列的TTL" class="headerlink" title="2. 队列的TTL"></a>2. 队列的TTL</h3><ul><li>通过在<code>channel.queueDeclare</code>方法中的<code>x-expires</code> 参数可以控制队列被自动删除前处于多久未使用的状态<ul><li>未使用的意思是队列上没有任何消费者，队列也没有被重新声明，并且这段时间内也灭有调用过<code>Basic.Get()</code> 命令</li></ul></li><li><strong>核心代码</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Object&gt; args2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args2.put(<span class="string">"x-expires"</span>,<span class="number">5000</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">"ttl.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args2);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-09-过期时间TTL&quot;&gt;&lt;a href=&quot;#RabbitMQ-09-过期时间TTL&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-09-过期时间TTL&quot;&gt;&lt;/a&gt;RabbitMQ-09-过期时间TTL&lt;/h2&gt;&lt;h3 id=&quot;1-TTL的概念&quot;&gt;&lt;a href=&quot;#1-TTL的概念&quot; class=&quot;headerlink&quot; title=&quot;1. TTL的概念&quot;&gt;&lt;/a&gt;1. TTL的概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;过期时间&lt;code&gt;TTL&lt;/code&gt;表示可以对消息设置预期的时间，在这个时间内都可以被消费者接收获取；过了之后消息将自动被删除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;RabbitMQ可以对&lt;strong&gt;消息和队列&lt;/strong&gt;设置TTL。目前有两种方法可以设置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第一种方法是通过队列属性设置&lt;/strong&gt;，队列中所有消息都有相同的过期时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二种方法是对消息进行单独设置&lt;/strong&gt;，每条消息TTL可以不同。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果上述两种方法同时使用，则消息的过期时间以两者之间TTL较小的那个数值为准。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消息在队列的生存时间一旦超过设置的TTL值，就称为dead message被投递到死信队列， 消费者将无法再收到该消息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;TTL的标识&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210407-154021368.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-080-删除有序数组中的重复项II</title>
    <link href="http://zhuuu.work/2021/04/06/Leetcode/Leetcode-080-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9II/"/>
    <id>http://zhuuu.work/2021/04/06/Leetcode/Leetcode-080-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9II/</id>
    <published>2021-04-06T04:02:24.000Z</published>
    <updated>2021-04-06T03:30:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-080-删除有序数组中的重复项-II"><a href="#Leetcode-080-删除有序数组中的重复项-II" class="headerlink" title="Leetcode-080- 删除有序数组中的重复项 II"></a>Leetcode-080-<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/" target="_blank" rel="noopener"> 删除有序数组中的重复项 II</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给你一个有序数组 <code>nums</code> ，请你<strong><a href="http://baike.baidu.com/item/原地算法" target="_blank" rel="noopener"> 原地</a></strong> 删除重复出现的元素，使每个元素 <strong>最多出现两次</strong> ，返回删除后数组的新长度。</li><li>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</li></ul><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len &#x3D; removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [1,1,1,2,2,3]</span><br><span class="line">输出：5, nums &#x3D; [1,1,2,2,3]</span><br><span class="line">解释：函数应返回新长度 length &#x3D; 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [0,0,1,1,1,1,2,3,3]</span><br><span class="line">输出：7, nums &#x3D; [0,0,1,1,2,3,3]</span><br><span class="line">解释：函数应返回新长度 length &#x3D; 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><h2 id="方法一-：-双指针"><a href="#方法一-：-双指针" class="headerlink" title="方法一 ： 双指针"></a>方法一 ： 双指针</h2><ul><li><p>因为给定数组是有序的，所以相同元素必然连续。我们可以使用双指针解决本题，<strong>遍历数组检查每一个元素是否应该被保留，如果应该被保留，就将其移动到指定位置。</strong></p></li><li><p>具体地，我们定义两个指针slow 和 fast 分别为慢指针和快指针，其中<strong>慢指针表示处理出的数组的长度，快指针表示已经检查过的数组的长度</strong></p><ul><li><code>nums[fast]</code> : 为第一个待检查的元素</li><li><em>nums</em>[<em>slow</em>−1] 为上一个应该被保留的元素所移动到的指定位置。</li></ul></li><li><p>本题要求相同元素最多出现两次而非一次，所以我们需要检查上上个应该被保留的元素 <code>nums[slow−2]</code>是否和当前待检查元素<code>nums[fast]</code> 相同。</p><ul><li>若<code>nums[slow - 2] == nums[fast]</code> 则当前元素不应该被保留</li><li>当前<code>nums[slow−2]=nums[slow−1]=nums[fast]</code></li></ul></li></ul><p>  <strong>最后slow即为数组的长度</strong></p><p>  <strong>特别地，</strong></p><p>  数组的前两个数必然可以被保留，因此对于长度不超过 2 的数组，我们无需进行任何处理，</p><p>  对于长度超过 2 的数组，我们直接将双指针的初始值设为 2 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 特判及初始化 : 长度小于等于二直接满足条件</span></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 双指针逻辑 : 从下标为2开始检查</span></span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">2</span>;                               <span class="comment">// fast代表待检查的元素</span></span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">2</span>;                               <span class="comment">// slow代表已经检查完的长度</span></span><br><span class="line">        <span class="keyword">while</span>(fast &lt; len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[slow - <span class="number">2</span>] != nums[fast])&#123;        <span class="comment">// 说明中间产生了重复元素</span></span><br><span class="line">                slow++;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 返回值</span></span><br><span class="line">        <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n) ，遍历一遍数组</li><li>空间复杂度：O(1) ， 原地修改</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Leetcode-080-删除有序数组中的重复项-II&quot;&gt;&lt;a href=&quot;#Leetcode-080-删除有序数组中的重复项-II&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-080- 删除有序数组中的重复项 II&quot;&gt;&lt;/a&gt;Leet
      
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-026-删除有序数组中的重复元素</title>
    <link href="http://zhuuu.work/2021/04/06/Leetcode/Leetcode-026-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>http://zhuuu.work/2021/04/06/Leetcode/Leetcode-026-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</id>
    <published>2021-04-06T03:02:24.000Z</published>
    <updated>2021-04-06T03:21:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-026-删除有序数组中的重复项"><a href="#Leetcode-026-删除有序数组中的重复项" class="headerlink" title="Leetcode-026-删除有序数组中的重复项"></a>Leetcode-026-<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">删除有序数组中的重复项</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给你一个有序数组 <code>nums</code> ，请你<strong><a href="http://baike.baidu.com/item/原地算法" target="_blank" rel="noopener"> 原地</a></strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。</li><li>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</li></ul><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len &#x3D; removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [1,1,2]</span><br><span class="line">输出：2, nums &#x3D; [1,2]</span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">输出：5, nums &#x3D; [0,1,2,3,4]</span><br><span class="line">解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><h2 id="方法一-：-双指针"><a href="#方法一-：-双指针" class="headerlink" title="方法一 ： 双指针"></a>方法一 ： 双指针</h2><ul><li>数组完成排序后，我们可以放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。只要 <code>nums[i] == nums[j]</code>，我们就增加 j 以跳过重复项。<ul><li>其中慢指针表示处理出的数组的长度，快指针表示已经检查过的数组的长度</li></ul></li><li>当我们遇到<code>nums[i] != nums[j]</code> 时，跳过重复项的运行已经结束，<ul><li>将 <code>i++</code> 并且将 <code>nums[i] = nums[j]</code></li><li>作用：为了覆盖重复的元素</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 初始化及特判</span></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;                                  <span class="comment">// i慢指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 双指针逻辑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; len;j++)&#123;                 <span class="comment">// j快指针</span></span><br><span class="line">            <span class="comment">// 2.1 如果nums[j] != nums[i]</span></span><br><span class="line">            <span class="keyword">if</span>(nums[j] != nums[i])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                nums[i] = nums[j];                  <span class="comment">// i++ 并将重复元素直接覆盖 </span></span><br><span class="line">            &#125;                                       <span class="comment">// 否则如果 nums[j] == nums[i] 直接外层for循环跳到下一个j</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 返回慢指针长度</span></span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n) ，遍历一遍数组</li><li>空间复杂度：O(1) ， 原地修改</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Leetcode-026-删除有序数组中的重复项&quot;&gt;&lt;a href=&quot;#Leetcode-026-删除有序数组中的重复项&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-026-删除有序数组中的重复项&quot;&gt;&lt;/a&gt;Leetcode-026-&lt;
      
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-783-二叉搜索树节点最小距离</title>
    <link href="http://zhuuu.work/2021/04/06/Leetcode/Leetcode-783-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%8A%82%E7%82%B9%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB/"/>
    <id>http://zhuuu.work/2021/04/06/Leetcode/Leetcode-783-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%8A%82%E7%82%B9%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB/</id>
    <published>2021-04-06T03:02:24.000Z</published>
    <updated>2021-04-16T01:19:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-783-二叉搜索树节点最小距离"><a href="#Leetcode-783-二叉搜索树节点最小距离" class="headerlink" title="Leetcode-783-二叉搜索树节点最小距离"></a>Leetcode-783-<a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/" target="_blank" rel="noopener">二叉搜索树节点最小距离</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210416-090527376.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [4,2,6,1,3]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210416-090547189.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,0,48,null,null,12,49]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[2, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 105</code></li><li>差值是一个正数，其数值等于两值之差的绝对值</li></ul><a id="more"></a><h2 id="算法思路：中序遍历"><a href="#算法思路：中序遍历" class="headerlink" title="算法思路：中序遍历"></a>算法思路：中序遍历</h2><ul><li>一看到二叉搜索树：中序遍历就对了(转为升序数组)</li><li>考虑对升序数组 <em>a</em> 求任意两个元素之差的最小值，<strong>答案一定为相邻两个元素之差的最小值</strong>，即其他任意间隔距离大于等于 2 的下标对 (<em>i</em>,<em>j</em>) 的元素之差一定大于下标对 (<em>i</em>,<em>i</em>+1) 的元素之差，故不需要再被考虑。</li><li><strong>回到本题，本题要求二叉搜索树任意两节点差的最小值，而我们知道二叉搜索树有个性质为二叉搜索树中序遍历得到的值序列是递增有序的，因此我们只要得到中序遍历后的值序列即能用上文提及的方法来解决。</strong></li><li>朴素的方法是经过一次中序遍历将值保存在一个数组中再进行遍历求解<ul><li>我们也可以在中序遍历的过程中用 <em>pre</em> 变量保存前驱节点的值，这样即能边遍历边更新答案</li><li>不再需要显式创建数组来保存，需要注意的是 <em>pre</em> 的初始值需要设置成任意负数标记开头，下文代码中设置为 −1。</li><li>二叉树的中序遍历有多种方式，包括递归、栈、Morris 遍历等，读者可选择自己最擅长的来实现。下文代码提供最普遍的递归方法来实现</li><li>其他遍历方法的介绍可以详细看「<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/" target="_blank" rel="noopener">94. 二叉树的中序遍历的官方题解</a>」，这里不再赘述。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210416-091725798.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">int</span> pre;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDiffInBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ans = Integer.MAX_VALUE;</span><br><span class="line">        pre = -<span class="number">1</span>; <span class="comment">//pre 用于保存前一个root.val</span></span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1. 递归结束的条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 中序遍历</span></span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="comment">// 处理逻辑</span></span><br><span class="line">        <span class="keyword">if</span>(pre == -<span class="number">1</span>)&#123;</span><br><span class="line">            pre = root.val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans = Math.min(ans,root.val - pre);</span><br><span class="line">            pre = root.val; <span class="comment">// pre更新为当前节点的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度：<em>O</em>(<em>N</em>)，因为每个节点只访问了一次；</li><li>空间复杂度：<em>O</em>(<em>N</em>)，因为递归用了系统栈。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-783-二叉搜索树节点最小距离&quot;&gt;&lt;a href=&quot;#Leetcode-783-二叉搜索树节点最小距离&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-783-二叉搜索树节点最小距离&quot;&gt;&lt;/a&gt;Leetcode-783-&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二叉搜索树节点最小距离&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给你一个二叉搜索树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回 &lt;strong&gt;树中任意两不同节点值之间的最小差值&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210416-090527376.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：root &amp;#x3D; [4,2,6,1,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210416-090547189.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：root &amp;#x3D; [1,0,48,null,null,12,49]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;树中节点数目在范围 &lt;code&gt;[2, 100]&lt;/code&gt; 内&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= Node.val &amp;lt;= 105&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;差值是一个正数，其数值等于两值之差的绝对值&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-08-SpringBoot整合使用</title>
    <link href="http://zhuuu.work/2021/04/05/RabbitMQ/RabbitMQ-08-SpringBoot%E6%95%B4%E5%90%88%E4%BD%BF%E7%94%A8/"/>
    <id>http://zhuuu.work/2021/04/05/RabbitMQ/RabbitMQ-08-SpringBoot%E6%95%B4%E5%90%88%E4%BD%BF%E7%94%A8/</id>
    <published>2021-04-05T06:02:24.000Z</published>
    <updated>2021-04-07T07:03:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-08-SpringBoot整合使用"><a href="#RabbitMQ-08-SpringBoot整合使用" class="headerlink" title="RabbitMQ-08-SpringBoot整合使用"></a>RabbitMQ-08-SpringBoot整合使用</h2><h2 id="1-使用场景概述"><a href="#1-使用场景概述" class="headerlink" title="1. 使用场景概述"></a>1. 使用场景概述</h2><ul><li><strong>rabbitMQ的作用 ： 解耦 削峰 异步</strong></li></ul><h3 id="1-1-同步异步的问题（串行）"><a href="#1-1-同步异步的问题（串行）" class="headerlink" title="1.1 同步异步的问题（串行）"></a>1.1 同步异步的问题（串行）</h3><ul><li>串行方式：将订单信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210401-140556054.png" alt="mark"></p><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 :保存订单 </span></span><br><span class="line">    orderService.saveOrder();</span><br><span class="line">    <span class="comment">// 2： 发送短信服务</span></span><br><span class="line">    messageService.sendSMS(<span class="string">"order"</span>);<span class="comment">//1-2 s</span></span><br><span class="line">    <span class="comment">// 3： 发送email服务</span></span><br><span class="line">    emailService.sendEmail(<span class="string">"order"</span>);<span class="comment">//1-2 s</span></span><br><span class="line">    <span class="comment">// 4： 发送APP服务</span></span><br><span class="line">    appService.sendApp(<span class="string">"order"</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="1-2-并行方式-异步线程池"><a href="#1-2-并行方式-异步线程池" class="headerlink" title="1.2 并行方式 异步线程池"></a>1.2 并行方式 异步线程池</h3><ul><li>并行方式：将订单信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210401-140723072.png" alt="mark"></p><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 :保存订单 </span></span><br><span class="line">    orderService.saveOrder();</span><br><span class="line">   <span class="comment">// 相关发送</span></span><br><span class="line">   relationMessage();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">relationMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 异步</span></span><br><span class="line">     theadpool.submit(<span class="keyword">new</span> Callable&lt;Object&gt;&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">             <span class="comment">// 2： 发送短信服务  </span></span><br><span class="line">             messageService.sendSMS(<span class="string">"order"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">    <span class="comment">// 异步</span></span><br><span class="line">     theadpool.submit(<span class="keyword">new</span> Callable&lt;Object&gt;&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">              <span class="comment">// 3： 发送email服务</span></span><br><span class="line">            emailService.sendEmail(<span class="string">"order"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">      <span class="comment">// 异步</span></span><br><span class="line">     theadpool.submit(<span class="keyword">new</span> Callable&lt;Object&gt;&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">             <span class="comment">// 4： 发送短信服务</span></span><br><span class="line">             appService.sendApp(<span class="string">"order"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">      <span class="comment">// 异步</span></span><br><span class="line">         theadpool.submit(<span class="keyword">new</span> Callable&lt;Object&gt;&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">             <span class="comment">// 4： 发送短信服务</span></span><br><span class="line">             appService.sendApp(<span class="string">"order"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>存在问题：</strong><br>1：耦合度高<br>2：需要自己写线程池自己维护成本太高<br>3：出现了消息可能会丢失，需要你自己做消息补偿<br>4：如何保证消息的可靠性你自己写<br>5：如果服务器承载不了，你需要自己去写高可用</p><h3 id="1-3-异步消息队列模式"><a href="#1-3-异步消息队列模式" class="headerlink" title="1.3 异步消息队列模式"></a>1.3 异步消息队列模式</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210401-140820922.png" alt="mark"></p><p><strong>好处</strong><br>1：完全解耦，用MQ建立桥接<br>2：有独立的线程池和运行模型<br>3：出现了消息可能会丢失，MQ有持久化功能<br>4：如何保证消息的可靠性，死信队列和消息转移的等<br>5：如果服务器承载不了，你需要自己去写高可用，HA镜像模型高可用。<br>按照以上约定，用户的响应时间相当于是订单信息写入数据库的时间，也就是50毫秒。注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能是50毫秒。因此架构改变后，系统的吞吐量提高到每秒20 QPS。比串行提高了3倍，比并行提高了两倍</p><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 :保存订单 </span></span><br><span class="line">    orderService.saveOrder();   </span><br><span class="line">    rabbitTemplate.convertSend(<span class="string">"ex"</span>,<span class="string">"2"</span>,<span class="string">"消息内容"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>之后若进行服务的扩展（高内聚 低耦合的特点）</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210401-141007724.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210401-141032549.png" alt="mark"></p><ul><li>还有以下场景的使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">04、分布式事务的可靠消费和可靠生产</span><br><span class="line">05、索引、缓存、静态化处理的数据同步</span><br><span class="line">06、流量监控</span><br><span class="line">07、日志监控（ELK）</span><br><span class="line">08、下单、订单分发、抢票</span><br></pre></td></tr></table></figure><h2 id="2-SpringBoot-fanout-模式"><a href="#2-SpringBoot-fanout-模式" class="headerlink" title="2. SpringBoot - fanout 模式"></a>2. SpringBoot - fanout 模式</h2><ul><li>使用<code>springboot</code>完成<code>rabbitmq</code>的消费模式<code>-Fanout</code></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210406-142051131.png" alt="mark"></p><p><strong>步骤概览：</strong></p><p>1：创建生产者工程：<code>springboot-rabbitmq-fanout-producer</code><br>2：创建消费者工程：<code>springboot-rabbitmq-fanout-consumer</code><br>3：引入<code>spring-boot-rabbitmq</code>的依赖<br>4：进行消息的分发和测试<br>5：查看和观察web控制台的状况</p><p><strong>代码实现：生产者和消费者都需要配置</strong></p><ol><li><strong>引入依赖</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>在application.yml进行配置</strong></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="comment"># 配置rabbitmq服务</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">ip</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br></pre></td></tr></table></figure><h3 id="2-1-生产者"><a href="#2-1-生产者" class="headerlink" title="2.1 生产者"></a>2.1 生产者</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210406-155414551.png" alt="mark"></p><ul><li><code>OrderService</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">// 1: 定义交换机</span></span><br><span class="line">    <span class="keyword">private</span> String exchangeName = <span class="string">"fanout_order_exchange"</span>;</span><br><span class="line">    <span class="comment">// 2: 路由key</span></span><br><span class="line">    <span class="keyword">private</span> String routeKey = <span class="string">""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeOrder</span><span class="params">(Long userId, Long productId, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1： 模拟用户下单</span></span><br><span class="line">        String orderNumer = UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">// 2: 根据商品id productId 去查询商品的库存</span></span><br><span class="line">        <span class="comment">// int numstore = productSerivce.getProductNum(productId);</span></span><br><span class="line">        <span class="comment">// 3:判断库存是否充足</span></span><br><span class="line">        <span class="comment">// if(num &gt;  numstore )&#123; return  "商品库存不足..."; &#125;</span></span><br><span class="line">        <span class="comment">// 4: 下单逻辑</span></span><br><span class="line">        <span class="comment">// orderService.saveOrder(order);</span></span><br><span class="line">        <span class="comment">// 5: 下单成功要扣减库存</span></span><br><span class="line">        <span class="comment">// 6: 下单完成以后</span></span><br><span class="line">        System.out.println(<span class="string">"用户 "</span> + userId + <span class="string">",订单编号是："</span> + orderNumer);</span><br><span class="line">        <span class="comment">// 发送订单信息给RabbitMQ fanout</span></span><br><span class="line">        rabbitTemplate.convertAndSend(exchangeName, routeKey, orderNumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>FanoutConfig</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.rabbitmq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 定义交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">fanoutOrderExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  return new DirectExchange("TestDirectExchange",true,true);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(<span class="string">"fanout_order_exchange"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 声明队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">emailQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// durable:是否持久化,默认是false,持久化队列：会被存储在磁盘上，当消息代理重启时仍然存在，暂存队列：当前连接有效</span></span><br><span class="line">        <span class="comment">// exclusive:默认也是false，只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable</span></span><br><span class="line">        <span class="comment">// autoDelete:是否自动删除，当没有生产者或者消费者使用此队列，该队列会自动删除。</span></span><br><span class="line">        <span class="comment">//   return new Queue("TestDirectQueue",true,true,false);</span></span><br><span class="line">        <span class="comment">//一般设置一下队列的持久化就好,其余两个就是默认false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"email.fanout.queue"</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">smsQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// durable:是否持久化,默认是false,持久化队列：会被存储在磁盘上，当消息代理重启时仍然存在，暂存队列：当前连接有效</span></span><br><span class="line">        <span class="comment">// exclusive:默认也是false，只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable</span></span><br><span class="line">        <span class="comment">// autoDelete:是否自动删除，当没有生产者或者消费者使用此队列，该队列会自动删除。</span></span><br><span class="line">        <span class="comment">//   return new Queue("TestDirectQueue",true,true,false);</span></span><br><span class="line">        <span class="comment">//一般设置一下队列的持久化就好,其余两个就是默认false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"sms.fanout.queue"</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">weixinQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// durable:是否持久化,默认是false,持久化队列：会被存储在磁盘上，当消息代理重启时仍然存在，暂存队列：当前连接有效</span></span><br><span class="line">        <span class="comment">// exclusive:默认也是false，只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable</span></span><br><span class="line">        <span class="comment">// autoDelete:是否自动删除，当没有生产者或者消费者使用此队列，该队列会自动删除。</span></span><br><span class="line">        <span class="comment">//   return new Queue("TestDirectQueue",true,true,false);</span></span><br><span class="line">        <span class="comment">//一般设置一下队列的持久化就好,其余两个就是默认false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"weixin.fanout.queue"</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingFanoutweixinQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(weixinQueue()).to(fanoutOrderExchange());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingFanoutsmsQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(smsQueue()).to(fanoutOrderExchange());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingFanoutemailQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(emailQueue()).to(fanoutOrderExchange());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-消费者"><a href="#2-2-消费者" class="headerlink" title="2.2 消费者"></a>2.2 消费者</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210406-155652005.png" alt="mark"></p><p><strong>邮件服务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.ExchangeTypes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="comment">// bindings其实就是用来确定队列消费者绑定关系</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings =<span class="meta">@QueueBinding</span>(</span><br><span class="line">        <span class="comment">// email.fanout.queue 是队列名字，这个名字你可以自定随便定义。</span></span><br><span class="line">        value = <span class="meta">@Queue</span>(value = <span class="string">"email.fanout.queue"</span>,autoDelete = <span class="string">"false"</span>),</span><br><span class="line">        <span class="comment">// order.fanout 交换机的名字 必须和生产者保持一致</span></span><br><span class="line">        exchange = <span class="meta">@Exchange</span>(value = <span class="string">"fanout_order_exchange"</span>,</span><br><span class="line">                <span class="comment">// 这里是确定的rabbitmq模式是：fanout 是以广播模式 、 发布订阅模式</span></span><br><span class="line">                type = ExchangeTypes.FANOUT)</span><br><span class="line">))</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// @RabbitHandler 代表此方法是一个消息接收的方法。该不要有返回值</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messagerevice</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 此处省略发邮件的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"email--------------&gt;"</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>短信服务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.ExchangeTypes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="comment">// bindings其实就是用来确定队列和消费者绑定关系</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings =<span class="meta">@QueueBinding</span>(</span><br><span class="line">        <span class="comment">// email.fanout.queue 是队列名字，这个名字你可以自定随便定义。</span></span><br><span class="line">        value = <span class="meta">@Queue</span>(value = <span class="string">"sms.fanout.queue"</span>,autoDelete = <span class="string">"false"</span>),</span><br><span class="line">        <span class="comment">// order.fanout 交换机的名字 必须和生产者保持一致</span></span><br><span class="line">        exchange = <span class="meta">@Exchange</span>(value = <span class="string">"fanout_order_exchange"</span>,</span><br><span class="line">                <span class="comment">// 这里是确定的rabbitmq模式是：fanout 是以广播模式 、 发布订阅模式</span></span><br><span class="line">                type = ExchangeTypes.FANOUT)</span><br><span class="line">))</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// @RabbitHandler 代表此方法是一个消息接收的方法。该不要有返回值</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messagerevice</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 此处省略发邮件的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"sms--------------&gt;"</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>微信服务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.ExchangeTypes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="comment">// bindings其实就是用来确定队列和消费者绑定关系</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings =<span class="meta">@QueueBinding</span>(</span><br><span class="line">        <span class="comment">// email.fanout.queue 是队列名字，这个名字你可以自定随便定义。</span></span><br><span class="line">        value = <span class="meta">@Queue</span>(value = <span class="string">"weixin.fanout.queue"</span>,autoDelete = <span class="string">"false"</span>),</span><br><span class="line">        <span class="comment">// order.fanout 交换机的名字 必须和生产者保持一致</span></span><br><span class="line">        exchange = <span class="meta">@Exchange</span>(value = <span class="string">"fanout_order_exchange"</span>,</span><br><span class="line">                <span class="comment">// 这里是确定的rabbitmq模式是：fanout 是以广播模式 、 发布订阅模式</span></span><br><span class="line">                type = ExchangeTypes.FANOUT)</span><br><span class="line">))</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeixinService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// @RabbitHandler 代表此方法是一个消息接收的方法。该不要有返回值</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messagerevice</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 此处省略发邮件的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"weixin--------------&gt;"</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-结果"><a href="#2-3-结果" class="headerlink" title="2.3 结果"></a>2.3 结果</h3><ul><li>启动项目 结果预览</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210406-155838578.png" alt="mark"></p><h2 id="3-SpringBoot-Direct-模式"><a href="#3-SpringBoot-Direct-模式" class="headerlink" title="3. SpringBoot - Direct 模式"></a>3. SpringBoot - Direct 模式</h2><ul><li>环境设置同第二节</li></ul><h3 id="3-1-生产者"><a href="#3-1-生产者" class="headerlink" title="3.1 生产者"></a>3.1 生产者</h3><ul><li><code>orderService</code> : 不同的是交换的名字还有类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">// 1: 定义交换机</span></span><br><span class="line">    <span class="keyword">private</span> String exchangeName = <span class="string">"direct_order_exchange"</span>;</span><br><span class="line">    <span class="comment">// 2: 路由key</span></span><br><span class="line">    <span class="keyword">private</span> String routeKey = <span class="string">""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeOrder</span><span class="params">(Long userId, Long productId, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1： 模拟用户下单</span></span><br><span class="line">        String orderNumer = UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">// 2: 根据商品id productId 去查询商品的库存</span></span><br><span class="line">        <span class="comment">// int numstore = productSerivce.getProductNum(productId);</span></span><br><span class="line">        <span class="comment">// 3:判断库存是否充足</span></span><br><span class="line">        <span class="comment">// if(num &gt;  numstore )&#123; return  "商品库存不足..."; &#125;</span></span><br><span class="line">        <span class="comment">// 4: 下单逻辑</span></span><br><span class="line">        <span class="comment">// orderService.saveOrder(order);</span></span><br><span class="line">        <span class="comment">// 5: 下单成功要扣减库存</span></span><br><span class="line">        <span class="comment">// 6: 下单完成以后</span></span><br><span class="line">        System.out.println(<span class="string">"用户 "</span> + userId + <span class="string">",订单编号是："</span> + orderNumer);</span><br><span class="line">        <span class="comment">// 发送订单信息给RabbitMQ fanout</span></span><br><span class="line">        rabbitTemplate.convertAndSend(exchangeName, routeKey, orderNumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>DirectRabbitConfig</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.rabbitmq.config;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.DirectExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.声明队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">emailQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// durable:是否持久化,默认是false,持久化队列：会被存储在磁盘上，当消息代理重启时仍然存在，暂存队列：当前连接有效</span></span><br><span class="line">        <span class="comment">// exclusive:默认也是false，只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable</span></span><br><span class="line">        <span class="comment">// autoDelete:是否自动删除，当没有生产者或者消费者使用此队列，该队列会自动删除。</span></span><br><span class="line">        <span class="comment">//   return new Queue("TestDirectQueue",true,true,false);</span></span><br><span class="line">        <span class="comment">//一般设置一下队列的持久化就好,其余两个就是默认false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"email.direct.queue"</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">smsQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// durable:是否持久化,默认是false,持久化队列：会被存储在磁盘上，当消息代理重启时仍然存在，暂存队列：当前连接有效</span></span><br><span class="line">        <span class="comment">// exclusive:默认也是false，只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable</span></span><br><span class="line">        <span class="comment">// autoDelete:是否自动删除，当没有生产者或者消费者使用此队列，该队列会自动删除。</span></span><br><span class="line">        <span class="comment">//   return new Queue("TestDirectQueue",true,true,false);</span></span><br><span class="line">        <span class="comment">//一般设置一下队列的持久化就好,其余两个就是默认false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"sms.direct.queue"</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">weixinQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// durable:是否持久化,默认是false,持久化队列：会被存储在磁盘上，当消息代理重启时仍然存在，暂存队列：当前连接有效</span></span><br><span class="line">        <span class="comment">// exclusive:默认也是false，只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable</span></span><br><span class="line">        <span class="comment">// autoDelete:是否自动删除，当没有生产者或者消费者使用此队列，该队列会自动删除。</span></span><br><span class="line">        <span class="comment">//   return new Queue("TestDirectQueue",true,true,false);</span></span><br><span class="line">        <span class="comment">//一般设置一下队列的持久化就好,其余两个就是默认false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"weixin.direct.queue"</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. Direct交换机 起名：TestDirectExchange</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">directOrderExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  return new DirectExchange("TestDirectExchange",true,true);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">"direct_order_exchange"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 绑定  将队列和交换机绑定, 并设置用于匹配键：TestDirectRouting</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingDirect1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(weixinQueue()).to(directOrderExchange()).with(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingDirect2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(smsQueue()).to(directOrderExchange()).with(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingDirect3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(emailQueue()).to(directOrderExchange()).with(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-消费者"><a href="#3-2-消费者" class="headerlink" title="3.2 消费者"></a>3.2 消费者</h3><p><strong>结构如下：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210407-145848520.png" alt="mark"></p><ul><li>代码如上2.2 雷同，这里不再详细写出</li></ul><h2 id="4-SpringBoot-Topic-模式"><a href="#4-SpringBoot-Topic-模式" class="headerlink" title="4. SpringBoot - Topic 模式"></a>4. SpringBoot - Topic 模式</h2><ul><li>代码如上雷同，这里不再详细写出</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-08-SpringBoot整合使用&quot;&gt;&lt;a href=&quot;#RabbitMQ-08-SpringBoot整合使用&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-08-SpringBoot整合使用&quot;&gt;&lt;/a&gt;RabbitMQ-08-SpringBoot整合使用&lt;/h2&gt;&lt;h2 id=&quot;1-使用场景概述&quot;&gt;&lt;a href=&quot;#1-使用场景概述&quot; class=&quot;headerlink&quot; title=&quot;1. 使用场景概述&quot;&gt;&lt;/a&gt;1. 使用场景概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;rabbitMQ的作用 ： 解耦 削峰 异步&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-1-同步异步的问题（串行）&quot;&gt;&lt;a href=&quot;#1-1-同步异步的问题（串行）&quot; class=&quot;headerlink&quot; title=&quot;1.1 同步异步的问题（串行）&quot;&gt;&lt;/a&gt;1.1 同步异步的问题（串行）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;串行方式：将订单信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210401-140556054.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码示例&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;makeOrder&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 1 :保存订单 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    orderService.saveOrder();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 2： 发送短信服务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    messageService.sendSMS(&lt;span class=&quot;string&quot;&gt;&quot;order&quot;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//1-2 s&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 3： 发送email服务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    emailService.sendEmail(&lt;span class=&quot;string&quot;&gt;&quot;order&quot;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//1-2 s&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 4： 发送APP服务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    appService.sendApp(&lt;span class=&quot;string&quot;&gt;&quot;order&quot;&lt;/span&gt;);    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1143-最长公共子序列</title>
    <link href="http://zhuuu.work/2021/04/03/Leetcode/Leetcode-1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://zhuuu.work/2021/04/03/Leetcode/Leetcode-1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2021-04-03T03:02:24.000Z</published>
    <updated>2021-04-04T12:46:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-1143-最长公共子序列"><a href="#Leetcode-1143-最长公共子序列" class="headerlink" title="Leetcode-1143-最长公共子序列"></a>Leetcode-1143-<a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">最长公共子序列</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</li><li>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li><li>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line"></span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;def&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0 。</span><br></pre></td></tr></table></figure><ul><li><strong>提示：</strong><ul><li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li><li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li></ul></li></ul><a id="more"></a><h2 id="算法思路：动态规划"><a href="#算法思路：动态规划" class="headerlink" title="算法思路：动态规划"></a>算法思路：动态规划</h2><p><strong>思路</strong></p><ul><li>最长公共子序列问题是典型的二维动态规划问题。</li></ul><p><strong>算法：动态规划</strong></p><ol><li><strong>定义dp数组</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210404-204250982.png" alt="mark"></p><ol start="2"><li><strong>初始化边界</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210404-204319577.png" alt="mark"></p><ol start="3"><li><strong>转移规律</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210404-204410567.png" alt="mark"></p><ol start="4"><li><strong>返回结果</strong></li></ol><ul><li>最终计算得到<code>return dp[m][n];</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 初始化条件:dp[m + 1][n + 1]</span></span><br><span class="line">        <span class="keyword">int</span> m = text1.length();</span><br><span class="line">        <span class="keyword">int</span> n = text2.length();</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 边界条件</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;++j)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. dp 转移逻辑</span></span><br><span class="line">        <span class="keyword">char</span> char_i = <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">char</span> char_j = <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;++i)&#123;                                                  <span class="comment">// </span></span><br><span class="line">            char_i = text1.charAt(i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">                char_j = text2.charAt(j - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 3.1 如果text[i] == text[j] :dp[i][j] = dp[i - 1][j - 1] + 1;</span></span><br><span class="line">                <span class="keyword">if</span>(char_i == char_j)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 3.2 如果text[i] ！= text[j] dp[i][j] = max(dp[i][j - 1],dp[i -1][j]);</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>],dp[i -<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O(mn) 。对m 行 n 列元素进行一一遍历</li><li>空间复杂度 ： O(mn) 。二维dp数组的大小</li></ul><h2 id="打表过程"><a href="#打表过程" class="headerlink" title="打表过程"></a>打表过程</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210404-204453590.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-1143-最长公共子序列&quot;&gt;&lt;a href=&quot;#Leetcode-1143-最长公共子序列&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-1143-最长公共子序列&quot;&gt;&lt;/a&gt;Leetcode-1143-&lt;a href=&quot;https://leetcode-cn.com/problems/longest-common-subsequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;最长公共子序列&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给定两个字符串 &lt;code&gt;text1&lt;/code&gt; 和 &lt;code&gt;text2&lt;/code&gt;，返回这两个字符串的最长 &lt;strong&gt;公共子序列&lt;/strong&gt; 的长度。如果不存在 &lt;strong&gt;公共子序列&lt;/strong&gt; ，返回 &lt;code&gt;0&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;一个字符串的 &lt;strong&gt;子序列&lt;/strong&gt; 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。&lt;ul&gt;
&lt;li&gt;例如，&lt;code&gt;&amp;quot;ace&amp;quot;&lt;/code&gt; 是 &lt;code&gt;&amp;quot;abcde&amp;quot;&lt;/code&gt; 的子序列，但 &lt;code&gt;&amp;quot;aec&amp;quot;&lt;/code&gt; 不是 &lt;code&gt;&amp;quot;abcde&amp;quot;&lt;/code&gt; 的子序列。&lt;/li&gt;
&lt;li&gt;两个字符串的 &lt;strong&gt;公共子序列&lt;/strong&gt; 是这两个字符串所共同拥有的子序列。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：text1 &amp;#x3D; &amp;quot;abcde&amp;quot;, text2 &amp;#x3D; &amp;quot;ace&amp;quot; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：3  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：最长公共子序列是 &amp;quot;ace&amp;quot; ，它的长度为 3 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：text1 &amp;#x3D; &amp;quot;abc&amp;quot;, text2 &amp;#x3D; &amp;quot;abc&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：最长公共子序列是 &amp;quot;abc&amp;quot; ，它的长度为 3 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：text1 &amp;#x3D; &amp;quot;abc&amp;quot;, text2 &amp;#x3D; &amp;quot;def&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：两个字符串没有公共子序列，返回 0 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= text1.length, text2.length &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;text1&lt;/code&gt; 和 &lt;code&gt;text2&lt;/code&gt; 仅由小写英文字符组成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://zhuuu.work/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-面试题17.21-直方图的水量</title>
    <link href="http://zhuuu.work/2021/04/02/Leetcode/Leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9817.21-%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E6%B0%B4%E9%87%8F/"/>
    <id>http://zhuuu.work/2021/04/02/Leetcode/Leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9817.21-%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E6%B0%B4%E9%87%8F/</id>
    <published>2021-04-02T03:02:24.000Z</published>
    <updated>2021-04-02T14:49:06.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-面试题17-21-直方图的水量"><a href="#Leetcode-面试题17-21-直方图的水量" class="headerlink" title="Leetcode-面试题17.21-直方图的水量"></a>Leetcode-面试题17.21-<a href="https://leetcode-cn.com/problems/volume-of-histogram-lcci/" target="_blank" rel="noopener">直方图的水量</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-093642478.png" alt="mark"></p><ul><li>上面是由数组 <code>[0,1,0,2,1,0,1,3,2,1,2,1]</code>表示的直方图，在这种情况下，可以接 6 个单位的水（蓝色部分表示水）。</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路一-：-单调栈"><a href="#思路一-：-单调栈" class="headerlink" title="思路一 ： 单调栈"></a>思路一 ： 单调栈</h2><p><strong>算法思路</strong></p><ul><li><p>维护一个单调栈，单调栈存储的是下标，满足从栈底到栈顶的下标对应的数组 <em>height</em> 中的元素递减。（单调递减栈）</p></li><li><p>从左到右遍历数组，遍历到下标 i 时，如果栈内至少有两个元素，记栈顶元素为 top，top 的栈内下面一个元素是left，则一定有 <code>height[left]≥height[top]。</code></p></li><li><p>如果 <code>height[i]&gt;height[top]</code>，则得到一个可以接雨水的区域，该区域的宽度是 <code>i−left−1</code>，高度是<code>min(height[left],height[i])−height[top]</code>，根据宽度和高度即可计算得到该区域能接的水的量。</p><ul><li>为了得到left , 需要将top 进行出栈。在对<code>top</code>计算能接的水量之后，<code>left</code>变成新的<code>top</code>。 </li><li>重复上述操作，直到栈变为空，或者栈顶下标对应的<code>height</code>中元素大于或等于 <code>height[i]</code></li><li>在对下标<code>i</code> 处计算能接的水量之后，将i入栈，继续遍历后面的下标，计算能接的水量</li><li>遍历结束之后累加和就是能接的总水量</li></ul></li></ul><p><strong>下面用一个例子<code>height=[0,1,0,2,1,0,1,3,2,1,2,1]</code>来帮助理解单调栈的做法。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095132375.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095139991.png" alt="mark"></p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095149597.png" alt="mark" /><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095149597.png" alt="mark"  /><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095208256.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095215424.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095223482.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095229807.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095236306.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095242251.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095247559.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095256468.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095303684.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095309385.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095315519.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095321578.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095327520.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095334609.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095341286.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095347231.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-095353479.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 初始化变量和栈</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = height.length;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;                                                            <span class="comment">// 用于记录最终结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 处理逻辑:遍历数组中每一个元素的下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()])&#123;        <span class="comment">// 保证栈内元素对应的数组中的值是单调递减的</span></span><br><span class="line">                <span class="keyword">int</span> top = stack.pop();                                          <span class="comment">// 拿到栈顶的元素,并且弹出</span></span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty())&#123;                                            <span class="comment">// 如果此时栈为空，说明没有left的存在，即无法围成面积</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> left = stack.peek();                                        <span class="comment">// 拿到此时对应的left，不弹出</span></span><br><span class="line">                <span class="keyword">int</span> currwidth  = i - left - <span class="number">1</span>;                                  <span class="comment">// 宽</span></span><br><span class="line">                <span class="keyword">int</span> currHeight = Math.min(height[i],height[left]) - height[top];<span class="comment">// 高</span></span><br><span class="line">                ans += currHeight * currwidth;                                  <span class="comment">// 面积进行累加 </span></span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">// 3. 当前区域面积计算完，对新元素入栈</span></span><br><span class="line">            stack.push(i);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;                                                       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n)，其中 n 是数组 height 的长度。从 0 到 n−1 的每个下标最多只会入栈和出栈各一次。</p></li><li><p>空间复杂度：O(n)，其中 n 是数组 height 的长度。空间复杂度主要取决于栈空间，栈的大小不会超过 n。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-面试题17-21-直方图的水量&quot;&gt;&lt;a href=&quot;#Leetcode-面试题17-21-直方图的水量&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-面试题17.21-直方图的水量&quot;&gt;&lt;/a&gt;Leetcode-面试题17.21-&lt;a href=&quot;https://leetcode-cn.com/problems/volume-of-histogram-lcci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;直方图的水量&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210402-093642478.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上面是由数组 &lt;code&gt;[0,1,0,2,1,0,1,3,2,1,2,1]&lt;/code&gt;表示的直方图，在这种情况下，可以接 6 个单位的水（蓝色部分表示水）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [0,1,0,2,1,0,1,3,2,1,2,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://zhuuu.work/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="单调栈" scheme="http://zhuuu.work/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1006-笨阶乘</title>
    <link href="http://zhuuu.work/2021/03/31/Leetcode/Leetcode-1006-%E7%AC%A8%E9%98%B6%E4%B9%98/"/>
    <id>http://zhuuu.work/2021/03/31/Leetcode/Leetcode-1006-%E7%AC%A8%E9%98%B6%E4%B9%98/</id>
    <published>2021-03-31T03:02:24.000Z</published>
    <updated>2021-04-02T14:49:11.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-1006-笨阶乘"><a href="#Leetcode-1006-笨阶乘" class="headerlink" title="Leetcode-1006-笨阶乘"></a>Leetcode-1006-<a href="https://leetcode-cn.com/problems/clumsy-factorial/" target="_blank" rel="noopener">笨阶乘</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>通常，正整数 n 的阶乘是所有小于或等于 n 的正整数的乘积。例如，<code>factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1。</code></p></li><li><p>相反，我们设计了一个笨阶乘<code>clumsy：</code>在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法(*)，除法(/)，加法(+)和减法(-)。</p><p>例如，<code>clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1。</code>然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。</p></li><li><p>另外，我们使用的除法是地板除法<code>（floor division）</code>，所以 <code>10 * 9 / 8</code>等于 11。这保证结果是一个整数。</p><p><strong>实现上面定义的笨函数：给定一个整数 N，它返回 N 的笨阶乘。</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：4</span><br><span class="line">输出：7</span><br><span class="line">解释：7 &#x3D; 4 * 3 &#x2F; 2 + 1</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：10</span><br><span class="line">输出：12</span><br><span class="line">解释：12 &#x3D; 10 * 9 &#x2F; 8 + 7 - 6 * 5 &#x2F; 4 + 3 - 2 * 1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= N &lt;= 10000</code></li><li><code>-2^31 &lt;= answer &lt;= 2^31 - 1</code> （答案保证符合 32 位整数。）</li></ol><a id="more"></a><h2 id="思路-：-栈"><a href="#思路-：-栈" class="headerlink" title="思路 ： 栈"></a>思路 ： 栈</h2><ul><li><p>根据求解问题<strong>「150. 逆波兰表达式求值」、「224. 基本计算器」、「227. 基本计算器 II」的经验，表达式的计算一般可以借助数据结构「栈」完成，特别是带有括号的表达式。</strong></p></li><li><p>将暂时还不能确定的数据存入栈，确定了优先级最高以后，一旦可以计算出结果，我们就把数据从栈里取出，<strong>整个过程恰好符合了「后进先出」的规律</strong>。本题也不例外。</p></li><li><p>根据题意，<strong>「笨阶乘」没有显式括号，运算优先级是先「乘除」后「加减」。我们可以从 N 开始，枚举 N , N−1、N−2 直到 1 ，枚举这些数的时候，认为它们之前的操作符按照「乘」「除」「加」「减」交替进行。</strong></p><ul><li>出现乘法、除法的时候可以把栈顶元素取出，与当前的 <em>N</em> 进行乘法运算、除法运算（除法运算需要注意先后顺序），并将运算结果重新压入栈中；</li><li>出现加法、减法的时候，把减法视为加上一个数的相反数，然后压入栈，等待以后遇见「乘」「除」法的时候取出。</li><li>最后将栈中元素累加即为答案。由于加法运算交换律成立，可以将栈里的元素依次出栈相加。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">clumsy</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 类似波兰表达式，使用栈结构</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        stack.push(N);</span><br><span class="line">        N--;                                                        <span class="comment">// 首元素入栈</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 处理逻辑</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;                                              <span class="comment">// 用于处理乘 除 加 法 的顺序逻辑</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                stack.push(stack.pop() * N);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index % <span class="number">4</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                stack.push(stack.pop() / N);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index % <span class="number">4</span> == <span class="number">2</span>) &#123;</span><br><span class="line">                stack.push(N);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(-N);</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            N--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 最后把所有栈内数字相加即是结果</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            result += stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O(N)  ，每个元素入栈出栈一次</li><li>空间复杂度 ： O(N)  ,由于「乘」「除」运算在进栈、出栈过程中被计算出来，最后一步弹出栈之前，栈里保存的是「加」「减」法项。 </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-1006-笨阶乘&quot;&gt;&lt;a href=&quot;#Leetcode-1006-笨阶乘&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-1006-笨阶乘&quot;&gt;&lt;/a&gt;Leetcode-1006-&lt;a href=&quot;https://leetcode-cn.com/problems/clumsy-factorial/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;笨阶乘&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;通常，正整数 n 的阶乘是所有小于或等于 n 的正整数的乘积。例如，&lt;code&gt;factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1。&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;相反，我们设计了一个笨阶乘&lt;code&gt;clumsy：&lt;/code&gt;在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法(*)，除法(/)，加法(+)和减法(-)。&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1。&lt;/code&gt;然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;另外，我们使用的除法是地板除法&lt;code&gt;（floor division）&lt;/code&gt;，所以 &lt;code&gt;10 * 9 / 8&lt;/code&gt;等于 11。这保证结果是一个整数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现上面定义的笨函数：给定一个整数 N，它返回 N 的笨阶乘。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：7 &amp;#x3D; 4 * 3 &amp;#x2F; 2 + 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：12 &amp;#x3D; 10 * 9 &amp;#x2F; 8 + 7 - 6 * 5 &amp;#x2F; 4 + 3 - 2 * 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= N &amp;lt;= 10000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-2^31 &amp;lt;= answer &amp;lt;= 2^31 - 1&lt;/code&gt; （答案保证符合 32 位整数。）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="波兰表达式" scheme="http://zhuuu.work/tags/%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-074-搜索二维矩阵</title>
    <link href="http://zhuuu.work/2021/03/30/Leetcode/Leetcode-074-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/"/>
    <id>http://zhuuu.work/2021/03/30/Leetcode/Leetcode-074-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</id>
    <published>2021-03-30T03:02:24.000Z</published>
    <updated>2021-04-02T14:49:14.374Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-074-搜索二维矩阵"><a href="#Leetcode-074-搜索二维矩阵" class="headerlink" title="Leetcode-074-搜索二维矩阵"></a>Leetcode-074-<a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">搜索二维矩阵</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>编写一个高效的算法来判断 <code>m x n</code>矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><ul><li>每行中的整数从左到右按升序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210330-095448593.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target &#x3D; 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210330-095518901.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target &#x3D; 13</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m &#x3D;&#x3D; matrix.length</span><br><span class="line">n &#x3D;&#x3D; matrix[i].length</span><br><span class="line">1 &lt;&#x3D; m, n &lt;&#x3D; 100</span><br><span class="line">-10^4 &lt;&#x3D; matrix[i][j], target &lt;&#x3D; 10^4</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p><strong>思路</strong></p><ul><li><p>由于每行的第一个元素大于前一行的最后一个元素，且每行元素是升序的，所以每行的第一个元素大于前一行的第一个元素，<strong>因此矩阵第一列的元素是升序的。</strong></p></li><li><p>我们可以<strong>对矩阵的第一列的元素二分查找，找到最后一个不大于目标值的元素</strong>，</p></li><li><p><strong>然后在该元素所在行中二分查找目标值是否存在。</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rowIndex = searchColumn(matrix,target);             <span class="comment">// 搜索在哪一行</span></span><br><span class="line">        <span class="keyword">if</span>(rowIndex &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;                                       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> searchRow(matrix[rowIndex],target);              <span class="comment">// 找到所在行号后，再在行内进行搜索</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次二分：搜索target在哪一行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchColumn</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (high + low + <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;                    <span class="comment">// + 1：目的是为了防止死循环的发生（left = mid 这种情况都需要+1）</span></span><br><span class="line">            <span class="keyword">if</span>(matrix[mid][<span class="number">0</span>] &lt;= target)&#123;                        <span class="comment">// 比较每一行第一个元素与target 判断在哪一行</span></span><br><span class="line">                low = mid;                                       <span class="comment">// 下一轮搜索的区间是 [mid, high]</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;                                  <span class="comment">// 下一轮搜索的区间是 [low, mid]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二次二分：确定行号后进行行内查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchRow</span><span class="params">(<span class="keyword">int</span>[] row,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = row.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(row[mid] &lt; target)&#123;                              <span class="comment">// 小于 target 的元素一定不是解      </span></span><br><span class="line">                low = mid + <span class="number">1</span>;                                  <span class="comment">// 下一轮搜索的区间是 [mid + 1, high]</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid;                                     <span class="comment">// 下一轮搜索的区间是 [low, mid]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确认一下结果是否正确</span></span><br><span class="line">        <span class="keyword">if</span>(row[low] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O（logm） + O(logn) = O(logmn)</li><li>空间复杂度 ： O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-074-搜索二维矩阵&quot;&gt;&lt;a href=&quot;#Leetcode-074-搜索二维矩阵&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-074-搜索二维矩阵&quot;&gt;&lt;/a&gt;Leetcode-074-&lt;a href=&quot;https://leetcode-cn.com/problems/search-a-2d-matrix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;搜索二维矩阵&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;编写一个高效的算法来判断 &lt;code&gt;m x n&lt;/code&gt;矩阵中，是否存在一个目标值。该矩阵具有如下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每行中的整数从左到右按升序排列。&lt;/li&gt;
&lt;li&gt;每行的第一个整数大于前一行的最后一个整数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210330-095448593.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：matrix &amp;#x3D; [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210330-095518901.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：matrix &amp;#x3D; [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target &amp;#x3D; 13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;m &amp;#x3D;&amp;#x3D; matrix.length&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n &amp;#x3D;&amp;#x3D; matrix[i].length&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; m, n &amp;lt;&amp;#x3D; 100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-10^4 &amp;lt;&amp;#x3D; matrix[i][j], target &amp;lt;&amp;#x3D; 10^4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="(i,j,k)" scheme="http://zhuuu.work/tags/i-j-k/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-07-交换机类型</title>
    <link href="http://zhuuu.work/2021/03/28/RabbitMQ/RabbitMQ-07-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B/"/>
    <id>http://zhuuu.work/2021/03/28/RabbitMQ/RabbitMQ-07-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-03-28T08:02:24.000Z</published>
    <updated>2021-03-28T07:48:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-07-交换机类型"><a href="#RabbitMQ-07-交换机类型" class="headerlink" title="RabbitMQ-07-交换机类型"></a>RabbitMQ-07-交换机类型</h2><h2 id="1-交换机的类型"><a href="#1-交换机的类型" class="headerlink" title="1. 交换机的类型"></a>1. 交换机的类型</h2><p><strong>AMQP 0-9-1 的代理提供了四种交换机：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-150948908.png" alt="mark"></p><ul><li>参考官网：<a href="https://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener">https://www.rabbitmq.com/getstarted.html</a></li></ul><a id="more"></a><ul><li><p><strong>交换机可以有两个状态：持久（durable）、暂存（transient）。</strong></p></li><li><p><strong>持久化的交换机会在消息代理（broker）重启后依旧存在，而暂存的交换机则不会（它们需要在代理再次上线后重新被声明）。</strong></p></li><li><p>在正式介绍五种交换机（包括默认交换机）前，在这里重申一下，发布者生产的消息中包含了交换机类型。<strong>消息中声明的交换机类型不同，路由规则也就不同，也就会采取不同的规则将消息投入队列。</strong></p></li></ul><h3 id="1-1-默认交换机"><a href="#1-1-默认交换机" class="headerlink" title="1.1 默认交换机"></a>1.1 默认交换机</h3><ul><li><p>默认交换机（default exchange）实际上是一个由消息代理预先声明好的没有名字（名字为空字符串）的<strong>直连交换机（direct exchange）。</strong></p></li><li><p>它有一个特殊的属性使得它对于简单应用特别有用处：那就是每个新建队列（queue）都会自动绑定到默认交换机上，绑定的路由键（routing key）名称与队列名称相同。</p><ul><li>举个栗子：当你声明了一个名为<code>“search-indexing-online”</code>的队列，AMQP 代理会自动将其绑定到默认交换机上，绑定（<code>binding</code>）的路由键名称也是为 <code>“search-indexing-online”。</code></li><li>因此，当携带着名为 “search-indexing-online” 的路由键的消息被发送到默认交换机的时候，此消息会被默认交换机路由至名为 “search-indexing-online” 的队列中。换句话说，默认交换机看起来貌似能够直接将消息投递给队列.</li></ul></li></ul><h3 id="1-2-Direct"><a href="#1-2-Direct" class="headerlink" title="1.2 Direct"></a>1.2 Direct</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-151430656.png" alt="mark"></p><ul><li><p>直连型交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应绑定键的队列。直连交换机用来处理消息的单播路由（unicast routing）（尽管它也可以处理多播路由）。下边介绍它是如何工作的：</p><ul><li>将一个队列绑定到某个交换机上时，赋予该绑定一个绑定键（Binding Key），假设为R；</li><li>当一个携带着路由键（Routing Key）为R的消息被发送给直连交换机时，交换机会把它路由给绑定键为R的队列。</li></ul></li><li><p>直连交换机的队列通常是循环分发任务给多个消费者（我们称之为轮询）。比如说有3个消费者，4个任务。分别分发每个消费者一个任务后，第4个任务又分发给了第一个消费者。</p></li><li><p>综上，我们很容易得出一个结论，在 AMQP 0-9-1 中，<strong>消息的负载均衡是发生在消费者（consumer）之间的，而不是队列（queue）之间。</strong></p></li></ul><p><strong>如图举例</strong></p><ul><li><p>当生产者（P）发送消息时 Rotuing key=booking 时，这时候将消息传送给 Exchange，Exchange 获取到生产者发送过来消息后，会根据自身的规则进行与匹配相应的 Queue，这时发现 Queue1 和 Queue2 都符合，就会将消息传送给这两个队列。</p></li><li><p>如果我们以 Rotuing key=create 和 Rotuing key=confirm 发送消息时，这时消息只会被推送到 Queue2 队列中，其他 Routing Key 的消息将会被丢弃。</p></li></ul><p><strong>注意：</strong></p><ul><li><code>BindingKey</code>和 <code>RoutingKey</code> 的区别<ul><li><code>BindingKey</code> : <strong>在绑定的时候</strong>，其中需要的路由键是<code>BindingKey</code>，涉及的客户端方法为<code>channel.exchangeBind,channel.queueBind</code><ul><li><code>RoutingKey</code>  : <strong>在发送消息的时候</strong>，其中需要的路由键是<code>RoutingKey</code> ，涉及的客户端方法如<code>channel.basicPublish</code> 对应的AMQP命令为<code>Basic.Publish</code></li></ul></li></ul></li></ul><h3 id="1-3-fanout"><a href="#1-3-fanout" class="headerlink" title="1.3 fanout"></a>1.3 fanout</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-152013014.png" alt="mark"></p><ul><li><p>扇型交换机（funout exchange）将消息路由给绑定到它身上的所有队列，<strong>而不理会绑定的路由键。</strong></p></li><li><p>如果 N 个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的拷贝分别发送给这所有的 N 个队列。</p></li><li><p>扇型用来交换机处理消息的广播路由（broadcast routing）。</p><ul><li>因为扇型交换机投递消息的拷贝到所有绑定到它的队列，所以他的应用案例都极其相似：<ul><li>大规模多用户在线（MMO）游戏可以使用它来处理排行榜更新等全局事件</li><li>体育新闻网站可以用它来近乎实时地将比分更新分发给移动客户端</li><li>分发系统使用它来广播各种状态和配置更新</li><li>在群聊的时候，它被用来分发消息给参与群聊的用户。（AMQP 没有内置 presence 的概念，因此 XMPP 可能会是个更好的选择）</li></ul></li></ul></li></ul><p><strong>如图举例</strong></p><ul><li>上图所示，生产者（P）生产消息 1 将消息 1 推送到 <code>Exchange</code>，由于 <code>Exchange Type=fanout</code>这时候会遵循 <code>fanout</code>的规则将消息推送到所有与它绑定<code>Queue</code>，也就是图上的两个 <code>Queue</code>最后两个消费者消费。</li></ul><h3 id="1-4-Topic"><a href="#1-4-Topic" class="headerlink" title="1.4 Topic"></a>1.4 Topic</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-153449817.png" alt="mark"></p><ul><li>前面提到的 direct 规则是<strong>严格意义上的匹配</strong>，换言之 Routing Key 必须与 Binding Key 相匹配的时候才将消息传送给 Queue.</li><li>而Topic 的路由规则是一种<strong>模糊匹配</strong>，可以通过通配符满足一部分规则就可以传送。<ul><li>binding key 中可以存在两种特殊字符 <code>“*” 与“#”，</code>用于做模糊匹配，其中 <code>“*”</code>用于匹配一个单词，<code>“#”</code>用于匹配多个单词（可以是零个）<ul><li><code>“*”</code> : 一定要有一个匹配 （只有一个）</li><li><code>“#”</code> ：0个 1个 多个  （都可以匹配）</li></ul></li><li><code>routing key</code>为一个句点号 <code>“.”</code> 分隔的字符串（我们将被句点号 <code>“. ”</code> 分隔开的每一段独立的字符串称为一个单词），如<code>“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit”binding key 与 routing key</code>一样也是句点号<code>“.”</code>分隔的字符串</li></ul></li></ul><p><strong>如图举例</strong></p><ul><li>当生产者发送消息 Routing Key=F.C.E 的时候，这时候只满足 Queue1，所以会被路由到 Queue1 中</li><li>如果 Routing Key=A.C.E 这时候会被同是路由到 Queue1 和 Queue2 中，如果 Routing Key=A.F.B 时，这里只会发送一条消息到 Queue2 中。</li></ul><p><strong>注意：</strong></p><ul><li><p>主题交换机拥有非常广泛的用户案例。无论何时，当一个问题涉及到那些想要有针对性的选择需要接收消息的 <strong>多消费者 / 多应用（multiple consumers/applications） 的时候</strong>，主题交换机都可以被列入考虑范围。</p></li><li><p><strong>使用场景：</strong></p><ul><li>分发有关于特定地理位置的数据，例如销售点</li><li>由多个工作者（workers）完成的后台任务，每个工作者负责处理某些特定的任务</li><li>股票价格更新（以及其他类型的金融数据更新）</li><li>涉及到分类或者标签的新闻更新（例如，针对特定的运动项目或者队伍）</li><li>云端的不同种类服务的协调</li><li>分布式架构 / 基于系统的软件封装，其中每个构建者仅能处理一个特定的架构或者系统。</li></ul></li></ul><h3 id="1-5-headers"><a href="#1-5-headers" class="headerlink" title="1.5 headers"></a>1.5 headers</h3><ul><li><p><code>headers</code> 类型的 <code>Exchange</code> 不依赖于<code>routing key</code> 与 <code>binding key</code>的匹配规则来路由消息，而是根据发送的消息内容中的 <code>headers</code> 属性进行匹配。</p></li><li><p><strong>头交换机可以视为直连交换机的另一种表现形式。但直连交换机的路由键必须是一个字符串，而头属性值则没有这个约束</strong></p><ul><li>它们甚至可以是整数或者哈希值（字典）等。</li><li>灵活性更强（但实际上我们很少用到头交换机）。</li></ul></li><li><p><strong>工作流程：</strong></p><ul><li>绑定一个队列到头交换机上时，会同时绑定多个用于匹配的头<code>header</code>。</li><li>传来的消息会携带<code>header</code>，以及会有一个 <code>“x-match”</code>参数。<ul><li>当 “x-match” 设置为 “any” 时，消息头的任意一个值被匹配就可以满足条件</li><li>当 “x-match” 设置为 “all” 的时候，就需要消息头的所有值都匹配成功。</li></ul></li></ul></li></ul><h3 id="1-6-交换机小结"><a href="#1-6-交换机小结" class="headerlink" title="1.6 交换机小结"></a>1.6 交换机小结</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-165226361.png" alt="mark"></p><ul><li><strong>何时创建交换机或者队列的问题？</strong><ul><li><code>rabbitMQ</code> 的消息都存储在队列中，因此交换机的使用不用真正的耗费服务器的性能，但是队列是会的</li><li>所以衡量<code>rabbitMQ</code> 当前的QPS只需要看当前的队列即可</li><li>按照<code>rabbitMQ</code> 官方的建议，生产者和消费者都应该尝试创建队列<ul><li>这是一个很好的建议，但是不适用于所有的情况</li><li>如果业务架构之初已经考虑好了所有的情况，这样的话业务可以免去声明的过程，直接使用</li><li>还有一个好处的：可以确保交换机和队列之间正确的绑定<ul><li>这样不会出现发送的消息和交换器没有绑定任何队列造成的消息丢失</li><li>同时路由键无法与现存的队列进行匹配</li></ul></li><li>后期超过预定的QPS，只需要对集群进行扩容或者队列进行迁移即可</li></ul></li><li>总之，动态创建或者静态创建的方式需要从业务的逻辑去考虑</li></ul></li></ul><h2 id="2-入门代码演示"><a href="#2-入门代码演示" class="headerlink" title="2. 入门代码演示"></a>2. 入门代码演示</h2><h3 id="2-1-核心流程再讲"><a href="#2-1-核心流程再讲" class="headerlink" title="2.1 核心流程再讲"></a>2.1 核心流程再讲</h3><p><strong>生产者</strong></p><ul><li>生产者链接到<code>rabbitMQ Broker</code>,建立一个Connection并且开启一个信道</li><li>生产者声明一个交换器，并设置相关的属性，比如交换器的类型，是否持久化等</li><li>生产者声明一个队列并设置相关属性：是否排他，是否持久化，是否自动删除等</li><li>生产者通过路由键将交换器和队列绑定起来</li><li>生产者发送消息到<code>rabbitMQ Broker</code>，其中包含路由键，浇花器等信息</li><li>相应的交换器把接收到的路由key查找相匹配的队列<ul><li>如果找到，则将生产者发送过来的消息存入相应的队列中</li><li>如果没有找到，则根据生产者的配置属性选择丢弃还是退还给生产者</li></ul></li><li>关闭信道</li><li>关闭连接</li></ul><p><strong>消费者</strong></p><ul><li>消费者连接到 <code>rabbitMQ Broker</code>，建立一个连接并且开启一个信道</li><li>消费者向<code>rabbitMQ Broker</code>请求消费相应队列中的消息，可能会设置回调函数之类的</li><li>等待<code>rabbitMQ Broker</code>的回应并且投递相应队列中的消息</li><li>消费者确认（ACK）接收到的消息</li><li><code>rabbitMQ Broker</code> 从队列中删除相应的被确认的消息</li><li>关闭信道</li><li>关闭连接</li></ul><h3 id="2-2-fanout-发布-订阅"><a href="#2-2-fanout-发布-订阅" class="headerlink" title="2.2 fanout (发布/订阅)"></a>2.2 fanout (发布/订阅)</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-105512613.png" alt="mark"></p><ul><li>特点：Fanout—发布与订阅模式，是一种广播机制，它是没有路由key的模式。</li></ul><p><strong>生产者代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建链接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 3. 通过链接获取通道</span></span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"生产者"</span>);     <span class="comment">// 从工厂中获取链接</span></span><br><span class="line">            channel = connection.createChannel();               <span class="comment">// 从链接中获取通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            // 4. 通过通道创建交换机，声明队列，绑定关系，路由key,发送消息和接收消息</span></span><br><span class="line"><span class="comment">//            String queuename = "queue1";</span></span><br><span class="line"><span class="comment">//            /*</span></span><br><span class="line"><span class="comment">//             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">//             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">//             *</span></span><br><span class="line"><span class="comment">//             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">//             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">//             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">//             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">//             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">//             * */</span></span><br><span class="line"><span class="comment">//            channel.queueDeclare(queuename,false,false,false,null);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 准备消息内容并发送到通道</span></span><br><span class="line">            String message = <span class="string">"Hello 朱酱酱"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6. 交换机的名称和类型</span></span><br><span class="line">            String exchangeName = <span class="string">"fanoutExange"</span>;</span><br><span class="line">            String type = <span class="string">"fanout"</span>;</span><br><span class="line">            <span class="comment">// 7. 路由key</span></span><br><span class="line">            String routingKey = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8. 发送消息</span></span><br><span class="line">            channel.basicPublish(exchangeName,routingKey,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">"发送消息成功"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 9. 先关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 10. 再关闭链接</span></span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runnable runnable = () -&gt; &#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建链接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 3. 通过链接获取通道</span></span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取队列的名字</span></span><br><span class="line">        <span class="keyword">final</span> String queueName = Thread.currentThread().getName();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"生产者"</span>);     <span class="comment">// 从工厂中获取链接</span></span><br><span class="line">            channel = connection.createChannel();               <span class="comment">// 从链接中获取通道</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.接收消息并且处理异常</span></span><br><span class="line">            Channel finalchannel = channel;</span><br><span class="line">            finalchannel.basicConsume(<span class="string">"queue1"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s, Delivery message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"收到消息是"</span> + <span class="keyword">new</span> String(message.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"接收消息失败！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 6. 关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 7. 关闭链接</span></span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动三个线程去执行</span></span><br><span class="line">        <span class="keyword">new</span> Thread(runnable, <span class="string">"queue-1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable, <span class="string">"queue-2"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable, <span class="string">"queue-3"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong><ul><li><strong><code>Connection</code> 可以用来创建多个<code>Channel</code> 实例，但是<code>Channel</code> 实例不能在线程间共享，应用程序应该为每一个线程开辟一个Channel。</strong></li><li>在某些情况下<code>Channel</code> 的操作可以并发的运行，但是在其他情况下会导致在网络上出现错误的通信帧交错，同时会影响发送方的确认机制，所以多线程间共享channel是非线程安全的</li></ul></li></ul><h3 id="2-3-Direct"><a href="#2-3-Direct" class="headerlink" title="2.3 Direct"></a>2.3 Direct</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-152219269.png" alt="mark"></p><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建链接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 3. 通过链接获取通道</span></span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"生产者"</span>);     <span class="comment">// 从工厂中获取链接</span></span><br><span class="line">            channel = connection.createChannel();               <span class="comment">// 从链接中获取通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            // 4. 通过通道创建交换机，声明队列，绑定关系，路由key,发送消息和接收消息</span></span><br><span class="line"><span class="comment">//            String queuename = "queue1";</span></span><br><span class="line"><span class="comment">//            /*</span></span><br><span class="line"><span class="comment">//             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">//             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">//             *</span></span><br><span class="line"><span class="comment">//             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">//             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">//             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">//             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">//             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">//             * */</span></span><br><span class="line"><span class="comment">//            channel.queueDeclare(queuename,false,false,false,null);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 准备消息内容并发送到通道</span></span><br><span class="line">            String message = <span class="string">"Hello 朱酱酱"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6. 交换机的名称和类型</span></span><br><span class="line">            String exchangeName = <span class="string">"fanoutExange"</span>;</span><br><span class="line">            String type = <span class="string">"direct"</span>;</span><br><span class="line">            <span class="comment">// 7. 路由key</span></span><br><span class="line">            String routingKey = <span class="string">"你的路由key"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8. 发送消息</span></span><br><span class="line">            channel.basicPublish(exchangeName,routingKey,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">"发送消息成功"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 9. 先关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 10. 再关闭链接</span></span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-Topic"><a href="#2-4-Topic" class="headerlink" title="2.4 Topic"></a>2.4 Topic</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-152409430.png" alt="mark"></p><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建链接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 3. 通过链接获取通道</span></span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"生产者"</span>);     <span class="comment">// 从工厂中获取链接</span></span><br><span class="line">            channel = connection.createChannel();               <span class="comment">// 从链接中获取通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            // 4. 通过通道创建交换机，声明队列，绑定关系，路由key,发送消息和接收消息</span></span><br><span class="line"><span class="comment">//            String queuename = "queue1";</span></span><br><span class="line"><span class="comment">//            /*</span></span><br><span class="line"><span class="comment">//             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">//             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">//             *</span></span><br><span class="line"><span class="comment">//             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">//             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">//             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">//             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">//             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">//             * */</span></span><br><span class="line"><span class="comment">//            channel.queueDeclare(queuename,false,false,false,null);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 准备消息内容并发送到通道</span></span><br><span class="line">            String message = <span class="string">"Hello 朱酱酱"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6. 交换机的名称和类型</span></span><br><span class="line">            String exchangeName = <span class="string">"fanoutExange"</span>;</span><br><span class="line">            String type = <span class="string">"topic"</span>;</span><br><span class="line">            <span class="comment">// 7. 路由key</span></span><br><span class="line">            String routingKey = <span class="string">"模糊匹配"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8. 发送消息</span></span><br><span class="line">            channel.basicPublish(exchangeName,routingKey,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">"发送消息成功"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 9. 先关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 10. 再关闭链接</span></span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-注意事项小结"><a href="#2-5-注意事项小结" class="headerlink" title="2.5 注意事项小结"></a>2.5 注意事项小结</h3><p><strong>注意</strong></p><ul><li><strong><code>Connection</code> 可以用来创建多个<code>Channel</code> 实例，但是<code>Channel</code> 实例不能在线程间共享，应用程序应该为每一个线程开辟一个Channel。</strong></li><li>在某些情况下<code>Channel</code> 的操作可以并发的运行，但是在其他情况下会导致在网络上出现错误的通信帧交错，同时会影响发送方的确认机制，所以多线程间共享channel是非线程安全的</li></ul><ul><li><p><strong>生产者和消费者都可以声明一个交换器和队列。</strong></p><ul><li><p>如果声明的一个已经存在的交换器或者队列，只要声明的参数完全匹配现存的交换器或者队列，rabbitMQ就什么都不做</p></li><li><p>否则的话，就会抛出异常（<code>ShutdownSignalException</code>）</p></li></ul></li></ul><p><strong>应答AutoAck</strong></p><ul><li><strong>在生产实践中需要显示的设置<code>autoAck</code>为false,然后再接收到消息之后进行显示的ack操作（<code>channel.basicAck</code>） ，对于消费者来说这个是十分必要的，可以防止消息不必要的丢失</strong></li><li>当<code>autoAck</code>为false的时候，对于<code>rabbitMQ</code>服务器而言，队列的消息分为了两个部分<ul><li>一个是等待投递给消费者的消息</li><li>一个是已经投递给消费者，但是还没有收到确认的消息</li></ul></li><li>如果<code>rabbitMQ</code>服务器一直没有收到消费者的确认信号，并且消费此消息的消费者已经断开了连接，那么<code>rabbitMQ</code>服务器会重新安排该消息进入队列，等待下一个消费者，可能这个消费者就是原来的那个消费者</li><li>如果将消息进行拒绝（<code>channel.basicReject 和 channel.basicNack</code>）中的 <code>requeue</code> 设置为false,那么将启用<strong>“死信队列”功能</strong><ul><li>死信队列可以通过检测被拒绝的消息或者未送达的消息来追踪问题</li></ul></li></ul><p><strong>对于消费和的推(push) 和 拉（pull）模式而言</strong></p><ul><li><code>Basic.Consume</code> 将 channel 设置为投递模式（push），直到取消队列的订阅为止。在投递消息的期间，RabbitMQ会不断的将消息推送给消费者，当然推送消息的个数还是收到<code>Basic.Qos</code>的限制</li><li>如果只想要获得带条消息而不是持续的订阅，建议还是使用<code>Basic.Get()</code>方法进行消费。(pull)</li><li>建议消费者应该使用<code>Basic.Consume</code> 来提高吞吐量</li></ul><h3 id="2-6-完整版本生产者"><a href="#2-6-完整版本生产者" class="headerlink" title="2.6 完整版本生产者"></a>2.6 完整版本生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建链接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 3. 通过链接获取通道</span></span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"生产者"</span>);     <span class="comment">// 从工厂中获取链接</span></span><br><span class="line">            channel = connection.createChannel();               <span class="comment">// 从链接中获取通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            // 4. 通过通道创建交换机，声明队列，绑定关系，路由key,发送消息和接收消息</span></span><br><span class="line"><span class="comment">//            String queuename = "queue1";</span></span><br><span class="line"><span class="comment">//            /*</span></span><br><span class="line"><span class="comment">//             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">//             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">//             *</span></span><br><span class="line"><span class="comment">//             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">//             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">//             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">//             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">//             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">//             * */</span></span><br><span class="line"><span class="comment">//            channel.queueDeclare(queuename,false,false,false,null);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 准备消息内容并发送到通道</span></span><br><span class="line">            String message = <span class="string">"Hello 朱酱酱"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6. 声明交换机的名称和类型</span></span><br><span class="line">            String exchangeName = <span class="string">"direct_exchange_test"</span>;</span><br><span class="line">            String type = <span class="string">"direct"</span>;</span><br><span class="line">            channel.exchangeDeclare(exchangeName,type,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7. 路由key和声明队列</span></span><br><span class="line">            channel.queueDeclare(<span class="string">"queue5"</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">            channel.queueDeclare(<span class="string">"queue6"</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">            channel.queueDeclare(<span class="string">"queue7"</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">            String routingKey = <span class="string">"你的路由key"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8. 绑定队列</span></span><br><span class="line">            channel.queueBind(<span class="string">"queue5"</span>,exchangeName,routingKey);</span><br><span class="line">            channel.queueBind(<span class="string">"queue6"</span>,exchangeName,routingKey);</span><br><span class="line">            channel.queueBind(<span class="string">"queue7"</span>,exchangeName,routingKey);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 9. 发送消息</span></span><br><span class="line">            channel.basicPublish(exchangeName,routingKey,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">"发送消息成功"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 10. 先关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 11. 再关闭链接</span></span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>操作结果如下</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-165147022.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-165202693.png" alt="mark"></p><ul><li><strong>绑定的关系既可以在web界面进行声明也可以如上使用代码进行绑定</strong></li><li>最好使用代码的方式进行绑定</li><li><strong>如果队列或者交换机没有进行声明是会抛异常的</strong><ul><li><strong>同时消费者和生产者中声明队列和交换机都是可以的</strong></li><li><strong>因为channel是双向可以创建的</strong></li></ul></li></ul><h2 id="3-Worker-模式"><a href="#3-Worker-模式" class="headerlink" title="3. Worker 模式"></a>3. Worker 模式</h2><ul><li><strong>这里需要单独列出的是Woker模式</strong><ul><li>因为工作队列模式中有两种机制</li><li>分别是轮询模式和公平分发</li></ul></li></ul><ul><li><strong>如何均衡消费者消费信息的多少呢?</strong></li><li>主要有两种模式：<br>1、<strong>轮询模式</strong>的分发：一个消费者一条，<strong>按均分配；</strong><br>2、<strong>公平分发</strong>：根据消费者的消费能力进行公平分发，处理快的处理的多，处理慢的处理的少；<strong>按劳分配；</strong></li></ul><h3 id="3-1-轮询分发"><a href="#3-1-轮询分发" class="headerlink" title="3.1 轮询分发"></a>3.1 轮询分发</h3><ul><li>特点：该模式接收消息是当有多个消费者接入时，消息的分配模式是一个消费者分配一条，直至消息消费完成；</li><li><strong>默认情况下，rabbitMQ是轮询分发</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-113640288.png" alt="mark"></p><p><strong>代码样例</strong></p><ol><li><strong>生产者：生产消息进行投递</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.lunxun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建链接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 3. 通过链接获取通道</span></span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"生产者"</span>);     <span class="comment">// 从工厂中获取链接</span></span><br><span class="line">            channel = connection.createChannel();               <span class="comment">// 从链接中获取通道</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 通过通道创建交换机，声明队列，绑定关系，路由key,发送消息和接收消息</span></span><br><span class="line">            String queuename = <span class="string">"queue1"</span>;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            channel.queueDeclare(queuename,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 准备消息内容并发送到通道</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//消息的内容</span></span><br><span class="line">                String msg = <span class="string">"朱酱酱:"</span> + i;</span><br><span class="line">                <span class="comment">// 7: 发送消息给中间件rabbitmq-server</span></span><br><span class="line">                <span class="comment">// @params1: 交换机exchange</span></span><br><span class="line">                <span class="comment">// @params2: 队列名称/routingkey</span></span><br><span class="line">                <span class="comment">// @params3: 属性配置</span></span><br><span class="line">                <span class="comment">// @params4: 发送消息的内容</span></span><br><span class="line">                channel.basicPublish(<span class="string">""</span>, <span class="string">"queue1"</span>, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 6. 关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 7. 关闭链接</span></span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>消费者 worker1</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.lunxun;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3: 从连接工厂中获取连接</span></span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"消费者-Work1"</span>);</span><br><span class="line">            <span class="comment">// 4: 从连接中获取通道channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">// 5: 申明队列queue存储消息</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="comment">// 这里如果queue已经被创建过一次了，可以不需要定义</span></span><br><span class="line"><span class="comment">//            channel.queueDeclare("queue1", false, false, false, null);</span></span><br><span class="line">            <span class="comment">// 同一时刻，服务器只会推送一条消息给消费者</span></span><br><span class="line">            <span class="comment">// 6： 定义接受消息的回调</span></span><br><span class="line">            Channel finalChannel = channel;</span><br><span class="line">            finalChannel.basicQos(<span class="number">1</span>);</span><br><span class="line">            finalChannel.basicConsume(<span class="string">"queue1"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s, Delivery delivery)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"Work1-收到消息是："</span> + <span class="keyword">new</span> String(delivery.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(<span class="string">"Work1-开始接受消息"</span>);</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"发送消息出现异常..."</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7: 释放连接关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者2：worker2(代码几乎一摸一样)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.lunxun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3: 从连接工厂中获取连接</span></span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"消费者-Work1"</span>);</span><br><span class="line">            <span class="comment">// 4: 从连接中获取通道channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">// 5: 申明队列queue存储消息</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="comment">// 这里如果queue已经被创建过一次了，可以不需要定义</span></span><br><span class="line"><span class="comment">//            channel.queueDeclare("queue1", false, false, false, null);</span></span><br><span class="line">            <span class="comment">// 同一时刻，服务器只会推送一条消息给消费者</span></span><br><span class="line">            <span class="comment">// 6： 定义接受消息的回调</span></span><br><span class="line">            Channel finalChannel = channel;</span><br><span class="line">            finalChannel.basicQos(<span class="number">1</span>);</span><br><span class="line">            finalChannel.basicConsume(<span class="string">"queue1"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s, Delivery delivery)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"Work2-收到消息是："</span> + <span class="keyword">new</span> String(delivery.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">                        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(<span class="string">"Work2-开始接受消息"</span>);</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"发送消息出现异常..."</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7: 释放连接关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>预览结果如下：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-152557735.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-152615219.png" alt="mark"></p><ul><li><strong>小结：可以看到的是，轮询分发不会因为服务器的性能差异而产生竞争消费，而是依次消费</strong></li><li>案例采用的是自动应答模式</li></ul><h3 id="3-2-公平分发"><a href="#3-2-公平分发" class="headerlink" title="3.2 公平分发"></a>3.2 公平分发</h3><ul><li>特点：由于消息接收者处理消息的能力不同，存在处理快慢的问题，我们就需要能者多劳，处理快的多处理，处理慢的少处理；</li><li><strong>公平分发：一定要将应答模式改为手动应答</strong></li></ul><p><strong>案例分析：</strong></p><ol><li><strong>生产者：代码不变</strong></li></ol><ol start="2"><li><strong>消费者1：关闭自动应答，设置手动应答</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.fair;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3: 从连接工厂中获取连接</span></span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"消费者-Work1"</span>);</span><br><span class="line">            <span class="comment">// 4: 从连接中获取通道channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">// 5: 申明队列queue存储消息</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="comment">// 这里如果queue已经被创建过一次了，可以不需要定义</span></span><br><span class="line"><span class="comment">//            channel.queueDeclare("queue1", false, false, false, null);</span></span><br><span class="line">            <span class="comment">// 同一时刻，服务器只会推送一条消息给消费者</span></span><br><span class="line">            <span class="comment">// 6： 定义接受消息的回调</span></span><br><span class="line">            Channel finalChannel = channel;</span><br><span class="line">            finalChannel.basicQos(<span class="number">1</span>);</span><br><span class="line">            finalChannel.basicConsume(<span class="string">"queue1"</span>, <span class="keyword">false</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s, Delivery delivery)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"Work1-收到消息是："</span> + <span class="keyword">new</span> String(delivery.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                        finalChannel.basicAck(delivery.getEnvelope().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(<span class="string">"Work1-开始接受消息"</span>);</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"发送消息出现异常..."</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7: 释放连接关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>消费者2：关闭自动应答，设置手动应答</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.fair;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3: 从连接工厂中获取连接</span></span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"消费者-Work1"</span>);</span><br><span class="line">            <span class="comment">// 4: 从连接中获取通道channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">// 5: 申明队列queue存储消息</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="comment">// 这里如果queue已经被创建过一次了，可以不需要定义</span></span><br><span class="line"><span class="comment">//            channel.queueDeclare("queue1", false, false, false, null);</span></span><br><span class="line">            <span class="comment">// 同一时刻，服务器只会推送一条消息给消费者</span></span><br><span class="line">            <span class="comment">// 6： 定义接受消息的回调</span></span><br><span class="line">            Channel finalChannel = channel;</span><br><span class="line">            finalChannel.basicQos(<span class="number">1</span>);</span><br><span class="line">            finalChannel.basicConsume(<span class="string">"queue1"</span>, <span class="keyword">false</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s, Delivery delivery)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"Work2-收到消息是："</span> + <span class="keyword">new</span> String(delivery.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">                        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                        finalChannel.basicAck(delivery.getEnvelope().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(<span class="string">"Work2-开始接受消息"</span>);</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"发送消息出现异常..."</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7: 释放连接关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果预览</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-153656542.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-153708362.png" alt="mark"></p><ul><li><strong>小结：可以看到的是，消费者2由于性能较高，对消费者1的工作进行了截取</strong><ul><li>公平分发需要消费者开启手动应答，关闭自动应答</li><li>关闭自动应答代码channel.BasicConsume(“queue_test”, false, consumer);</li><li>消费者开启手动应答代码：channel.BasicAck(ea.DeliveryTag, false);</li><li>消费者一次接收一条消息，代码channel.BasicQos(0, 1, false);</li></ul></li></ul><h3 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h3><ul><li>当队列里消息较多时，我们通常会开启多个消费者处理消息；公平分发和轮询分发都是我们经常使用的模式。</li><li>轮询分发的主要思想是“按均分配”，不考虑消费者的处理能力，所有消费者均分；这种情况下，处理能力弱的服务器，一直都在处理消息，而处理能力强的服务器，在处理完消息后，处于空闲状态；</li><li>公平分发的主要思想是”能者多劳”，按需分配，能力强的干的多。</li><li>Qos 在线上环境建议不要设置的太大，会影响服务器的性能</li><li><strong>默认情况下，rabbitMQ是轮询分发</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-07-交换机类型&quot;&gt;&lt;a href=&quot;#RabbitMQ-07-交换机类型&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-07-交换机类型&quot;&gt;&lt;/a&gt;RabbitMQ-07-交换机类型&lt;/h2&gt;&lt;h2 id=&quot;1-交换机的类型&quot;&gt;&lt;a href=&quot;#1-交换机的类型&quot; class=&quot;headerlink&quot; title=&quot;1. 交换机的类型&quot;&gt;&lt;/a&gt;1. 交换机的类型&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;AMQP 0-9-1 的代理提供了四种交换机：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-150948908.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考官网：&lt;a href=&quot;https://www.rabbitmq.com/getstarted.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.rabbitmq.com/getstarted.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-04-数据的表示</title>
    <link href="http://zhuuu.work/2021/03/27/Compute_Organization/%E8%AE%A1%E7%BB%84-04-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA(%E5%AE%9A%E7%82%B9%E6%95%B0)/"/>
    <id>http://zhuuu.work/2021/03/27/Compute_Organization/%E8%AE%A1%E7%BB%84-04-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA(%E5%AE%9A%E7%82%B9%E6%95%B0)/</id>
    <published>2021-03-27T03:02:24.000Z</published>
    <updated>2021-04-21T07:11:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机组成原理-04-数据的表示"><a href="#计算机组成原理-04-数据的表示" class="headerlink" title="计算机组成原理-04-数据的表示"></a>计算机组成原理-04-数据的表示</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><strong>本篇内容多涉及计算，内容较为硬核，请耐心观看</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-205829908.png" alt="mark"></p><h2 id="1-定点数和浮点数的区别"><a href="#1-定点数和浮点数的区别" class="headerlink" title="1. 定点数和浮点数的区别"></a>1. 定点数和浮点数的区别</h2><ul><li><p>根据小数点的位置是否固定，在计算机内有两种数据格式</p><ul><li>定点数</li><li>浮点数</li></ul></li><li><p>定点表示：约定机器数中的小数点位置固定不变，小数点不再用“,”表示，而是约定了它的位置</p></li></ul><h2 id="2-无符号数和有符号数"><a href="#2-无符号数和有符号数" class="headerlink" title="2. 无符号数和有符号数"></a>2. 无符号数和有符号数</h2><ul><li><strong>无符号数</strong>：指整个机器字长的全部二进制位均为数值位，没有符号位。若机器字长为8位，则数的表示范围 <code>0~2^8-1</code> , 即<code>0~255</code>。<ul><li>无符号数一般只代表整数，不代表小数</li></ul></li><li><strong>有符号数</strong>：在机器中，数的正负我们无法识别，但是我们可以用<strong>二进制数来代替正负号。一般‘0’为正，‘1’为负</strong>，符号位一般在有效数的最前面。若机器字长为8位，是有符号数，则数的表示范围为 -2^7<del>2^7-1 ，即-128</del>127。</li></ul><a id="more"></a><h2 id="3-定点数的表示"><a href="#3-定点数的表示" class="headerlink" title="3. 定点数的表示"></a>3. 定点数的表示</h2><ul><li>定点小数：一般将小数点的位置固定在数据的<code>最高位之前</code>。</li><li>定点整数：一般将小数点的位置固定在数据的<code>最低位之后</code>。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-091024201.png" alt="mark"></p><h3 id="3-1-原码"><a href="#3-1-原码" class="headerlink" title="3.1 原码"></a>3.1 原码</h3><ul><li>用机器数的最高位来代表该数的符号，其余的各位表示数的绝对值    </li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-091658245.png" alt="mark"></p><h3 id="3-2-反码"><a href="#3-2-反码" class="headerlink" title="3.2 反码"></a>3.2 反码</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-091855834.png" alt="mark"></p><ul><li>反码通常用于原码求补码的中间过渡</li><li>反码<ul><li>若符号位为0，则反码和原码相同</li><li>若符号位为1，则数值位全部取反</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-092022869.png" alt="mark"></p><h3 id="3-3-补码"><a href="#3-3-补码" class="headerlink" title="3.3 补码"></a>3.3 补码</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-093338403.png" alt="mark"></p><ul><li>正数的补码和原码相同</li><li>负数的补码<ul><li>先求出反码</li><li>反码的基础上+1（需要注意进位的问题）</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-093400463.png" alt="mark"></p><ul><li>补码如何求原码？<ul><li>正数的补码和原码一样</li><li><strong>负数 ：数值位全部取反，然后+1</strong></li></ul></li></ul><h3 id="3-4-移码"><a href="#3-4-移码" class="headerlink" title="3.4 移码"></a>3.4 移码</h3><ul><li><strong>移码的特性：非常方便比较大小</strong></li><li>只能用于表示整数</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-093731979.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-093824082.png" alt="mark"></p><h3 id="3-5-例题小结"><a href="#3-5-例题小结" class="headerlink" title="3.5 例题小结"></a>3.5 例题小结</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-094010561.png" alt="mark"></p><ul><li><strong>如何从[x]补 求得 [-x]补</strong><ul><li><strong>技巧：符号位 数值位 全部取反</strong></li><li><strong>并且末尾+1</strong></li></ul></li><li><strong>转换技巧小结</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210328-094226591.png" alt="mark"></p><h2 id="4-补码的作用和由来"><a href="#4-补码的作用和由来" class="headerlink" title="4. 补码的作用和由来"></a>4. 补码的作用和由来</h2><ul><li><strong>原因：原码的加减法和无符号的加减法的差异</strong><ul><li>因此需要涉及一种算法：用加法代替减法</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-204046237.png" alt="mark"></p><ul><li><strong>模m计算法则（详情请学习离散数学）</strong><ul><li>如采用时钟，则相当于对12取模（-3和9的地位是等价的）</li><li>(mod 12)相当于把所有的整数分为了12类（余数为0-11）</li><li>mod12 属于相同的数，都是属于同一类，是等价的</li><li><strong>图示如下：这样就相当于把-3 改为了 +9等等（加法代替了减法）</strong></li><li><strong>这里的 -3 和 9 互为补数，他们的绝对值之和是等于模的（12）</strong></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-204307371.png" alt="mark"></p><ul><li>如计算机的<strong>机器字长是8bit</strong>，那么超出这个范围的话，只保留8为，那么就<strong>相当于mod 2^8 的条件</strong><ul><li>那么<strong>补数 = 2^8 - 负数的绝对值</strong></li><li><strong>补数 就是 补码的原生定义</strong></li><li>针对上个例子如图所示</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-205012290.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-205148396.png" alt="mark"></p><ul><li><strong>再来看个例子</strong><ul><li>补码的加减法：符号位一起加入计算</li><li>注意：加法会有溢出的产生</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-205556014.png" alt="mark"></p><h2 id="5-定点数的移位运算"><a href="#5-定点数的移位运算" class="headerlink" title="5. 定点数的移位运算"></a>5. 定点数的移位运算</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-205917524.png" alt="mark"></p><h3 id="5-1-算数移位"><a href="#5-1-算数移位" class="headerlink" title="5.1 算数移位"></a>5.1 算数移位</h3><h4 id="5-1-1-原码的移位规则"><a href="#5-1-1-原码的移位规则" class="headerlink" title="5.1.1 原码的移位规则"></a>5.1.1 原码的移位规则</h4><ol><li><strong>整数的算数右移</strong><ul><li>相当于除以2的操作</li><li>高位补0，低位舍弃</li><li>若舍弃的位不等于0，那么会造成精度的丢失</li></ul></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-210129544.png" alt="mark"></p><ol start="2"><li><strong>整数的算数左移</strong><ul><li>相当于乘以2的规则</li><li>低位补0，高位舍弃</li><li>若舍弃的位不等于0，则会造成严重的精度错误</li></ul></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-210327660.png" alt="mark"></p><ol start="3"><li><strong>小数的原理同整数</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-210550762.png" alt="mark"></p><h4 id="5-1-2-反码的算数移位"><a href="#5-1-2-反码的算数移位" class="headerlink" title="5.1.2 反码的算数移位"></a>5.1.2 反码的算数移位</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-210741679.png" alt="mark"></p><ol><li><strong>正数的反码移位</strong></li></ol><ul><li>同原码</li></ul><ol start="2"><li><strong>负数的反码移位</strong></li></ol><ul><li>右移除2，高位补1，低位舍弃</li><li>左移乘2，低位补1，高位舍弃</li><li>因为原码和反码的0和1互为相反</li></ul><h4 id="5-1-3-补码的算数移位"><a href="#5-1-3-补码的算数移位" class="headerlink" title="5.1.3 补码的算数移位"></a>5.1.3 补码的算数移位</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-211035647.png" alt="mark"></p><ol><li><strong>正数的反码移位</strong></li></ol><ul><li>同原码</li></ul><ol start="2"><li><strong>负数的反码移位</strong></li></ol><ul><li>右移除2，补位同反码 ，高位补1，低位舍弃</li><li>左移乘2，补码同原码 ，低位补0，高位舍弃</li><li>负数补码 = 反码末尾+1<ul><li>导致反码最右边几个连续的1都因进位而变为0，直到进位碰到第一个0为止</li></ul></li><li><strong>规律 ： 负数补码中，最右边的1及其右边同原码，最右边的左边同反码</strong></li></ul><h4 id="5-1-4-算数移位小结"><a href="#5-1-4-算数移位小结" class="headerlink" title="5.1.4 算数移位小结"></a>5.1.4 算数移位小结</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-213119125.png" alt="mark"></p><h3 id="5-2-逻辑移位"><a href="#5-2-逻辑移位" class="headerlink" title="5.2 逻辑移位"></a>5.2 逻辑移位</h3><ul><li>看作对<strong>无符号数的算数移位</strong></li><li>左移右移都补0</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-213352208.png" alt="mark"></p><ol><li><strong>RGB的应用</strong></li></ol><ul><li>用3B来存储RGB的值</li><li>不断的右移就是RGB对应的机器码</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-213528606.png" alt="mark"></p><h3 id="5-3-循环移位"><a href="#5-3-循环移位" class="headerlink" title="5.3 循环移位"></a>5.3 循环移位</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-213703982.png" alt="mark"></p><ul><li>对于加法产生的进位超过数据字长<ul><li>计算机采用进位位（CF）来记录进位值的大小</li><li>具体左移右移如下所示</li><li><strong>作用：适合将数据的高位和低位进行调换（大端存储和小端存储）</strong></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-213834957.png" alt="mark"></p><h3 id="5-4-小结"><a href="#5-4-小结" class="headerlink" title="5.4 小结"></a>5.4 小结</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-213948591.png" alt="mark"></p><h2 id="6-定点数的溢出"><a href="#6-定点数的溢出" class="headerlink" title="6. 定点数的溢出"></a>6. 定点数的溢出</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-223331029.png" alt="mark"></p><p><strong>发生的原因及分类</strong></p><ul><li>上溢：两个正数相加得到一个负数</li><li>下溢：两个负数相加得到一个正数</li></ul><p><strong>举例描述</strong></p><ul><li>三位二进制位的原码加法</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-221009343.png" alt="mark"></p><h3 id="6-1-原码加法的规则"><a href="#6-1-原码加法的规则" class="headerlink" title="6.1 原码加法的规则"></a>6.1 原码加法的规则</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-214826290.png" alt="mark"></p><h3 id="6-2-采用一位符号位"><a href="#6-2-采用一位符号位" class="headerlink" title="6.2 采用一位符号位"></a>6.2 采用一位符号位</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-221219755.png" alt="mark"></p><ul><li><strong>符合规律</strong><ul><li>正 + 正 = 负</li><li>负 + 负 = 正</li></ul></li></ul><h3 id="6-3-采用一位符号位并判断进位"><a href="#6-3-采用一位符号位并判断进位" class="headerlink" title="6.3 采用一位符号位并判断进位"></a>6.3 采用一位符号位并判断进位</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-221821701.png" alt="mark"></p><ul><li><p>符号位的进位和最高数位的进位C1</p><ul><li>相同则说明没有溢出</li><li>否则表示发生了溢出</li></ul></li><li><p>计算机可以简单的通过异或两个进位的值运算得到是否产生溢出</p></li></ul><h3 id="6-4-采用双符号位"><a href="#6-4-采用双符号位" class="headerlink" title="6.4 采用双符号位"></a>6.4 采用双符号位</h3><ul><li><strong>双符号位又叫做模4补码</strong></li><li>正数的符号位是00</li><li>负数的符号位是11</li></ul><p><strong>结果规则：</strong></p><ul><li>符号位00 ：结果为正 无溢出</li><li>符号位11 :   结果为负 无溢出</li><li>10 ： 1表示原来的应该是负的 结果却是正的</li><li>01 ： 0表示原来的应该是正的 结果却是负的</li></ul><p><strong>举个例子：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-222201396.png" alt="mark"></p><p><strong>注意：</strong></p><ul><li>使用双符号位：并不是有两个符号位，而是机器复制了一个符号位，这样并不会造成数据的扩展</li></ul><h3 id="6-5-溢出的原因"><a href="#6-5-溢出的原因" class="headerlink" title="6.5 溢出的原因"></a>6.5 溢出的原因</h3><ul><li><strong>目前的计算结果超出了机器字长所能表示的范围</strong></li></ul><p><strong>符号扩展</strong></p><ul><li><strong>正整数的扩展</strong><ul><li>在符号位后的高位补上0</li></ul></li><li><strong>负整数的扩展</strong><ul><li>原码：在符号位和数值位之间补0</li><li>反码：在符号位和数值位之间补1</li><li><strong>补码：在符号位和数值位之间补1</strong><ul><li>找到最右边的1</li><li>右半部分同原码</li><li>左半部分同反码</li></ul></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-222841325.png" alt="mark"></p><p><strong>小数的扩展</strong></p><ul><li><strong>正小数</strong><ul><li>在尾部添加0</li></ul></li><li><strong>负小数</strong><ul><li>原码 ：在末尾添0</li><li>反码 ： 在末尾添1</li><li>补码 ： 在末尾添0<ul><li>找到最右边的1</li><li>右半部分同原码</li><li>左半部分同反码</li></ul></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-223229253.png" alt="mark"></p><h2 id="7-定点数的乘-除法原理"><a href="#7-定点数的乘-除法原理" class="headerlink" title="7. 定点数的乘/除法原理"></a>7. 定点数的乘/除法原理</h2><h3 id="7-1-乘法原理"><a href="#7-1-乘法原理" class="headerlink" title="7.1 乘法原理"></a>7.1 乘法原理</h3><ol><li><strong>首先看看10进制乘法原理</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-220141435.png" alt="mark"></p><ol start="2"><li><strong>二进制的原码乘法</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-220334359.png" alt="mark"></p><ol start="3"><li>以上是手算的方式，如果考虑用计算机如何实现？<ul><li>实际的数字有正负，符号位如何处理</li><li>乘积的位数扩大一倍，如何处理？</li><li>4个位积都要保存下来，最后统一相加？</li></ul></li></ol><h4 id="7-1-1-原码一位乘法计算"><a href="#7-1-1-原码一位乘法计算" class="headerlink" title="7.1.1 原码一位乘法计算"></a>7.1.1 原码一位乘法计算</h4><ul><li>首先回忆一下运算器的组成</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-220936083.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-221034940.png" alt="mark"></p><ul><li><strong>对于乘法而言（实现方法：先加法再移位 重复n次）</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-221056544.png" alt="mark"></p><ul><li><strong>原码一位乘法计算方法：</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-223316038.png" alt="mark"></p><p><strong>举个例子</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-221454132.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-221722710.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-222411004.png" alt="mark"></p><ul><li><strong>手算做题过程：采用双符号位</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-222742601.png" alt="mark"></p><ul><li><strong>本质 ： n 轮的加法和逻辑右移</strong></li></ul><h4 id="7-1-2-补码的一位乘法（Booth-算法）"><a href="#7-1-2-补码的一位乘法（Booth-算法）" class="headerlink" title="7.1.2 补码的一位乘法（Booth 算法）"></a>7.1.2 补码的一位乘法（Booth 算法）</h4><ul><li><strong>计算方式</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-223407997.png" alt="mark"></p><ul><li><p>所谓的辅助位：初始化就是在最后加了一位0</p></li><li><p>实现方式： n 轮加法 和 补码的算数移位（最后还需多一轮加法，符号位）</p></li></ul><p><strong>举个例子 ： 需要采用双符号位</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-223600933.png" alt="mark"></p><ul><li><strong>手算过程 ： 双符号位</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-224133466.png" alt="mark"></p><h4 id="7-1-3-小结"><a href="#7-1-3-小结" class="headerlink" title="7.1.3 小结"></a>7.1.3 小结</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-224526001.png" alt="mark"></p><h3 id="7-2-除法原理"><a href="#7-2-除法原理" class="headerlink" title="7.2 除法原理"></a>7.2 除法原理</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-224715815.png" alt="mark"></p><ul><li><strong>首先来看看十进制除法（思想：尽可能拼凑出余数）</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-105343294.png" alt="mark"></p><ul><li><strong>手算二进制除法举例</strong></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-165502051.png" alt="mark" style="zoom:80%;" /><ul><li>再来回顾运算器的组成</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-165709748.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-165724089.png" alt="mark"></p><h4 id="7-2-1-原码的一位除法（恢复余数法）"><a href="#7-2-1-原码的一位除法（恢复余数法）" class="headerlink" title="7.2.1 原码的一位除法（恢复余数法）"></a>7.2.1 原码的一位除法（恢复余数法）</h4><ul><li><strong>符号单独用异或来确定。</strong></li><li><strong>计算机会默认上商1，如果搞错了再商0，并且恢复余数。</strong></li></ul><p><strong>计算方式如下所示：</strong></p><ul><li>数值位为 n , 逻辑左移需要作n 次</li><li>加法 n + 1次  </li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-171502583.png" alt="mark"></p><p><strong>举个例子</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-170430344.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-170548702.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-171143595.png" alt="mark"></p><ul><li><strong>恢复余数法（手算）</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-171353550.png" alt="mark"></p><h4 id="7-2-2-原码的一位除法（不恢复余数法）"><a href="#7-2-2-原码的一位除法（不恢复余数法）" class="headerlink" title="7.2.2 原码的一位除法（不恢复余数法）"></a>7.2.2 原码的一位除法（不恢复余数法）</h4><p><strong>计算方法如下</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-172331806.png" alt="mark"></p><ul><li>上面那个例子，中间过程推导一下，如下图所示：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-171745622.png" alt="mark"></p><ul><li><strong>操作合并为 ：（余数*2 + 除数）</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-172034278.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-172211278.png" alt="mark"></p><p><strong>小结：</strong></p><ul><li>加/ 减 共 <code>n + 1</code> 次，每次加减确定一位商</li><li>左移 n 次，最后一次加减完不移位</li><li>最后因为余数可能为负，还需要一次的恢复余数</li></ul><h4 id="7-2-3-补码的一位除法运算"><a href="#7-2-3-补码的一位除法运算" class="headerlink" title="7.2.3 补码的一位除法运算"></a>7.2.3 补码的一位除法运算</h4><p><strong>补码除法</strong></p><ul><li>符号位参与运算</li><li>被除数/余数，除数采用双符号位</li></ul><p><strong>规则如下</strong></p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-173050847.png" alt="mark" style="zoom:67%;" /><p><strong>举个例子</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-173247343.png" alt="mark"></p><p><strong>注意</strong></p><ul><li>末位的商恒为1，这样带来的误差是非常小的</li><li>补码商最后一步，不需要恢复余数</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-173442600.png" alt="mark"></p><p><strong>除法小结</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210412-173458313.png" alt="mark"></p><h2 id="8-C语言中的强制类型转换"><a href="#8-C语言中的强制类型转换" class="headerlink" title="8. C语言中的强制类型转换"></a>8. C语言中的强制类型转换</h2><ul><li>前提 ： C语言中的定点整数使用补码进行表示的</li><li>注意：数值范围没有负数的则为无符号位的数，有负数范围的则为有符号位的数</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-104820948.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输出时：</span><br><span class="line">%u无符号十进制整数</span><br><span class="line">%d有符号十进制整数</span><br><span class="line">%0无符号八进制</span><br><span class="line">%x无符号十六进制整数</span><br><span class="line">在计算机中数据都是以补码形式存储的，%u无符号输出，没有符号位，是正数；%d有符号输出，有符号位，符号位在最高位。</span><br></pre></td></tr></table></figure><h3 id="8-1-有符号和无符号的转换"><a href="#8-1-有符号和无符号的转换" class="headerlink" title="8.1 有符号和无符号的转换"></a>8.1 有符号和无符号的转换</h3><ul><li>C语言中常利用强制类型转换，有时候强制类型转换的结果却不是我们希望得到的，因为计算机存储数据是以<code>补码</code>形式存储的。</li><li>有时候强制类型转换可能会改变数值，可能是数据类型有无符号位导致的。<ul><li>无符号位是正数就不用转换，因为正数原码=补码</li><li>有符号位的数，根据符号位是0还是1来判断是否需要转换，那么如果符号位是1，是负数就要转换，数值当然会不同。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">short x=<span class="number">-4321</span>;</span><br><span class="line"><span class="keyword">unsigned</span> short y=(<span class="keyword">unsigned</span> short)x;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"x=%d,y=%u\n"</span>,x,y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果如下：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-105040654.png" alt="mark"></p><ul><li>可以看出y值和x值没有一点关系，咱们将其都转换成二进制，我们便知道了为什么。且看二进制转换表；</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-105102281.png" alt="mark"></p><ul><li>由于电脑是64位，所以转换就是64个二进制数，至于为什么16位往左所有数都是1，这就涉及到了符号扩展</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-105138559.png" alt="mark"></p><p><strong>小结：</strong></p><ul><li>可以看出，强制类型转换结果相应位置的值不变，仅仅只改变了解释这些位的方式，是short解释，还是<code>unsigned short</code> 解释，这两种方式。</li></ul><p>同样的我们再看一段代码仔细揣摩揣摩：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> short x=<span class="number">65535</span>;</span><br><span class="line">short y=(short)x;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"x=%u,y=%d\n"</span>,x,y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-105350695.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-105358683.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-105404461.png" alt="mark"></p><ul><li>相应位置数值相等，但是表示结果不同，那是因为解释方式不同；unsigned short 和short两种解释 方式。</li></ul><h3 id="8-2-不同字长的整数之间的转换"><a href="#8-2-不同字长的整数之间的转换" class="headerlink" title="8.2 不同字长的整数之间的转换"></a>8.2 不同字长的整数之间的转换</h3><h4 id="8-2-1-大字长变量向小字长变量强制类型转换"><a href="#8-2-1-大字长变量向小字长变量强制类型转换" class="headerlink" title="8.2.1 大字长变量向小字长变量强制类型转换"></a>8.2.1 大字长变量向小字长变量强制类型转换</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">165537</span>,u=<span class="number">-34991</span>;  <span class="comment">//int 4B  </span></span><br><span class="line">short y=(short)x,v=(short)u; <span class="comment">// short 2B</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"x=%d,y=%d\n"</span>,x,y);   </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"u=%d,v=%d\n"</span>,u,v);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当大字长变量向小字长变量强制类型转换时，系统将多余的高位字长部分直接截断舍去，低位直接赋值</span></span><br></pre></td></tr></table></figure><p><strong>结果显示：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-105544482.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-105805700.png" alt="mark"></p><p><strong>小结：</strong></p><ul><li>当大字长变量向小字长变量强制类型转换时，系统将多余的高位字长部分直接截断舍去，低位直接赋值</li></ul><h4 id="8-2-2-小字长变量向大字长变量强制类型转换"><a href="#8-2-2-小字长变量向大字长变量强制类型转换" class="headerlink" title="8.2.2 小字长变量向大字长变量强制类型转换"></a>8.2.2 小字长变量向大字长变量强制类型转换</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">short x=<span class="number">-4321</span>; <span class="comment">// short 2B</span></span><br><span class="line"><span class="keyword">int</span> y=x; <span class="comment">//int 4B</span></span><br><span class="line"><span class="keyword">unsigned</span> short u=(<span class="keyword">unsigned</span> short)x; <span class="comment">//无符号数的符号拓展直接高位添0即可</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> v=u;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"x=%d,y=%d\n"</span>,x,y);   </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"u=%u,v=%u\n"</span>,u,v);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果显示：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-111957718.png" alt="mark"></p><ul><li>这里我们转换成十六进制输出</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">short x=<span class="number">-4321</span>; <span class="comment">// short 2B</span></span><br><span class="line"><span class="keyword">int</span> y=x; <span class="comment">//int 4B</span></span><br><span class="line"><span class="keyword">unsigned</span> short u=(<span class="keyword">unsigned</span> short)x;<span class="comment">//无符号数的符号拓展直接高位添0即可</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> v=u;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"x=%d,y=%d\n"</span>,x,y);   </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"u=%x,v=%u\x"</span>,u,v);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-112042907.png" alt="mark"></p><p><strong>小结</strong></p><ul><li><p>短字长整数到长字长整数的转换，不仅要使相应的位置相等，<code>高位部分还会扩展为原数字的符号位</code>。</p></li><li><p>char类型为8位ASCII码整数，转换成int型时，高位部分补0即可。ASCII码由7位二进制数字组成。</p></li><li><p>无符号数的符号拓展直接高位添0即可</p></li></ul><h2 id="9-数据的存储和排列（大小端模式）"><a href="#9-数据的存储和排列（大小端模式）" class="headerlink" title="9. 数据的存储和排列（大小端模式）"></a>9. 数据的存储和排列（大小端模式）</h2><ul><li><p>注意：<code>在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8bit</code>。</p><ul><li><strong>现代计算机基本都采用的是字节编址，即每个地址编号中存放1个字节的数据</strong>。</li><li><strong>多字节的数据都存放在连续的字节序列中</strong>，根据数据中各字节在连续字节序列中的排位顺序不同，可以分为<ul><li>大端模式</li><li>小端模式</li></ul></li></ul></li><li><p><code>大端模式</code>：<code>指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中</code>，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。</p><ul><li><strong>符合人类阅读的习惯</strong></li><li>高地址：存放最低有效字节</li><li>低地址：存放最高有效字节</li></ul></li><li><p><code>小端模式</code>：<code>指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中</code>，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。</p><ul><li><strong>符合机器的处理方式</strong></li></ul></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-113449083.png" alt="mark" style="zoom:67%;" /><h3 id="9-1-大小端的原因？"><a href="#9-1-大小端的原因？" class="headerlink" title="9.1 大小端的原因？"></a>9.1 大小端的原因？</h3><ul><li><code>在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8bit</code>。</li><li>在C语言中除了<code>8bit</code>的<code>char</code>之外，还有<code>16bit</code>的<code>short</code>型，<code>32bit的long</code>型（要看具体的编译器），另外，对于位数大于 8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。 因此就导致了大端存储模式和小端存储模式</li></ul><hr><ul><li>对于 大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。</li><li>小端模式，刚好相反。<strong>我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。</strong>有些ARM处理器还可以随时在程序中(在ARM Cortex 系列使用REV、REV16、REVSH指令 )进行大小端的切换。</li></ul><h3 id="9-2-边界对齐的存储方式"><a href="#9-2-边界对齐的存储方式" class="headerlink" title="9.2 边界对齐的存储方式"></a>9.2 边界对齐的存储方式</h3><ul><li>假设存储字长32位，可按<strong>字节、半字和字寻址。</strong><ul><li><code>位、字节、字是计算机数据存储的单位。</code></li><li><code>位是最小的存储单位，每一个位存储一个1位的二进制码，</code></li><li><code>一个字节由8位组成。</code></li><li><code>而字通常为16、32或64个位组成。</code></li><li><code>一个存储字可以是多个字节组成。</code></li></ul></li><li><strong>对于32位计算机，数据以<code>边界对齐</code>方式存储，半字地址一定是2的整数倍，字地址一定是4的整数倍</strong>，这样无论所取的数据是字节、半字还是字。<strong>均可一次访存取出。</strong><ul><li>所存储的数据不满足上诉要求时，通过填充空白字节使其符合要求。这样虽然浪费了一些存储空间，但是却<code>提高了取指令和取数据的速度</code>。</li></ul></li><li><strong>不按边界对齐方式存储的缺点</strong>：半字长或字长的指令可能会存储在两个存储字中，此时需要<strong>两次访存</strong><ul><li>并且对高低字节的位置进行调整、连接后才能得到想要的完整指令或数据，从而影响了指令的执行效率和速度。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-151000210.png" alt="mark"></p><p><strong>举个例子：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-150339300.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210421-150506377.png" alt="mark"></p><p><strong>注意：</strong></p><ul><li><strong>边界对齐的存储方式使用了空间换时间的策略</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;计算机组成原理-04-数据的表示&quot;&gt;&lt;a href=&quot;#计算机组成原理-04-数据的表示&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理-04-数据的表示&quot;&gt;&lt;/a&gt;计算机组成原理-04-数据的表示&lt;/h2&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;本篇内容多涉及计算，内容较为硬核，请耐心观看&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210331-205829908.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-定点数和浮点数的区别&quot;&gt;&lt;a href=&quot;#1-定点数和浮点数的区别&quot; class=&quot;headerlink&quot; title=&quot;1. 定点数和浮点数的区别&quot;&gt;&lt;/a&gt;1. 定点数和浮点数的区别&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;根据小数点的位置是否固定，在计算机内有两种数据格式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定点数&lt;/li&gt;
&lt;li&gt;浮点数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;定点表示：约定机器数中的小数点位置固定不变，小数点不再用“,”表示，而是约定了它的位置&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-无符号数和有符号数&quot;&gt;&lt;a href=&quot;#2-无符号数和有符号数&quot; class=&quot;headerlink&quot; title=&quot;2. 无符号数和有符号数&quot;&gt;&lt;/a&gt;2. 无符号数和有符号数&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;无符号数&lt;/strong&gt;：指整个机器字长的全部二进制位均为数值位，没有符号位。若机器字长为8位，则数的表示范围 &lt;code&gt;0~2^8-1&lt;/code&gt; , 即&lt;code&gt;0~255&lt;/code&gt;。&lt;ul&gt;
&lt;li&gt;无符号数一般只代表整数，不代表小数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有符号数&lt;/strong&gt;：在机器中，数的正负我们无法识别，但是我们可以用&lt;strong&gt;二进制数来代替正负号。一般‘0’为正，‘1’为负&lt;/strong&gt;，符号位一般在有效数的最前面。若机器字长为8位，是有符号数，则数的表示范围为 -2^7&lt;del&gt;2^7-1 ，即-128&lt;/del&gt;127。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
      <category term="计算机组成原理" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-06-核心组成部分</title>
    <link href="http://zhuuu.work/2021/03/26/RabbitMQ/RabbitMQ-06-%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/"/>
    <id>http://zhuuu.work/2021/03/26/RabbitMQ/RabbitMQ-06-%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/</id>
    <published>2021-03-26T08:02:24.000Z</published>
    <updated>2021-04-12T01:41:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-06-核心组成部分"><a href="#RabbitMQ-06-核心组成部分" class="headerlink" title="RabbitMQ-06-核心组成部分"></a>RabbitMQ-06-核心组成部分</h2><h2 id="1-核心组成概览"><a href="#1-核心组成概览" class="headerlink" title="1. 核心组成概览"></a>1. 核心组成概览</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-114609454.png" alt="mark"></p><p><strong>核心概念：</strong></p><ul><li><strong>Server</strong>：又称Broker ,接受客户端的连接，实现AMQP实体服务。 安装rabbitmq-server</li><li><strong>Connection</strong>：连接，应用程序与Broker的网络连接 TCP/IP/ 三次握手和四次挥手</li><li><strong>Channel</strong>：网络信道，几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对各Channel，每个Channel代表一个会话任务。</li><li><strong>Message</strong> :消息：服务与应用程序之间传送的数据，由Properties和body组成，Properties可是对消息进行修饰，比如消息的优先级，延迟等高级特性，Body则就是消息体的内容。</li><li><strong>Virtual Host</strong> 虚拟地址，用于进行逻辑隔离，最上层的消息路由，一个虚拟主机可以有若干个Exhange和Queue，同一个虚拟主机里面不能有相同名字的Exchange</li><li><strong>Exchange</strong>：交换机，接受消息，根据路由键发送消息到绑定的队列。(==不具备消息存储的能力==)</li><li><strong>Bindings</strong>：Exchange和Queue之间的虚拟连接，binding中可以保护多个routing key.</li><li><strong>Routing key</strong>：是一个路由规则，虚拟机可以用它来确定如何路由一个特定消息。</li><li><strong>Queue</strong>：队列：也成为Message Queue,消息队列，保存消息并将它们转发给消费者。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-144505890.png" alt="mark"></p><a id="more"></a><h2 id="2-运行流程"><a href="#2-运行流程" class="headerlink" title="2. 运行流程"></a>2. 运行流程</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-144556342.png" alt="mark"></p><ul><li><strong>Producer ：</strong> 生产者创建消息，然后发布到RabbitMQ中，消息一般包含两个部分：消息体和标签（Label）。消息体也可以称为<code>payload</code>, 在实际的应用中，消息体一般是一个带有业务逻辑结构的数据，比如一个JSON字符串，当然可以进一步对这个 消息体进行序列化操作。</li><li><strong>Consumer :</strong> 消费者连接到rabbitMQ服务器，并订阅到该队列上。当消费者消费一条消息的时候，只是消费消息体（payload）。在消息路由的过程中，消息的标签会被丢弃，存入到队列的消息只有消息体，消费者也只会得到消息体，也就是不知道消息的生产者是谁，，当然消费者也不需要知道这些。</li><li><strong>Broker :</strong> 对于rabbitMQ来说，一个rabbitMQ broker 可以看作一台服务节点，也就是服务器</li></ul><p><strong>注意</strong></p><ul><li><p>真实的情况是，生产者将消息发送到<code>Exchange</code>,而不是将消息发送到队列中，由交换机将消息路由到一个或者多个队列中。如果路由不到，或许会返回给生产者，或许直接丢弃。</p></li><li><p>如果不填，默认是一定存在一个交换机的</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-145855934.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-145901162.png" alt="mark"></p><h2 id="3-队列"><a href="#3-队列" class="headerlink" title="3. 队列"></a>3. 队列</h2><ul><li>AMQP 中的队列（queue）跟其他消息队列或任务队列中的队列是很相似的：它们存储着即将被应用消费掉的消息。</li></ul><h3 id="3-1-属性"><a href="#3-1-属性" class="headerlink" title="3.1 属性"></a>3.1 属性</h3><p>队列跟交换机共享某些属性，<strong>但是队列也有一些另外的属性。</strong></p><ul><li><p>Name</p></li><li><p>Durable（消息代理重启后，队列依旧存在）</p></li><li><p>Exclusive（只被一个连接（connection）使用，而且当连接关闭后队列即被删除）</p></li><li><p>Auto-delete（当最后一个消费者退订后即被删除</p></li><li><p>Arguments（一些消息代理用他来完成类似与 TTL 的某些额外功能）</p></li></ul><h3 id="3-2-队列的创建"><a href="#3-2-队列的创建" class="headerlink" title="3.2 队列的创建"></a>3.2 队列的创建</h3><ul><li>队列在声明（declare）后才能被使用。如果一个队列尚不存在，声明一个队列会创建它。</li><li>如果声明的队列已经存在，并且属性<strong>完全相同</strong>，那么此次声明不会对原有队列产生任何影响。</li><li>如果声明中的属性与已存在队列的<strong>属性有差异</strong>，那么一个错误代码为 406 的通道级异常就会被抛出。</li></ul><h3 id="3-3-队列的持久化"><a href="#3-3-队列的持久化" class="headerlink" title="3.3 队列的持久化"></a>3.3 队列的持久化</h3><ul><li><p><strong>持久化队列<code>（Durable queues）</code>会被存储在磁盘</strong>上，当消息代理<code>（broker）</code>重启的时候，它依旧存在。</p></li><li><p><strong>没有被持久化的队列称作暂存队列</strong>（<code>Transient queues</code>）。并不是所有的场景和案例都需要将队列持久化。</p></li><li><p><strong>持久化的队列并不会使得路由到它的消息也具有持久性</strong>。倘若消息代理挂掉了，重新启动，那么在重启的过程中持久化队列会被重新声明，无论怎样，只有经过持久化的消息才能被重新恢复。</p></li></ul><h2 id="4-消费者"><a href="#4-消费者" class="headerlink" title="4. 消费者"></a>4. 消费者</h2><h3 id="4-1-消费模式"><a href="#4-1-消费模式" class="headerlink" title="4.1  消费模式"></a>4.1  消费模式</h3><ul><li><p>消息如果只是存储在队列里是没有任何用处的。被应用消费掉，消息的价值才能够体现。在 AMQP 0-9-1 模型中，有两种途径可以达到此目的：</p><ul><li>将消息投递给应用 <strong>(“push API”)</strong></li><li>应用根据需要主动获取消息 <strong>(“pull API”)</strong></li></ul></li><li><p><strong>使用 push API，应用（application）需要明确表示出它在某个特定队列里所感兴趣的，想要消费的消息。</strong>如是，我们可以说应用注册了一个消费者，或者说订阅了一个队列。一个队列可以注册多个消费者，也可以注册一个独享的消费者（当独享消费者存在时，其他消费者即被排除在外）。</p></li><li><p><strong>每个消费者（订阅者）都有一个叫做消费者标签的标识符</strong>。它可以被用来退订消息。消费者标签实际上是一个字符串。</p></li></ul><hr><ul><li>消息中间件有很多种，进程也会拿几个来对比对比，其中一种对比项就是消费模式。</li><li><strong>消息的消费模式分Push、Pull两种，或者两者兼具。</strong></li><li><strong>RabbitMQ的消费模式就是兼具Push和Pull。</strong></li></ul><h4 id="4-1-1-push-模式"><a href="#4-1-1-push-模式" class="headerlink" title="4.1.1 push 模式"></a>4.1.1 push 模式</h4><ul><li>发送端向broker端发送数据，数据内容为：<code>RabbitMQ Demo Test, Send Messages 0；RabbitMQ Demo Test, Send Messages 1；RabbitMQ Demo Test, Send Messages 2</code>，依次类推……</li></ul><p>下面是消费端的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = factory.newConnection();</span><br><span class="line">Channel channel = connection.createChannel();</span><br><span class="line">QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line">channel.basicQos(<span class="number">1</span>);</span><br><span class="line">channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, <span class="string">"consumer_zzh"</span>,consumer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">    String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">    System.out.println(<span class="string">" [X] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">    channel.basicAck(delivery.getEnvelope().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">channel.close();</span><br><span class="line">connection.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行输出：RabbitMQ Demo Test, Send Messages 0</span></span><br></pre></td></tr></table></figure><ul><li>通过<code>wirkshark</code>工具来查看上面示例代码的整个AMQP的过程（图1）：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-152428837.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">上图可以对照实例代码来看，</span><br><span class="line">比如图中：Basic.Qos和Basic.Qos-Ok就是示例代码中的：channel.basicQos(1);</span><br><span class="line">再比如图中的Basic.Ack就是示例代码中的channel.basicAck(delivery.getEnvelope().getDeliveryTag(),false);</span><br><span class="line">对于上图中的带蓝色背影的那行（即No.545，展开如下图，broker to client）</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-152554232.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以看到&#96;Delivery-Tag &#x3D; 1&#96;, 消息内容：“RabbitMQ Demo Test, Send Messages 0”。</span><br><span class="line">展开No.546，即Basic.Ack这行：</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-152717935.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以看到client to broker的Ack:delievery-tag&#x3D;1,和上面的符合。</span><br><span class="line">仔细的朋友可以看到No.548同样是broker向client发送了一条数据，通过展开数据可知：</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-152853666.png" alt="mark"></p><ul><li><p>其内包含的数据正好是下一条的消息——“RabbitMQ Demo Test, Send Messages 1”。但是在运行实例的时候是没有打印出来的，<strong>可以看图1，是broker端主动向client端发送的数据，client端没有请求。</strong></p></li><li><p><strong>在broker端发送第一条数据，即”RabbitMQ Demo Test, Send Messages 0”之后发送Ack，之后关闭Channel,到真正关闭完channel之间，broker端还是会发送(push)数据给Client, 此时Client不会在Ack此条数据了。</strong></p></li><li><p><strong>那么这样这条消息会不会丢失呢？答案是否定的，你可以再运行下consumer程序，就能消费到这条消息，rabbitmq对设置autoAck=false之后没有被Ack的消息是不会清除掉的。</strong></p></li></ul><p><strong>注意：</strong></p><ul><li>实际上如果不设置<code>channel.basicQos(1),</code>那么broker端会一次推送多条数据<br>RabbitMQ的每一数据帧（Frame）都是以0xCE结尾。</li></ul><h4 id="4-1-2-pull-模式"><a href="#4-1-2-pull-模式" class="headerlink" title="4.1.2 pull 模式"></a>4.1.2 pull 模式</h4><ul><li>同样采用wirkshark工具来观察pull模式的AMQP过程，pull模式主要是通过<code>channel,basicGet</code>方法来获取消息，示例代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GetResponse response = channel.basicGet(QUEUE_NAME, <span class="keyword">false</span>);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(response.getBody()));</span><br><span class="line">channel.basicAck(response.getEnvelope().getDeliveryTag(),<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><ul><li><code>wireshark</code>抓包结果：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210411-153157619.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可以观察No.122, No.123, No.124，这些对于上面的示例代码。</span><br><span class="line">首先是client端发送Get请求，然后broker响应请求回传消息，最后client端发送Ack. </span><br><span class="line"></span><br><span class="line">可以看到有别于push模式，broker端不会在client端没有请求的情况下来回传消息。</span><br></pre></td></tr></table></figure><h3 id="4-2-消息分发"><a href="#4-2-消息分发" class="headerlink" title="4.2 消息分发"></a>4.2 消息分发</h3><ul><li>当<code>rabbitMQ</code>有多个消费者的时候，队列收到的消息以<strong>轮询的方式</strong>分发给消费者（默认情况下）</li><li>如果有n个消费者，那么<code>rabbitMQ</code> 会把第m 条消息发给第<code>m % n</code>（取余数的方式）个消费者<ul><li><code>rabbitMQ</code>不管消息是否消费并已经（<code>Basic.Ack</code>）了消息</li><li>此时，如果当前的消费者任务繁重，而其他消费者由于性能较好很快处理完了自己的消息，那么就会造成整体吞吐量的下降<ul><li>解决的方案：<code>channel.basicQos</code> 方法限制信道上消费者所能保持最大的未确认消息的数量（即消费的最大能力，类似于TCP的滑动窗口）</li><li>但是此方法对拉模式的消费方式无效</li></ul></li></ul></li></ul><h3 id="4-3-消息的顺序性"><a href="#4-3-消息的顺序性" class="headerlink" title="4.3 消息的顺序性"></a>4.3 消息的顺序性</h3><ul><li><strong>目前很多资料显示 rabbitMQ  能够保证消息的顺序性，这是不正确的，或者说这个观点有很大的局限性</strong><ul><li>在不使用任何 rabbitMQ 的高级特性，也没有消息丢失，网络故障之类的情况发生的，并且只有一个消费者的情况下，最好也只有一个消费者的情况下可以保障消息的顺序性（即生产者发送的消息分别为 <code>msg1 msg2 msg3</code>, 那么消费者必然也是按照 <code>msg1 msg2 msg3</code> 的顺序进行消费的）</li></ul></li><li><strong>那么现在有哪些情况下消息的顺序性会被打破呢？</strong><ul><li>如果生产者使用了事务机制，在发送消息的时候遇到异常进行了回滚，那么需要重新补偿发送的这条消息，如果补偿发送实在另外一个线程实现的，那么消息在生产者这个源头就错序了。同样的，使用 <code>publisher confirm</code>时，在发生超时，中断，又或者是收到<code>Basic.Nack</code>命令的时候，那么同样需要进行补偿发送，结果会和事务机制一样发生错序。（这种情况下，我们可以认为rabbitMQ 消息的顺序性保障是从存入队列之后开始的，而不是从发送的时候就开始了）</li><li>如果生产者设置了消息的不同超时时间，并且也设置了死信队列，整体来说这样就相当于是一个延迟队列，那么消费者在消费这个队列的时候，消息消费的顺序必然不会和生产者发送的消息顺序一致</li><li>另外一种情况，如果消息设置了优先级，那么消费者消费到的顺序也必然不是一致的。</li><li>还有一种情况，如果消息以轮询的方式发送给消费者，而消费者拒绝消息从而消息重新入队的话，那么消息的消费顺序也是不一致的。</li></ul></li></ul><h3 id="4-4-弃用-QueueingConsumer"><a href="#4-4-弃用-QueueingConsumer" class="headerlink" title="4.4 弃用 QueueingConsumer"></a>4.4 弃用 QueueingConsumer</h3><ul><li><code>QueueingConsumer 在 rabbitMQ 3.x</code>版本用的如火如荼，但是在4.x 版本标记位 <code>@Deprecated</code>, 那么这个类一定有很大的缺陷</li><li><code>QueueingConsumer</code> 有几大缺陷<ul><li>首当其冲的就是内存溢出的假死问题，由于某些原因，队列中堆积了太多的消息，那么JVM就会爆出<code>java.lang.OutOfMemoryERROR</code><ul><li>这个问题可以通过<code>channel.basicQos</code>方法进行有效的解决<ul><li>原因是：<code>QueueingConsumer</code>内部使用的是<code>LinkedBlockingQueue</code> 来存储消息，而<code>basicQos</code>限制了队列的大小</li></ul></li></ul></li><li>同步递归调用<code>QueueingConsumer</code>会产生死锁</li><li><code>QueueingConsumer</code>会拖累同一个connection 下的所有信道性能</li></ul></li><li><strong>为了避免不必要的麻烦，建议全部继承<code>DefaultConsumer</code></strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-06-核心组成部分&quot;&gt;&lt;a href=&quot;#RabbitMQ-06-核心组成部分&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-06-核心组成部分&quot;&gt;&lt;/a&gt;RabbitMQ-06-核心组成部分&lt;/h2&gt;&lt;h2 id=&quot;1-核心组成概览&quot;&gt;&lt;a href=&quot;#1-核心组成概览&quot; class=&quot;headerlink&quot; title=&quot;1. 核心组成概览&quot;&gt;&lt;/a&gt;1. 核心组成概览&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-114609454.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心概念：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Server&lt;/strong&gt;：又称Broker ,接受客户端的连接，实现AMQP实体服务。 安装rabbitmq-server&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Connection&lt;/strong&gt;：连接，应用程序与Broker的网络连接 TCP/IP/ 三次握手和四次挥手&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Channel&lt;/strong&gt;：网络信道，几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对各Channel，每个Channel代表一个会话任务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Message&lt;/strong&gt; :消息：服务与应用程序之间传送的数据，由Properties和body组成，Properties可是对消息进行修饰，比如消息的优先级，延迟等高级特性，Body则就是消息体的内容。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Virtual Host&lt;/strong&gt; 虚拟地址，用于进行逻辑隔离，最上层的消息路由，一个虚拟主机可以有若干个Exhange和Queue，同一个虚拟主机里面不能有相同名字的Exchange&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Exchange&lt;/strong&gt;：交换机，接受消息，根据路由键发送消息到绑定的队列。(==不具备消息存储的能力==)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bindings&lt;/strong&gt;：Exchange和Queue之间的虚拟连接，binding中可以保护多个routing key.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Routing key&lt;/strong&gt;：是一个路由规则，虚拟机可以用它来确定如何路由一个特定消息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Queue&lt;/strong&gt;：队列：也成为Message Queue,消息队列，保存消息并将它们转发给消费者。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-144505890.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-03-校验码</title>
    <link href="http://zhuuu.work/2021/03/26/Compute_Organization/%E8%AE%A1%E7%BB%84-03-%E6%A0%A1%E9%AA%8C%E7%A0%81/"/>
    <id>http://zhuuu.work/2021/03/26/Compute_Organization/%E8%AE%A1%E7%BB%84-03-%E6%A0%A1%E9%AA%8C%E7%A0%81/</id>
    <published>2021-03-26T03:02:24.000Z</published>
    <updated>2021-03-27T12:43:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机组成原理-03-校验码"><a href="#计算机组成原理-03-校验码" class="headerlink" title="计算机组成原理-03-校验码"></a>计算机组成原理-03-校验码</h2><h2 id="1-校验码概述"><a href="#1-校验码概述" class="headerlink" title="1. 校验码概述"></a>1. 校验码概述</h2><ul><li><p>校验码：指能够<code>发现</code>或能够<code>自动纠正错误</code>的数据编码，也称检错纠错编码。</p></li><li><p>实现原理：通过加一<code>冗余码</code>，来检验或纠错编码</p></li><li><p>码距：简单来说就是两个二进制数比较，在同一数位的地方，数位值不同的个数有多少个，即码距，也称海明距离；</p></li><li><p>两种方法计算码距。比如0100和1111<br><code>直接观察法</code>：可以看出，有3个数位值不同，所以码距为3.<br><code>异或计算法</code>：0100⊕1111=1011 ，结果为1011，里面有几个1就代表有多少个数位值不同，即码距是多少，这里码距是3。</p></li></ul><a id="more"></a><h2 id="2-奇偶校验码"><a href="#2-奇偶校验码" class="headerlink" title="2. 奇偶校验码"></a>2. 奇偶校验码</h2><ul><li>实现原理： 在原编码中加一个校验位，则<code>原编码就变成了校验码</code>，它的码距为2，可以检查出奇数位错误，但不能检查出偶数位错误，增加的冗余位为奇偶校验位，一般校验位设置在原编码的最左边或最右边。</li><li>奇校验码：整个校验码（信息位+校验位）中1的个数位奇数</li><li>偶校验码：整个校验码（信息位+校验位）中1的个数位偶数</li></ul><h3 id="2-1-奇校验"><a href="#2-1-奇校验" class="headerlink" title="2.1 奇校验"></a>2.1 奇校验</h3><p><strong>如何检测出错误？</strong></p><ul><li>首先在计算机中，我们<strong>就要约定好，数据是采用奇校验还是偶校验</strong>，下面分奇校验和偶校验来说明一下奇偶校验如何检查在计算机传输数据的过程中数据是否正确。</li><li>假设我们的原始编码是<code>10110111</code>，因为我们规定计算机采用<code>奇校验</code>，所以我们在原编码最左边多加了一个校验位，并置为1，那么原编码就变成了奇校验码，有奇数（7）个1。<ul><li><code>传输过程中奇数个数据改变</code>：在传输过程中有<code>奇数个数位值发生了改变</code>，那么我们通过<code>奇校验运算</code>，可以发现现在变成了6个1，和奇校验码相比有3个数位值发生了改变，奇校验码不再有奇数个1，而是变成了偶数个1，可以判断我们的数据发生了改变，可以检查出错误。</li><li><code>传输过程中有偶数个数据改变</code>：在传输过程中有<code>偶数个数位值发生了改变</code>，那么我们通过<code>奇校验运算</code>，都是奇数，这时我们便无法通过奇校验运算判断数据是否发生了改变，<code>即无法检查出偶数个错误</code>。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-093122129.png" alt="mark"></p><h3 id="2-2-偶校验"><a href="#2-2-偶校验" class="headerlink" title="2.2 偶校验"></a>2.2 偶校验</h3><ul><li>假设我们的原始编码是<code>10110111</code>，因为我们规定计算机采用<code>偶校验</code>，所以我们在原编码最左边多加了一个校验位，并置为0，那么原编码就变成了偶校验码，有偶数（6）个1。<ul><li><code>传输过程中奇数个数据改变</code>：在传输过程中有<code>奇数个数位值发生了改变</code>，那么我们通过<code>偶校验运算</code>，可以发现现在变成了5个1，和偶校验码相比有3个数位值发生了改变，偶校验码不再有偶数个1，而是变成了奇数个1，可以判断我们的数据发生了改变，可以检查出错误。</li><li><code>传输过程中有偶数个数据改变</code>：在传输过程中有<code>偶数个数位值发生了改变</code>，那么我们通过<code>偶校验运算</code>，可以发现现在变成了6个1，和原偶校验码6个1一样，都是偶数，这时我们便无法通过偶校验运算判断数据是否发生了改变，<code>即无法检查出偶数个错误</code>。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-093311353.png" alt="mark"></p><h3 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h3><ul><li>通过上述奇偶校验两种方式校验数据，<strong>可以比较得出奇偶校验可以检测出奇数个错误而无法检查出偶数个错误，也无法纠正错误，无法定位错误位置。</strong></li></ul><h2 id="3-汉明校验码"><a href="#3-汉明校验码" class="headerlink" title="3. 汉明校验码"></a>3. 汉明校验码</h2><ul><li>一种多重奇偶校验码。</li><li><strong>实现原理</strong>：在有效信息位中加入几个校验位形成海明码，并把海明码的每一个二进制位分配到几个奇偶校验组中。当某一位出错后，就会引起有关的几个校验位的值发生变化。</li><li>特点：可以发现错误，定位错误位置，自动纠正错误。 <code>可以检测双比特错误，但只能纠正单比特错误</code>。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">纠错理论：L-1&#x3D;D+C且D≥C</span><br><span class="line">编码最小码距L越大，其检测错误的位数D越大，纠正错误的位数C也越大，且纠错能力恒小于检错能力</span><br></pre></td></tr></table></figure><h3 id="3-1-例题讲解"><a href="#3-1-例题讲解" class="headerlink" title="3.1 例题讲解"></a>3.1 例题讲解</h3><ul><li>信息为 n=4 , 校验位 k=3,求1010的海明码</li></ul><ol><li><strong>确定海明码的位数</strong></li></ol><ul><li>根据公式：<strong>2k ≥ n+k+1</strong>（若要检测两位错，则需再增加1位校验位，即k+1位）</li><li>海明码位数n+k=7，公式 <strong>2^3 ≥ n+k+1=8</strong>成立，n,k有效。设置变量来表示信息位、校验位、海明码。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-203146422.png" alt="mark"></p><ol start="2"><li><strong>确定校验位的分布</strong></li></ol><ul><li>规定校验位 pi 在海明位号位 2^(i-1) 的位置上，所以：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-203249694.png" alt="mark"></p><ol start="3"><li><strong>分组形成校验关系</strong></li></ol><ul><li>每个数据位用多个校验位来检验。</li><li>必须满足条件：<code>被校验数据位的海明码位号 = 校验该数据位的各校验位海明位号之和</code>，比如校验D3，它的海明位号H6为6，那么校验它的校验位为P3和P2，因为他们的海明位号H4和H2加起来等于6。（化为二进制的位数）</li><li>校验位不需要再被校验</li><li>分组关系如图：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-203511638.png" alt="mark"></p><ol start="4"><li><strong>校验位的取值</strong></li></ol><ul><li>Pi的值 = 第 i 组所有数据位求异或⨁</li><li>P1=D1⨁D2⨁D4=0</li><li>P2=D1⨁D3⨁D4=1</li><li>P3=D2⨁D3⨁D4=0</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-203558634.png" alt="mark"></p><ol start="5"><li><strong>海明码的校验原理</strong></li></ol><ul><li><p>每个校验组分别利用校验位和参与形成该校验位的信息位进行奇偶校验检查，即异或运算⨁，构成k个校验方程。</p><ul><li>S1=P1⨁D1⨁D2⨁D4</li><li>S2=P2⨁D1⨁D3⨁D4</li><li>S3=P3⨁D2⨁D3⨁D4</li></ul></li><li><p>若S1S2S3=000,则说明无错，否则说明出错。</p></li><li><p>这个数的值就是出错的位置，如S1S2S3=001,表示第1位出错，即H1出错，直接将该位取反就可以达到<code>纠错</code>的目的。</p></li></ul><h2 id="4-循环冗余CRC码"><a href="#4-循环冗余CRC码" class="headerlink" title="4. 循环冗余CRC码"></a>4. 循环冗余CRC码</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-203807533.png" alt="mark"></p><ul><li>基本思想：校验码中的一种。在K位信息位后拼接R位检验位，组成CRC码，这种编码也称(N,R)码</li><li>特点：可以发现错误，定位错误位置，自动纠正错误。<code>可检测出所有奇数位错，所有双比特的错和所有小于、等于校验位长度的突发错</code></li></ul><ol><li><strong>生成多项式</strong></li></ol><ul><li>首先，发送端和接受端会有一个生成多项式G(x)约定,生成多项式G(x)的最高次幂为<code>R</code>。任意一个二进制数码都可用一个系数为0或1的多项式与之对应。比如：二进制数码 1101 对应的G(x)=1<em>X^3+1</em>X^2+0<em>X^1+1</em>X^0= X^3+X^2+1</li><li>在发送端，将要传送的K位二进制信息码左移R位，将它与生成多项式G(x)所对应的的二进制数码进行<code>模2除法</code>，产生余数，生成一个R位检验码，并附在信息码后，构成一个新的二进制码（CRC）码，共K+R位。</li></ul><h3 id="4-1-例题讲解"><a href="#4-1-例题讲解" class="headerlink" title="4.1 例题讲解"></a>4.1 例题讲解</h3><ul><li>例题： 设生成多项式G(x)=X^3+X^2+1 ,信息码为 101001 ，求对应的CRC码 。</li></ul><p><strong>分析</strong></p><ul><li>分析：校验位长度：R=3 , 信息码长度：K=6 , CRC码长度：N=R+K= 9</li><li>生成多项式对应二进制码：1101</li></ul><ol><li><strong>信息码左移R位</strong></li></ol><ul><li>发送端将原信息码左移R位，低位补0：101001 000</li></ul><ol start="2"><li><strong>模2除得到余数</strong></li></ol><ul><li>方法：发送端用移位后的信息码 101001000 除以G(x)所对应的二进制数码 1101 求余数，余数除得够就写1，不够就写0，直到余数小于 1101 ，余数即为校验位的数值。</li><li>图中即为具体计算步骤，得到最后的结果CRC码为：101001 001，然后发送端将CRC码101001 001发送给接收端。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-204223140.png" alt="mark"></p><ol start="3"><li><strong>如何检错和纠错？</strong></li></ol><ul><li><p>接收端收到CRC码后，用生成的CRC码除以生成多项式G(x)所对应的的二进制数码，<strong>若余数为0，则信息码在传输过程中没有产生错误，数据正确。</strong></p></li><li><p>若接受到的CRC码为<code>C9C8C7C6C5C4C3C2C1= 101001011</code>,除以G(x)所对应的二进制码1101得到余数为010，不为0，说明数据在传输过程中产生错误。<code>010=2（10）</code>说明C2出错，将C2取反即可纠正错误。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;计算机组成原理-03-校验码&quot;&gt;&lt;a href=&quot;#计算机组成原理-03-校验码&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理-03-校验码&quot;&gt;&lt;/a&gt;计算机组成原理-03-校验码&lt;/h2&gt;&lt;h2 id=&quot;1-校验码概述&quot;&gt;&lt;a href=&quot;#1-校验码概述&quot; class=&quot;headerlink&quot; title=&quot;1. 校验码概述&quot;&gt;&lt;/a&gt;1. 校验码概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;校验码：指能够&lt;code&gt;发现&lt;/code&gt;或能够&lt;code&gt;自动纠正错误&lt;/code&gt;的数据编码，也称检错纠错编码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现原理：通过加一&lt;code&gt;冗余码&lt;/code&gt;，来检验或纠错编码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;码距：简单来说就是两个二进制数比较，在同一数位的地方，数位值不同的个数有多少个，即码距，也称海明距离；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;两种方法计算码距。比如0100和1111&lt;br&gt;&lt;code&gt;直接观察法&lt;/code&gt;：可以看出，有3个数位值不同，所以码距为3.&lt;br&gt;&lt;code&gt;异或计算法&lt;/code&gt;：0100⊕1111=1011 ，结果为1011，里面有几个1就代表有多少个数位值不同，即码距是多少，这里码距是3。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
      <category term="计算机组成原理" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-02-进制与编码</title>
    <link href="http://zhuuu.work/2021/03/25/Compute_Organization/%E8%AE%A1%E7%BB%84-02-%E8%BF%9B%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/"/>
    <id>http://zhuuu.work/2021/03/25/Compute_Organization/%E8%AE%A1%E7%BB%84-02-%E8%BF%9B%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/</id>
    <published>2021-03-25T03:02:24.000Z</published>
    <updated>2021-03-26T01:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机组成原理-02-数据的表示和运算"><a href="#计算机组成原理-02-数据的表示和运算" class="headerlink" title="计算机组成原理-02-数据的表示和运算"></a>计算机组成原理-02-数据的表示和运算</h2><h2 id="1-进制概述"><a href="#1-进制概述" class="headerlink" title="1. 进制概述"></a>1. 进制概述</h2><ol><li><strong>使用二进制的原因</strong><ul><li>二进制只有两种状态，物理电路的高电平和低电平可以很好的表示0和1</li><li>二进制的0和1正好可以分别代表 true 和 false</li><li>二进制的运算规则特别适合逻辑门电路的计算</li></ul></li></ol><a id="more"></a><ul><li><strong>10进制</strong></li></ul><blockquote><p>先说 我们最 熟悉的 10进制 , 就是 用 0~9 的数表示 , 逢 10 进 1 .</p></blockquote><ul><li><strong>16进制</strong></li></ul><blockquote><p>如果是 16 进制 , 它就是 由 0-9，A-F组成， 与10进制的对应关系是：0-9 对应 0-9；A-F对应10-15；<br>字母不区分大小写。</p></blockquote><ul><li><strong>2进制 和 8进制</strong></li></ul><blockquote><p>2进制 由 0-1组成</p><p>8进制 由 0-7组成</p></blockquote><p><strong>再看几个特别的例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 写出各个进制1-20</span><br><span class="line"></span><br><span class="line"># 一进制 </span><br><span class="line">1</span><br><span class="line">1 1</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1 1</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"># 三进制</span><br><span class="line">0 1 2</span><br><span class="line">101112</span><br><span class="line">202122</span><br><span class="line">100101102</span><br><span class="line">110111112</span><br><span class="line">120121122</span><br><span class="line">1000 .....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 七进制</span><br><span class="line">0123456</span><br><span class="line">10111213141516</span><br><span class="line">20212223242526</span><br><span class="line">30313233343536</span><br><span class="line"></span><br><span class="line"># 十进制(自己定义)</span><br><span class="line">0 1 2 3 4 5 6 7 8 9        10  11 12</span><br><span class="line">0 2 4 6 8 9 a c d f    20  22 24</span><br></pre></td></tr></table></figure><ul><li><strong>八进制</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 八进制计算下面结果</span><br><span class="line"></span><br><span class="line">2 + 3 &#x3D; 5</span><br><span class="line">2 * 3 &#x3D; 6</span><br><span class="line">4 + 5 &#x3D; 11</span><br><span class="line">4 * 5 &#x3D; 24</span><br><span class="line"></span><br><span class="line"># 运算的本质就是查数</span><br><span class="line">0 1 2 3 4 5 6 7 </span><br><span class="line">10 11 12 13 14 15 16 17</span><br><span class="line">20 21 22 23 24 25 26 27</span><br><span class="line"></span><br><span class="line">八进制计算  (进位和计算)</span><br><span class="line">277 + 333 &#x3D; </span><br><span class="line">276 * 54 &#x3D; </span><br><span class="line">237 - 54 &#x3D; </span><br><span class="line">234 &#x2F; 4 &#x3D;</span><br></pre></td></tr></table></figure><ul><li><strong>各种进制的乘法表</strong>：<a href="https://wenku.baidu.com/view/ee774a731ed9ad51f01df252.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/ee774a731ed9ad51f01df252.html</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**八进制乘法表**</span><br></pre></td></tr></table></figure><table><thead><tr><th>1*1 = 1</th><th>1*2 = 2</th><th>1*3 = 3</th><th>1*4 =4</th><th>1*5 =5</th><th>1*6 = 6</th><th>1*7 = 7</th></tr></thead><tbody><tr><td>2*2 = 2</td><td>2*3 = 6</td><td>2*4 = 10</td><td>2*5 = 12</td><td>2*6 = 14</td><td>2*7 = 16</td><td></td></tr><tr><td>3*3 = 11</td><td>3*4 = 14</td><td>3*5 = 17</td><td>3* 6 = 22</td><td>3*7 = 25</td><td></td><td></td></tr><tr><td>4*4 = 20</td><td>4 * 5= 24</td><td>4*6 = 30</td><td>4*7 = 34</td><td></td><td></td><td></td></tr><tr><td>5*5 = 31</td><td>5*6 = 36</td><td>5*7 = 43</td><td></td><td></td><td></td><td></td></tr><tr><td>6*6 = 44</td><td>6*7 = 52</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>7*7 = 61</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="2-进制转换"><a href="#2-进制转换" class="headerlink" title="2. 进制转换"></a>2. 进制转换</h2><ul><li>所谓进位计数法是一种计数方法，咱们最常用的莫过于十进制了，除此之外还有八进制、十六进制等。</li><li>这里不得不提几个概念术语：<ul><li>基数：比如说十进制、八进制和十六进制，它们的基数分别为10（0<del>9）、8（0</del>7）、16（0~15）</li><li>数位：比如二进制数1010，这里就有4个数位，从高位到低位依次的数码值为1、0、1、1</li><li>数码：比如八进制，那么数码，即数码值的范围为（0~7）</li><li>基数和数码的关系：每个数位所用到的不同数码的个数称为基</li><li>位权：每个数码所表示的数值等于该数码值乘以一个与它所在位有关的常数，这个常数称为位权。</li></ul></li></ul><ol start="2"><li><strong>二进制转换为八进制和十六进制</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-085929193.png" alt="mark"></p><ol start="3"><li><strong>十进制转换成二进制</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-090058906.png" alt="mark"></p><p><strong>注意：</strong></p><ul><li><strong>不是每一个十进制小数都可以准确的用二进制表示<code>，比如：0.3转换为二进制数，无论经过多少次</code>乘二取整<code>都</code>无法获得精确<code>的结果。</code>但任意一个二进制小数都可以用十进制小数表示！！！</strong></li></ul><h2 id="3-真值，机器数"><a href="#3-真值，机器数" class="headerlink" title="3. 真值，机器数"></a>3. 真值，机器数</h2><ul><li><strong>真值</strong>：我们日常见到的，有<code>“+”、“-”</code>号的数为真值，比如：+5，-7。真值是机器数所代表的实际值，一般为十进制数。</li><li><strong>机器数</strong>：将<code>“符号-&gt;数字化”</code>的数。一般为二进制数，比如带符号位的4位二进制数<strong>0</strong>110，最高位<code>0</code>就是符号位，这个数的<code>真值就是+6</code>。通常<code>0</code>代表“+”号，<code>1</code>代表<code>-</code>号。</li></ul><h2 id="4-BCD-码"><a href="#4-BCD-码" class="headerlink" title="4. BCD 码"></a>4. BCD 码</h2><ul><li><p>简单来说：就是用<strong>4位二进制数来表示1位十进制数（0—9）</strong>，是一种用二进制编码来代替十进制编码的方式。</p></li><li><p>BCD码可分为两类：<code>有权码和无权码</code></p></li><li><p>这种编码方法使得二进制数和十进制数之间的转换十分的快速，但4位二进制数字可以转换出16中代码的组合，因此会有6种冗余的状态。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-090452539.png" alt="mark"></p><h3 id="4-1-8421码"><a href="#4-1-8421码" class="headerlink" title="4.1 8421码"></a>4.1 8421码</h3><ul><li><strong>其中最常用的BCD码就是8421码</strong></li><li>当两个8421码进行计算时，如果结果<code>小于等于9</code>，则不作任何操作</li><li>如果计算结果<code>大于9</code>则需要进行+6的修正操作（10-18（9+9）需要进行修正，1010-10010范围）需要进行修正操作，并向高位进位</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-090727440.png" alt="mark"></p><h2 id="5-ASCII-码"><a href="#5-ASCII-码" class="headerlink" title="5. ASCII 码"></a>5. ASCII 码</h2><p>ASCII码大致由三部分组成： </p><ol><li><strong>ASCII 打印字符：</strong>数字 32–126 分配给了能在键盘上找到的字符，当您查看或打印文档时就会出现。注：十进制32代表空格 ，十进制数字 127 代表 DELETE 命令。下面是ASCII码和相应数字的对照表</li></ol><table><thead><tr><th>ASCII 码</th><th>字符</th><th></th><th>ASCII 码</th><th>字符</th><th></th><th>ASCII 码</th><th>字符</th><th></th><th>ASCII 码</th><th>字符</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>十进位</td><td>十六进位</td><td></td><td>十进位</td><td>十六进位</td><td></td><td>十进位</td><td>十六进位</td><td></td><td>十进位</td><td>十六进位</td><td></td><td></td><td></td><td></td></tr><tr><td>032</td><td>20</td><td></td><td></td><td>056</td><td>38</td><td>8</td><td></td><td>080</td><td>50</td><td>P</td><td></td><td>104</td><td>68</td><td>h</td></tr><tr><td>033</td><td>21</td><td>!</td><td></td><td>057</td><td>39</td><td>9</td><td></td><td>081</td><td>51</td><td>Q</td><td></td><td>105</td><td>69</td><td>i</td></tr><tr><td>034</td><td>22</td><td>“</td><td></td><td>058</td><td>3A</td><td>:</td><td></td><td>082</td><td>52</td><td>R</td><td></td><td>106</td><td>6A</td><td>j</td></tr><tr><td>035</td><td>23</td><td>#</td><td></td><td>059</td><td>3B</td><td>;</td><td></td><td>083</td><td>53</td><td>S</td><td></td><td>107</td><td>6B</td><td>k</td></tr><tr><td>036</td><td>24</td><td>$</td><td></td><td>060</td><td>3C</td><td>&lt;</td><td></td><td>084</td><td>54</td><td>T</td><td></td><td>108</td><td>6C</td><td>l</td></tr><tr><td>037</td><td>25</td><td>%</td><td></td><td>061</td><td>3D</td><td>=</td><td></td><td>085</td><td>55</td><td>U</td><td></td><td>109</td><td>6D</td><td>m</td></tr><tr><td>038</td><td>26</td><td>&amp;</td><td></td><td>062</td><td>3E</td><td>&gt;</td><td></td><td>086</td><td>56</td><td>V</td><td></td><td>110</td><td>6E</td><td>n</td></tr><tr><td>039</td><td>27</td><td>‘</td><td></td><td>063</td><td>3F</td><td>?</td><td></td><td>087</td><td>57</td><td>W</td><td></td><td>111</td><td>6F</td><td>o</td></tr><tr><td>040</td><td>28</td><td>(</td><td></td><td>064</td><td>40</td><td>@</td><td></td><td>088</td><td>58</td><td>X</td><td></td><td>112</td><td>70</td><td>p</td></tr><tr><td>041</td><td>29</td><td>)</td><td></td><td>065</td><td>41</td><td>A</td><td></td><td>089</td><td>59</td><td>Y</td><td></td><td>113</td><td>71</td><td>q</td></tr><tr><td>042</td><td>2A</td><td>*</td><td></td><td>066</td><td>42</td><td>B</td><td></td><td>090</td><td>5A</td><td>Z</td><td></td><td>114</td><td>72</td><td>r</td></tr><tr><td>043</td><td>2B</td><td>+</td><td></td><td>067</td><td>43</td><td>C</td><td></td><td>091</td><td>5B</td><td>[</td><td></td><td>115</td><td>73</td><td>s</td></tr><tr><td>044</td><td>2C</td><td>,</td><td></td><td>068</td><td>44</td><td>D</td><td></td><td>092</td><td>5C</td><td>\</td><td></td><td>116</td><td>74</td><td>t</td></tr><tr><td>045</td><td>2D</td><td>-</td><td></td><td>069</td><td>45</td><td>E</td><td></td><td>093</td><td>5D</td><td>]</td><td></td><td>117</td><td>75</td><td>u</td></tr><tr><td>046</td><td>2E</td><td>.</td><td></td><td>070</td><td>46</td><td>F</td><td></td><td>094</td><td>5E</td><td>^</td><td></td><td>118</td><td>76</td><td>v</td></tr><tr><td>047</td><td>2F</td><td>/</td><td></td><td>071</td><td>47</td><td>G</td><td></td><td>095</td><td>5F</td><td>_</td><td></td><td>119</td><td>77</td><td>w</td></tr><tr><td>048</td><td>30</td><td>0</td><td></td><td>072</td><td>48</td><td>H</td><td></td><td>096</td><td>60</td><td>`</td><td></td><td>120</td><td>78</td><td>x</td></tr><tr><td>049</td><td>31</td><td>1</td><td></td><td>073</td><td>49</td><td>I</td><td></td><td>097</td><td>61</td><td>a</td><td></td><td>121</td><td>79</td><td>y</td></tr><tr><td>050</td><td>32</td><td>2</td><td></td><td>074</td><td>4A</td><td>J</td><td></td><td>098</td><td>62</td><td>b</td><td></td><td>122</td><td>7A</td><td>z</td></tr><tr><td>051</td><td>33</td><td>3</td><td></td><td>075</td><td>4B</td><td>K</td><td></td><td>099</td><td>63</td><td>c</td><td></td><td>123</td><td>7B</td><td>{</td></tr><tr><td>052</td><td>34</td><td>4</td><td></td><td>076</td><td>4C</td><td>L</td><td></td><td>100</td><td>64</td><td>d</td><td></td><td>124</td><td>7C</td><td>|</td></tr><tr><td>053</td><td>35</td><td>5</td><td></td><td>077</td><td>4D</td><td>M</td><td></td><td>101</td><td>65</td><td>e</td><td></td><td>125</td><td>7D</td><td>}</td></tr><tr><td>054</td><td>36</td><td>6</td><td></td><td>078</td><td>4E</td><td>N</td><td></td><td>102</td><td>66</td><td>f</td><td></td><td>126</td><td>7E</td><td>~</td></tr><tr><td>055</td><td>37</td><td>7</td><td></td><td>079</td><td>4F</td><td>O</td><td></td><td>103</td><td>67</td><td>g</td><td></td><td>127</td><td>7F</td><td>DEL</td></tr></tbody></table><ol start="2"><li><strong>ASCII 非打印控制字符：</strong>ASCII 表上的数字 0–31 分配给了控制字符，用于控制像打印机等一些外围设备。例如，12 代表换页/新页功能。此命令指示打印机跳到下一页的开头。</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-091133175.png" alt="mark"></p><ol start="3"><li><strong>扩展 ASCII 打印字符：</strong>扩展的 ASCII 字符满足了对更多字符的需求。扩展的 ASCII 包含 ASCII 中已有的 128 个字符（数字 0–32 显示在下图中），又增加了 128 个字符，总共是 256 个。即使有了这些更多的字符，许多语言还是包含无法压缩到 256 个字符中的符号。因此，出现了一些 ASCII 的变体来囊括地区性字符和符号.</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210326-091206473.png" alt="mark"></p><p><strong>注意：</strong></p><ul><li>0-9的ASCII码值位48（0110000）-57（0111001）</li><li>即去掉高3位，只保留四位的话，正好是二进制的0-9</li><li>大写字母和小写字母转换成二进制也是同样的道理</li></ul><h2 id="6-汉字编码"><a href="#6-汉字编码" class="headerlink" title="6. 汉字编码"></a>6. 汉字编码</h2><ul><li><code>分类</code>：计算机中汉字的表示也是用二进制编码，同样是人为编码的。根据应用目的的不同，汉字编码分为外码、交换码、机内码和字形码。</li></ul><ol><li>外码（输入码）</li></ol><ul><li>外码也叫输入码，是用来将汉字输入到计算机中的一组键盘符号。常用的输入码有拼音码、五笔字型码、自然码、表形码、认知码、区位码和电报码等</li></ul><ol start="2"><li>交换码(国标码)</li></ol><ul><li>计算机内部处理的信息，都是用二进制代码表示的，汉字也不例外。</li><li>而二进制代码使用起来是不方便的，于是需要采用信息交换码。中国标准总局1981年制定了中华人民共和国国家标准GB2312–80《信息交换用汉字编码字符集–基本集》<strong>，即国标码。</strong></li><li>区位码是国标码的另一种表现形式，把国标GB2312–80中的汉字、图形符号组成一个<strong>94×94的方阵，分为94个“区”</strong>，每区包含94个“位”，其中“区”的序号由01至94，“位”的序号也是从01至94。</li><li>94个区中位置总数=94×94=8836个，其中7445个汉字和图形字符中的每一个占一个位置后，还剩下1391个空位，这1391个位置空下来保留备用。</li></ul><ol start="3"><li>机内码</li></ol><ul><li>根据国标码的规定，每一个汉字都有了确定的二进制代码，在微机内部汉字代码都用机内码<strong>，在磁盘上记录汉字代码也使用机内码。</strong></li></ul><ol start="4"><li>字形码</li></ol><ul><li>字形码是汉字的输出码，输出汉字时都采用图形方式，无论汉字的笔画多少，每个汉字都可以写在同样大小的方块中。通常用16×16点阵来显示汉字。</li><li>其实也就是0101的网格 （类似于Banner）</li></ul><p><strong>转换关系</strong></p><ul><li>国际码 = （区位码）+ 2020H<ul><li>20H = 32 ：为了传输的时候避开前32个控制字符</li></ul></li><li>汉字内码 = （国际码）+ 8080H<ul><li>80H = 128: 为了与英文的ASCII码兼容</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;计算机组成原理-02-数据的表示和运算&quot;&gt;&lt;a href=&quot;#计算机组成原理-02-数据的表示和运算&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理-02-数据的表示和运算&quot;&gt;&lt;/a&gt;计算机组成原理-02-数据的表示和运算&lt;/h2&gt;&lt;h2 id=&quot;1-进制概述&quot;&gt;&lt;a href=&quot;#1-进制概述&quot; class=&quot;headerlink&quot; title=&quot;1. 进制概述&quot;&gt;&lt;/a&gt;1. 进制概述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;使用二进制的原因&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;二进制只有两种状态，物理电路的高电平和低电平可以很好的表示0和1&lt;/li&gt;
&lt;li&gt;二进制的0和1正好可以分别代表 true 和 false&lt;/li&gt;
&lt;li&gt;二进制的运算规则特别适合逻辑门电路的计算&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
      <category term="计算机组成原理" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode--083-删除排序链表中的重复元素I</title>
    <link href="http://zhuuu.work/2021/03/25/Leetcode/Leetcode-083-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0I/"/>
    <id>http://zhuuu.work/2021/03/25/Leetcode/Leetcode-083-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0I/</id>
    <published>2021-03-25T03:02:24.000Z</published>
    <updated>2021-03-27T02:46:38.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode–083-删除排序链表中的重复元素"><a href="#Leetcode–083-删除排序链表中的重复元素" class="headerlink" title="Leetcode–083-删除排序链表中的重复元素"></a>Leetcode–083-<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">删除排序链表中的重复元素</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除所有重复的元素，使每个元素 <strong>只出现一次</strong> 。</li><li>返回同样按升序排列的结果链表。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-095204452.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,1,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-095226721.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,1,2,3,3]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围 <code>[0, 300]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li>题目数据保证链表已经按升序排列</li></ul><a id="more"></a><h2 id="算法与思路"><a href="#算法与思路" class="headerlink" title="算法与思路"></a>算法与思路</h2><ul><li>由于给定的链表是排好序的，因此<strong>重复的元素在链表中出现的位置是连续的</strong>，因此我们只需要对链表进行一次遍历，就可以删除重复的元素。</li><li>具体地，从指针cur 指向链表的头节点，随后开始对链表进行遍历<ul><li>如果当前的<em>cur</em> 与 <code>cur.next</code>对应元素相同，那么我们就将<code>cur.next</code> 从链表中移除；</li><li>否则说明链表中已经不存在其它与<code>cur</code>对应元素相同的节点，因此可以将<code>cur</code> 指向 <code>cur.next</code></li></ul></li><li>当遍历完整个链表之后，返回链表的头节点即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 特判</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 2. 处理逻辑</span></span><br><span class="line">        ListNode cur = head;                    <span class="comment">// cur 指向头节点</span></span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123;                <span class="comment">// 遍历一次链表</span></span><br><span class="line">            <span class="keyword">if</span>(cur.val == cur.next.val)&#123;        <span class="comment">// 如果相邻的链表节点是重复的</span></span><br><span class="line">                cur.next = cur.next.next;       <span class="comment">// 跳过这个节点</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                          </span><br><span class="line">                cur = cur.next;                 <span class="comment">// 否则cur向前移动一位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n) 遍历一次链表所花费的时间</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode–083-删除排序链表中的重复元素&quot;&gt;&lt;a href=&quot;#Leetcode–083-删除排序链表中的重复元素&quot; class=&quot;headerlink&quot; title=&quot;Leetcode–083-删除排序链表中的重复元素&quot;&gt;&lt;/a&gt;Leetcode–083-&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;删除排序链表中的重复元素&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;存在一个按升序排列的链表，给你这个链表的头节点 &lt;code&gt;head&lt;/code&gt; ，请你删除所有重复的元素，使每个元素 &lt;strong&gt;只出现一次&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;返回同样按升序排列的结果链表。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-095204452.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：head &amp;#x3D; [1,1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,2]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-095226721.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：head &amp;#x3D; [1,1,2,3,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,2,3]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链表中节点数目在范围 &lt;code&gt;[0, 300]&lt;/code&gt; 内&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-100 &amp;lt;= Node.val &amp;lt;= 100&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;题目数据保证链表已经按升序排列&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="链表" scheme="http://zhuuu.work/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-05-AMQP协议</title>
    <link href="http://zhuuu.work/2021/03/24/RabbitMQ/RabbitMQ-05-AMQP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://zhuuu.work/2021/03/24/RabbitMQ/RabbitMQ-05-AMQP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-03-24T07:02:24.000Z</published>
    <updated>2021-03-24T08:44:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-05-AMQP协议"><a href="#RabbitMQ-05-AMQP协议" class="headerlink" title="RabbitMQ-05-AMQP协议"></a>RabbitMQ-05-AMQP协议</h2><h2 id="1-概要"><a href="#1-概要" class="headerlink" title="1. 概要"></a>1. 概要</h2><ul><li>AMQP全称：<code>Advanced Message Queuing Protocol</code>(高级消息队列协议)。</li><li><strong>是应用层协议的一个开发标准，为面向消息的中间件设计。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-162118081.png" alt="mark"></p><ul><li><strong>工作过程：</strong><ul><li>发布者（Publisher）发布消息（Message），经由交换机（Exchange）。</li><li>交换机根据<strong>路由规则</strong>将收到的消息分发给与该交换机绑定的队列（Queue）。</li><li>最后 AMQP 代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。</li></ul></li></ul><a id="more"></a><h2 id="2-详细解释"><a href="#2-详细解释" class="headerlink" title="2. 详细解释"></a>2. 详细解释</h2><ul><li>发布者、交换机、队列、消费者都可以有多个。同时因为 AMQP 是一个网络协议，所以这个过程中的发布者，消费者，消息代理 可以分别存在于不同的设备上。</li><li>发布者发布消息时可以给消息指定各种消息属性（Message Meta-data）。有些属性有可能会被消息代理（Brokers）使用，然而其他的属性则是完全不透明的，它们只能被接收消息的应用所使用。</li><li>从安全角度考虑，网络是不可靠的，又或是消费者在处理消息的过程中意外挂掉，这样没有处理成功的消息就会丢失。基于此原因，AMQP 模块包含了一个消息确认（Message Acknowledgements）机制：当一个消息从队列中投递给消费者后，不会立即从队列中删除，直到它收到来自消费者的确认回执（Acknowledgement）后，才完全从队列中删除。</li><li>在某些情况下，例如当一个消息无法被成功路由时（无法从交换机分发到队列），消息或许会被返回给发布者并被丢弃。或者，如果消息代理执行了延期操作，消息会被放入一个所谓的死信队列中。此时，消息发布者可以选择某些参数来处理这些特殊情况。</li></ul><h2 id="3-AMQP-生产者流转过程"><a href="#3-AMQP-生产者流转过程" class="headerlink" title="3. AMQP 生产者流转过程"></a>3. AMQP 生产者流转过程</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-163035448.png" alt="mark"></p><ul><li>当客户端与<code>Broker</code>建立链接的时候，会调用<code>factory.newConnection()</code> 方法，这个方法会进一步封装成<code>Protocol Header 0-9-1</code>的报文头发送给<code>Broker</code>，以此通知<code>Broker</code>本次交互采用的是<code>AMQP 0-9-1</code>协议，紧接着<code>Broker</code>返回<code>Connection.Start</code> 来建立链接，在链接的过程中涉及的交互命令如图上过程1所示</li><li>当客户端调用<code>Connection.createChannel()</code>时候准备开启信道，其中包含的<code>Channel.Open</code> 发送给<code>Broker</code>，等待确认<code>Channel.Open-ok</code> </li><li>当客户端发送消息的时候，需要调用<code>Basic.Publish</code> ，注意这个命令和前面设计的命令有所不同，这个命令还包含了<code>Content Header</code> 和 <code>Content Body</code>, <code>Content Header</code>里面包含的是消息体的属性，例如投递模式和优先级等等，而<code>Content Body</code>包含了消息体的本身</li><li>当客户端断开资源的时候，如图过程4所示。</li></ul><h2 id="4-AMQP-消费者流转过程"><a href="#4-AMQP-消费者流转过程" class="headerlink" title="4. AMQP 消费者流转过程"></a>4. AMQP 消费者流转过程</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-163757877.png" alt="mark"></p><ul><li>当客户端与<code>Broker</code>建立链接的时候，会调用<code>factory.newConnection()</code> 方法，这个方法会进一步封装成<code>Protocol Header 0-9-1</code>的报文头发送给<code>Broker</code>，以此通知<code>Broker</code>本次交互采用的是<code>AMQP 0-9-1</code>协议，紧接着<code>Broker</code>返回<code>Connection.Start</code> 来建立链接，在链接的过程中涉及的交互命令如图上过程1所示</li><li>当客户端调用<code>Connection.createChannel()</code>时候准备开启信道，其中包含的<code>Channel.Open</code> 发送给<code>Broker</code>，等待确认<code>Channel.Open-ok</code> </li><li><strong>上面都和生产者一样</strong></li><li>在真正消费之前，消费者客户端需要向<code>Broker</code>发送<code>Basic.Consume</code>命令（channel.BasicConsume 方法）将Channel 设置为接收的模式，之后<code>Broker</code>向消费者客户端推送消息（即<code>Basic.Deliver</code> 命令），有意思的是这个<code>Basic.Deliver</code> 命令一样会携带<code>Content Header</code> 和 <code>Content Body</code></li><li>消费者接收到消息并且真正确实消费之后，向<code>Broker</code> 发送确认，即<code>Basic.Ack</code>命令</li><li>在消费者停止消费之后，主动关闭链接，这点和生产者一样</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-05-AMQP协议&quot;&gt;&lt;a href=&quot;#RabbitMQ-05-AMQP协议&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-05-AMQP协议&quot;&gt;&lt;/a&gt;RabbitMQ-05-AMQP协议&lt;/h2&gt;&lt;h2 id=&quot;1-概要&quot;&gt;&lt;a href=&quot;#1-概要&quot; class=&quot;headerlink&quot; title=&quot;1. 概要&quot;&gt;&lt;/a&gt;1. 概要&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;AMQP全称：&lt;code&gt;Advanced Message Queuing Protocol&lt;/code&gt;(高级消息队列协议)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;是应用层协议的一个开发标准，为面向消息的中间件设计。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-162118081.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;工作过程：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;发布者（Publisher）发布消息（Message），经由交换机（Exchange）。&lt;/li&gt;
&lt;li&gt;交换机根据&lt;strong&gt;路由规则&lt;/strong&gt;将收到的消息分发给与该交换机绑定的队列（Queue）。&lt;/li&gt;
&lt;li&gt;最后 AMQP 代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-04-Simple模式</title>
    <link href="http://zhuuu.work/2021/03/24/RabbitMQ/RabbitMQ-04-Simple%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zhuuu.work/2021/03/24/RabbitMQ/RabbitMQ-04-Simple%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-03-24T06:02:24.000Z</published>
    <updated>2021-03-24T07:57:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-04-Simple模式"><a href="#RabbitMQ-04-Simple模式" class="headerlink" title="RabbitMQ-04-Simple模式"></a>RabbitMQ-04-Simple模式</h2><h2 id="1-rabbitMQ角色分类"><a href="#1-rabbitMQ角色分类" class="headerlink" title="1. rabbitMQ角色分类"></a>1. rabbitMQ角色分类</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-103601463.png" alt="mark"></p><ol><li><strong>none</strong></li></ol><ul><li>不能访问<code>management plugin</code></li></ul><ol start="2"><li><strong>management : 查看自己的相关节点信息</strong></li></ol><ul><li>列出自己可以通过AMQP登入的虚拟机</li><li>查看自己的虚拟机节点 virtual hosts的queues,exchanges和bindings信息</li><li>查看和关闭自己的channels和connections</li><li>查看有关自己的虚拟机节点virtual hosts的统计信息。包括其他用户在这个节点virtual hosts中的活动信息。</li></ul><ol start="3"><li><strong>Policymaker</strong></li></ol><ul><li>包含management所有权限</li><li>查看和创建和删除自己的virtual hosts所属的policies和parameters信息。</li></ul><a id="more"></a><ol start="4"><li><strong>Monitoring</strong></li></ol><ul><li>包含management所有权限</li><li>罗列出所有的virtual hosts，包括不能登录的virtual hosts。</li><li>查看其他用户的connections和channels信息</li><li>查看节点级别的数据如clustering和memory使用情况</li><li>查看所有的virtual hosts的全局统计信息。</li></ul><ol start="5"><li><strong>Administrator</strong></li></ol><ul><li>最高权限</li><li>可以创建和删除virtual hosts</li><li>可以查看，创建和删除users</li><li>查看创建permisssions</li><li>关闭所有用户的connections</li></ul><h2 id="2-工作模式预览"><a href="#2-工作模式预览" class="headerlink" title="2. 工作模式预览"></a>2. 工作模式预览</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-113120197.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-113216449.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-113232003.png" alt="mark"></p><h2 id="3-Simple-简单模式"><a href="#3-Simple-简单模式" class="headerlink" title="3. Simple 简单模式"></a>3. Simple 简单模式</h2><h3 id="2-1-环境准备"><a href="#2-1-环境准备" class="headerlink" title="2.1 环境准备"></a>2.1 环境准备</h3><p>1：jdk1.8<br>2：构建一个maven工程<br>3：导入rabbitmq的maven依赖<br>4：启动rabbitmq-server服务<br>5：定义生产者<br>6：定义消费者<br>7：观察消息的在rabbitmq-server服务中的过程</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-111925099.png" alt="mark"></p><ul><li><strong>导入maven依赖</strong></li></ul><ol><li><strong>Java原生依赖</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-simple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>Spring依赖</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>SpringBoot 依赖</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>番外：</strong>rabbitmq和spring同属一个公司开放的产品，所以他们的支持也是非常完善，这也是为什么推荐使用rabbitmq的一个原因。</li><li>上面根据自己的项目环境进行选择即可。</li></ul><h3 id="2-2-生产者-Provider"><a href="#2-2-生产者-Provider" class="headerlink" title="2.2 生产者 (Provider)"></a>2.2 生产者 (Provider)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建链接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 3. 通过链接获取通道</span></span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"生产者"</span>);     <span class="comment">// 从工厂中获取链接</span></span><br><span class="line">            channel = connection.createChannel();               <span class="comment">// 从链接中获取通道</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 通过通道创建交换机，声明队列，绑定关系，路由key,发送消息和接收消息</span></span><br><span class="line">            String queuename = <span class="string">"queue1"</span>;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *  如果队列不存在，则会创建</span></span><br><span class="line"><span class="comment">             *  Rabbitmq不允许创建两个相同的队列名称，否则会报错。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *  @params1： queue 队列的名称</span></span><br><span class="line"><span class="comment">             *  @params2： durable 队列是否持久化</span></span><br><span class="line"><span class="comment">             *  @params3： exclusive 是否排他，即是否私有的，如果为true,会对当前队列加锁，其他的通道不能访问，并且连接自动关闭</span></span><br><span class="line"><span class="comment">             *  @params4： autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除消息。</span></span><br><span class="line"><span class="comment">             *  @params5： arguments 可以设置队列附加参数，设置队列的有效期，消息的最大长度，队列的消息生命周期等等。</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            channel.queueDeclare(queuename, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 准备消息内容并发送到通道</span></span><br><span class="line">            String message = <span class="string">"Hello 朱酱酱"</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, queuename, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 6. 关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 7. 关闭链接</span></span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码执行完毕后，这个时候可以在web控制台查看到这个队列queue的信息</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-151035330.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-151110538.png" alt="mark"></p><ul><li><strong>我们可以进行对队列的消息进行预览和测试如下：</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-151211114.png" alt="mark"></p><ul><li>进行预览和获取消息进行测试</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-151235934.png" alt="mark"></p><h3 id="2-3-消费者（Consumer）"><a href="#2-3-消费者（Consumer）" class="headerlink" title="2.3 消费者（Consumer）"></a>2.3 消费者（Consumer）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建链接工厂并且设置链接属性</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.104.46"</span>); <span class="comment">//ip</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);      <span class="comment">// 消息发在根节点上</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建链接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 3. 通过链接获取通道</span></span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">"生产者"</span>);     <span class="comment">// 从工厂中获取链接</span></span><br><span class="line">            channel = connection.createChannel();               <span class="comment">// 从链接中获取通道</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.接收消息并且处理异常</span></span><br><span class="line">            channel.basicConsume(<span class="string">"queue1"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s, Delivery message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"收到消息是"</span> + <span class="keyword">new</span> String(message.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"接收消息失败！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 6. 关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 7. 关闭链接</span></span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><strong>持久化的消息是会进行存盘的，随着服务重启还在</strong></li><li><strong>非持久化的消息也会进行存盘，但是重启就没有了</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-04-Simple模式&quot;&gt;&lt;a href=&quot;#RabbitMQ-04-Simple模式&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-04-Simple模式&quot;&gt;&lt;/a&gt;RabbitMQ-04-Simple模式&lt;/h2&gt;&lt;h2 id=&quot;1-rabbitMQ角色分类&quot;&gt;&lt;a href=&quot;#1-rabbitMQ角色分类&quot; class=&quot;headerlink&quot; title=&quot;1. rabbitMQ角色分类&quot;&gt;&lt;/a&gt;1. rabbitMQ角色分类&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210324-103601463.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;none&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;不能访问&lt;code&gt;management plugin&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;strong&gt;management : 查看自己的相关节点信息&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;列出自己可以通过AMQP登入的虚拟机&lt;/li&gt;
&lt;li&gt;查看自己的虚拟机节点 virtual hosts的queues,exchanges和bindings信息&lt;/li&gt;
&lt;li&gt;查看和关闭自己的channels和connections&lt;/li&gt;
&lt;li&gt;查看有关自己的虚拟机节点virtual hosts的统计信息。包括其他用户在这个节点virtual hosts中的活动信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;&lt;strong&gt;Policymaker&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;包含management所有权限&lt;/li&gt;
&lt;li&gt;查看和创建和删除自己的virtual hosts所属的policies和parameters信息。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-03-安装与入门</title>
    <link href="http://zhuuu.work/2021/03/18/RabbitMQ/RabbitMQ-03-%E5%AE%89%E8%A3%85%E4%B8%8E%E5%85%A5%E9%97%A8/"/>
    <id>http://zhuuu.work/2021/03/18/RabbitMQ/RabbitMQ-03-%E5%AE%89%E8%A3%85%E4%B8%8E%E5%85%A5%E9%97%A8/</id>
    <published>2021-03-18T06:02:24.000Z</published>
    <updated>2021-03-24T02:30:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-03-安装与入门"><a href="#RabbitMQ-03-安装与入门" class="headerlink" title="RabbitMQ-03-安装与入门"></a>RabbitMQ-03-安装与入门</h2><p><strong>简单概述：</strong></p><ul><li><p>RabbitMQ是一个开源的<strong>遵循AMQP协议实现的基于Erlang语言编写</strong>，支持多种客户端（语言）。用于在分布式系统中存储消息，转发消息，具有高可用，高可扩性，易用性等特征。</p></li><li><p>官网：<a href="https://www.rabbitmq.com/" target="_blank" rel="noopener">https://www.rabbitmq.com/</a></p></li><li><p>下载地址 ： <a href="https://www.rabbitmq.com/download.html" target="_blank" rel="noopener">https://www.rabbitmq.com/download.html</a></p></li><li><p><strong>环境准备：CentOS7.x+ / Erlang</strong></p><ul><li>RabbitMQ是采用Erlang语言开发的，所以系统环境必须提供Erlang环境，第一步就是安装Erlang。</li></ul></li></ul><a id="more"></a><h2 id="1-普通方式安装"><a href="#1-普通方式安装" class="headerlink" title="1. 普通方式安装"></a>1. 普通方式安装</h2><h3 id="1-1-Erlang-安装"><a href="#1-1-Erlang-安装" class="headerlink" title="1.1 Erlang 安装"></a>1.1 Erlang 安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">参考地址：https://www.erlang-solutions.com/downloads/</span><br><span class="line"></span><br><span class="line">1. 安装下载</span><br><span class="line">wget https://packages.erlang-solutions.com/erlang-solutions-2.0-1.noarch.rpm</span><br><span class="line">rpm -Uvh erlang-solutions-2.0-1.noarch.rpm</span><br><span class="line">2. 安装成功</span><br><span class="line">yum install -y erlang</span><br><span class="line">3. erl -v</span><br><span class="line">4. 安装socat</span><br><span class="line">yum install -y socat</span><br><span class="line">5. 安装rabbitmq</span><br></pre></td></tr></table></figure><h3 id="2-rabbitMQ-下载"><a href="#2-rabbitMQ-下载" class="headerlink" title="2. rabbitMQ 下载"></a>2. rabbitMQ 下载</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-154059327.png" alt="mark"></p><ol><li>下载<code>rabbitmq</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; wget https:&#x2F;&#x2F;github.com&#x2F;rabbitmq&#x2F;rabbitmq-server&#x2F;releases&#x2F;download&#x2F;v3.8.13&#x2F;rabbitmq-server-3.8.13-1.el8.noarch.rpm</span><br><span class="line">&gt; rpm -Uvh rabbitmq-server-3.8.13-1.el8.noarch.rpm</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>启动服务</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 启动服务</span><br><span class="line">&gt; systemctl start rabbitmq-server</span><br><span class="line"># 查看服务状态</span><br><span class="line">&gt; systemctl status rabbitmq-server</span><br><span class="line"># 停止服务</span><br><span class="line">&gt; systemctl stop rabbitmq-server</span><br><span class="line"># 开机启动服务</span><br><span class="line">&gt; systemctl enable rabbitmq-server</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>rabbitMQ的配置</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RabbitMQ默认情况下有一个配置文件，定义了RabbitMQ的相关配置信息，默认情况下能够满足日常的开发需求。如果需要修改需要，需要自己创建一个配置文件进行覆盖。</span><br><span class="line">参考官网：</span><br><span class="line">1:https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;documentation.html</span><br><span class="line">2:https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;configure.html</span><br><span class="line">3:https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;configure.html#config-items</span><br><span class="line">4：https:&#x2F;&#x2F;github.com&#x2F;rabbitmq&#x2F;rabbitmq-server&#x2F;blob&#x2F;add-debug-messages-to-quorum_queue_SUITE&#x2F;docs&#x2F;rabbitmq.conf.example</span><br></pre></td></tr></table></figure><h3 id="3-rabbitMQ-端口"><a href="#3-rabbitMQ-端口" class="headerlink" title="3. rabbitMQ 端口"></a>3. rabbitMQ 端口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5672:RabbitMQ的通讯端口</span><br><span class="line">25672:RabbitMQ的节点间的CLI通讯端口是</span><br><span class="line">15672:RabbitMQ HTTP_API的端口，管理员用户才能访问，用于管理RabbitMQ,需要启动Management插件。</span><br><span class="line">1883，8883：MQTT插件启动时的端口。</span><br><span class="line">61613、61614：STOMP客户端插件启用的时候的端口。</span><br><span class="line">15674、15675：基于webscoket的STOMP端口和MOTT端口</span><br></pre></td></tr></table></figure><h3 id="4-可视化管理节面"><a href="#4-可视化管理节面" class="headerlink" title="4. 可视化管理节面"></a>4. 可视化管理节面</h3><ol><li>默认情况下，rabbitmq是没有安装web端的客户端插件，需要安装才可以生效</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure><ol start="2"><li>安装完毕以后，重启服务即可</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure><ol start="3"><li>在浏览器访问</li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-154907967.png" alt="mark"></p><h3 id="5-授权账号和登录级别"><a href="#5-授权账号和登录级别" class="headerlink" title="5. 授权账号和登录级别"></a>5. 授权账号和登录级别</h3><ol><li><strong>新增用户</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_user admin admin</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>分配权限操作</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>对应级别</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用户级别：</span><br><span class="line"></span><br><span class="line">1、administrator 可以登录控制台、查看所有信息、可以对rabbitmq进行管理</span><br><span class="line">2、monitoring 监控者 登录控制台，查看所有信息</span><br><span class="line">3、policymaker 策略制定者 登录控制台,指定策略</span><br><span class="line">4、managment 普通管理员 登录控制台</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>添加级别权限</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl.bat set_permissions -p &#x2F; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>常用命令小结</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_user 账号 密码</span><br><span class="line">rabbitmqctl set_user_tags 账号 administrator</span><br><span class="line">rabbitmqctl change_password Username Newpassword 修改密码</span><br><span class="line">rabbitmqctl delete_user Username 删除用户</span><br><span class="line">rabbitmqctl list_users 查看用户清单</span><br><span class="line">rabbitmqctl set_permissions -p &#x2F; 用户名 &quot;.*&quot; &quot;.*&quot; &quot;.*&quot; 为用户设置administrator角色</span><br><span class="line">rabbitmqctl set_permissions -p &#x2F; root &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure><hr><h2 id="2-Docker方式安装"><a href="#2-Docker方式安装" class="headerlink" title="2. Docker方式安装"></a>2. Docker方式安装</h2><ol><li><strong>未安装Docker–&gt;安装Docker</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">（1）yum 包更新到最新</span><br><span class="line">&gt; yum update</span><br><span class="line">（2）安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</span><br><span class="line">&gt; yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">（3）设置yum源为阿里云</span><br><span class="line">&gt; yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">（4）安装docker</span><br><span class="line">&gt; yum install docker-ce -y</span><br><span class="line">（5）安装后查看docker版本</span><br><span class="line">&gt; docker -v</span><br><span class="line"> (6) 安装加速镜像</span><br><span class="line"> sudo mkdir -p /etc/docker</span><br><span class="line"> sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://0wrdwnn6.mirror.aliyuncs.com"</span>]</span><br><span class="line"> &#125;</span><br><span class="line"> EOF</span><br><span class="line"> sudo systemctl daemon-reload</span><br><span class="line"> sudo systemctl restart docker</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>docker 常用命令</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动docker：</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="comment"># 停止docker：</span></span><br><span class="line">systemctl stop docker</span><br><span class="line"><span class="comment"># 重启docker：</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="comment"># 查看docker状态：</span></span><br><span class="line">systemctl status docker</span><br><span class="line"><span class="comment"># 开机启动：  </span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line">systemctl unenable docker</span><br><span class="line"><span class="comment"># 查看docker概要信息</span></span><br><span class="line">docker info</span><br><span class="line"><span class="comment"># 查看docker帮助文档</span></span><br><span class="line">docker --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>安装rabbitMQ</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">参考网站：</span><br><span class="line">1：https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;download.html</span><br><span class="line">2：https:&#x2F;&#x2F;registry.hub.docker.com&#x2F;_&#x2F;rabbitmq&#x2F;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>拉取rabbitMQ镜像</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:management</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>创建容器并且执行</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=myrabbit -p 15672:15672 rabbitmq:management</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>不用进容器设置就创建镜像</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">—hostname：指定容器主机名称</span><br><span class="line">—name:指定容器名称</span><br><span class="line">-p:将mq端口号映射到本地</span><br><span class="line">或者运行时设置用户和密码</span><br><span class="line"></span><br><span class="line">docker run -di --name myrabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 -p 25672:25672 -p 61613:61613 -p 1883:1883 rabbitmq:management</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>如果你按照之前操作安装了docker , 那么现在需要将服务给停掉</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop rabbitmq-server</span><br></pre></td></tr></table></figure><ol start="7"><li><strong>查看docker 中的rabbitmq日志</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f myrabbit</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-03-安装与入门&quot;&gt;&lt;a href=&quot;#RabbitMQ-03-安装与入门&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-03-安装与入门&quot;&gt;&lt;/a&gt;RabbitMQ-03-安装与入门&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;简单概述：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;RabbitMQ是一个开源的&lt;strong&gt;遵循AMQP协议实现的基于Erlang语言编写&lt;/strong&gt;，支持多种客户端（语言）。用于在分布式系统中存储消息，转发消息，具有高可用，高可扩性，易用性等特征。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;官网：&lt;a href=&quot;https://www.rabbitmq.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.rabbitmq.com/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载地址 ： &lt;a href=&quot;https://www.rabbitmq.com/download.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.rabbitmq.com/download.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;环境准备：CentOS7.x+ / Erlang&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RabbitMQ是采用Erlang语言开发的，所以系统环境必须提供Erlang环境，第一步就是安装Erlang。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-02-消息队列</title>
    <link href="http://zhuuu.work/2021/03/16/RabbitMQ/RabbitMQ-02-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <id>http://zhuuu.work/2021/03/16/RabbitMQ/RabbitMQ-02-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</id>
    <published>2021-03-16T11:02:24.000Z</published>
    <updated>2021-04-11T07:19:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-02-消息队列"><a href="#RabbitMQ-02-消息队列" class="headerlink" title="RabbitMQ-02-消息队列"></a>RabbitMQ-02-消息队列</h2><h2 id="1-消息队列协议"><a href="#1-消息队列协议" class="headerlink" title="1. 消息队列协议"></a>1. 消息队列协议</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210317-210932098.png" alt="mark"></p><ul><li><strong>消息中间件负责数据的传递，存储，和分发消费三个部分</strong>，数据的存储和分发的过程中肯定要遵循某种约定成俗的规范，你是采用底层的TCP/IP，UDP协议还是其他的自己取构建等，而这些约定成俗的规范就称之为：协议。</li><li><strong>所谓协议是指：</strong><ul><li>计算机底层操作系统和应用程序通讯时共同遵守的一组约定，只有<strong>遵循共同的约定和规范，系统和底层操作系统之间才能相互交流。</strong></li><li>和<strong>一般的网络应用程序的不同它主要负责数据的接受和传递，所以性能比较的高。</strong></li><li>协议对数据格式和计算机之间交换数据都必须<strong>严格遵守规范。</strong></li></ul></li></ul><a id="more"></a><h2 id="2-网络协议需要遵循的要素"><a href="#2-网络协议需要遵循的要素" class="headerlink" title="2. 网络协议需要遵循的要素"></a>2. 网络协议需要遵循的要素</h2><p><strong>1. 语法</strong>。语法是用户数据与控制信息的<strong>结构与格式,</strong>以及数据出现的顺序。<br><strong>2. 语义</strong>。语义是解释控制信息每个部分的意义。它规定了需要发出何种控制信息,以及<strong>完成的动作与做出什么样的响应。</strong><br><strong>3. 时序</strong>。时序是对<strong>事件发生顺序</strong>的详细说明。</p><ul><li><strong>而消息中间件采用的并不是http协议</strong>，而常见的消息中间件协议有：<code>OpenWire、AMQP、MQTT、Kafka，</code>OpenMessage协议。</li><li><strong>面试题：为什么消息中间件不直接使用http协议呢？</strong><ul><li><strong>1: 因为http请求报文头和响应报文头是比较复杂的</strong>，包含了cookie，数据的加密解密，状态码，响应码等附加的功能，但是对于一个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就行，<strong>一定要追求的是高性能。尽量简洁，快速。</strong></li><li><strong>2:大部分情况下http大部分都是短链接</strong>，在实际的交互过程中，一个请求到响应很有可能会中断，中断以后就不会就行持久化，就<strong>会造成请求的丢失</strong>。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取消息的过程，出现问题和故障要对数据或消息就行持久化等，目的是为了保证消息和数据的高可靠和稳健的运行。</li></ul></li></ul><h2 id="3-消息队列协议"><a href="#3-消息队列协议" class="headerlink" title="3. 消息队列协议"></a>3. 消息队列协议</h2><h3 id="3-1AMQP协议"><a href="#3-1AMQP协议" class="headerlink" title="3.1AMQP协议"></a>3.1AMQP协议</h3><ul><li>AMQP：(全称：Advanced Message Queuing Protocol) 是高级消息队列协议。由摩根大通集团联合其他公司共同设计。是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。</li><li>基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。Erlang中的实现有RabbitMQ等。</li></ul><p><strong>特性：</strong><br>1：分布式事务支持。<br>2：消息的持久化支持。<br>3：高性能和高可靠的消息处理优势。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-141250242.png" alt="mark"></p><h3 id="3-2MQTT协议"><a href="#3-2MQTT协议" class="headerlink" title="3.2MQTT协议"></a>3.2MQTT协议</h3><ul><li><strong>MQTT协议：</strong>（Message Queueing Telemetry Transport）消息队列是IBM开放的一个即时通讯协议，<strong>物联网系统架构中的重要组成部分。</strong></li><li><strong>特点：</strong><br>1：轻量<br>2：结构简单<br>3：传输快，不支持事务<br>4：没有持久化设计。</li><li><strong>应用场景：</strong><br>1：适用于计算能力有限<br>2：低带宽<br>3：网络不稳定的场景。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-141351884.png" alt="mark"></p><h3 id="3-3-OpenMessage协议"><a href="#3-3-OpenMessage协议" class="headerlink" title="3.3 OpenMessage协议"></a>3.3 OpenMessage协议</h3><ul><li>是近几年由阿里、雅虎和滴滴出行、Stremalio等公司共同参与创立的分布式消息中间件、流处理等领域的应用开发标准。</li><li><strong>特点：</strong><br>1：结构简单<br>2：解析速度快<br>3：支持事务和持久化设计。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-141428320.png" alt="mark"></p><h3 id="3-4-Kafka协议"><a href="#3-4-Kafka协议" class="headerlink" title="3.4 Kafka协议"></a>3.4 Kafka协议</h3><ul><li><p><strong>Kafka协议是基于TCP/IP的二进制协议</strong>。消息内部是通过长度来分割，由一些基本数据类型组成。</p></li><li><p><strong>特点是</strong>：<br>1：结构简单<br>2：解析速度快<br>3：无事务支持<br>4：有持久化设计</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-141511555.png" alt="mark"></p><h2 id="4-消息队列的持久化"><a href="#4-消息队列的持久化" class="headerlink" title="4. 消息队列的持久化"></a>4. 消息队列的持久化</h2><ul><li>简单来说就是将数据存入磁盘，而不是存在内存中随服务器重启断开而消失，使数据能够永久保存</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-142053516.png" alt="mark"></p><ul><li>常见的持久化方式</li></ul><table><thead><tr><th>ActiveMQ</th><th>RabbitMQ</th><th>Kafka</th><th>RocketMQ</th><th></th></tr></thead><tbody><tr><td>文件存储</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>数据库</td><td>支持</td><td>/</td><td>/</td><td>/</td></tr></tbody></table><h2 id="5-消息的分发策略"><a href="#5-消息的分发策略" class="headerlink" title="5. 消息的分发策略"></a>5. 消息的分发策略</h2><ul><li><strong>MQ消息队列有如下几个角色</strong><br>1：生产者<br>2：存储消息<br>3：消费者</li><li><strong>那么生产者生成消息以后，MQ进行存储，消费者是如何获取消息的呢？</strong><ul><li>一般获取数据的方式无外乎<strong>推（push）或者拉（pull）两种方式，</strong></li><li><strong>典型的git就有推拉机制</strong>，我们发送的http请求就是一种典型的拉取数据库数据返回的过程。</li><li><strong>而消息队列MQ是一种推送的过程</strong>，而这些推机制会适用到很多的业务场景也有很多对应推机制策略。</li></ul></li></ul><h3 id="5-1-场景一"><a href="#5-1-场景一" class="headerlink" title="5.1 场景一"></a>5.1 场景一</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-142306233.png" alt="mark"></p><ul><li>比如我在APP上下了一个订单，我们的系统和服务很多，我们如何得知这<strong>个消息被那个系统或者那些服务或者系统进行消费，那这个时候就需要一个分发的策略</strong>。这就需要消费策略。或者称之为消费的方法论。</li></ul><h3 id="5-2-场景二"><a href="#5-2-场景二" class="headerlink" title="5.2 场景二"></a>5.2 场景二</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-142359085.png" alt="mark"></p><ul><li>在发送消息的过程中可能会出现异常，或者网络的抖动，故障等等因为造成消息的无法消费，比如用户在下订单，消费MQ接受，<strong>订单系统出现故障，导致用户支付失败</strong>，那么这个时候就需要消息中间件就必须支持消息重试机制策略。也就是支持：出现问题和故障的情况下，<strong>消息不丢失还可以进行重发。</strong></li><li><strong>小结如下：</strong></li></ul><table><thead><tr><th>ActiveMQ</th><th>RabbitMQ</th><th>Kafka</th><th>RocketMQ</th><th></th></tr></thead><tbody><tr><td>发布订阅</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>轮询分发</td><td>支持</td><td>支持</td><td>支持</td><td>/</td></tr><tr><td>公平分发</td><td>/</td><td>支持</td><td>支持</td><td>/</td></tr><tr><td>重发</td><td>支持</td><td>支持</td><td>/</td><td>支持</td></tr><tr><td>消息拉取</td><td>/</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table><h2 id="6-消息队列高可用和高可靠"><a href="#6-消息队列高可用和高可靠" class="headerlink" title="6. 消息队列高可用和高可靠"></a>6. 消息队列高可用和高可靠</h2><h3 id="6-1-高可用"><a href="#6-1-高可用" class="headerlink" title="6.1 高可用"></a>6.1 高可用</h3><ul><li><strong>高可用：</strong>是指产品在规定的条件和规定的时刻或时间内处于可执行规定功能状态的能力。<br>当业务量增加时，请求也过大，一台消息中间件服务器的会触及硬件（CPU,内存，磁盘）的极限，一台消息服务器你已经无法满足业务的需求，所以<strong>消息中间件必须支持集群部署。来达到高可用的目的。</strong></li></ul><ul><li><h3 id="集群模式1-Master-slave主从共享数据的部署方式"><a href="#集群模式1-Master-slave主从共享数据的部署方式" class="headerlink" title="集群模式1 - Master-slave主从共享数据的部署方式"></a>集群模式1 - Master-slave主从共享数据的部署方式</h3></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-142651818.png" alt="mark"></p><p>生产者将消费发送到Master节点，所有的都连接这个消息队列共享这块数据区域，Master节点负责写入，一旦Master挂掉，slave节点继续服务。从而形成高可用，</p><ul><li><h3 id="集群模式2-Master-slave主从同步部署方式"><a href="#集群模式2-Master-slave主从同步部署方式" class="headerlink" title="集群模式2 - Master- slave主从同步部署方式"></a>集群模式2 - Master- slave主从同步部署方式</h3></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-142728662.png" alt="mark"></p><p>这种模式写入消息同样在Master主节点上，但是主节点会同步数据到slave节点形成副本，和zookeeper或者redis主从机制很类同。这样可以达到负载均衡的效果，如果消费者有多个这样就可以去不同的节点就行消费，以为消息的拷贝和同步会暂用很大的带宽和网络资源。在后续的rabbtmq中会有使用。</p><ul><li><h3 id="集群模式3-多主集群同步部署模式"><a href="#集群模式3-多主集群同步部署模式" class="headerlink" title="集群模式3 - 多主集群同步部署模式"></a>集群模式3 - 多主集群同步部署模式</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-142830807.png" alt="mark"></p></li></ul><p><strong>解释：</strong></p><p>如果你插入的数据是broker-1中，元数据信息会存储数据的相关描述和记录存放的位置（队列）。<br>它会对描述信息也就是元数据信息就行同步，如果消费者在broker-2中进行消费，发现自己几点没有对应的消息，可以从<strong>对应的元数据信息中去查询</strong>，然后返回对应的消息信息，场景：比如买火车票或者黄牛买演唱会门票，比如第一个黄牛有顾客说要买的演唱会门票，但是没有但是他会去联系其他的黄牛询问，如果有就返回。</p><ul><li><h3 id="集群模式5-Master-slave与Broker-cluster组合的方案"><a href="#集群模式5-Master-slave与Broker-cluster组合的方案" class="headerlink" title="集群模式5 Master-slave与Broker-cluster组合的方案"></a>集群模式5 Master-slave与Broker-cluster组合的方案</h3></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210318-142935098.png" alt="mark"></p><p><strong>解释：</strong>实现多主多从的热备机制来完成消息的高可用以及数据的热备机制，在生产规模达到一定的阶段的时候，这种使用的频率比较高。</p><p><strong>反正终归三句话：</strong><br><strong>1：要么消息共享，</strong><br><strong>2：要么消息同步</strong><br><strong>3：要么元数据共享</strong></p><h3 id="6-2-高可靠"><a href="#6-2-高可靠" class="headerlink" title="6.2 高可靠"></a>6.2 高可靠</h3><ul><li><strong>高可靠</strong>：是指系统可以无故障低持续运行，比如一个系统突然崩溃，报错，异常等等并不影响线上业务的正常运行，出错的几率极低，就称之为：高可靠。</li><li>在高并发的业务场景中，如果不能保证系统的高可靠，那造成的隐患和损失是非常严重的。</li><li>如何保证<strong>中间件消息的可靠性</strong>呢？可以从两个方面考虑：<br><strong>1：消息的传输：通过协议来保证系统间数据解析的正确性。</strong><br><strong>2：消息的存储可靠：通过持久化来保证消息的可靠性。</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-02-消息队列&quot;&gt;&lt;a href=&quot;#RabbitMQ-02-消息队列&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-02-消息队列&quot;&gt;&lt;/a&gt;RabbitMQ-02-消息队列&lt;/h2&gt;&lt;h2 id=&quot;1-消息队列协议&quot;&gt;&lt;a href=&quot;#1-消息队列协议&quot; class=&quot;headerlink&quot; title=&quot;1. 消息队列协议&quot;&gt;&lt;/a&gt;1. 消息队列协议&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210317-210932098.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;消息中间件负责数据的传递，存储，和分发消费三个部分&lt;/strong&gt;，数据的存储和分发的过程中肯定要遵循某种约定成俗的规范，你是采用底层的TCP/IP，UDP协议还是其他的自己取构建等，而这些约定成俗的规范就称之为：协议。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;所谓协议是指：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;计算机底层操作系统和应用程序通讯时共同遵守的一组约定，只有&lt;strong&gt;遵循共同的约定和规范，系统和底层操作系统之间才能相互交流。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;和&lt;strong&gt;一般的网络应用程序的不同它主要负责数据的接受和传递，所以性能比较的高。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;协议对数据格式和计算机之间交换数据都必须&lt;strong&gt;严格遵守规范。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ-01-中间件概述</title>
    <link href="http://zhuuu.work/2021/03/15/RabbitMQ/RabbitMQ-01-%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%A6%82%E8%BF%B0/"/>
    <id>http://zhuuu.work/2021/03/15/RabbitMQ/RabbitMQ-01-%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%A6%82%E8%BF%B0/</id>
    <published>2021-03-15T11:02:24.000Z</published>
    <updated>2021-04-11T07:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ-01-中间件概述"><a href="#RabbitMQ-01-中间件概述" class="headerlink" title="RabbitMQ-01-中间件概述"></a>RabbitMQ-01-中间件概述</h2><h2 id="1-中间件简介"><a href="#1-中间件简介" class="headerlink" title="1. 中间件简介"></a>1. 中间件简介</h2><ul><li><p><code>中间件（Middleware）是处于操作系统和应用程序之间的软件，也有人认为它应该属于操作系统中的一部分。人们在使用中间件时，往往是一组中间件集成在一起，构成一个平台（包括开发平台和运行平台），但在这组中间件中必须要有一个通信中间件，即中间件=平台+通信，这个定义也限定了只有用于分布式系统中才能称为中间件，同时还可以把它与支撑软件和实用软件区分开来。</code></p></li><li><p>为解决分布异构问题，人们提出了中间件(middleware)的概念。中间件是位于平台(硬件和操作系统)和应用之间的通用服务，如下图所示，这些服务具有标准的程序接口和协议。针对不同的操作系统和硬件平台，它们可以有符合接口和协议规范的多种实现。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210317-195441380.png" alt="mark"></p><a id="more"></a><ul><li>简单说：中间件有个很大的特点，是脱离于具体设计目标，而具备提供普遍独立功能需求的模块。<strong>这使得中间件一定是可替换的。如果一个系统设计中，中间件是不可替换的，不是架构、框架设计有问题，那么就是这个中间件，在 别处可能是个中间件，在这个系统内是引擎</strong>。哈。</li></ul><h2 id="2-中间件的使用时机"><a href="#2-中间件的使用时机" class="headerlink" title="2. 中间件的使用时机"></a>2. 中间件的使用时机</h2><ul><li>在项目的架构和重构中，使用任何技术和架构的改变我们都需要谨慎斟酌和思考，因为任何技术的融入和变化都可能人员，技术，和成本的增加，中间件的技术一般现在一些互联网公司或者项目中使用比较多，如果你仅仅还只是一个初创公司建议还是使用单体架构，最多加个缓存中间件即可，不要盲目追求新或者所谓的高性能，而追求的背后一定是业务的驱动和项目的驱动，因为一旦追求就意味着你的学习成本，公司的人员结构以及服务器成本，维护和运维的成本都会增加，所以需要谨慎选择和考虑。</li><li>但是作为一个开放人员，一定要有学习中间件技术的能力和思维，否则很容易当项目发展到一个阶段在去掌握估计或者在面试中提及，就会给自己带来不小的困扰，在当今这个时代这些技术也并不是什么新鲜的东西，如果去掌握和挖掘最关键的还是自己花时间和花精力去探讨和研究。</li></ul><h2 id="3-单体架构和分布式架构"><a href="#3-单体架构和分布式架构" class="headerlink" title="3. 单体架构和分布式架构"></a>3. 单体架构和分布式架构</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210317-195713227.png" alt="mark"></p><p>在实际的项目中，大部分的企业项目开发中，在早期都采用的是<strong>单体的架构模式</strong>，如下图：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210317-200010624.png" alt="mark"></p><p>在企业开发的中，大部分的初期架构都采用的是单体架构的模式进行架构，而这种架构的典型的特点：就是把所有的业务和模块，源代码，静态资源文件等都放在一个一工程中，如果其中的一个模块升级或者迭代发生一个很小变动都会重新编译和重新部署项目。 这种的架构存在的问题就是：<br>1：耦合度太高<br>2：运维的成本过高<br>3：不易维护<br>4：服务器的成本高<br>5：以及升级架构的复杂度也会增大<br>这样就有后续的分布式架构系统。如下</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210317-200044247.png" alt="mark"></p><p><strong>通俗一点：就是一个请求由服务器端的多个服务（服务或者系统）协同处理完成</strong></p><ul><li>和单体架构不同的是，单体架构是一个请求发起jvm调度线程（确切的是tomcat线程池）分配线程Thread来处理请求直到释放，而分布式是系统是：一个请求是由多个系统共同来协同完成，jvm和环境都可能是独立。如果生活中的比喻的话，单体架构就想建设一个小房子很快就能够搞定，如果你要建设一个鸟巢或者大型的建筑，你就必须是各个环节的协同和分布，这样目的也是项目发展都后期的时候要去部署和思考的问题。</li></ul><h2 id="4-消息中间件概念"><a href="#4-消息中间件概念" class="headerlink" title="4. 消息中间件概念"></a>4. 消息中间件概念</h2><p><strong>应用场景</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1:跨系统数据传递</span><br><span class="line">2:高并发的流量削峰</span><br><span class="line">3:数据的分发和异步处理</span><br><span class="line">4:大数据分析与传递</span><br><span class="line">5:分布式事务</span><br></pre></td></tr></table></figure><p>比如你有一个数据要进行迁移或者请求并发过多的时候，比如你有10W的并发请求下订单，我们可以在这些订单入库之前，我们可以把订单请求堆积到消息队列中，让它稳健可靠的入库和执行。</p><p><strong>常见的消息中间件</strong></p><ul><li>ActiveMQ、RabbitMQ、Kafka、RocketMQ等。</li></ul><p><strong>同时消息中间件是一种接受数据，接受请求、存储数据、发送数据等功能的技术服务。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210317-200352244.png" alt="mark"></p><p>谁来生产消息，存储消息和消费消息呢？</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210317-200408369.png" alt="mark"></p><h2 id="5-消息中间件的两种模式"><a href="#5-消息中间件的两种模式" class="headerlink" title="5. 消息中间件的两种模式"></a>5. 消息中间件的两种模式</h2><ol><li><strong>点对点模式 P2P</strong></li></ol><ul><li>点对点模式是基于队列的，消息的生产者发送消息到队列，消息的消费者从队列中接收消息，队列的存在使得消息的异步传输成为可能</li></ul><ol start="2"><li><strong>发布订阅模式</strong></li></ol><ul><li>发布订阅模式定义了如何向一个内容节点发布和订阅消息，这个内容节点称为主题（topic）,主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题中，而消息的订阅者从主题中订阅消息。</li></ul><p><strong>参考博客系列 ：</strong> <a href="https://blog.csdn.net/u013256816/article/details/54743481" target="_blank" rel="noopener">https://blog.csdn.net/u013256816/article/details/54743481</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ-01-中间件概述&quot;&gt;&lt;a href=&quot;#RabbitMQ-01-中间件概述&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ-01-中间件概述&quot;&gt;&lt;/a&gt;RabbitMQ-01-中间件概述&lt;/h2&gt;&lt;h2 id=&quot;1-中间件简介&quot;&gt;&lt;a href=&quot;#1-中间件简介&quot; class=&quot;headerlink&quot; title=&quot;1. 中间件简介&quot;&gt;&lt;/a&gt;1. 中间件简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;中间件（Middleware）是处于操作系统和应用程序之间的软件，也有人认为它应该属于操作系统中的一部分。人们在使用中间件时，往往是一组中间件集成在一起，构成一个平台（包括开发平台和运行平台），但在这组中间件中必须要有一个通信中间件，即中间件=平台+通信，这个定义也限定了只有用于分布式系统中才能称为中间件，同时还可以把它与支撑软件和实用软件区分开来。&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为解决分布异构问题，人们提出了中间件(middleware)的概念。中间件是位于平台(硬件和操作系统)和应用之间的通用服务，如下图所示，这些服务具有标准的程序接口和协议。针对不同的操作系统和硬件平台，它们可以有符合接口和协议规范的多种实现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210317-195441380.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="http://zhuuu.work/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://zhuuu.work/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-01-计算机系统概述</title>
    <link href="http://zhuuu.work/2021/03/15/Compute_Organization/%E8%AE%A1%E7%BB%84-01-%E6%A6%82%E8%BF%B0/"/>
    <id>http://zhuuu.work/2021/03/15/Compute_Organization/%E8%AE%A1%E7%BB%84-01-%E6%A6%82%E8%BF%B0/</id>
    <published>2021-03-15T03:02:24.000Z</published>
    <updated>2021-03-22T07:24:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机组成原理-01-计算机系统概述"><a href="#计算机组成原理-01-计算机系统概述" class="headerlink" title="计算机组成原理-01-计算机系统概述"></a>计算机组成原理-01-计算机系统概述</h2><h2 id="1-计算机的四代变化"><a href="#1-计算机的四代变化" class="headerlink" title="1. 计算机的四代变化"></a>1. 计算机的四代变化</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-105224626.png" alt="mark"></p><p><strong>1）摩尔定律。</strong>摩尔定律是由英特尔（Intel）创始人之一戈登·摩尔（Gordon Moore）提出来的。其内容为：当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。换言之，每一美元所能买到的电脑性能，将每隔18-24个月翻一倍以上。这一定律揭示了信息技术进步的速度 。尽管这种趋势已经持续了超过半个世纪，摩尔定律仍应该被认为是观测或推测，而不是一个物理或自然法 。</p><p><strong>2）半导体存储器的发展。</strong>1970年仙童半导体公司生产出第一个较大容量的半导体存储器，至今，半导体存储器经历了11代；单芯片1KB、4KB、16KB、64KB、256KB、1MB、4MB、16MB、64MB、256MB、1GB。</p><p>3）微处理器的发展。微处理器位数：8-&gt;16-&gt;32-&gt;64，这里的32、64指的是机器字长，是指计算机进行一次整数运算所能处理的二进制数据的位数。</p><a id="more"></a><h2 id="2-计算机的组成"><a href="#2-计算机的组成" class="headerlink" title="2. 计算机的组成"></a>2. 计算机的组成</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-105756753.png" alt="mark"></p><p><strong>软件分类如下：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-105842514.png" alt="mark"></p><p><strong>语言等级</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-105934707.png" alt="mark"></p><h2 id="3-冯·诺依曼机"><a href="#3-冯·诺依曼机" class="headerlink" title="3. 冯·诺依曼机"></a>3. 冯·诺依曼机</h2><ul><li><p>美籍匈牙利科学家冯·诺依曼最先提出“程序存储”的思想，并成功将其运用在计算机的设计之中，根据这一原理制造的计算机被称为冯·诺依曼结构计算机。由于他对现代计算机技术的突出贡献，因此冯·诺依曼又被称为“现代计算机之父”。</p><ul><li>“程序存储”：指令以代码的形式事先输入到计算机的主存储器中，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。</li></ul></li><li><p><strong>计算机的五大功能部件</strong>：<code>输入设备、输出设备、存储器、运算器、控制器</code></p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-111632056.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-111934913.png" alt="mark"></p><h2 id="4-现代计算机的结构"><a href="#4-现代计算机的结构" class="headerlink" title="4. 现代计算机的结构"></a>4. 现代计算机的结构</h2><ul><li>在微处理器问世之前，运算器与控制器分离。而且存储器容量小，因此设计成以运算器为中心的结构，其他部件都通过运算器完成信息的传递，如上图所示。</li><li>随着微电子技术的进步，同时计算机需要处理的信息也越来越多，大量I/O设备的速度和CPU的速度差距悬殊，因此需要更新换代计算机的组织结构以适应新的需求。计算机发展为了以存储器为中心，使I/O设备尽可能的绕过CPU，直接在I/O设备与存储器之间完成操作，以提高整体效率。其结构如下图所示：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-112030679.png" alt="mark"></p><h2 id="5-主存储器"><a href="#5-主存储器" class="headerlink" title="5. 主存储器"></a>5. 主存储器</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-113400653.png" alt="mark"></p><ul><li>存储体：存放二进制信息</li><li>地址寄存器（MAR-Memory Address Register）:存放访存地址，经过地址译码后找到所选的逻辑单元</li><li>数据寄存器（MDR-Memory Data Register）:暂存要从存储器中读或写的信息</li><li>时序控制逻辑：用于产生存储器操作所需的各种时序信号</li><li>地址寄存器（MAR-Memory Address Register）用于寻址，其位数对应着存储单元的个数，如MAR为10位，则有2^10^=1024个存储单元，记为1K。MAR的长度与PC（程序计数器）长度相等。</li><li>MDR位数=存储字长，一般为字节(B)的二次幂的整数倍</li><li>MAR和MDR虽然是存储器的一部分，但在现代CPU中却是存在于CPU中的；另外高速缓存（Cache）也存在于CPU中<br><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-113700559.png" alt="mark"></li></ul><h2 id="6-运算器"><a href="#6-运算器" class="headerlink" title="6. 运算器"></a>6. 运算器</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-113919523.png" alt="mark"></p><ul><li>运算器：ALU 算数逻辑单元是最主要的组成部件，运算器包含若干通用寄存器，用于暂存操作数和中间结果。</li></ul><h2 id="7-控制器"><a href="#7-控制器" class="headerlink" title="7. 控制器"></a>7. 控制器</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-114103653.png" alt="mark"></p><ul><li>控制器是计算机的<code>指挥中心</code>，它指挥着各部件自动协调地进行工作</li></ul><h2 id="8-工作过程小结"><a href="#8-工作过程小结" class="headerlink" title="8. 工作过程小结"></a>8. 工作过程小结</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-115017372.png" alt="mark"></p><ul><li><p><code>总线</code>中有<code>地址、数据、控制</code>三组信号线</p></li><li><p><code>CPU与主存</code>之间通过一组<code>总线</code>相连</p></li><li><p><code>MAR</code>中的地址信息会直接送到<code>地址线</code>上，用于指向<code>读/写</code>操作的<code>主存存储单元</code></p></li><li><p><code>控制线</code>中有<code>读/写</code>信号线，指出数据是从CPU<code>写入</code>主存还是从主存<code>读出</code>到<code>CPU</code></p></li><li><p>根据<code>读</code>操作还是<code>写</code>操作来控制将<code>MDR中的数据</code>是直接<code>送到数据线上</code>还是将数据线上的数据<code>接收到MDR</code>中</p></li></ul><h2 id="9-计算机的工作过程"><a href="#9-计算机的工作过程" class="headerlink" title="9. 计算机的工作过程"></a>9. 计算机的工作过程</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-151055001.png" alt="mark"></p><ul><li>这里以UNIX系统中的GCC编译器程序为例，将C语言源程序转换为<code>可执行文件（以二进制磁盘文件形式存储）</code></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-151153003.png" alt="mark"></p><p> 例题：以取数指令（即将指令地址码指示的存储单元中的操作数取出后送至运算器的累加器(ACC)中）为例进行说明。其信息流程如下：</p><blockquote><p>累加器ACC：二进制8位寄存器，存放操作数或运算结果。<br>M : 主存储器</p></blockquote><ol><li><strong>取指令</strong>  ：PC-&gt;MAR-&gt;M-&gt;MDR-&gt;IR</li></ol><ul><li><code>根据PC取指令到IR</code>。将PC的内容送MAR，MAR中的内容直接送地址线，同时控制器将读/写信号送读/写信号线，主存根据地址线上的地址和读信号，从指定存储单元读出指令，送到数据线上，MDR从数据线接受指令信息，并传送到IR中。</li></ul><ol start="2"><li><strong>分析指令</strong> ： OP(IR)-&gt;CU</li></ol><ul><li><code>指令译码器解释操作码OP(IR)并送出控制信号</code>。指令寄存器（IR）将操作码OP(IR)送至指令译码器（ID）进行解释翻译，将翻译的信息送至操作控制器（OC），OC生成相应的控制信号，送到不同的执行部件。</li></ul><ol start="3"><li><strong>执行指令</strong> ： Ad(IR)-&gt;MAR-&gt;M-&gt;MDR-&gt;ACC</li></ol><ul><li><code>取数操作</code>。将IR中的指令地址码送MAR，MAR将内容送至地址线，同时控制器将读/写信号送读/写线，从主存指定单元读出操作数，并通过数据线送至MDR，再传送到ACC中。</li></ul><ol start="4"><li><strong>每取完一条指令，(PC)+1-&gt;PC，取下一条指令的地址。</strong></li></ol><h2 id="10-计算机的层次结构"><a href="#10-计算机的层次结构" class="headerlink" title="10. 计算机的层次结构"></a>10. 计算机的层次结构</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-150749119.png" alt="mark"></p><h2 id="11-计算机的主要性能指标"><a href="#11-计算机的主要性能指标" class="headerlink" title="11. 计算机的主要性能指标"></a>11. 计算机的主要性能指标</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-152255067.png" alt="mark"></p><p><strong>性能指标：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-152429772.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;计算机组成原理-01-计算机系统概述&quot;&gt;&lt;a href=&quot;#计算机组成原理-01-计算机系统概述&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理-01-计算机系统概述&quot;&gt;&lt;/a&gt;计算机组成原理-01-计算机系统概述&lt;/h2&gt;&lt;h2 id=&quot;1-计算机的四代变化&quot;&gt;&lt;a href=&quot;#1-计算机的四代变化&quot; class=&quot;headerlink&quot; title=&quot;1. 计算机的四代变化&quot;&gt;&lt;/a&gt;1. 计算机的四代变化&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210322-105224626.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）摩尔定律。&lt;/strong&gt;摩尔定律是由英特尔（Intel）创始人之一戈登·摩尔（Gordon Moore）提出来的。其内容为：当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。换言之，每一美元所能买到的电脑性能，将每隔18-24个月翻一倍以上。这一定律揭示了信息技术进步的速度 。尽管这种趋势已经持续了超过半个世纪，摩尔定律仍应该被认为是观测或推测，而不是一个物理或自然法 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）半导体存储器的发展。&lt;/strong&gt;1970年仙童半导体公司生产出第一个较大容量的半导体存储器，至今，半导体存储器经历了11代；单芯片1KB、4KB、16KB、64KB、256KB、1MB、4MB、16MB、64MB、256MB、1GB。&lt;/p&gt;
&lt;p&gt;3）微处理器的发展。微处理器位数：8-&amp;gt;16-&amp;gt;32-&amp;gt;64，这里的32、64指的是机器字长，是指计算机进行一次整数运算所能处理的二进制数据的位数。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
      <category term="计算机组成原理" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode--082-删除排序链表中的重复元素II</title>
    <link href="http://zhuuu.work/2021/03/15/Leetcode/Leetcode-082-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II/"/>
    <id>http://zhuuu.work/2021/03/15/Leetcode/Leetcode-082-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II/</id>
    <published>2021-03-15T03:02:24.000Z</published>
    <updated>2021-03-25T11:37:29.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode–082-删除排序链表中的重复元素-II"><a href="#Leetcode–082-删除排序链表中的重复元素-II" class="headerlink" title="Leetcode–082-删除排序链表中的重复元素 II"></a>Leetcode–082-<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">删除排序链表中的重复元素 II</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 <strong>没有重复出现</strong> 的数字。</li><li>返回同样按升序排列的结果链表。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210325-185810569.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,3,4,4,5]</span><br><span class="line">输出：[1,2,5]</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210325-185829197.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,1,1,2,3]</span><br><span class="line">输出：[2,3]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围 <code>[0, 300]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li>题目数据保证链表已经按升序排列</li></ul><a id="more"></a><h2 id="方法一：一次遍历"><a href="#方法一：一次遍历" class="headerlink" title="方法一：一次遍历"></a>方法一：一次遍历</h2><ul><li>由于给定的链表是排好序的，因此重复的元素在链表中出现的位置是连续的，因此我们只需要对链表进行一次遍历，就可以删除重复的元素。由于链表的头节点可能会被删除，因此我们需要额外使用一个哑节点（<code>dummy node</code>）指向链表的头节点。</li><li>具体地，首先从指针<code>cur</code>指向链表的哑节点，<ul><li>随后开始对链表进行遍历。如果当前<code>cur.next</code>与<code>cur.next.next</code>对应的元素相同，那么我们就需要将<code>cur.next</code> 以及所有后面拥有相同元素值的链表节点全部删除。</li><li>记下这个元素值 x，随后不断将<code>cur.next</code>从链表中移除，直到 <code>cur.next</code>为空节点或者其元素值不等于<code>x</code> 为止。此时，将链表中所有元素值为<code>x</code>的节点全部删除。</li></ul></li><li>如果当前<code>cur.next</code> 与<code>cur.next.next</code> 对应的元素不相同，那么说明链表中只有一个元素值为<code>cur.next</code> 的节点，那么就可以将 <code>cur</code> 指向 <code>cur.next</code>。</li></ul><ul><li>当遍历完整个链表之后，我们返回链表的的哑节点的下一个节点 <em>dummy.next</em> 即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1. 如果链表为空</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 创建哑节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>,head);</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 处理逻辑</span></span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == cur.next.next.val)&#123; <span class="comment">// 如果是重复元素的话</span></span><br><span class="line">                <span class="keyword">int</span> x = cur.next.val;<span class="comment">// 为了在删除前记录重复的值大小</span></span><br><span class="line">                <span class="keyword">while</span>(cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.val == x)&#123;<span class="comment">// 循环删除重复元素</span></span><br><span class="line">                    cur.next = cur.next.next;<span class="comment">// 删除这个重复元素</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">// 如果不是重复元素的话</span></span><br><span class="line">                cur = cur.next;<span class="comment">// 指针向前走一位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 返回dummy.next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)，其中 n 是链表的长度。</li><li>空间复杂度：O(1)。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode–082-删除排序链表中的重复元素-II&quot;&gt;&lt;a href=&quot;#Leetcode–082-删除排序链表中的重复元素-II&quot; class=&quot;headerlink&quot; title=&quot;Leetcode–082-删除排序链表中的重复元素 II&quot;&gt;&lt;/a&gt;Leetcode–082-&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;删除排序链表中的重复元素 II&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;存在一个按升序排列的链表，给你这个链表的头节点 &lt;code&gt;head&lt;/code&gt; ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 &lt;strong&gt;没有重复出现&lt;/strong&gt; 的数字。&lt;/li&gt;
&lt;li&gt;返回同样按升序排列的结果链表。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210325-185810569.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：head &amp;#x3D; [1,2,3,3,4,4,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,2,5]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210325-185829197.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：head &amp;#x3D; [1,1,1,2,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[2,3]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链表中节点数目在范围 &lt;code&gt;[0, 300]&lt;/code&gt; 内&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-100 &amp;lt;= Node.val &amp;lt;= 100&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;题目数据保证链表已经按升序排列&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="链表" scheme="http://zhuuu.work/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode--456-132模式</title>
    <link href="http://zhuuu.work/2021/03/15/Leetcode/Leetcode-456-132%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zhuuu.work/2021/03/15/Leetcode/Leetcode-456-132%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-03-15T03:02:24.000Z</published>
    <updated>2021-03-27T01:43:57.025Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode–456-132-模式"><a href="#Leetcode–456-132-模式" class="headerlink" title="Leetcode–456-132 模式"></a>Leetcode–456-<a href="https://leetcode-cn.com/problems/132-pattern/" target="_blank" rel="noopener">132 模式</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给你一个整数数组 <code>nums</code> ，数组中共有 <code>n</code> 个整数。<strong>132 模式的子序列</strong> 由三个整数 <code>nums[i]</code>、<code>nums[j]</code> 和 <code>nums[k]</code> 组成</li><li>并同时满足：<code>i &lt; j &lt; k</code> 和 <code>nums[i] &lt; nums[k] &lt; nums[j]</code> 。</li></ul><p>如果 <code>nums</code> 中存在 <strong>132 模式的子序列</strong> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>注意：</strong></p><p><strong>进阶：</strong>很容易想到时间复杂度为 <code>O(n^2)</code> 的解决方案，你可以设计一个时间复杂度为 <code>O(n logn)</code> 或 <code>O(n)</code> 的解决方案吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：序列中不存在 132 模式的子序列。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [3,1,4,2]</span><br><span class="line">输出：true</span><br><span class="line">解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [-1,3,2,0]</span><br><span class="line">输出：true</span><br><span class="line">解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 10^4</code></li><li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li></ul><a id="more"></a><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p><strong>思路</strong></p><ul><li><strong>由于本题中的<code>n</code> 最大值为10^4，因此对一个满足132的三元组下标（i,j,k），枚举其中两个下标的时间复杂度是O(n^2),很容易超出时间的限制</strong></li><li><strong>因此我们可以考虑枚举其中的 1个下标，并使用合适的数据结构维护另外的 2 个下标的可能值。</strong></li></ul><p><strong>算法：枚举3</strong></p><ul><li>枚举 3 是容易想到并且也是最容易实现的。由于 3 是模式中的最大值，并且其出现在 1 和 2 的中间，因此我们只需要从左到右枚举 3 的下标 j，那么：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-093150639.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find132pattern</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 特判 : 少于三个元素不能构成132</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 定义左侧最小值</span></span><br><span class="line">        <span class="keyword">int</span> leftMin = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将右侧所有元素放进到有序集合中</span></span><br><span class="line">        TreeMap&lt;Integer,Integer&gt; rightAll = <span class="keyword">new</span> TreeMap&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>;k &lt; n;++k)&#123;</span><br><span class="line">            rightAll.put(nums[k],rightAll.getOrDefault(nums[k],<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 枚举3</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n - <span class="number">1</span>;++j)&#123;</span><br><span class="line">            <span class="comment">// 3.1 满足132中的nums[i] &lt; nums[j]的条件</span></span><br><span class="line">            <span class="keyword">if</span>(leftMin &lt; nums[j])&#123;              </span><br><span class="line">                Integer next = rightAll.ceilingKey(leftMin + <span class="number">1</span>);        <span class="comment">// ceilingKey：方法调用返回的最小的大于或等于的键，如果不存在这样的键在则返回null。（这里的作用是返回TreeMap 中的大于leftMin的最小值）</span></span><br><span class="line">                <span class="keyword">if</span>(next != <span class="keyword">null</span> &amp;&amp; next &lt; nums[j])&#123;                     <span class="comment">// 如果这个最小值存在且小于nums[j]:说明满足132的整体条件</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3.2 不满足132中：nums[i] &lt; nums[j] 条件</span></span><br><span class="line">            leftMin = Math.min(leftMin, nums[j]);                       <span class="comment">// 更新leftMin（nums[i]）的值</span></span><br><span class="line">            rightAll.put(nums[j + <span class="number">1</span>], rightAll.get(nums[j + <span class="number">1</span>]) - <span class="number">1</span>);   <span class="comment">// 将有序集合中的nums[j + 1]对应的键值-1 相当于将“窗口”右移一位</span></span><br><span class="line">            <span class="keyword">if</span>(rightAll.get(nums[j + <span class="number">1</span>]) == <span class="number">0</span>)&#123;                         <span class="comment">// 若有序集合中的nums[j + 1]对应的键值==0 删除这个键值对</span></span><br><span class="line">                rightAll.remove(nums[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 枚举结束未找到返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210327-094311749.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode–456-132-模式&quot;&gt;&lt;a href=&quot;#Leetcode–456-132-模式&quot; class=&quot;headerlink&quot; title=&quot;Leetcode–456-132 模式&quot;&gt;&lt;/a&gt;Leetcode–456-&lt;a href=&quot;https://leetcode-cn.com/problems/132-pattern/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;132 模式&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，数组中共有 &lt;code&gt;n&lt;/code&gt; 个整数。&lt;strong&gt;132 模式的子序列&lt;/strong&gt; 由三个整数 &lt;code&gt;nums[i]&lt;/code&gt;、&lt;code&gt;nums[j]&lt;/code&gt; 和 &lt;code&gt;nums[k]&lt;/code&gt; 组成&lt;/li&gt;
&lt;li&gt;并同时满足：&lt;code&gt;i &amp;lt; j &amp;lt; k&lt;/code&gt; 和 &lt;code&gt;nums[i] &amp;lt; nums[k] &amp;lt; nums[j]&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果 &lt;code&gt;nums&lt;/code&gt; 中存在 &lt;strong&gt;132 模式的子序列&lt;/strong&gt; ，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进阶：&lt;/strong&gt;很容易想到时间复杂度为 &lt;code&gt;O(n^2)&lt;/code&gt; 的解决方案，你可以设计一个时间复杂度为 &lt;code&gt;O(n logn)&lt;/code&gt; 或 &lt;code&gt;O(n)&lt;/code&gt; 的解决方案吗？&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [1,2,3,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：序列中不存在 132 模式的子序列。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [3,1,4,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [-1,3,2,0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;n == nums.length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= n &amp;lt;= 10^4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-10^9 &amp;lt;= nums[i] &amp;lt;= 10^9&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="(i,j,k)" scheme="http://zhuuu.work/tags/i-j-k/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-697-数组的度</title>
    <link href="http://zhuuu.work/2021/02/15/Leetcode/Leetcode-697-%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%A6/"/>
    <id>http://zhuuu.work/2021/02/15/Leetcode/Leetcode-697-%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%A6/</id>
    <published>2021-02-15T07:52:53.000Z</published>
    <updated>2021-02-20T05:16:28.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-697-数组的度"><a href="#Leecode-697-数组的度" class="headerlink" title="Leecode-697-数组的度"></a>Leecode-697-<a href="https://leetcode-cn.com/problems/degree-of-an-array/" target="_blank" rel="noopener">数组的度</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>给定一个非空且只包含非负数的整数数组 <code>nums</code>，数组的度的定义是指数组里任一元素出现频数的最大值。</p></li><li><p>你的任务是在 <code>nums</code> 中找到与 <code>nums</code>拥有<strong>相同大小的度的最短连续子数组，返回其长度。</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：[1, 2, 2, 3, 1]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">输入数组的度是2，因为元素1和2的出现频数最大，均为2.</span><br><span class="line">连续子数组里面拥有相同度的有如下所示:</span><br><span class="line">[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]</span><br><span class="line">最短连续子数组[2, 2]的长度为2，所以返回2.</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：[1,2,2,3,1,4,2]</span><br><span class="line">输出：6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">nums.length 在1到 50,000 区间范围内。</span><br><span class="line">nums[i] 是一个在 0 到 49,999 范围内的整数。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路：哈希表-贪心"><a href="#思路：哈希表-贪心" class="headerlink" title="思路：哈希表+贪心"></a>思路：哈希表+贪心</h2><ul><li>记原数组中出现次数最多的数为 x<em>，那么和原数组的度相同的最短连续子数组，必然包含了原数组中的全部 x</em>，<strong>且两端恰为 x 第一次出现和最后一次出现的位置。</strong></li><li>因为符合条件的 x可能有多个，即多个不同的数在原数组中出现次数相同。所以为了找到这个子数组，我们需要统计每一个数出现的次数，同时还需要统计每一个数第一次出现和最后一次出现的位置。<ul><li>使用哈希表实现该功能，每一个数映射到一个长度为 3 的数组，</li><li>数组中的三个元素分别代表这个数出现的次数、这个数在原数组中第一次出现的位置和这个数在原数组中最后一次出现的位置。</li></ul></li><li>当我们记录完所有信息后，我们需要遍历该哈希表，找到元素出现次数最多，且前后位置差最小的数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findShortestSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 哈希表记录：遍历一次哈希表</span></span><br><span class="line">            <span class="comment">// 1.数字出现的次数</span></span><br><span class="line">            <span class="comment">// 2.该数字第一次出现的下标</span></span><br><span class="line">            <span class="comment">// 3.该数字最后一次出现的下标</span></span><br><span class="line">        Map&lt;Integer,<span class="keyword">int</span>[]&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;</span><br><span class="line">                map.get(nums[i])[<span class="number">0</span>]++;                      <span class="comment">// 当前数字出现次数加1</span></span><br><span class="line">                map.get(nums[i])[<span class="number">2</span>] = i;                    <span class="comment">// 更新出现的最后一次下标</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(nums[i],<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,i,i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 统计哈希表</span></span><br><span class="line">        <span class="keyword">int</span> maxNum = <span class="number">0</span>;                                     <span class="comment">// 出现次数最多的数字</span></span><br><span class="line">        <span class="keyword">int</span> minLen = <span class="number">0</span>;                                     <span class="comment">// 第一次出现和最后一次出现的间隔</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,<span class="keyword">int</span>[]&gt; entry:map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = entry.getValue();                   <span class="comment">// 遍历哈希表拿到每个数字对应的数组</span></span><br><span class="line">            <span class="keyword">if</span>(maxNum &lt; arr[<span class="number">0</span>])&#123;                            <span class="comment">// 如果不是出现次数最多的</span></span><br><span class="line">                maxNum = arr[<span class="number">0</span>];</span><br><span class="line">                minLen = arr[<span class="number">2</span>] - arr[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(maxNum == arr[<span class="number">0</span>])&#123;                     <span class="comment">// 如果出现次数是最多的数字</span></span><br><span class="line">                <span class="keyword">if</span>(minLen &gt; arr[<span class="number">2</span>] - arr[<span class="number">1</span>] + <span class="number">1</span>)&#123;</span><br><span class="line">                    minLen = arr[<span class="number">2</span>] - arr[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLen;                                      <span class="comment">// 返回子数组长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n)，其中 n 是原数组的长度，我们需要遍历原数组和哈希表各一次，它们的大小均为 O(n)。</p></li><li><p>空间复杂度：O(n)，其中 n 是原数组的长度，最坏情况下，哈希表和原数组等大。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-697-数组的度&quot;&gt;&lt;a href=&quot;#Leecode-697-数组的度&quot; class=&quot;headerlink&quot; title=&quot;Leecode-697-数组的度&quot;&gt;&lt;/a&gt;Leecode-697-&lt;a href=&quot;https://leetcode-cn.com/problems/degree-of-an-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数组的度&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;给定一个非空且只包含非负数的整数数组 &lt;code&gt;nums&lt;/code&gt;，数组的度的定义是指数组里任一元素出现频数的最大值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;你的任务是在 &lt;code&gt;nums&lt;/code&gt; 中找到与 &lt;code&gt;nums&lt;/code&gt;拥有&lt;strong&gt;相同大小的度的最短连续子数组，返回其长度。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[1, 2, 2, 3, 1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入数组的度是2，因为元素1和2的出现频数最大，均为2.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;连续子数组里面拥有相同度的有如下所示:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;最短连续子数组[2, 2]的长度为2，所以返回2.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[1,2,2,3,1,4,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums.length 在1到 50,000 区间范围内。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums[i] 是一个在 0 到 49,999 范围内的整数。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="哈希表" scheme="http://zhuuu.work/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-703-数据流中的第K大元素</title>
    <link href="http://zhuuu.work/2021/02/11/Leetcode/Leetcode-703-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <id>http://zhuuu.work/2021/02/11/Leetcode/Leetcode-703-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/</id>
    <published>2021-02-11T05:24:53.000Z</published>
    <updated>2021-02-11T06:19:00.682Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-703-数据流中的第-K-大元素"><a href="#Leetcode-703-数据流中的第-K-大元素" class="headerlink" title="Leetcode-703- 数据流中的第 K 大元素"></a>Leetcode-703-<a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/" target="_blank" rel="noopener"> 数据流中的第 K 大元素</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。</p></li><li><p>请实现 <code>KthLargest</code>类：</p><ul><li><code>KthLargest(int k, int[] nums)</code> 使用整数 k 和整数流 <code>nums</code>初始化对象。<br><code>int add(int val)</code>将 val 插入数据流 <code>nums</code>后，返回当前数据流中第 k 大的元素。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;KthLargest&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;]</span><br><span class="line">[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]</span><br><span class="line">输出：</span><br><span class="line">[null, 4, 5, 5, 8, 8]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">KthLargest kthLargest &#x3D; new KthLargest(3, [4, 5, 8, 2]);</span><br><span class="line">kthLargest.add(3);   &#x2F;&#x2F; return 4</span><br><span class="line">kthLargest.add(5);   &#x2F;&#x2F; return 5</span><br><span class="line">kthLargest.add(10);  &#x2F;&#x2F; return 5</span><br><span class="line">kthLargest.add(9);   &#x2F;&#x2F; return 8</span><br><span class="line">kthLargest.add(4);   &#x2F;&#x2F; return 8</span><br><span class="line"></span><br><span class="line">**注意:**</span><br><span class="line"></span><br><span class="line">- 提示：</span><br><span class="line">  1 &lt;&#x3D; k &lt;&#x3D; 104</span><br><span class="line">  0 &lt;&#x3D; nums.length &lt;&#x3D; 104</span><br><span class="line">  -104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</span><br><span class="line">  -104 &lt;&#x3D; val &lt;&#x3D; 104</span><br><span class="line">  最多调用 add 方法 10^4 次</span><br><span class="line">  题目数据保证，在查找第 k 大元素时，数组中至少有 k 个元素</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-：-优先队列"><a href="#思路-：-优先队列" class="headerlink" title="思路 ： 优先队列"></a>思路 ： 优先队列</h2><ul><li>使用一个大小为 k 的优先队列来存储前 k大的元素，其中优先队列的队头为队列中最小的元素，也就是第 k 大的元素。</li><li>在单次插入的操作中，我们首先将元素 val 加入到优先队列中。</li><li>如果此时优先队列的大小大于 k，我们需要将优先队列的队头元素弹出，以保证优先队列的大小为 <em>k</em>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 初始化</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KthLargest</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        pq = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)&#123;</span><br><span class="line">            add(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. k大元素逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        pq.offer(val);</span><br><span class="line">        <span class="keyword">if</span>(pq.size() &gt; k)&#123;</span><br><span class="line">            pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li><h2 id="时间复杂度：O-nlogk"><a href="#时间复杂度：O-nlogk" class="headerlink" title="时间复杂度：O(nlogk)"></a>时间复杂度：O(nlogk)</h2></li><li>空间复杂度：O(k) 使用大小为k的优先队列</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-703-数据流中的第-K-大元素&quot;&gt;&lt;a href=&quot;#Leetcode-703-数据流中的第-K-大元素&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-703- 数据流中的第 K 大元素&quot;&gt;&lt;/a&gt;Leetcode-703-&lt;a href=&quot;https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; 数据流中的第 K 大元素&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;请实现 &lt;code&gt;KthLargest&lt;/code&gt;类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;KthLargest(int k, int[] nums)&lt;/code&gt; 使用整数 k 和整数流 &lt;code&gt;nums&lt;/code&gt;初始化对象。&lt;br&gt;&lt;code&gt;int add(int val)&lt;/code&gt;将 val 插入数据流 &lt;code&gt;nums&lt;/code&gt;后，返回当前数据流中第 k 大的元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&amp;quot;KthLargest&amp;quot;, &amp;quot;add&amp;quot;, &amp;quot;add&amp;quot;, &amp;quot;add&amp;quot;, &amp;quot;add&amp;quot;, &amp;quot;add&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[null, 4, 5, 5, 8, 8]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;KthLargest kthLargest &amp;#x3D; new KthLargest(3, [4, 5, 8, 2]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kthLargest.add(3);   &amp;#x2F;&amp;#x2F; return 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kthLargest.add(5);   &amp;#x2F;&amp;#x2F; return 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kthLargest.add(10);  &amp;#x2F;&amp;#x2F; return 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kthLargest.add(9);   &amp;#x2F;&amp;#x2F; return 8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kthLargest.add(4);   &amp;#x2F;&amp;#x2F; return 8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;**注意:**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- 提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  1 &amp;lt;&amp;#x3D; k &amp;lt;&amp;#x3D; 104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  0 &amp;lt;&amp;#x3D; nums.length &amp;lt;&amp;#x3D; 104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  -104 &amp;lt;&amp;#x3D; nums[i] &amp;lt;&amp;#x3D; 104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  -104 &amp;lt;&amp;#x3D; val &amp;lt;&amp;#x3D; 104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  最多调用 add 方法 10^4 次&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  题目数据保证，在查找第 k 大元素时，数组中至少有 k 个元素&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="优先队列" scheme="http://zhuuu.work/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-643-子数组最大平均数1</title>
    <link href="http://zhuuu.work/2021/02/04/Leetcode/Leetcode-643-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B01/"/>
    <id>http://zhuuu.work/2021/02/04/Leetcode/Leetcode-643-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B01/</id>
    <published>2021-02-04T07:52:53.000Z</published>
    <updated>2021-02-04T02:27:43.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-643-子数组最大平均数-I"><a href="#Leetcode-643-子数组最大平均数-I" class="headerlink" title="Leetcode-643-子数组最大平均数 I"></a>Leetcode-643-<a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/" target="_blank" rel="noopener">子数组最大平均数 I</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 <code>n</code> 个整数，找出平均数最大且长度为 <code>k</code> 的连续子数组，并输出该最大平均数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：[1,12,-5,-6,50,3], k &#x3D; 4</span><br><span class="line">输出：12.75</span><br><span class="line">解释：最大平均数 (12-5-6+50)&#x2F;4 &#x3D; 51&#x2F;4 &#x3D; 12.75</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; n &lt;&#x3D; 30,000。</span><br><span class="line">所给数据范围 [-10,000，10,000]。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法一-：-滑动窗口"><a href="#方法一-：-滑动窗口" class="headerlink" title="方法一 ： 滑动窗口"></a>方法一 ： 滑动窗口</h2><ul><li><strong>由于规定了子数组的长度为 k，因此可以通过寻找子数组的最大元素和的方式寻找子数组的最大平均数，元素和最大的子数组对应的平均数也是最大的。</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设两个不同的子数组的长度都是 k，这两个子数组的元素和分别是 x 和 y，</span><br><span class="line">则这两个子数组的平均数分别是 x&#x2F;k 和 y&#x2F;k。</span><br><span class="line">如果 x≥y，则有 x&#x2F;k ≥ y&#x2F;k，即如果一个子数组的元素和更大，则该子数组的平均数也更大。</span><br></pre></td></tr></table></figure><ul><li><strong>为了找到子数组的最大元素和，需要对数组中的每个长度为k的子数组为别计算元素和。对于长度为n的数组，当k &lt;= n的时候，有n - k + 1个长度为k的子数组</strong></li><li>如果直接计算每个子数组的元素和，则时间复杂度过高，无法通过全部测试用例，因此需要使用时间复杂度更低的方法计算每个子数组的元素和。</li></ul><hr><p><strong>滑动窗口推导</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/102250831.png" alt="mark"></p><ul><li><p>上述过程可以看成维护一个长度为k的滑动窗口。当滑动窗口的下标范围从<code>[i - k,i - 1]</code> 到 <code>[i - k + 1,i]</code>时，<code>nums[i - k]</code> 从窗口移除，<code>nums[i]</code> 进入到窗口内</p></li><li><p>利用上述关系，可以在O(1) 的时候内通过<code>sum_i-1</code> 得到 <code>sum_i</code></p></li><li><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/102651739.png" alt="mark"></p></li><li><p>在上述过程中维护最大的子数组元素和，记为maxSum，子数组的最大平均数即为 maxSum/k。</p></li><li><p>需要注意返回值是浮点型，因此计算除法时需要进行数据类型转换。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/102557416.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/102613774.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/102624973.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/102630741.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/102636265.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMaxAverage</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 长度小于k的时候，直接初始化sum</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 长度大于等于k的时候，比较最大的连续子数组和</span></span><br><span class="line">        <span class="keyword">int</span> maxSum = sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k;i &lt; n;i++)&#123;</span><br><span class="line">            sum = sum - nums[i - k] + nums[i];</span><br><span class="line">            maxSum = Math.max(maxSum,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 返回浮点结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span> * maxSum/k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度  : O(n)</li><li>空间复杂度 ：O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-643-子数组最大平均数-I&quot;&gt;&lt;a href=&quot;#Leetcode-643-子数组最大平均数-I&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-643-子数组最大平均数 I&quot;&gt;&lt;/a&gt;Leetcode-643-&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-average-subarray-i/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;子数组最大平均数 I&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定 &lt;code&gt;n&lt;/code&gt; 个整数，找出平均数最大且长度为 &lt;code&gt;k&lt;/code&gt; 的连续子数组，并输出该最大平均数。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[1,12,-5,-6,50,3], k &amp;#x3D; 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：12.75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：最大平均数 (12-5-6+50)&amp;#x2F;4 &amp;#x3D; 51&amp;#x2F;4 &amp;#x3D; 12.75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; k &amp;lt;&amp;#x3D; n &amp;lt;&amp;#x3D; 30,000。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;所给数据范围 [-10,000，10,000]。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="滑动窗口" scheme="http://zhuuu.work/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-424-替换后的最长重复字符</title>
    <link href="http://zhuuu.work/2021/02/03/Leetcode/Leetcode-424-%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6/"/>
    <id>http://zhuuu.work/2021/02/03/Leetcode/Leetcode-424-%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6/</id>
    <published>2021-02-03T03:52:53.000Z</published>
    <updated>2021-02-04T13:21:09.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-424-替换后的最长重复字符"><a href="#Leetcode-424-替换后的最长重复字符" class="headerlink" title="Leetcode-424-替换后的最长重复字符"></a>Leetcode-424-<a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/" target="_blank" rel="noopener">替换后的最长重复字符</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。</p><p>注意：字符串长度 和 k 不会超过 104。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;ABAB&quot;, k &#x3D; 2</span><br><span class="line">输出：4</span><br><span class="line">解释：用两个&#39;A&#39;替换为两个&#39;B&#39;,反之亦然。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;AABABBA&quot;, k &#x3D; 1</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">将中间的一个&#39;A&#39;替换为&#39;B&#39;,字符串变为 &quot;AABBBBA&quot;。</span><br><span class="line">子串 &quot;BBBB&quot; 有最长重复字母, 答案为 4。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法一-：-滑动窗口"><a href="#方法一-：-滑动窗口" class="headerlink" title="方法一 ： 滑动窗口"></a>方法一 ： 滑动窗口</h2><p><strong>说一下暴力解法：</strong></p><ul><li><p>如果一个问题暂时没有思路，可以先考虑暴力解法（不一定要实现）。<strong>当前问题的暴力解法是：枚举输入字符串的 所有 子串，对于每一个子串：</strong></p><ul><li>如果子串里所有的字符都一样，就考虑长度更长的子串；</li><li>如果当前子串里出现了至少两种字符，要想使得替换以后所有的字符都一样，并且重复的、连续的部分更长，<strong>应该替换掉出现次数最多字符 以外 的字符。</strong></li></ul></li></ul><p><strong>暴力解法的缺点：</strong></p><ul><li>做了重复的工作，子串和子串有很多重合的部分，重复扫描它们是不划算的；</li><li>做了很多没有必要的工作：<ul><li><strong>如果找到了一个长度为 L 且替换 k 个字符以后全部相等的子串</strong>，就没有必要考虑长度小于等于 L 的子串，因为题目只让我们找到符合题意的最长的长度；</li><li><strong>如果找到了一个长度为 L 且替换 k 个字符以后不能全部相等的子串</strong>，左边界相同、长度更长的子串一定不符合要求（原因我们放在最后说）。</li></ul></li></ul><hr><p><strong>滑动窗口</strong></p><ul><li>以 <code>s = AABCABBB</code>，<code>k = 2</code> 为例，寻找替换 <code>k</code> 次以后字符全部相等的最长子串的长度的过程如下图所示：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/104646614.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/104658660.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/104706538.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/104713644.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/104722926.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/104731243.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/104740342.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/112527361.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/113537783.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/113631793.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/113644299.png" alt="mark"></p><hr><ul><li><p>整个过程，我们使用了两个表示边界的变量，一前一后，交替在字符串上前进</p></li><li><p>右边界先向右移动，直到不能移动了为止，左边界再继续向右移动，整个过程像极了一条滑动的窗口在线段上移动。</p></li><li><p>除此之外，考虑的子串中最多出现的字符是次数，因此须要一个频数数组，记录每个字符出现的次数。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210204/114022723.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characterReplacement</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 特判</span></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)&#123;                                <span class="comment">// 长度为0或1</span></span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 初始化条件</span></span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] freq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];                   <span class="comment">// 记录字符出现的频率</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 遍历一次字符数组</span></span><br><span class="line">        <span class="keyword">while</span>(right &lt; len)&#123;</span><br><span class="line">            <span class="comment">// 3.1 在这里维护maxCount,因为每一次右边界读入一个字符，字符的频率增加，才会使得maxCount增加</span></span><br><span class="line">            freq[charArray[right] - <span class="string">'A'</span>]++;</span><br><span class="line">            maxCount = Math.max(maxCount,freq[charArray[right] - <span class="string">'A'</span>]);</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2 </span></span><br><span class="line">            <span class="keyword">if</span>(right - left &gt; maxCount + k)&#123;        <span class="comment">// 说明此时的k不够用，其他不适 最多出现的字符替换以后，都不能填满这个滑动窗口</span></span><br><span class="line">                freq[charArray[left] - <span class="string">'A'</span>]--;      <span class="comment">// 移出滑动窗口的时候，频数数组须要相应地做减法</span></span><br><span class="line">                left++;                             <span class="comment">// 左边界向右移动</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3.3 </span></span><br><span class="line">            res = Math.max(res,right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)，这里 N 是输入字符串 <code>S</code> 的长度；</li><li>空间复杂度：O(A)，这里 A<em>A</em> 是输入字符串 <code>S</code> 出现的字符 ASCII 值的范围</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-424-替换后的最长重复字符&quot;&gt;&lt;a href=&quot;#Leetcode-424-替换后的最长重复字符&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-424-替换后的最长重复字符&quot;&gt;&lt;/a&gt;Leetcode-424-&lt;a href=&quot;https://leetcode-cn.com/problems/longest-repeating-character-replacement/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;替换后的最长重复字符&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。&lt;/p&gt;
&lt;p&gt;注意：字符串长度 和 k 不会超过 104。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;ABAB&amp;quot;, k &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：用两个&amp;#39;A&amp;#39;替换为两个&amp;#39;B&amp;#39;,反之亦然。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;AABABBA&amp;quot;, k &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;将中间的一个&amp;#39;A&amp;#39;替换为&amp;#39;B&amp;#39;,字符串变为 &amp;quot;AABBBBA&amp;quot;。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;子串 &amp;quot;BBBB&amp;quot; 有最长重复字母, 答案为 4。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="滑动窗口" scheme="http://zhuuu.work/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-888-公平的糖果交换</title>
    <link href="http://zhuuu.work/2021/02/01/Leetcode/Leetcode-888-%E5%85%AC%E5%B9%B3%E7%9A%84%E7%B3%96%E6%9E%9C%E4%BA%A4%E6%8D%A2/"/>
    <id>http://zhuuu.work/2021/02/01/Leetcode/Leetcode-888-%E5%85%AC%E5%B9%B3%E7%9A%84%E7%B3%96%E6%9E%9C%E4%BA%A4%E6%8D%A2/</id>
    <published>2021-02-01T02:52:53.000Z</published>
    <updated>2021-02-03T12:24:35.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-888-公平的糖果棒交换"><a href="#Leetcode-888-公平的糖果棒交换" class="headerlink" title="Leetcode-888-公平的糖果棒交换"></a>Leetcode-888-<a href="https://leetcode-cn.com/problems/fair-candy-swap/" target="_blank" rel="noopener">公平的糖果棒交换</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>爱丽丝和鲍勃有不同大小的糖果棒：A[i] 是爱丽丝拥有的第 i 根糖果棒的大小，B[j] 是鲍勃拥有的第 j 根糖果棒的大小。</p></li><li><p>因为他们是朋友，所以他们想交换一根糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）</p></li><li><p>返回一个整数数组 ans，其中 ans[0] 是爱丽丝必须交换的糖果棒的大小，ans[1] 是 Bob 必须交换的糖果棒的大小。</p></li><li><p>如果有多个答案，你可以返回其中任何一个。保证答案存在。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; [1,1], B &#x3D; [2,2]</span><br><span class="line">输出：[1,2]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; [1,2], B &#x3D; [2,3]</span><br><span class="line">输出：[1,2]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; [2], B &#x3D; [1,3]</span><br><span class="line">输出：[2,3]</span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; [1,2,5], B &#x3D; [2,4]</span><br><span class="line">输出：[5,4]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; A.length &lt;&#x3D; 10000</span><br><span class="line">1 &lt;&#x3D; B.length &lt;&#x3D; 10000</span><br><span class="line">1 &lt;&#x3D; A[i] &lt;&#x3D; 100000</span><br><span class="line">1 &lt;&#x3D; B[i] &lt;&#x3D; 100000</span><br><span class="line">保证爱丽丝与鲍勃的糖果总量不同。</span><br><span class="line">答案肯定存在。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法一-：-哈希表"><a href="#方法一-：-哈希表" class="headerlink" title="方法一 ： 哈希表"></a>方法一 ： 哈希表</h2><ul><li>记爱丽丝的糖果棒的总大小为sumA，鲍勃的糖果棒的总大小为sumB。</li><li>设答案为 {x,y}，即爱丽丝的大小为 x 的糖果棒与鲍勃的大小为 y 的糖果棒交换，则有如下等式：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210203/202301960.png" alt="mark"></p><ul><li><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210203/202316825.png" alt="mark"></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] fairCandySwap(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B) &#123;</span><br><span class="line">        <span class="comment">// 1. 分别求出数组A和B的和</span></span><br><span class="line">        <span class="keyword">int</span> sumA = Arrays.stream(A).sum();</span><br><span class="line">        <span class="keyword">int</span> sumB = Arrays.stream(B).sum();</span><br><span class="line">        <span class="keyword">int</span> delta = (sumA - sumB)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 将A的数字存入哈希表 方便查询</span></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];                             <span class="comment">// 结果集</span></span><br><span class="line">        Set&lt;Integer&gt; setA = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:A)&#123;</span><br><span class="line">            setA.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 遍历B中每一个元素，看A中是否存在可以交换的数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y:B)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = y + delta;</span><br><span class="line">            <span class="keyword">if</span>(setA.contains(x))&#123;</span><br><span class="line">                ans[<span class="number">0</span>] = x;</span><br><span class="line">                ans[<span class="number">1</span>] = y;</span><br><span class="line">                <span class="keyword">break</span>;                                     <span class="comment">// 存在一组立即结束</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度 ： O(m + n) ，最差情况下两个数组都需要进行遍历</li><li>空间复杂度 ： O(n)  , n 为 数组A的长度</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-888-公平的糖果棒交换&quot;&gt;&lt;a href=&quot;#Leetcode-888-公平的糖果棒交换&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-888-公平的糖果棒交换&quot;&gt;&lt;/a&gt;Leetcode-888-&lt;a href=&quot;https://leetcode-cn.com/problems/fair-candy-swap/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;公平的糖果棒交换&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;爱丽丝和鲍勃有不同大小的糖果棒：A[i] 是爱丽丝拥有的第 i 根糖果棒的大小，B[j] 是鲍勃拥有的第 j 根糖果棒的大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;因为他们是朋友，所以他们想交换一根糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;返回一个整数数组 ans，其中 ans[0] 是爱丽丝必须交换的糖果棒的大小，ans[1] 是 Bob 必须交换的糖果棒的大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果有多个答案，你可以返回其中任何一个。保证答案存在。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：A &amp;#x3D; [1,1], B &amp;#x3D; [2,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：A &amp;#x3D; [1,2], B &amp;#x3D; [2,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：A &amp;#x3D; [2], B &amp;#x3D; [1,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[2,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 4：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：A &amp;#x3D; [1,2,5], B &amp;#x3D; [2,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[5,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; A.length &amp;lt;&amp;#x3D; 10000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; B.length &amp;lt;&amp;#x3D; 10000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; A[i] &amp;lt;&amp;#x3D; 100000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; B[i] &amp;lt;&amp;#x3D; 100000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;保证爱丽丝与鲍勃的糖果总量不同。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;答案肯定存在。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-724-寻找数组的中心索引</title>
    <link href="http://zhuuu.work/2021/01/28/Leetcode/Leetcode-724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/"/>
    <id>http://zhuuu.work/2021/01/28/Leetcode/Leetcode-724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/</id>
    <published>2021-01-28T05:24:53.000Z</published>
    <updated>2021-01-28T01:24:28.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-724-寻找数组的中心索引"><a href="#Leetcode-724-寻找数组的中心索引" class="headerlink" title="Leetcode-724-寻找数组的中心索引"></a>Leetcode-724-<a href="https://leetcode-cn.com/problems/find-pivot-index/" target="_blank" rel="noopener">寻找数组的中心索引</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>给定一个整数类型的数组 nums，请编写一个能够返回数组 “中心索引” 的方法。</p></li><li><p>我们是这样定义数组 中心索引 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。</p></li><li><p>如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">索引 <span class="number">3</span> (nums[<span class="number">3</span>] = <span class="number">6</span>) 的左侧数之和 (<span class="number">1</span> + <span class="number">7</span> + <span class="number">3</span> = <span class="number">11</span>)，与右侧数之和 (<span class="number">5</span> + <span class="number">6</span> = <span class="number">11</span>) 相等。</span><br><span class="line">同时, <span class="number">3</span> 也是第一个符合要求的中心索引。</span><br><span class="line">    </span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">输出：-<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">数组中不存在满足此条件的中心索引。</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><code>nums</code> 的长度范围为 <code>[0, 10000]</code>。</li><li>任何一个 <code>nums[i]</code> 将会是一个范围在 <code>[-1000, 1000]</code>的整数。</li></ul><a id="more"></a><h2 id="方法一-：-前缀和"><a href="#方法一-：-前缀和" class="headerlink" title="方法一 ： 前缀和"></a>方法一 ： 前缀和</h2><ul><li><p><strong>记录数组的全部元素之和为total</strong></p></li><li><p>当遍历到第i个元素的时候，设其左侧元素之和为sum,右侧之和就是<code>total - sum - nums[i]</code></p></li><li><p>左右侧元素相等 <code>sum = total - nums[i] - sum</code> ，即 <code>2 * sum + nums[i] = total</code></p></li><li><p>当中心索引左侧或右侧没有元素时，即为零个项相加，<strong>这在数学上称作「空和」（empty sum）。在程序设计中我们约定「空和是零」。</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 计算全部元素之和</span></span><br><span class="line">        <span class="keyword">int</span> total = Arrays.stream(nums).sum();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 左侧元素之和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 左右侧元素之和相等</span></span><br><span class="line">        <span class="comment">// sum = total - nums[i] - sum</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span> * sum + nums[i] == total)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 不存在的话</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O(n)</li><li>空间复杂度 ： O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-724-寻找数组的中心索引&quot;&gt;&lt;a href=&quot;#Leetcode-724-寻找数组的中心索引&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-724-寻找数组的中心索引&quot;&gt;&lt;/a&gt;Leetcode-724-&lt;a href=&quot;https://leetcode-cn.com/problems/find-pivot-index/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;寻找数组的中心索引&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;给定一个整数类型的数组 nums，请编写一个能够返回数组 “中心索引” 的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我们是这样定义数组 中心索引 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;索引 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; (nums[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;) 的左侧数之和 (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;)，与右侧数之和 (&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) 相等。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;同时, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; 也是第一个符合要求的中心索引。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;数组中不存在满足此条件的中心索引。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nums&lt;/code&gt; 的长度范围为 &lt;code&gt;[0, 10000]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;任何一个 &lt;code&gt;nums[i]&lt;/code&gt; 将会是一个范围在 &lt;code&gt;[-1000, 1000]&lt;/code&gt;的整数。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="前缀和" scheme="http://zhuuu.work/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-989-数组形式的加法</title>
    <link href="http://zhuuu.work/2021/01/22/Leetcode/Leetcode-989-%E6%95%B0%E7%BB%84%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%8A%A0%E6%B3%95/"/>
    <id>http://zhuuu.work/2021/01/22/Leetcode/Leetcode-989-%E6%95%B0%E7%BB%84%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%8A%A0%E6%B3%95/</id>
    <published>2021-01-22T07:52:53.000Z</published>
    <updated>2021-01-22T02:22:12.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-989-数组形式的整数加法"><a href="#Leetcode-989-数组形式的整数加法" class="headerlink" title="Leetcode-989-数组形式的整数加法"></a>Leetcode-989-<a href="https://leetcode-cn.com/problems/add-to-array-form-of-integer/" target="_blank" rel="noopener">数组形式的整数加法</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 <code>X = 1231</code>，那么其数组形式为<code>[1,2,3,1]</code>。</p></li><li><p>给定非负整数 X 的数组形式 A，返回整数<code>X+K</code>的数组形式。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; [1,2,0,0], K &#x3D; 34</span><br><span class="line">输出：[1,2,3,4]</span><br><span class="line">解释：1200 + 34 &#x3D; 1234</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; [2,7,4], K &#x3D; 181</span><br><span class="line">输出：[4,5,5]</span><br><span class="line">解释：274 + 181 &#x3D; 455</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; [2,1,5], K &#x3D; 806</span><br><span class="line">输出：[1,0,2,1]</span><br><span class="line">解释：215 + 806 &#x3D; 1021</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; [9,9,9,9,9,9,9,9,9,9], K &#x3D; 1</span><br><span class="line">输出：[1,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">解释：9999999999 + 1 &#x3D; 10000000000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; A.length &lt;&#x3D; 10000</span><br><span class="line">0 &lt;&#x3D; A[i] &lt;&#x3D; 9</span><br><span class="line">0 &lt;&#x3D; K &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法一-：-模拟按位相加"><a href="#方法一-：-模拟按位相加" class="headerlink" title="方法一 ： 模拟按位相加"></a>方法一 ： 模拟按位相加</h2><ul><li>逐位将数字加在一起。例如计算 123+912，我们从低位到高位依次计算 3+2、2+1 和 1+9。任何时候，若加法的结果大于等于 10，把进位的 1 加入到下一位的计算中，所以最终结果为 1035。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">addToArrayForm</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化参数</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 从后往前逐位相加</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">// 1.1 逐位相加</span></span><br><span class="line">            <span class="keyword">int</span> sum = A[i] + K % <span class="number">10</span>;         <span class="comment">// 每次重置sum</span></span><br><span class="line">            K /= <span class="number">10</span>;    </span><br><span class="line">            <span class="comment">// 1.2 处理两位相加 进位的情况</span></span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">                K++;                        <span class="comment">// 进位到K的末尾</span></span><br><span class="line">                sum -= <span class="number">10</span>;                  <span class="comment">// 进位清掉</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1.2 当前相加的结果 添加到结果集</span></span><br><span class="line">            res.add(sum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. K的数字长度大于数组的数字长度</span></span><br><span class="line">        <span class="keyword">for</span>(;K &gt; <span class="number">0</span>;K /= <span class="number">10</span>)&#123;                <span class="comment">// 每次K左移一位</span></span><br><span class="line">            res.add(K % <span class="number">10</span>);                <span class="comment">// 添加到结果集</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将结果集翻转即是所求答案</span></span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 : O(max(n,logK)) , 其中K是数组的长度</li><li>空间复杂度 : O(max(n,logK))</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-989-数组形式的整数加法&quot;&gt;&lt;a href=&quot;#Leetcode-989-数组形式的整数加法&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-989-数组形式的整数加法&quot;&gt;&lt;/a&gt;Leetcode-989-&lt;a href=&quot;https://leetcode-cn.com/problems/add-to-array-form-of-integer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数组形式的整数加法&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 &lt;code&gt;X = 1231&lt;/code&gt;，那么其数组形式为&lt;code&gt;[1,2,3,1]&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;给定非负整数 X 的数组形式 A，返回整数&lt;code&gt;X+K&lt;/code&gt;的数组形式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：A &amp;#x3D; [1,2,0,0], K &amp;#x3D; 34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,2,3,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：1200 + 34 &amp;#x3D; 1234&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：A &amp;#x3D; [2,7,4], K &amp;#x3D; 181&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[4,5,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：274 + 181 &amp;#x3D; 455&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：A &amp;#x3D; [2,1,5], K &amp;#x3D; 806&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,0,2,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：215 + 806 &amp;#x3D; 1021&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 4：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：A &amp;#x3D; [9,9,9,9,9,9,9,9,9,9], K &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,0,0,0,0,0,0,0,0,0,0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：9999999999 + 1 &amp;#x3D; 10000000000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; A.length &amp;lt;&amp;#x3D; 10000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0 &amp;lt;&amp;#x3D; A[i] &amp;lt;&amp;#x3D; 9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0 &amp;lt;&amp;#x3D; K &amp;lt;&amp;#x3D; 10000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="数学" scheme="http://zhuuu.work/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1232-缀点成线</title>
    <link href="http://zhuuu.work/2021/01/17/Leetcode/Leetcode-1232-%E7%BC%80%E7%82%B9%E6%88%90%E7%BA%BF/"/>
    <id>http://zhuuu.work/2021/01/17/Leetcode/Leetcode-1232-%E7%BC%80%E7%82%B9%E6%88%90%E7%BA%BF/</id>
    <published>2021-01-17T07:52:53.000Z</published>
    <updated>2021-01-17T06:02:14.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-1232-缀点成线"><a href="#Leetcode-1232-缀点成线" class="headerlink" title="Leetcode-1232-缀点成线"></a>Leetcode-1232-缀点成线</h1><h2 id="思路：深度优先遍历-DFS"><a href="#思路：深度优先遍历-DFS" class="headerlink" title="思路：深度优先遍历/DFS"></a>思路：深度优先遍历/DFS</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。</p></li><li><p>请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。</p></li></ul><p><strong>示例1：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210117/135800973.jpg" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coordinates &#x3D; [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210117/135821014.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coordinates &#x3D; [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-：-数学直线知识"><a href="#思路-：-数学直线知识" class="headerlink" title="思路 ： 数学直线知识"></a>思路 ： 数学直线知识</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210117/140102900.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkStraightLine</span><span class="params">(<span class="keyword">int</span>[][] coordinates)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 将所有点向(-deltax,-deltay) 方向进行平移 : 第一个点就移到了原点</span></span><br><span class="line">        <span class="keyword">int</span> deltaX = coordinates[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> deltaY = coordinates[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> n = coordinates.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            coordinates[i][<span class="number">0</span>] -= deltaX;</span><br><span class="line">            coordinates[i][<span class="number">1</span>] -= deltaY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 两点确定一条直线 设直线方程为 Ax + By = 0 带入(-deltax_1,-deltay_1)坐标</span></span><br><span class="line">        <span class="keyword">int</span> A = coordinates[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> B = -coordinates[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 判断从原点和第一个点以外的所有点是否在这条直线上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = coordinates[i][<span class="number">0</span>];<span class="comment">// 每个点的横坐标</span></span><br><span class="line">            <span class="keyword">int</span> y = coordinates[i][<span class="number">1</span>];<span class="comment">// 每个点的纵坐标</span></span><br><span class="line">            <span class="keyword">if</span>(A * x + B * y != <span class="number">0</span>)&#123;             <span class="comment">// 说明不在直线上</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)，其中 n 是数组中的元素数量。</li><li>时间复杂度：O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-1232-缀点成线&quot;&gt;&lt;a href=&quot;#Leetcode-1232-缀点成线&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-1232-缀点成线&quot;&gt;&lt;/a&gt;Leetcode-1232-缀点成线&lt;/h1&gt;&lt;h2 id=&quot;思路：深度优先遍历-DFS&quot;&gt;&lt;a href=&quot;#思路：深度优先遍历-DFS&quot; class=&quot;headerlink&quot; title=&quot;思路：深度优先遍历/DFS&quot;&gt;&lt;/a&gt;思路：深度优先遍历/DFS&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210117/135800973.jpg&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：coordinates &amp;#x3D; [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210117/135821014.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：coordinates &amp;#x3D; [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="数学" scheme="http://zhuuu.work/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-228-汇总区间</title>
    <link href="http://zhuuu.work/2021/01/10/Leetcode/Leetcode-228-%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4/"/>
    <id>http://zhuuu.work/2021/01/10/Leetcode/Leetcode-228-%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4/</id>
    <published>2021-01-10T00:33:53.000Z</published>
    <updated>2021-01-10T01:00:35.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-228-汇总区间"><a href="#Leetcode-228-汇总区间" class="headerlink" title="Leetcode-228-汇总区间"></a>Leetcode-228-<a href="https://leetcode-cn.com/problems/summary-ranges/" target="_blank" rel="noopener">汇总区间</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>给定一个无重复元素的有序整数数组 <code>nums</code> 。</p></li><li><p>返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。</p></li><li><p>列表中的每个区间范围 <code>[a,b]</code> 应该按如下格式输出：</p><ul><li><code>&quot;a-&gt;b&quot;</code> ，如果 <code>a != b</code></li><li><code>&quot;a&quot;</code> ，如果 <code>a == b</code></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [0,1,2,4,5,7]</span><br><span class="line">输出：[&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[0,2] --&gt; &quot;0-&gt;2&quot;</span><br><span class="line">[4,5] --&gt; &quot;4-&gt;5&quot;</span><br><span class="line">[7,7] --&gt; &quot;7&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [0,2,3,4,6,8,9]</span><br><span class="line">输出：[&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[0,0] --&gt; &quot;0&quot;</span><br><span class="line">[2,4] --&gt; &quot;2-&gt;4&quot;</span><br><span class="line">[6,6] --&gt; &quot;6&quot;</span><br><span class="line">[8,9] --&gt; &quot;8-&gt;9&quot;</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; []</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [-1]</span><br><span class="line">输出：[&quot;-1&quot;]</span><br><span class="line"></span><br><span class="line">示例 5：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：[&quot;0&quot;]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-：-双指针"><a href="#思路-：-双指针" class="headerlink" title="思路 ： 双指针"></a>思路 ： 双指针</h2><ul><li><strong>从数组的位置 0 出发，向右遍历。</strong></li><li>每次遇到相邻元素之间的差值大于 1 时，我们就找到了一个区间。遍历完数组之后，就能得到一系列的区间的列表。</li><li>在遍历过程中，<strong>维护下标 low 和 high 分别记录区间的起点和终点</strong><ul><li>对于任何区间都有 <code>low &lt;= high</code></li><li><strong>当得到一个区间的时候，根据low 和 high 的值生成区间的字符串表示</strong><ul><li><code>low &lt;= high</code> ，区间的字符串表示为<code>“nums[low] -&gt;nums[high]”</code></li><li><code>low == high</code> ，区间的字符串表表示为<code>&quot;nums[low]&quot;</code></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">summaryRanges</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();                               <span class="comment">// 结果集</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 遍历数组</span></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(idx &lt; n)&#123;</span><br><span class="line">            <span class="comment">// 1.1 区间扩大 ： 区间未断开</span></span><br><span class="line">            <span class="keyword">int</span> low = idx;                                                      <span class="comment">// 记录区间的起</span></span><br><span class="line">            idx++;                                                              <span class="comment">// ++到下一个位置 </span></span><br><span class="line">            <span class="keyword">while</span>(idx &lt; n &amp;&amp; nums[idx] == nums[idx - <span class="number">1</span>] + <span class="number">1</span>)&#123;                   <span class="comment">// 如果区间没有断开</span></span><br><span class="line">                idx++;                                                          <span class="comment">// 将区间进行扩大</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1.2 记录区间的终点 ： 断开退出循环</span></span><br><span class="line">            <span class="keyword">int</span> high = idx - <span class="number">1</span>;                                                 <span class="comment">// 记录区间的终点</span></span><br><span class="line">            <span class="comment">// 1.3 处理结果</span></span><br><span class="line">            StringBuilder temp = <span class="keyword">new</span> StringBuilder(Integer.toString(nums[low]));<span class="comment">// 首先加入起点位置,如果low &lt; high，当前区间为nums[low]]本身</span></span><br><span class="line">            <span class="keyword">if</span>(low &lt; high)&#123;                                                     <span class="comment">// low &lt; high 说明是一个完整连续的区间</span></span><br><span class="line">                temp.append(<span class="string">"-&gt;"</span>);</span><br><span class="line">                temp.append(Integer.toString(nums[high]));                      <span class="comment">// low -&gt; high</span></span><br><span class="line">            &#125;                   </span><br><span class="line">            <span class="comment">// 1.4 加入到结果集中</span></span><br><span class="line">            res.add(temp.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O(n)  其中n 为数组的长度</li><li>空间复杂度 ： O(1) 没有使用额外的空间</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-228-汇总区间&quot;&gt;&lt;a href=&quot;#Leetcode-228-汇总区间&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-228-汇总区间&quot;&gt;&lt;/a&gt;Leetcode-228-&lt;a href=&quot;https://leetcode-cn.com/problems/summary-ranges/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;汇总区间&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;给定一个无重复元素的有序整数数组 &lt;code&gt;nums&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;列表中的每个区间范围 &lt;code&gt;[a,b]&lt;/code&gt; 应该按如下格式输出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;a-&amp;gt;b&amp;quot;&lt;/code&gt; ，如果 &lt;code&gt;a != b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;a&amp;quot;&lt;/code&gt; ，如果 &lt;code&gt;a == b&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [0,1,2,4,5,7]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[&amp;quot;0-&amp;gt;2&amp;quot;,&amp;quot;4-&amp;gt;5&amp;quot;,&amp;quot;7&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：区间范围是：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[0,2] --&amp;gt; &amp;quot;0-&amp;gt;2&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[4,5] --&amp;gt; &amp;quot;4-&amp;gt;5&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[7,7] --&amp;gt; &amp;quot;7&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [0,2,3,4,6,8,9]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[&amp;quot;0&amp;quot;,&amp;quot;2-&amp;gt;4&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;8-&amp;gt;9&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：区间范围是：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[0,0] --&amp;gt; &amp;quot;0&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[2,4] --&amp;gt; &amp;quot;2-&amp;gt;4&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[6,6] --&amp;gt; &amp;quot;6&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[8,9] --&amp;gt; &amp;quot;8-&amp;gt;9&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 4：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [-1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[&amp;quot;-1&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 5：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[&amp;quot;0&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://zhuuu.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>图像学-色温、白平衡与色彩恒常性</title>
    <link href="http://zhuuu.work/2021/01/09/cv/%E5%9B%BE%E5%83%8F%E5%AD%A6-%E8%89%B2%E6%B8%A9%E3%80%81%E7%99%BD%E5%B9%B3%E8%A1%A1%E4%B8%8E%E8%89%B2%E5%BD%A9%E6%81%92%E5%B8%B8%E6%80%A7/"/>
    <id>http://zhuuu.work/2021/01/09/cv/%E5%9B%BE%E5%83%8F%E5%AD%A6-%E8%89%B2%E6%B8%A9%E3%80%81%E7%99%BD%E5%B9%B3%E8%A1%A1%E4%B8%8E%E8%89%B2%E5%BD%A9%E6%81%92%E5%B8%B8%E6%80%A7/</id>
    <published>2021-01-09T09:38:38.000Z</published>
    <updated>2021-05-16T03:10:31.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图像学-色温、白平衡与色彩恒常性"><a href="#图像学-色温、白平衡与色彩恒常性" class="headerlink" title="图像学-色温、白平衡与色彩恒常性"></a>图像学-色温、白平衡与色彩恒常性</h1><h2 id="1-色温"><a href="#1-色温" class="headerlink" title="1. 色温"></a>1. 色温</h2><ul><li><strong>色温这个概念是从黑体辐射来的。</strong></li><li>根据日常的经验我们可以知道，给一个铁块加热，随着温度升高，铁块开始是暗红色，逐渐变成亮红色，如果能达到炼钢炉里那样的高温，铁融化成铁水，发出耀眼的金黄色光芒。</li><li>而天文学家也告诉我们，宇宙中的恒星可以看做一个个黑体，随着恒星温度的升高，恒星的颜色也是从红色到黄色，非常高温度的恒星甚至发出偏蓝色的光。</li></ul><p>直接渲染了不同温度下黑体辐射的颜色。下图就是渲染出的不同温度黑体的颜色。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210108/160318930.png" alt="mark"></p><p>​                                                                            （黑体辐射的颜色）</p><a id="more"></a><ul><li><p>从这个例子里可以看出，随着温度的升高，黑体的颜色从暗红到亮红，逐渐到金黄色，再慢慢到蓝色。</p></li><li><p>在下面这个色品图上可以看得更清楚，随着温度升高，黑体颜色在色品图上移动，形成一条曲线轨迹</p></li><li><p>这条轨迹从右下角的红色区域出发，经过黄色区域，中间的白色区域，到达左侧的蓝色区域。这条轨迹就叫做 <a href="https://link.zhihu.com/?target=https%3A//www.wikiwand.com/en/Planckian_locus">普朗克轨迹</a>。下图显示了色品图上的普朗克轨迹（来自维基百科 <a href="https://link.zhihu.com/?target=https%3A//www.wikiwand.com/en/Planckian_locus">普朗克轨迹</a>）</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210108/161107925.png" alt="mark"></p><p>​                                                                                （普朗克轨迹）</p><ul><li>我们日常生活中，最重要的光源就是太阳，太阳发出的光很接近黑体光谱。我们的太阳表面温度约为 5500K，这个温度的黑体发出的光，基本就是白色。</li><li>读过本专栏之前文章的读者朋友肯定能理解，这当然不是巧合。在色彩空间中我们需要定义一个白点，而常见的一些标准白点，就是以 5500K 左右的黑体辐射（也就是我们的太阳）为基础的。</li><li>CIE 委员会规定的几种标准白点中，D50、D55 和 D65 是常用的白点，参照了 5000K、5500K 和 6500K 的黑体辐射来定义，模拟了不同条件下（比如地平线方向的光照，上下午的室外，正午室外）的光照。</li><li>色彩空间 <a href="https://link.zhihu.com/?target=https%3A//www.wikiwand.com/en/SRGB">sRGB</a> 所依赖的白点就是 D65。</li></ul><hr><p>注意：</p><ul><li>对于色温，通常有几个误解。<strong>第一个误解是</strong>混淆了色温和情感上的温度倾向。我们必须理解，色温是根据黑体辐射温度来定义的，是物理上的温度，而不是情感上的温度。<ul><li>从我们的情感上来说，橙色红色给人感觉温暖，蓝色给人感觉寒冷。但从色温的定义来看，红色橙色是温度较低的黑体发出的颜色，而温度高的黑体颜色反而是蓝色。</li></ul></li><li><strong>第二个误解</strong>是混淆了色温针对的对象。狭义上来说，色温是针对光源的。比如晴朗正午的室外，光源是太阳（以及部分蓝天），这个时候的光源接近标准光源 D65，色温接近 6500K；<ul><li>又比如说傍晚日落，经过大气层的散射，阳光中的蓝光大大减少，光线颜色偏黄，光源颜色也许接近 3500K 的黑体。</li></ul></li></ul><h2 id="2-白平衡"><a href="#2-白平衡" class="headerlink" title="2. 白平衡"></a>2. 白平衡</h2><ul><li><p>物理世界里是无所谓「颜色」这个概念的，一切都是 <a href="https://link.zhihu.com/?target=https%3A//www.wikiwand.com/en/Spectral_power_distribution">光谱功率分布</a>，所谓的「颜色」，是人类视觉过程产生的一种感受。</p></li><li><p>正是如此，我们才有了「三原色」理论，我们才可以用三种颜色的光来模拟世间万物的颜色。</p></li><li><p>生活常识告诉我们，光源的颜色不同，照射到同一个物体上，会引起物体颜色的变化。从单纯的物理的角度来看，这个事情再正常不过了。</p></li><li><p>光源有光谱功率分布，物体对不同波长的光线又有不同的反射率，那么光源照射到物体上，再反射到眼睛里的光，它的光谱功率分布就和光源密切相关了。</p></li><li><p>不同的光源，照射到同样的物体上，物体反射光的光谱功率分布就会不一样。</p></li></ul><p>下图展示了一个例子，物体的反射率是对蓝色光更高，对红色光更低。</p><ul><li>第一行的光源是一个接近白色的光源，照射到物体上之后，反射的光线就是蓝色；</li><li>而第二行的光源是一个黄色的光源，照射到物体上之后，反射的光线是偏棕红色的。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210108/164802986.png" alt="mark"></p><p>​                                                            （不同光源下物体有不同颜色）</p><ul><li>这里需要再强调一下，物理上没有所谓的「颜色」的概念，只有「光谱功率分布」、「反射率」这些概念。一个物体的反射率是固定不变的，但是这个物体的「颜色」在不同条件下是不一样的。<ul><li>我们可以用一个标准白点（比如 D65）作为光源，照射到物体上。我们认为这个时候物体表现出来的「颜色」就是物体「本来」的颜色，可以定义为物体的「固有色」。</li><li>很显然，固有色的光谱功率分布曲线与物体本身的反射率曲线两者是很接近的（参见上图中第一行的例子）。</li></ul></li></ul><ul><li><p><strong>白平衡（<a href="https://link.zhihu.com/?target=https%3A//www.wikiwand.com/en/Color_balance">White Balance</a>）要做的</strong>，就是在不同的光线条件下，根据当时得到的物体颜色，尽量恢复物体的「固有色」，</p><ul><li>或者说，尽量减小光源颜色对物体颜色的影响。（在下一节会继续讨论这个定义的合理性，本小节中先按照这个定义进行讨论）。</li><li>我们可以在色彩转换的过程中根据光源的情况指定不同的白点，从而得到相应正确的色彩转换结果。举例来说，在晴天正午室外拍摄的一张照片，光源近似于标准白点 D65，那么我们就用 D65 点作为白点进行色彩转换（实际上就是直接用 sRGB 空间进行展示）。</li><li>又比如在黄昏的光线下拍摄了照片，<strong>此时光源接近 2500K 的黑体</strong>，那么我们从普朗克曲线上找到 2500K 的点，作为新的白点，进行色彩转换，就能得到正确的颜色。</li><li><strong>由于色彩空间的线性性质，这个转换过程就是一个矩阵乘法</strong>，非常方便。详细的计算过程可以参见之前的文章，这里不再赘述。</li></ul></li><li><p><strong>这就是相机上色温调节的原理。</strong></p><ul><li>也就是说，相机上的色温选项，<strong>调节的是色彩转换中的白点的位置，在普朗克曲线上选取与色温相对应的点作为白点进行色彩转换，从而得到正确的颜色。</strong></li><li><strong>这个色温选项，是要与拍摄时的光源色温相匹配的</strong>，这也是为什么在晴朗的白天拍摄，色温控制在 5000K ~ 6000K 是比较合适的，而在黄昏时候拍摄，色温需要设置成 2500K ~ 3000K 才比较合适。</li></ul></li></ul><hr><p>注意：</p><ul><li>可以看到，沿着普朗克线移动白点，总体上是调节了画面偏蓝或者偏黄的色彩倾向。</li><li>当然，<strong>完整的白平衡要求白点可以任意设置，所以必须增加第二个移动方向。</strong><ul><li><strong>最合理的选择就是与普朗克线正交的另一个方向</strong></li><li>从色品图上看大致是从左上角到右下侧直线边的方向，也就是绿色到品红的方向。</li></ul></li><li>正因为如此，我们可以看到，<code>Photoshop、Lightroom</code>这样的照片处理软件，白平衡的面板上总是会有两个调节滑块<ul><li>一个调节黄-蓝平衡，<strong>通常叫色温（<code>Temperature</code>）</strong></li><li>一个调节绿-品红平衡，<strong>通常叫色调（Tint）</strong></li><li>这两个方向互相配合，才能使得白点位于色品图中的任意位置，才能对任意光线条件下拍摄的照片进行白平衡的调节。</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210108/165816640.png" alt="mark"></p><p>​                                                        <strong>（Photoshop 中的白平衡调节面板）</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210108/165629562.png" alt="mark"></p><p>​                                                                <strong>（色温和色调调节）</strong></p><h2 id="3-色彩恒常性"><a href="#3-色彩恒常性" class="headerlink" title="3. 色彩恒常性"></a>3. 色彩恒常性</h2><ul><li>白平衡解决了「怎样才能正确得到白色」的问题，在上一小节中，我提出白平衡的目的是「在不同的光线条件下，根据当时得到的物体颜色，尽量恢复物体的固有色」，这句话看似简单，仔细想想，却又并不那么显然</li><li>一个很明显的疑问是：我们怎么知道什么是物体的固有色？白炽灯照明下的一张白纸，与阳光照明下的一张橙黄色的纸，两者从物理上而言可以是几乎一样的，或者说两者的光谱功率分布函数，可以是几乎一样的。那么我们凭什么说一张是白纸，一张是橙黄色的纸呢？</li></ul><p>答案是，不能区分。如果仅仅看这张纸的话，我们不能区分哪张是白纸，哪张是黄纸。</p><hr><ul><li><p>但是，我们不仅仅只看了纸，我们还看到了周围的景物，也许是摆放纸张的书桌，也许是周围的植物盆景，也许是旁边的水果，甚至是我们自己的手。</p></li><li><p>所有这一切，都帮助我们认识周围的环境，根据环境去推测这张纸本来的颜色。</p></li><li><p>人类视觉过程不仅仅有视网膜的参与，更重要的还有大脑的参与。视觉是人类获取外界信息最重要的手段，在日复一日的使用中，人类大脑对外界环境建立起了复杂的感知和对应。我们的大脑早就知道，植物叶子是绿色的，樱桃是红色的，我们的皮肤是黄色</p></li><li><p><strong>通过对这些周围环境的感知，我们的大脑推断出了这个时候光源的情况——是白炽灯还是阳光，从而自动完成了「白平衡」的过程，使得我们迅速感知到一个物体本来的颜色是什么。这就是人类视觉的色彩恒常性。</strong></p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210110/150214753.png" alt="mark"></p><p>​                                                            没有红色的草莓</p><ul><li>上图是一个很好的例子（图片来自 <a href="https://link.zhihu.com/?target=http%3A//www.psy.ritsumei.ac.jp/~akitaoka/colorconstancy6e.html">Color constancy</a>），在这幅图中，如果我们单独一个一个像素点来看，没有一个像素点是红色的，所有的像素点都是绿色、青色、灰色，图中选取的几个像素点的 RGB 值也充分说明了这一点</li><li>但是当我们从整体来这张图，立刻会产生「红色草莓」、「黄色木桌」、「白色盘子」的印象。<strong>这就是我们大脑根据一些「先验知识」进行自动白平衡的结果。</strong></li></ul><hr><p>当然，在没有一个强有力的先验知识的情况下，人类也很容易给出错误的答案。君不见引起网络大撕逼的「白金、蓝黑」神奇衣服？</p><ul><li><p>在我看来，这些争论都是没什么意义的，因为图片提供的场景信息太少，人类的大脑还不足以利用先验知识，建立对当场光源的感知，只能凭借自身的经验进行推断，而每个人自身经验千差万别，自然也没办法正确推断衣服的颜色了。</p></li><li><p>如果大家能在现场看一眼，或者图片作者能上传一段附带周围环境的视频，我想大概就不会有人对这件衣服的颜色有疑问了。</p></li></ul><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210110/151159127.png" alt="mark" style="zoom:80%;" /><p>​                                                    <strong>（白金？蓝黑？）</strong></p><hr><p>当然，我们可以有意识地利用这种错觉，造成一些有趣的结果。比如下图中，绿色条纹和蓝色条纹，其实是同一种颜色（图片来自 <a href="https://link.zhihu.com/?target=http%3A//www.independent.co.uk/news/weird-news/forget-the-dress-theres-another-optical-illusion-blowing-our-minds-10076727.html">independent</a>）。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210110/151241238.png" alt="mark"></p><p>​                                                            <strong>（绿色？蓝色？）</strong></p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><ol><li><p><strong>色温是根据黑体辐射进行定义的，橙黄色色温低，蓝色色温高；</strong></p></li><li><p><strong>相机中的色温设置，需要与当时光源的色温相匹配；</strong></p></li><li><p><strong>白平衡的目的，是希望在不同光线条件下，都能正确得到物体的固有色；</strong></p></li><li><p><strong>白平衡本质上是调节两个参数：色温和色调</strong></p><ul><li>色温条件蓝-&gt;黄 的色调</li><li>色调调节绿-&gt;品红偏色</li><li>白平衡通过调节两个参数，来设置白点的位置，从而得到正确的色彩转换</li></ul></li><li><p><strong>人类视觉具有色彩恒常性，是大脑对外界环境感知的反应。当外界环境信息不足时，无法建立正确的色彩恒常感知。</strong></p></li></ol><p><strong>参考博客</strong> ： <a href="https://zhuanlan.zhihu.com/p/27165715" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27165715</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;图像学-色温、白平衡与色彩恒常性&quot;&gt;&lt;a href=&quot;#图像学-色温、白平衡与色彩恒常性&quot; class=&quot;headerlink&quot; title=&quot;图像学-色温、白平衡与色彩恒常性&quot;&gt;&lt;/a&gt;图像学-色温、白平衡与色彩恒常性&lt;/h1&gt;&lt;h2 id=&quot;1-色温&quot;&gt;&lt;a href=&quot;#1-色温&quot; class=&quot;headerlink&quot; title=&quot;1. 色温&quot;&gt;&lt;/a&gt;1. 色温&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;色温这个概念是从黑体辐射来的。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;根据日常的经验我们可以知道，给一个铁块加热，随着温度升高，铁块开始是暗红色，逐渐变成亮红色，如果能达到炼钢炉里那样的高温，铁融化成铁水，发出耀眼的金黄色光芒。&lt;/li&gt;
&lt;li&gt;而天文学家也告诉我们，宇宙中的恒星可以看做一个个黑体，随着恒星温度的升高，恒星的颜色也是从红色到黄色，非常高温度的恒星甚至发出偏蓝色的光。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;直接渲染了不同温度下黑体辐射的颜色。下图就是渲染出的不同温度黑体的颜色。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210108/160318930.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;​                                                                            （黑体辐射的颜色）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机图形学" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-547-省份数量</title>
    <link href="http://zhuuu.work/2021/01/07/Leetcode/Leetcode-547-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/"/>
    <id>http://zhuuu.work/2021/01/07/Leetcode/Leetcode-547-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/</id>
    <published>2021-01-07T07:21:53.000Z</published>
    <updated>2021-01-07T02:37:52.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-547-省份数量"><a href="#Leetcode-547-省份数量" class="headerlink" title="Leetcode-547-省份数量"></a>Leetcode-547-<a href="https://leetcode-cn.com/problems/number-of-provinces/" target="_blank" rel="noopener">省份数量</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p></li><li><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p></li><li><p>给你一个 n x n 的矩阵<code>isConnected</code>，其中<code>isConnected[i][j] = 1</code> 表示第 i 个城市和第 j 个城市直接相连，而<code>isConnected[i][j] = 0</code>表示二者不直接相连。</p></li><li><p>返回矩阵中 省份 的数量。</p></li></ul><p><strong>示例一 ：</strong> </p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210107/093358281.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：isConnected &#x3D; [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210107/093431219.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：isConnected &#x3D; [[1,0,0],[0,1,0],[0,0,1]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 200</span><br><span class="line">n &#x3D;&#x3D; isConnected.length</span><br><span class="line">n &#x3D;&#x3D; isConnected[i].length</span><br><span class="line">isConnected[i][j] 为 1 或 0</span><br><span class="line">isConnected[i][i] &#x3D;&#x3D; 1</span><br><span class="line">isConnected[i][j] &#x3D;&#x3D; isConnected[j][i]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>可以把 n个城市和它们之间的相连关系看成图，城市是图中的节点，相连关系是图中的边，</p></li><li><p>给定的矩阵 <code>isConnected</code> 即为图的邻接矩阵，</p></li><li><p>省份即为图中的连通分量。</p></li></ul><p>计算省份总数，等价于计算图中的连通分量数，<strong>可以通过深度优先搜索或广度优先搜索实现，也可以通过并查集实现。</strong></p><h2 id="方法一-：-DFS"><a href="#方法一-：-DFS" class="headerlink" title="方法一 ： DFS"></a>方法一 ： DFS</h2><ul><li>深度优先搜索的思路很直观<ul><li>遍历所有的城市，对于每个城市，如果该城市尚未被访问过，则从该城市开始深度优先搜索</li><li>通过矩阵<code>isConnected</code> 得到与该城市直接相连的城市有哪些，这些城市和该城市属于同一个连通分量</li><li>然后对这些城市继续进行深度优先搜索，直到同一个连通分量的所有城市都被访问到，即可得到一个省份</li><li>遍历完全部城市以后，即可得到连通分量的总数，即省份的总数。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.初始需要的变量</span></span><br><span class="line">        <span class="keyword">int</span> provinces = isConnected.length;                 <span class="comment">// 城市数量</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[provinces];         <span class="comment">// 标记该城市是否被访问过</span></span><br><span class="line">        <span class="keyword">int</span> circles = <span class="number">0</span>;                                    <span class="comment">// 连通分量的数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 遍历所有的城市</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; provinces;i++)&#123;</span><br><span class="line">            <span class="comment">// 2.1 对于该城市尚未被访问过，从该城市开始深度优先搜索</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;                                <span class="comment">// 该城市没有被访问过</span></span><br><span class="line">                dfs(isConnected,visited,provinces,i);       <span class="comment">// 2.2 dfs 逻辑</span></span><br><span class="line">                circles++;                                  <span class="comment">// 直到同一个连通分量的所有城市都被访问到，即可得到一个省份</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> circles;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.2 dfs 逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] isConnected,<span class="keyword">boolean</span>[] visited,<span class="keyword">int</span> provinces,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; provinces;j++)&#123;                  <span class="comment">// i : 作为起点 ，遍历 i 行元素，得到这一行元素（城市） 哪些是连通的</span></span><br><span class="line">            <span class="keyword">if</span>(isConnected[i][j] == <span class="number">1</span> &amp;&amp; !visited[j])&#123;     <span class="comment">// 如果到达一个没有访问过且可达的元素（城市）</span></span><br><span class="line">                visited[j] = <span class="keyword">true</span>;                         <span class="comment">// 标记为访问过           </span></span><br><span class="line">                dfs(isConnected,visited,provinces,j);      <span class="comment">// j : 作为起点， 遍历 j 行元素，得到这一行元素（城市） 哪些是连通的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O(n^2)，其中 <em>n</em> 是城市的数量。需要遍历矩阵 n 中的每个元素。</li><li>空间复杂度：  O(n)，其中 n 是城市的数量。<ul><li>需要使用数组visited 记录每个城市是否被访问过，数组长度是 n，</li><li>递归调用栈的深度不会超过 n。</li></ul></li></ul><h2 id="方法二-：-BFS"><a href="#方法二-：-BFS" class="headerlink" title="方法二 ： BFS"></a>方法二 ： BFS</h2><ul><li>对于每个城市，如果该城市尚未被访问过，则从该城市开始广度优先搜索，直到同一个连通分量中的所有城市都被访问到，即可得到一个省份。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.初始需要的变量</span></span><br><span class="line">        <span class="keyword">int</span> provinces = isConnected.length;                         <span class="comment">// 城市数量</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[provinces];                 <span class="comment">// 标记该城市是否被访问过</span></span><br><span class="line">        <span class="keyword">int</span> circles = <span class="number">0</span>;                                            <span class="comment">// 连通分量的数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. BFS 逻辑</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();                  <span class="comment">// 2.1 队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; provinces;i++)&#123;                           <span class="comment">// 遍历每个城市</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;                                        <span class="comment">// 如果该城市未被访问过</span></span><br><span class="line">                queue.offer(i);                                     <span class="comment">// 从该城市开始BFS搜索</span></span><br><span class="line">                <span class="keyword">while</span>(!queue.isEmpty())&#123;                            <span class="comment">// 2.2 BFS逻辑</span></span><br><span class="line">                    <span class="keyword">int</span> j = queue.poll();                           <span class="comment">// 弹出该城市</span></span><br><span class="line">                    visited[j] = <span class="keyword">true</span>;                              <span class="comment">// 标记该城市为访问过</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; provinces;k++)&#123;               <span class="comment">// 遍历与该城市所有邻接的城市</span></span><br><span class="line">                        <span class="keyword">if</span>(isConnected[j][k] == <span class="number">1</span> &amp;&amp; !visited[k])&#123;  <span class="comment">// 如果可以访问到</span></span><br><span class="line">                            queue.offer(k);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                circles++;                                          <span class="comment">// 直到同一个连通分量中的所有城市都被访问到，即可得到一个省份。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> circles;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O(n^2)，其中 <em>n</em> 是城市的数量。需要遍历<code>isConnected</code>中的每个元素</li><li>空间复杂度：  O(n)，其中 n 是城市的数量。<ul><li>visited 数组长度不会超过n</li><li>广度优先搜索队列元素不会超过n</li></ul></li></ul><h2 id="方法三-：-并查集"><a href="#方法三-：-并查集" class="headerlink" title="方法三 ： 并查集"></a>方法三 ： 并查集</h2><ul><li>待学习</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> provinces = isConnected.length;</span><br><span class="line">        <span class="keyword">int</span>[] parent = <span class="keyword">new</span> <span class="keyword">int</span>[provinces];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; provinces; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; provinces; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; provinces; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isConnected[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    union(parent, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> circles = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; provinces; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent[i] == i) &#123;</span><br><span class="line">                circles++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> circles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span>[] parent, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        parent[find(parent, index1)] = find(parent, index2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] parent, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[index] != index) &#123;</span><br><span class="line">            parent[index] = find(parent, parent[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-547-省份数量&quot;&gt;&lt;a href=&quot;#Leetcode-547-省份数量&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-547-省份数量&quot;&gt;&lt;/a&gt;Leetcode-547-&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-provinces/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;省份数量&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;给你一个 n x n 的矩阵&lt;code&gt;isConnected&lt;/code&gt;，其中&lt;code&gt;isConnected[i][j] = 1&lt;/code&gt; 表示第 i 个城市和第 j 个城市直接相连，而&lt;code&gt;isConnected[i][j] = 0&lt;/code&gt;表示二者不直接相连。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;返回矩阵中 省份 的数量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例一 ：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210107/093358281.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：isConnected &amp;#x3D; [[1,1,0],[1,1,0],[0,0,1]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210107/093431219.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：isConnected &amp;#x3D; [[1,0,0],[0,1,0],[0,0,1]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;&amp;#x3D; n &amp;lt;&amp;#x3D; 200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n &amp;#x3D;&amp;#x3D; isConnected.length&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n &amp;#x3D;&amp;#x3D; isConnected[i].length&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;isConnected[i][j] 为 1 或 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;isConnected[i][i] &amp;#x3D;&amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;isConnected[i][j] &amp;#x3D;&amp;#x3D; isConnected[j][i]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="BFS" scheme="http://zhuuu.work/tags/BFS/"/>
    
      <category term="DFS" scheme="http://zhuuu.work/tags/DFS/"/>
    
      <category term="并查集" scheme="http://zhuuu.work/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-830-较大分组的位置</title>
    <link href="http://zhuuu.work/2021/01/05/Leetcode/Leetcode-830-%E8%BE%83%E5%A4%A7%E5%88%86%E7%BB%84%E7%9A%84%E4%BD%8D%E7%BD%AE/"/>
    <id>http://zhuuu.work/2021/01/05/Leetcode/Leetcode-830-%E8%BE%83%E5%A4%A7%E5%88%86%E7%BB%84%E7%9A%84%E4%BD%8D%E7%BD%AE/</id>
    <published>2021-01-05T00:52:53.000Z</published>
    <updated>2021-01-05T01:33:09.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-830-较大分组的位置"><a href="#Leetcode-830-较大分组的位置" class="headerlink" title="Leetcode-830-较大分组的位置"></a>Leetcode-830-较大分组的位置</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。</p></li><li><p>例如，在字符串<code>s = &quot;abbxxxxzyy&quot;</code>中，就含有 “a”, “bb”, “xxxx”, “z” 和 “yy” 这样的一些分组。</p></li><li><p>分组可以用区间 <code>[start, end]</code>表示,其中 <code>start</code> 和 <code>end</code> 分别表示该分组的起始和终止位置的下标。上例中的 <code>&quot;xxxx&quot;</code> 分组用区间表示为 <code>[3,6]</code> 。</p></li><li><p>我们称所有包含大于或等于三个连续字符的分组为 <strong>较大分组</strong> 。</p></li><li><p>找到每一个 <strong>较大分组</strong> 的区间，<strong>按起始位置下标递增顺序排序后</strong>，返回结果。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;abbxxxxzzy&quot;</span><br><span class="line">输出：[[3,6]]</span><br><span class="line">解释：&quot;xxxx&quot; 是一个起始于 3 且终止于 6 的较大分组。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：[]</span><br><span class="line">解释：&quot;a&quot;,&quot;b&quot; 和 &quot;c&quot; 均不是符合要求的较大分组。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;abcdddeeeeaabbbcd&quot;</span><br><span class="line">输出：[[3,5],[6,9],[12,14]]</span><br><span class="line">解释：较大分组为 &quot;ddd&quot;, &quot;eeee&quot; 和 &quot;bbb&quot;</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;aba&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅含小写英文字母</li></ul><a id="more"></a><h2 id="思路：一次遍历"><a href="#思路：一次遍历" class="headerlink" title="思路：一次遍历"></a>思路：一次遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; largeGroupPositions(String s) &#123;</span><br><span class="line">        <span class="comment">// 1. 初始化</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();                <span class="comment">// 结果集</span></span><br><span class="line">        <span class="keyword">int</span> n   = s.length();                                       <span class="comment">// 字符串长度</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;                                                <span class="comment">// 用于记录分组长度 </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 一次遍历该字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="comment">// 2.1 如果下一个字符与当前字符不同,或者已经枚举到字符串尾部,就说明当前字符为当前分组的尾部</span></span><br><span class="line">            <span class="keyword">if</span>(i == n - <span class="number">1</span> || s.charAt(i) != s.charAt(i + <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(num &gt;= <span class="number">3</span>)&#123;                                       <span class="comment">// 如果分组长度达到3</span></span><br><span class="line">                    res.add(Arrays.asList(i - num + <span class="number">1</span>,i));          <span class="comment">// 记录结果</span></span><br><span class="line">                &#125;   </span><br><span class="line">                num = <span class="number">1</span>;                                            <span class="comment">// 重置分组长度</span></span><br><span class="line">            <span class="comment">// 2.2 字符重复的情况</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num++;                                              <span class="comment">// ++字符分区长度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 返回结果集</span></span><br><span class="line">        <span class="keyword">return</span> res;                                                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ： O(n)</li><li>空间复杂度 ： O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-830-较大分组的位置&quot;&gt;&lt;a href=&quot;#Leetcode-830-较大分组的位置&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-830-较大分组的位置&quot;&gt;&lt;/a&gt;Leetcode-830-较大分组的位置&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;例如，在字符串&lt;code&gt;s = &amp;quot;abbxxxxzyy&amp;quot;&lt;/code&gt;中，就含有 “a”, “bb”, “xxxx”, “z” 和 “yy” 这样的一些分组。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分组可以用区间 &lt;code&gt;[start, end]&lt;/code&gt;表示,其中 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 分别表示该分组的起始和终止位置的下标。上例中的 &lt;code&gt;&amp;quot;xxxx&amp;quot;&lt;/code&gt; 分组用区间表示为 &lt;code&gt;[3,6]&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我们称所有包含大于或等于三个连续字符的分组为 &lt;strong&gt;较大分组&lt;/strong&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;找到每一个 &lt;strong&gt;较大分组&lt;/strong&gt; 的区间，&lt;strong&gt;按起始位置下标递增顺序排序后&lt;/strong&gt;，返回结果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;abbxxxxzzy&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[[3,6]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&amp;quot;xxxx&amp;quot; 是一个起始于 3 且终止于 6 的较大分组。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;abc&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot; 和 &amp;quot;c&amp;quot; 均不是符合要求的较大分组。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;abcdddeeeeaabbbcd&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[[3,5],[6,9],[12,14]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：较大分组为 &amp;quot;ddd&amp;quot;, &amp;quot;eeee&amp;quot; 和 &amp;quot;bbb&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 4：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;aba&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= s.length &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; 仅含小写英文字母&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-509-斐波那契数</title>
    <link href="http://zhuuu.work/2021/01/04/Leetcode/Leetcode-509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
    <id>http://zhuuu.work/2021/01/04/Leetcode/Leetcode-509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</id>
    <published>2021-01-04T00:52:53.000Z</published>
    <updated>2021-01-04T01:19:23.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-509-斐波那契数"><a href="#Leetcode-509-斐波那契数" class="headerlink" title="Leetcode-509-斐波那契数"></a>Leetcode-509-<a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">斐波那契数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>斐波那契数</strong>，通常用 <code>F(n)</code> 表示，形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) &#x3D; 0，F(1) &#x3D; 1</span><br><span class="line">F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1</span><br></pre></td></tr></table></figure><p>给你 <code>n</code> ，请计算 <code>F(n)</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：2</span><br><span class="line">输出：1</span><br><span class="line">解释：F(2) &#x3D; F(1) + F(0) &#x3D; 1 + 0 &#x3D; 1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：3</span><br><span class="line">输出：2</span><br><span class="line">解释：F(3) &#x3D; F(2) + F(1) &#x3D; 1 + 1 &#x3D; 2</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：4</span><br><span class="line">输出：3</span><br><span class="line">解释：F(4) &#x3D; F(3) + F(2) &#x3D; 2 + 1 &#x3D; 3</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路一-：-动态规划"><a href="#思路一-：-动态规划" class="headerlink" title="思路一 ： 动态规划"></a>思路一 ： 动态规划</h2><ul><li><p>斐波那契数的边界条件是 <code>F(0) =0</code> 和 <code>F(1)=1</code>。</p></li><li><p>n&gt;1时，每一项的和都等于前两项的和，因此有如下递推关系：</p><ul><li>​                                            F<em>(</em>n<em>)=*F</em>(<em>n</em>−1)+<em>F</em>(<em>n</em>−2)</li></ul></li></ul><ul><li><p>由于斐波那契数存在递推关系，因此可以使用动态规划求解。动态规划的状态转移方程即为上述递推关系，边界条件为 F(0) 和 F(1)。</p></li><li><p>根据状态转移方程和边界条件，可以得到时间复杂度和空间复杂度都是 O(n) 的实现。</p></li><li><p><strong>由于 F(n) 只和 F(n-1)与 F(n-2)有关，因此可以使用「滚动数组思想」把空间复杂度优化成 O(1)。</strong></p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210104/085317533.gif" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 特判</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.初始化变量</span></span><br><span class="line">        <span class="keyword">int</span> dp_a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp_b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp_i = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 3. 滚动数组：动态规划</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            dp_a = dp_b;</span><br><span class="line">            dp_b = dp_i;</span><br><span class="line">            dp_i = dp_a + dp_b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp_i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：O(1)。</li></ul><h2 id="思路二-：-数学通项"><a href="#思路二-：-数学通项" class="headerlink" title="思路二 ： 数学通项"></a>思路二 ： 数学通项</h2><ul><li>斐波那契数 F(n)是齐次线性递推，根据递推方程 F(n)=F(n-1)+F(n-2)可以写出这样的特征方程：</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210104/090716393.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20210104/091850906.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sqrt_5 = Math.sqrt(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">double</span> fib_n  = Math.pow((<span class="number">1</span> + sqrt_5)/<span class="number">2</span>,n) - Math.pow((<span class="number">1</span> - sqrt_5)/<span class="number">2</span>,n);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.round(fib_n/sqrt_5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>与各个语言的pow 函数有关</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-509-斐波那契数&quot;&gt;&lt;a href=&quot;#Leetcode-509-斐波那契数&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-509-斐波那契数&quot;&gt;&lt;/a&gt;Leetcode-509-&lt;a href=&quot;https://leetcode-cn.com/problems/fibonacci-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;斐波那契数&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;斐波那契数&lt;/strong&gt;，通常用 &lt;code&gt;F(n)&lt;/code&gt; 表示，形成的序列称为 &lt;strong&gt;斐波那契数列&lt;/strong&gt; 。该数列由 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 开始，后面的每一项数字都是前面两项数字的和。也就是：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;F(0) &amp;#x3D; 0，F(1) &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;F(n) &amp;#x3D; F(n - 1) + F(n - 2)，其中 n &amp;gt; 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;给你 &lt;code&gt;n&lt;/code&gt; ，请计算 &lt;code&gt;F(n)&lt;/code&gt; 。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：F(2) &amp;#x3D; F(1) + F(0) &amp;#x3D; 1 + 0 &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：F(3) &amp;#x3D; F(2) + F(1) &amp;#x3D; 1 + 1 &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：F(4) &amp;#x3D; F(3) + F(2) &amp;#x3D; 2 + 1 &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://zhuuu.work/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-205-同构字符串</title>
    <link href="http://zhuuu.work/2020/12/27/Leetcode/Leetcode-205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://zhuuu.work/2020/12/27/Leetcode/Leetcode-205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-12-27T00:52:53.000Z</published>
    <updated>2021-01-17T02:21:00.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-205-同构字符串"><a href="#Leetcode-205-同构字符串" class="headerlink" title="Leetcode-205-同构字符串"></a>Leetcode-205-<a href="https://leetcode-cn.com/problems/isomorphic-strings/" target="_blank" rel="noopener">同构字符串</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>给定两个字符串 <strong><em>s</em></strong> 和 <em>t</em>，判断它们是否是同构的。</li><li>如果 <strong><em>s</em></strong> 中的字符可以被替换得到 <em>t</em> ，那么这两个字符串是同构的。</li><li>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;egg&quot;, t &#x3D; &quot;add&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;foo&quot;, t &#x3D; &quot;bar&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;paper&quot;, t &#x3D; &quot;title&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">你可以假设 s 和 t 具有相同的长度。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-：-集合论双射"><a href="#思路-：-集合论双射" class="headerlink" title="思路 ： 集合论双射"></a>思路 ： 集合论双射</h2><ul><li><p>此题是「290. 单词规律」的简化版，</p></li><li><p><strong>需要我们判断 s 和 t 每个位置上的字符是否都一一对应，即 s 的任意一个字符被 t中唯一的字符对应，同时 t 的任意一个字符被 s 中唯一的字符对应。这也被称为「双射」的关系。</strong></p><ul><li>以示例 2 为例，t 中的字符 a 和 r 虽然有唯一的映射 o，但对于 s 中的字符 o 来说其存在两个映射 {a,r}，故不满足条件。</li></ul></li></ul><ul><li>因此 ， 我们需要维护两张哈希表。<ul><li>第一张哈希表s2t : 以s中的字符为键，t中的字符为值</li><li>第二张哈希表t2s : 以t中的字符为键，s中的字符为值</li></ul></li></ul><p><strong>算法整体</strong></p><ol><li>从左直右遍历两个字符串的字符，不断更新两张哈希表，如果出现冲突，说明两个字符无法构成同构，返回false</li><li>如果遍历没有发生冲突，说明两个字符串是同构的 ， 返回true 即可。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuuu.Leetcode__205;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">stringtostring</span><span class="params">(String input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> input.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">booleanToString</span><span class="params">(<span class="keyword">boolean</span> input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input?<span class="string">"True"</span>:<span class="string">"False"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = in.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            String s = stringtostring(line);</span><br><span class="line">            line = in.readLine();</span><br><span class="line">            String t = stringtostring(line);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> ret = <span class="keyword">new</span> Solution().isIsomorphic(s,t);</span><br><span class="line">            String out = booleanToString(ret);</span><br><span class="line">            System.out.println(out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 初始化</span></span><br><span class="line">        Map&lt;Character,Character&gt; s2t = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Character,Character&gt; t2s = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;++i)&#123;</span><br><span class="line">            <span class="comment">// 2.1 拿到当前字符做判断</span></span><br><span class="line">            <span class="keyword">char</span> curr_s = s.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> curr_t = t.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>((s2t.containsKey(curr_s) &amp;&amp; s2t.get(curr_s) != curr_t) || (t2s.containsKey(curr_t) &amp;&amp; t2s.get(curr_t) != curr_s))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2.2 不在map中就放入到map中</span></span><br><span class="line">            s2t.put(curr_s,curr_t);</span><br><span class="line">            t2s.put(curr_t,curr_s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p><strong>时间复杂度：O(n)，其中 n 为字符串的长度。</strong>我们只需同时遍历一遍字符串 s和 t 即可。</p></li><li><p><strong>空间复杂度：O(∣Σ∣)，其中 \SigmaΣ 是字符串的字符集。</strong>哈希表存储字符的空间取决于字符串的字符集大小，最坏情况下每个字符均不相同，需要 O(∣Σ∣) 的空间。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-205-同构字符串&quot;&gt;&lt;a href=&quot;#Leetcode-205-同构字符串&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-205-同构字符串&quot;&gt;&lt;/a&gt;Leetcode-205-&lt;a href=&quot;https://leetcode-cn.com/problems/isomorphic-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;同构字符串&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给定两个字符串 &lt;strong&gt;&lt;em&gt;s&lt;/em&gt;&lt;/strong&gt; 和 &lt;em&gt;t&lt;/em&gt;，判断它们是否是同构的。&lt;/li&gt;
&lt;li&gt;如果 &lt;strong&gt;&lt;em&gt;s&lt;/em&gt;&lt;/strong&gt; 中的字符可以被替换得到 &lt;em&gt;t&lt;/em&gt; ，那么这两个字符串是同构的。&lt;/li&gt;
&lt;li&gt;所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: s &amp;#x3D; &amp;quot;egg&amp;quot;, t &amp;#x3D; &amp;quot;add&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: s &amp;#x3D; &amp;quot;foo&amp;quot;, t &amp;#x3D; &amp;quot;bar&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: s &amp;#x3D; &amp;quot;paper&amp;quot;, t &amp;#x3D; &amp;quot;title&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;说明:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;你可以假设 s 和 t 具有相同的长度。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>单调栈-合集</title>
    <link href="http://zhuuu.work/2020/12/25/LeetcodeExplore/%E5%8D%95%E8%B0%83%E6%A0%88-%E5%90%88%E9%9B%86/"/>
    <id>http://zhuuu.work/2020/12/25/LeetcodeExplore/%E5%8D%95%E8%B0%83%E6%A0%88-%E5%90%88%E9%9B%86/</id>
    <published>2020-12-25T07:11:53.000Z</published>
    <updated>2020-12-26T02:44:19.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单调栈-合集"><a href="#单调栈-合集" class="headerlink" title="单调栈-合集"></a>单调栈-合集</h1><p>以下列出了单调栈的问题，供大家参考。</p><table><thead><tr><th><strong>序号</strong></th><th><strong>题目</strong></th><th><strong>题解</strong></th></tr></thead><tbody><tr><td>1</td><td><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水（困难）</a></td><td><a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/bao-li-jie-fa-yi-kong-jian-huan-shi-jian-zhi-zhen-/" target="_blank" rel="noopener">暴力解法、优化、双指针、单调栈</a></td></tr><tr><td>2</td><td><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">739. 每日温度（中等）</a></td><td><a href="https://leetcode-cn.com/problems/daily-temperatures/solution/bao-li-jie-fa-dan-diao-zhan-by-liweiwei1419/" target="_blank" rel="noopener">暴力解法 + 单调栈</a></td></tr><tr><td>3</td><td><a href="https://leetcode-cn.com/problems/next-greater-element-i/" target="_blank" rel="noopener">496. 下一个更大元素 I（简单）</a></td><td><a href="https://leetcode-cn.com/problems/next-greater-element-i/solution/bao-li-jie-fa-dan-diao-zhan-by-liweiwei1419-2/" target="_blank" rel="noopener">暴力解法、单调栈</a></td></tr><tr><td>4</td><td><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/" target="_blank" rel="noopener">316. 去除重复字母（困难）</a></td><td><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/solution/zhan-by-liweiwei1419/" target="_blank" rel="noopener">栈 + 哨兵技巧（Java、C++、Python）</a></td></tr><tr><td>5</td><td><a href="https://leetcode-cn.com/problems/online-stock-span/" target="_blank" rel="noopener">901. 股票价格跨度（中等）</a></td><td><a href="https://blog.csdn.net/lw_power/article/details/103957702" target="_blank" rel="noopener"> 「力扣」第 901 题：股票价格跨度（单调栈）</a></td></tr><tr><td>6</td><td><a href="https://leetcode-cn.com/problems/remove-k-digits/" target="_blank" rel="noopener">402. 移掉K位数字</a></td><td></td></tr><tr><td>7</td><td><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener">581. 最短无序连续子数组</a></td><td></td></tr><tr><td>8</td><td></td><td></td></tr><tr><td>9</td><td></td><td></td></tr></tbody></table><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;单调栈-合集&quot;&gt;&lt;a href=&quot;#单调栈-合集&quot; class=&quot;headerlink&quot; title=&quot;单调栈-合集&quot;&gt;&lt;/a&gt;单调栈-合集&lt;/h1&gt;&lt;p&gt;以下列出了单调栈的问题，供大家参考。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;序号&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;题解&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/trapping-rain-water/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;42. 接雨水（困难）&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/trapping-rain-water/solution/bao-li-jie-fa-yi-kong-jian-huan-shi-jian-zhi-zhen-/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;暴力解法、优化、双指针、单调栈&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/daily-temperatures/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;739. 每日温度（中等）&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/daily-temperatures/solution/bao-li-jie-fa-dan-diao-zhan-by-liweiwei1419/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;暴力解法 + 单调栈&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/next-greater-element-i/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;496. 下一个更大元素 I（简单）&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/next-greater-element-i/solution/bao-li-jie-fa-dan-diao-zhan-by-liweiwei1419-2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;暴力解法、单调栈&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicate-letters/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;316. 去除重复字母（困难）&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicate-letters/solution/zhan-by-liweiwei1419/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;栈 + 哨兵技巧（Java、C++、Python）&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/online-stock-span/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;901. 股票价格跨度（中等）&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://blog.csdn.net/lw_power/article/details/103957702&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; 「力扣」第 901 题：股票价格跨度（单调栈）&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-k-digits/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;402. 移掉K位数字&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;581. 最短无序连续子数组&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="单调栈" scheme="http://zhuuu.work/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-290-单词规律</title>
    <link href="http://zhuuu.work/2020/12/16/Leetcode/Leetcode-290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/"/>
    <id>http://zhuuu.work/2020/12/16/Leetcode/Leetcode-290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/</id>
    <published>2020-12-16T05:52:53.000Z</published>
    <updated>2020-12-16T08:34:44.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-290-单词规律"><a href="#Leetcode-290-单词规律" class="headerlink" title="Leetcode-290-单词规律"></a>Leetcode-290-<a href="https://leetcode-cn.com/problems/word-pattern/" target="_blank" rel="noopener">单词规律</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。</p></li><li><p>这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着<strong>双向连接的对应规律</strong>。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">示例1:</span><br><span class="line"></span><br><span class="line">输入: pattern &#x3D; &quot;abba&quot;, str &#x3D; &quot;dog cat cat dog&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入:pattern &#x3D; &quot;abba&quot;, str &#x3D; &quot;dog cat cat fish&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: pattern &#x3D; &quot;aaaa&quot;, str &#x3D; &quot;dog cat cat dog&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">输入: pattern &#x3D; &quot;abba&quot;, str &#x3D; &quot;dog dog dog dog&quot;</span><br><span class="line">输出: false</span><br><span class="line">说明:</span><br><span class="line">你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。</span><br></pre></td></tr></table></figure><p>​    </p><a id="more"></a><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ul><li><p>在本题中，我们需要判断字符与字符串之间是否恰好一一对应。即任意一个字符都对应着唯一的字符串，任意一个字符串也只被唯一的一个字符对应。<strong>在集合论中，这种关系被称为「双射」。</strong></p></li><li><p>想要解决本题，我们可以利用<strong>哈希表记录每一个字符对应的字符串</strong>，<strong>以及每一个字符串对应的字符。</strong></p></li><li><p>然后我们枚举每一对字符与字符串的配对过程，不断更新哈希表，如果发生了冲突，则说明给定的输入不满足双射关系。</p></li></ul><p><strong>在实际代码中，我们枚举 pattern 中的每一个字符，利用双指针来均摊线性地找到该字符在 str 中对应的字符串。</strong></p><p><strong>每次确定一个字符与字符串的组合，我们就检查是否出现冲突，最后我们再检查两字符串是否比较完毕即可。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordPattern</span><span class="params">(String pattern, String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,Character&gt; str2ch = <span class="keyword">new</span> HashMap&lt;&gt;();         <span class="comment">// 字符串映射字符</span></span><br><span class="line">        Map&lt;Character,String&gt; ch2str = <span class="keyword">new</span> HashMap&lt;&gt;();         <span class="comment">// 字符映射字符串</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m   = s.length();</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;                                            <span class="comment">// idx 用于记录每个单词的开头位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举pattern中的每一个字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">0</span>;p &lt; pattern.length();++p)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = pattern.charAt(p);                                <span class="comment">// 枚举pattern中的每一个字符</span></span><br><span class="line">            <span class="keyword">if</span>(idx &gt;= m)&#123;                                               <span class="comment">// 说明字符和对应字符串的数量不匹配，直接返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理空格之间的字符串单词</span></span><br><span class="line">            <span class="keyword">int</span> j = idx;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; m &amp;&amp; s.charAt(j) != <span class="string">' '</span>)&#123;                         <span class="comment">// j用于记录每个字符串单词的结束位置</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            String temp = s.substring(idx,j);                           <span class="comment">// 拿出空格之间的这个单词</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 离散数学：集合的双射匹配</span></span><br><span class="line">            <span class="keyword">if</span>(str2ch.containsKey(temp) &amp;&amp; str2ch.get(temp) != ch)&#123;     <span class="comment">// 字符串不匹配字符直接返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ch2str.containsKey(ch) &amp;&amp; !temp.equals(ch2str.get(ch)))&#123; <span class="comment">// 字符不匹配字符串直接返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 不在哈希表中 就加入到哈希表中 并且进入下一轮字符匹配</span></span><br><span class="line">            str2ch.put(temp,ch);</span><br><span class="line">            ch2str.put(ch,temp);</span><br><span class="line">            idx = j + <span class="number">1</span>;            <span class="comment">// 从下一个单词的开头进行匹配 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 匹配到结束都满足条件（idx = j + 1）</span></span><br><span class="line">        <span class="keyword">return</span> idx &gt; m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong> ： O(n + m)。 其中 n 是pattern的长度 , m是str 的长度。每个字符至多只被遍历一次，插入和查询哈希表的均摊时间复杂度为O(n + m)</li><li><strong>空间复杂度</strong> ： O(n + m) 。其中 n 是pattern的长度 , m是str 的长度。最坏情况下，我们需要存储pattern的每一个字符和str中的每一个字符串</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-290-单词规律&quot;&gt;&lt;a href=&quot;#Leetcode-290-单词规律&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-290-单词规律&quot;&gt;&lt;/a&gt;Leetcode-290-&lt;a href=&quot;https://leetcode-cn.com/problems/word-pattern/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;单词规律&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着&lt;strong&gt;双向连接的对应规律&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: pattern &amp;#x3D; &amp;quot;abba&amp;quot;, str &amp;#x3D; &amp;quot;dog cat cat dog&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入:pattern &amp;#x3D; &amp;quot;abba&amp;quot;, str &amp;#x3D; &amp;quot;dog cat cat fish&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: pattern &amp;#x3D; &amp;quot;aaaa&amp;quot;, str &amp;#x3D; &amp;quot;dog cat cat dog&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 4:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: pattern &amp;#x3D; &amp;quot;abba&amp;quot;, str &amp;#x3D; &amp;quot;dog dog dog dog&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;说明:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;​    &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="哈希表" scheme="http://zhuuu.work/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>排序-04-基数排序</title>
    <link href="http://zhuuu.work/2020/12/13/Sort/%E6%8E%92%E5%BA%8F-04-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhuuu.work/2020/12/13/Sort/%E6%8E%92%E5%BA%8F-04-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</id>
    <published>2020-12-13T10:33:24.000Z</published>
    <updated>2020-12-13T08:34:19.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序-04-基数排序"><a href="#排序-04-基数排序" class="headerlink" title="排序-04-基数排序"></a>排序-04-基数排序</h1><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;排序-04-基数排序&quot;&gt;&lt;a href=&quot;#排序-04-基数排序&quot; class=&quot;headerlink&quot; title=&quot;排序-04-基数排序&quot;&gt;&lt;/a&gt;排序-04-基数排序&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="排序算法" scheme="http://zhuuu.work/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-376-摆动序列</title>
    <link href="http://zhuuu.work/2020/12/12/Leetcode/Leetcode-376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/"/>
    <id>http://zhuuu.work/2020/12/12/Leetcode/Leetcode-376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/</id>
    <published>2020-12-12T01:52:53.000Z</published>
    <updated>2020-12-12T02:29:42.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-376-摆动序列"><a href="#Leetcode-376-摆动序列" class="headerlink" title="Leetcode-376-摆动序列"></a>Leetcode-376-<a href="https://leetcode-cn.com/problems/wiggle-subsequence/" target="_blank" rel="noopener">摆动序列</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p><strong>如果连续数字之间的差严格地在正数和负数之间交替</strong>，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p></li><li><p>例如， <code>[1,7,4,9,2,5]</code> 是一个摆动序列，因为差值 <code>(6,-3,5,-7,3)</code> 是正负交替出现的。相反,<code>[1,4,7,2,5]</code> 和 <code>[1,7,4,5,5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p></li><li><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 <strong>通过从原始序列中删除一些（也可以不删除）元素来获得子序列</strong>，剩下的元素保持其原始顺序。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [1,7,4,9,2,5]</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 整个序列均为摆动序列。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [1,17,5,10,13,15,10,5,16,8]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: [1,2,3,4,5,6,7,8,9]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong><br>你能否用 O(<em>n</em>) 时间复杂度完成此题?</p><a id="more"></a><h2 id="算法思路-：-贪心算法"><a href="#算法思路-：-贪心算法" class="headerlink" title="算法思路 ： 贪心算法"></a>算法思路 ： 贪心算法</h2><ul><li><p>本题要求通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p></li><li><p>来分析一下，要求删除元素使其达到最大摆动序列，应该删除什么元素呢？</p></li></ul><p>用示例二来举例，如图所示：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201212/092659036.png" alt="mark"></p><p><strong>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值</strong>。</p><p><strong>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列</strong>。</p><p>局部最优推出全局最优，并举不出反例，那么试试贪心！</p><p>（为方便表述，以下说的峰值都是指局部峰值）</p><p><strong>实际操作上，其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）</strong></p><p><strong>这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点</strong>。</p><ul><li>本题代码实现中，还有一些技巧，例如统计峰值的时候，数组最左面和最右面是最不好统计的。</li><li>例如序列[2,5]，它的峰值数量是2，如果靠统计差值来计算峰值个数就需要考虑数组最左面和最右面的特殊情况。</li><li>所以可以针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即<code>preDiff = 0</code>，如图：<ul><li>此时<code>curDiff &gt; 0 &amp;&amp; preDiff &lt;= 0</code>，那么<code>result++</code></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201212/092926932.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 长度为1的都是摆动序列</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 初始化</span></span><br><span class="line">        <span class="keyword">int</span> prevdiff = nums[<span class="number">1</span>] - nums[<span class="number">0</span>];        <span class="comment">// 记录相邻三个元素 x y z(x 和 y 的差是正还是负)</span></span><br><span class="line">        <span class="keyword">int</span> ret = prevdiff != <span class="number">0</span>?<span class="number">2</span>:<span class="number">1</span>;             <span class="comment">// 前两个元素是否有重复（产生了坡度）</span></span><br><span class="line">        <span class="comment">// 3. 贪心遍历数组:加入一个新元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> diff = nums[i] - nums[i - <span class="number">1</span>];   <span class="comment">// 记录相邻三个元素 x y z(y 和 z 的差是正还是负)</span></span><br><span class="line">            <span class="keyword">if</span>((diff &gt; <span class="number">0</span> &amp;&amp; prevdiff &lt;= <span class="number">0</span>) || (diff &lt; <span class="number">0</span> &amp;&amp; prevdiff &gt;= <span class="number">0</span>))&#123;  <span class="comment">// 如果出现了峰或者谷</span></span><br><span class="line">                ret++;                          <span class="comment">// 如果出现了「峰」或「谷」，答案加一</span></span><br><span class="line">                prevdiff = diff;                <span class="comment">// 更新当前序列的上升下降趋势</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret; <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-376-摆动序列&quot;&gt;&lt;a href=&quot;#Leetcode-376-摆动序列&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-376-摆动序列&quot;&gt;&lt;/a&gt;Leetcode-376-&lt;a href=&quot;https://leetcode-cn.com/problems/wiggle-subsequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;摆动序列&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;如果连续数字之间的差严格地在正数和负数之间交替&lt;/strong&gt;，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;例如， &lt;code&gt;[1,7,4,9,2,5]&lt;/code&gt; 是一个摆动序列，因为差值 &lt;code&gt;(6,-3,5,-7,3)&lt;/code&gt; 是正负交替出现的。相反,&lt;code&gt;[1,4,7,2,5]&lt;/code&gt; 和 &lt;code&gt;[1,7,4,5,5]&lt;/code&gt; 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;给定一个整数序列，返回作为摆动序列的最长子序列的长度。 &lt;strong&gt;通过从原始序列中删除一些（也可以不删除）元素来获得子序列&lt;/strong&gt;，剩下的元素保持其原始顺序。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,7,4,9,2,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 6 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 整个序列均为摆动序列。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,17,5,10,13,15,10,5,16,8]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,2,3,4,5,6,7,8,9]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;进阶:&lt;/strong&gt;&lt;br&gt;你能否用 O(&lt;em&gt;n&lt;/em&gt;) 时间复杂度完成此题?&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="贪心算法" scheme="http://zhuuu.work/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-649-Dota2参议院</title>
    <link href="http://zhuuu.work/2020/12/11/Leetcode/Leetcode-649-Dota2%E5%8F%82%E8%AE%AE%E9%99%A2/"/>
    <id>http://zhuuu.work/2020/12/11/Leetcode/Leetcode-649-Dota2%E5%8F%82%E8%AE%AE%E9%99%A2/</id>
    <published>2020-12-11T07:52:53.000Z</published>
    <updated>2020-12-11T02:12:43.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-649-Dota2-参议院"><a href="#Leetcode-649-Dota2-参议院" class="headerlink" title="Leetcode-649-Dota2 参议院"></a>Leetcode-649-<a href="https://leetcode-cn.com/problems/dota2-senate/" target="_blank" rel="noopener">Dota2 参议院</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Dota2 的世界里有两个阵营：Radiant(天辉)和 Dire(夜魇)</p><p>Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：</p><ul><li><p>禁止一名参议员的权利：</p></li><li><p>参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。</p></li></ul><p>宣布胜利：</p><pre><code>如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。</code></pre><p>给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。</p><p><strong>以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。</strong></p><p>假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 <code>Dota2</code>游戏中决定改变。输出应该是 <code>Radiant</code> 或 <code>Dire</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：&quot;RD&quot;</span><br><span class="line">输出：&quot;Radiant&quot;</span><br><span class="line">解释：第一个参议员来自 Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：&quot;RDD&quot;</span><br><span class="line">输出：&quot;Dire&quot;</span><br><span class="line">解释：</span><br><span class="line">第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利</span><br><span class="line">第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止</span><br><span class="line">第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利</span><br><span class="line">因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>给定字符串的长度在 <code>[1, 10,000]</code> 之间.</li></ul><a id="more"></a><h2 id="算法思路-循环队列"><a href="#算法思路-循环队列" class="headerlink" title="算法思路 : 循环队列"></a>算法思路 : 循环队列</h2><ul><li>我们以天辉方的议员为例。当一名天辉方的议员行使权利时：<ul><li>如果目前所有的议员都为天辉方，那么该议员可以直接宣布天辉方取得胜利；</li><li>如果目前仍然有夜魇方的议员，那么这名天辉方的议员只能行使「禁止一名参议员的权利」这一项权利。<ul><li>显然，该议员不会令一名同为天辉方的议员丧失权利，所以他一定会挑选一名夜魇方的议员。那么应该挑选哪一名议员呢？</li><li>容易想到的是，<strong>应该贪心地挑选按照投票顺序的下一名夜魇方的议员</strong>。</li><li>这也是很容易形象化证明的：既然只能挑选<strong>一名</strong>夜魇方的议员，那么就应该挑最早可以进行投票的那一名议员；</li><li>如果挑选了其它较晚投票的议员，那么等到最早可以进行投票的那一名议员行使权利时，一名天辉方议员就会丧失权利，这样就得不偿失了。</li></ul></li></ul></li></ul><p><strong>具体算法</strong></p><ul><li>由于我们总要挑选投票顺序最早的议员 ，因此我们可以使用两个队列<code>radiant</code> 和 <code>dire</code> 分别按照投票顺序存储天辉方和夜魇方每一名议员的投票时间</li><li>随后我们就可以开始模拟整个投票的过程：<ul><li><strong>如果此时 队列<code>radiant</code> 或者 <code>dire</code> 为空</strong>，那么就可以宣布另一方获得胜利；</li><li><strong>如果此时队列不为空</strong> ： 那么比较这两个队列的首元素，就可以确定当前行使权利的是哪一名议员<ul><li><strong>如果 <em>radiant</em> 的首元素较小，</strong>那说明轮到天辉方的议员行使权利，其会挑选 <em>dire</em> 的首元素对应的那一名议员</li><li><strong>因此，我们会将 <em>dire</em> 的首元素永久地弹出</strong></li><li><strong>并将 <em>radiant</em> 的首元素弹出，增加 <em>n</em> 之后再重新放回队列</strong></li><li>这里 n 是给给定字符串 senate 的长度,即表示该议员因为没有被ban掉所以参加了下一轮投票</li><li>同理 ： 如果dire 首元素较小,那么会永久的弹出 <code>radiant  的首元素，剩余的处理方法也是一样的</code></li></ul></li></ul></li></ul><blockquote><p>为什么这里是固定地增加 n，而不是增加与当前剩余议员数量相关的一个数？</p></blockquote><p>这样一来，我们就模拟了整个投票的过程，也就可以得到最终的答案了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">predictPartyVictory</span><span class="params">(String senate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = senate.length();</span><br><span class="line">        Queue&lt;Integer&gt; radiant = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; dire    = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 遍历数组 记录下每个阵营议员的下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(senate.charAt(i) == <span class="string">'R'</span>)&#123;</span><br><span class="line">                radiant.offer(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dire.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 如果两个队列都不空的情况下</span></span><br><span class="line">        <span class="keyword">while</span>(!radiant.isEmpty() &amp;&amp; !dire.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> radiantIndex = radiant.poll();      <span class="comment">// radiant的第一名议员 暂时弹出</span></span><br><span class="line">            <span class="keyword">int</span> direIndex    = dire.poll();         <span class="comment">// dire 的第一名议员   暂时弹出</span></span><br><span class="line">            <span class="keyword">if</span>(radiantIndex &lt; direIndex)&#123;           <span class="comment">// 如果radiant第一名议员首元素较小</span></span><br><span class="line">                radiant.offer(radiantIndex + n);    <span class="comment">// 暂时弹出 +n之后重新放回队列 对应dire第一名议员永久弹出</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                     <span class="comment">// 加上n后，可以保证这个议员只会参加下一轮，或者被上一轮的对手干掉。</span></span><br><span class="line">                dire.offer(direIndex + n);          <span class="comment">// 暂时弹出 +n之后重新放回队列 对应radiant第一名议员永久弹出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 宣布胜利</span></span><br><span class="line">        <span class="keyword">return</span> !radiant.isEmpty()?<span class="string">"Radiant"</span>:<span class="string">"Dire"</span>; <span class="comment">// 最后非空的队列宣布胜利</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度 ：</strong> O(n)   其中 <code>n</code> 是字符串<code>senate</code> 的长度。在模拟整个投票过程的每一步，我们进行的操作的时间复杂度均为<code>O(1)</code>，并且会弹出一名天辉方或夜魇方的议员。由于议员的数量为 n，因此模拟的步数不会超过 n，时间复杂度即为 O(n)。</li><li><strong>空间复杂度</strong> ： O(n)   队列所需要的复杂度</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-649-Dota2-参议院&quot;&gt;&lt;a href=&quot;#Leetcode-649-Dota2-参议院&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-649-Dota2 参议院&quot;&gt;&lt;/a&gt;Leetcode-649-&lt;a href=&quot;https://leetcode-cn.com/problems/dota2-senate/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dota2 参议院&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;Dota2 的世界里有两个阵营：Radiant(天辉)和 Dire(夜魇)&lt;/p&gt;
&lt;p&gt;Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;禁止一名参议员的权利：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;宣布胜利：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 &lt;code&gt;Dota2&lt;/code&gt;游戏中决定改变。输出应该是 &lt;code&gt;Radiant&lt;/code&gt; 或 &lt;code&gt;Dire&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&amp;quot;RD&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&amp;quot;Radiant&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：第一个参议员来自 Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：&amp;quot;RDD&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&amp;quot;Dire&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定字符串的长度在 &lt;code&gt;[1, 10,000]&lt;/code&gt; 之间.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="贪心算法" scheme="http://zhuuu.work/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-860-柠檬水找零</title>
    <link href="http://zhuuu.work/2020/12/10/Leetcode/Leetcode-860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/"/>
    <id>http://zhuuu.work/2020/12/10/Leetcode/Leetcode-860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/</id>
    <published>2020-12-10T02:52:53.000Z</published>
    <updated>2020-12-10T01:27:30.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-860-柠檬水找零"><a href="#Leetcode-860-柠檬水找零" class="headerlink" title="Leetcode-860-柠檬水找零"></a>Leetcode-860-<a href="https://leetcode-cn.com/problems/lemonade-change/" target="_blank" rel="noopener">柠檬水找零</a></h1><h2 id="思路：贪心算法"><a href="#思路：贪心算法" class="headerlink" title="思路：贪心算法"></a>思路：贪心算法</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><ul><li><p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。</p></li><li><p>顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p></li><li><p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p></li></ul><p>  注意，一开始你手头没有任何零钱。</p><p>  如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">20</span>]</span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：</span><br><span class="line">前 <span class="number">3</span> 位顾客那里，我们按顺序收取 <span class="number">3</span> 张 <span class="number">5</span> 美元的钞票。</span><br><span class="line">第 <span class="number">4</span> 位顾客那里，我们收取一张 <span class="number">10</span> 美元的钞票，并返还 <span class="number">5</span> 美元。</span><br><span class="line">第 <span class="number">5</span> 位顾客那里，我们找还一张 <span class="number">10</span> 美元的钞票和一张 <span class="number">5</span> 美元的钞票。</span><br><span class="line">由于所有客户都得到了正确的找零，所以我们输出 <span class="keyword">true</span>。</span><br><span class="line">    </span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">5</span>,<span class="number">5</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">    </span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">10</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">    </span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">5</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">20</span>]</span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">解释：</span><br><span class="line">前 <span class="number">2</span> 位顾客那里，我们按顺序收取 <span class="number">2</span> 张 <span class="number">5</span> 美元的钞票。</span><br><span class="line">对于接下来的 <span class="number">2</span> 位顾客，我们收取一张 <span class="number">10</span> 美元的钞票，然后返还 <span class="number">5</span> 美元。</span><br><span class="line">对于最后一位顾客，我们无法退回 <span class="number">15</span> 美元，因为我们现在只有两张 <span class="number">10</span> 美元的钞票。</span><br><span class="line">由于不是每位顾客都得到了正确的找零，所以答案是 <span class="keyword">false</span>。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="算法思路：贪心-模拟（CRUD）"><a href="#算法思路：贪心-模拟（CRUD）" class="headerlink" title="算法思路：贪心 + 模拟（CRUD）"></a>算法思路：贪心 + 模拟（CRUD）</h2><p>由于顾客只可能给你三个面值的钞票，而且我们一开始没有任何钞票，因此我们拥有的钞票的面值只可能是 5 美元，10美元和 20 美元三种。基于此，我们可以进行如下的分类讨论。</p><ol><li><strong>5 美元</strong>，由于柠檬水的价格也为 5美元，因此我们直接收下即可</li><li><strong>10 美元，我们需要找回 5 美元</strong>，如果没有 5 美元面值的钞票，则无法正确找零。</li><li><strong>20 美元，我们需要找回 15 美元</strong>，此时有<strong>两种组合方式</strong><ul><li>一种是一张 10 美元和 5 美元的钞票</li><li>一种是 3 张  5 美元的钞票</li><li>如果两种组合方式都没有，则无法正确找零</li></ul></li></ol><ol start="4"><li><strong>对于情况三的找零方式 ：</strong> <ul><li>当可以正确找零时，两种找零的方式中我们更倾向于第一种</li><li>即如果存在5美元和10美元 我们就按照第一种方式找零</li><li>否则按照第二种情况找零，这样的目的是尽可以保留5美元的钞票</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lemonadeChange</span><span class="params">(<span class="keyword">int</span>[] bills)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> five = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ten  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  遍历所有的数组元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> bill:bills)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bill == <span class="number">5</span>)&#123;          <span class="comment">// 如果发现是五块钱，直接收了</span></span><br><span class="line">                five++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bill == <span class="number">10</span>)&#123;   <span class="comment">// 如果发现是10块钱</span></span><br><span class="line">                <span class="keyword">if</span>(five == <span class="number">0</span>)&#123;      <span class="comment">// 如果没有钱来找零了</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                five--;</span><br><span class="line">                ten++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                  <span class="comment">// 如果账单是20块钱</span></span><br><span class="line">                <span class="keyword">if</span>(ten &gt; <span class="number">0</span> &amp;&amp; five &gt; <span class="number">0</span>)&#123;    <span class="comment">// 1. 首先判断10块和5块的组合够不够找钱</span></span><br><span class="line">                    ten--;</span><br><span class="line">                    five--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(five &gt;= <span class="number">3</span>)&#123;        <span class="comment">// 2. 不够的话就用3张5块钱去找零</span></span><br><span class="line">                    five -= <span class="number">3</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;                      <span class="comment">// 3. 都没有零钱可找了</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可以找零的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong> ： O（N） 遍历一遍数组所需要的时间</li><li><strong>空间复杂度</strong>  ： O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-860-柠檬水找零&quot;&gt;&lt;a href=&quot;#Leetcode-860-柠檬水找零&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-860-柠檬水找零&quot;&gt;&lt;/a&gt;Leetcode-860-&lt;a href=&quot;https://leetcode-cn.com/problems/lemonade-change/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;柠檬水找零&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：贪心算法&quot;&gt;&lt;a href=&quot;#思路：贪心算法&quot; class=&quot;headerlink&quot; title=&quot;思路：贪心算法&quot;&gt;&lt;/a&gt;思路：贪心算法&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在柠檬水摊上，每一杯柠檬水的售价为 5 美元。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  注意，一开始你手头没有任何零钱。&lt;/p&gt;
&lt;p&gt;  如果你能给每位顾客正确找零，返回 true ，否则返回 false 。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;前 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; 位顾客那里，我们按顺序收取 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; 张 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 美元的钞票。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第 &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; 位顾客那里，我们收取一张 &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; 美元的钞票，并返还 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 美元。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 位顾客那里，我们找还一张 &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; 美元的钞票和一张 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 美元的钞票。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;由于所有客户都得到了正确的找零，所以我们输出 &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;前 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 位顾客那里，我们按顺序收取 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 张 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 美元的钞票。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;对于接下来的 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 位顾客，我们收取一张 &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; 美元的钞票，然后返还 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 美元。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;对于最后一位顾客，我们无法退回 &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt; 美元，因为我们现在只有两张 &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; 美元的钞票。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;由于不是每位顾客都得到了正确的找零，所以答案是 &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="贪心算法" scheme="http://zhuuu.work/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学-伽马修正</title>
    <link href="http://zhuuu.work/2020/12/09/cv/%E5%9B%BE%E5%83%8F%E5%AD%A6-%E4%BC%BD%E9%A9%AC%E4%BF%AE%E6%AD%A3/"/>
    <id>http://zhuuu.work/2020/12/09/cv/%E5%9B%BE%E5%83%8F%E5%AD%A6-%E4%BC%BD%E9%A9%AC%E4%BF%AE%E6%AD%A3/</id>
    <published>2020-12-09T09:38:38.000Z</published>
    <updated>2020-12-09T09:04:02.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图像学-伽马修正"><a href="#图像学-伽马修正" class="headerlink" title="图像学-伽马修正"></a>图像学-伽马修正</h1><h1 id="计算机图形学-伽马修正"><a href="#计算机图形学-伽马修正" class="headerlink" title="计算机图形学-伽马修正"></a>计算机图形学-伽马修正</h1><p><strong>起因：</strong> [][][一个伽马矫正的视频][<a href="https://v.youku.com/v_show/id_XMTQwMjg5NzM4OA==.html]" target="_blank" rel="noopener">https://v.youku.com/v_show/id_XMTQwMjg5NzM4OA==.html]</a></p><p><strong>答案 ：</strong> [一个知乎答案][<a href="https://www.zhihu.com/question/27467127]" target="_blank" rel="noopener">https://www.zhihu.com/question/27467127]</a></p><p><strong>参考博客 ：</strong> [博客地址][<a href="http://hanshilin.com/blog/gamma-and-linear-workflow/]" target="_blank" rel="noopener">http://hanshilin.com/blog/gamma-and-linear-workflow/]</a></p><a id="more"></a><h2 id="1-韦伯-费希纳定律"><a href="#1-韦伯-费希纳定律" class="headerlink" title="1. 韦伯-费希纳定律"></a>1. 韦伯-费希纳定律</h2><ul><li>最早见到韦伯定律的时候，以为就是个非常简单的式子：△I/I=K，△I是差别阈限；I是刺激强度；K是韦伯常数</li><li>根据刺激的不同，受试的不同，其值不同，但对于同一个被试在同等条件下进行同类型的刺激，该值为常数。</li><li>意思是，刺激强度I和在该刺激强度下引起最小可觉差所需要的刺激强度呈正比。例如，假设手里拿一个重量为10g的物体，若增加1g能让你恰好感觉到它的重量产生了变化（增加的重量低于1g你便不能感觉到重量发生了改变），那么如果手里拿一个重量为100g的物体，则需要增加其重量10g才能让你恰好感觉到重量发生了变化。</li></ul><p><strong>费希纳则在韦伯的基础上作出这样一个假设</strong>：</p><ul><li><strong>恰好引起感觉变化的刺激强度变化所引起的感觉变化是相等的。</strong>以上面那个例子为例，<ul><li>意思是，对于给10g物体增加1g所引起的你感觉变化与给100g物体增加10g所引起的你的感觉变化是一样的，都是1个单位的感觉变化。</li><li>换言之，你左手拿11g物体右手拿10g物体，你感觉左手比右手重”一些“；你左手拿110g物体右手拿100g物体，感觉左手比右手重”一些“，这两个”一些“的程度是一样的。 </li></ul></li></ul><ul><li>在这个假设的基础上，费希纳总结出公式：△P = k * △S/S         </li><li>根据该公式，若在某初始刺激为S的条件下，进行强度为10倍最小可觉差的刺激，则相应的感觉变化也应当变成10倍。比如给10g物体增加1g重量刚好能感觉到重量发生了改变，主观感觉变化量为△p；</li></ul><ul><li>虽然这个公式有一部分与韦伯定律的公式非常相似，但意义并不相同：<ul><li>在韦伯定律那里， △I/I=K指的是“当前刺激强度下的最小可觉差”与”当前刺激强度“的关系， △I与I均为变量。</li><li>而关系式△P = k * △S/S 则指示了在初始刺激强度为S时，刺激变化量△S与主观感觉变化量△P的关系。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">将上式改写成微分式，则有dP &#x3D; k * dS &#x2F; S</span><br><span class="line">   </span><br><span class="line">      对该式两侧同时进行积分：</span><br><span class="line">       ∫ dP  &#x3D; P &#x3D;  ∫ k&#x2F;S * dS  &#x3D;  k*lnS + C</span><br><span class="line">      </span><br><span class="line">      得到了主观感觉量P与刺激强度S的关系式：</span><br><span class="line">      P &#x3D; k*lnS + C</span><br><span class="line"></span><br><span class="line">      为消除积分常数C，令P&#x3D;0，有C &#x3D; -k*lns, s是绝对阈限。</span><br><span class="line"></span><br><span class="line">      可得：</span><br><span class="line">      P &#x3D; k * (lnS - lns)</span><br><span class="line">     </span><br><span class="line">     设绝对阈限为单位1，则lns &#x3D;0，</span><br><span class="line"></span><br><span class="line">     故可改写为P &#x3D;k *lnS &#x3D; k*(lgS&#x2F;lge) &#x3D; k&#x2F;lge * lgS  </span><br><span class="line">                         &#x3D; K * lgS</span><br><span class="line"></span><br><span class="line">     得到费希纳定律的公式。</span><br><span class="line"></span><br><span class="line">     若某振幅为10个单位的音波引起的声音的主观感觉量为1，如果把该音波的振幅扩大到100个单位，则声音的主观感觉量仅增加1。换言之，根据费希纳定律，若要感觉强度呈线性增长，则刺激强度需要呈几何倍数增长。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>[知乎另外一个答案][<a href="https://www.zhihu.com/question/314657948?sort=created]" target="_blank" rel="noopener">https://www.zhihu.com/question/314657948?sort=created]</a></p><p><strong>参考博客 ：</strong> </p><p><a href="https://www.douban.com/note/506270934/" target="_blank" rel="noopener">https://www.douban.com/note/506270934/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;图像学-伽马修正&quot;&gt;&lt;a href=&quot;#图像学-伽马修正&quot; class=&quot;headerlink&quot; title=&quot;图像学-伽马修正&quot;&gt;&lt;/a&gt;图像学-伽马修正&lt;/h1&gt;&lt;h1 id=&quot;计算机图形学-伽马修正&quot;&gt;&lt;a href=&quot;#计算机图形学-伽马修正&quot; class=&quot;headerlink&quot; title=&quot;计算机图形学-伽马修正&quot;&gt;&lt;/a&gt;计算机图形学-伽马修正&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;起因：&lt;/strong&gt; [][][一个伽马矫正的视频][&lt;a href=&quot;https://v.youku.com/v_show/id_XMTQwMjg5NzM4OA==.html]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://v.youku.com/v_show/id_XMTQwMjg5NzM4OA==.html]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答案 ：&lt;/strong&gt; [一个知乎答案][&lt;a href=&quot;https://www.zhihu.com/question/27467127]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.zhihu.com/question/27467127]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考博客 ：&lt;/strong&gt; [博客地址][&lt;a href=&quot;http://hanshilin.com/blog/gamma-and-linear-workflow/]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://hanshilin.com/blog/gamma-and-linear-workflow/]&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机图形学" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-897-递增顺序查找树</title>
    <link href="http://zhuuu.work/2020/12/07/Leetcode/Leetcode-897-%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    <id>http://zhuuu.work/2020/12/07/Leetcode/Leetcode-897-%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%A0%91/</id>
    <published>2020-12-07T07:52:53.000Z</published>
    <updated>2020-12-07T03:42:02.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-897-递增顺序查找树"><a href="#Leetcode-897-递增顺序查找树" class="headerlink" title="Leetcode-897-递增顺序查找树"></a>Leetcode-897-<a href="https://leetcode-cn.com/problems/increasing-order-search-tree/" target="_blank" rel="noopener">递增顺序查找树</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><p>给你一个树，请你 <strong>按中序遍历</strong> 重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。</p><pre><code>示例 ：输入：[5,3,6,2,4,null,8,1,null,null,null,7,9]      5      /     \    3    6   / \    \  2   4    8 /        / \ 1        7   9输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] 1  \   2    \     3      \       4        \         5          \           6            \             7              \               8                \                 9  </code></pre><a id="more"></a><h2 id="思路：中序遍历-构造新树"><a href="#思路：中序遍历-构造新树" class="headerlink" title="思路：中序遍历 + 构造新树"></a>思路：中序遍历 + 构造新树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; vals = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inorder(root,vals);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造新树</span></span><br><span class="line">        TreeNode ans = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        TreeNode cur = ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> val:vals)&#123;</span><br><span class="line">            cur.right = <span class="keyword">new</span> TreeNode(val);  <span class="comment">// 构造新的结点</span></span><br><span class="line">            cur = cur.right;    <span class="comment">// 方向只向右延伸</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode node,List&lt;Integer&gt; vals)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorder(node.left,vals);</span><br><span class="line">        vals.add(node.val);</span><br><span class="line">        inorder(node.right,vals);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：O(N)，其中 N 是树上的节点个数。</li><li><strong>空间复杂度</strong>：O(N)。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-897-递增顺序查找树&quot;&gt;&lt;a href=&quot;#Leetcode-897-递增顺序查找树&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-897-递增顺序查找树&quot;&gt;&lt;/a&gt;Leetcode-897-&lt;a href=&quot;https://leetcode-cn.com/problems/increasing-order-search-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;递增顺序查找树&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;给你一个树，请你 &lt;strong&gt;按中序遍历&lt;/strong&gt; 重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例 ：

输入：[5,3,6,2,4,null,8,1,null,null,null,7,9]

      5
      /     \
    3    6
   / \    \
  2   4    8
 /        / \ 
1        7   9

输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]

 1
  \
   2
    \
     3
      \
       4
        \
         5
          \
           6
            \
             7
              \
               8
                \
                 9  &lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="中序遍历" scheme="http://zhuuu.work/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-861-翻转矩阵后的得分</title>
    <link href="http://zhuuu.work/2020/12/07/Leetcode/Leetcode-861-%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5%E5%90%8E%E7%9A%84%E5%BE%97%E5%88%86/"/>
    <id>http://zhuuu.work/2020/12/07/Leetcode/Leetcode-861-%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5%E5%90%8E%E7%9A%84%E5%BE%97%E5%88%86/</id>
    <published>2020-12-07T02:52:53.000Z</published>
    <updated>2020-12-07T03:22:28.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-861-翻转矩阵后的得分"><a href="#Leetcode-861-翻转矩阵后的得分" class="headerlink" title="Leetcode-861-翻转矩阵后的得分"></a>Leetcode-861-<a href="https://leetcode-cn.com/problems/score-after-flipping-matrix/" target="_blank" rel="noopener">翻转矩阵后的得分</a></h1><h2 id="思路：贪心算法"><a href="#思路：贪心算法" class="headerlink" title="思路：贪心算法"></a>思路：贪心算法</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><ul><li><p>有一个二维矩阵 A 其中每个元素的值为 0 或 1 。</p></li><li><p><strong>移动是指选择任一行或列</strong>，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。</p></li><li><p>在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。</p></li><li><p>返回尽可能高的分数。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">39</span></span><br><span class="line">解释：</span><br><span class="line">转换为 [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line"><span class="number">0b1111</span> + <span class="number">0b1001</span> + <span class="number">0b1111</span> = <span class="number">15</span> + <span class="number">9</span> + <span class="number">15</span> = <span class="number">39</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ol><li>根据题意，能够知道一个重要的事实：给定一个翻转方案，则它们之间任意交换顺序后，得到的结果保持不变。<strong>因此，我们总可以先考虑所有的行翻转，再考虑所有的列翻转。</strong></li><li><strong>行翻转</strong> ：<strong>不难发现一点：为了得到最高的分数，矩阵的每一行的最左边的数都必须为1。为了做到这一点，我们可以翻转那些最左边的数不为 1 的那些行，而其他的行则保持不动。</strong></li><li><strong>列翻转</strong> ： 当将每一行的最左边的数都变为 1 之后，就只能进行列翻转了。<ul><li>为了使得总得分最大，我们要让每个列中 1 的数目尽可能多。</li><li>因此，我们扫描除了最左边的列以外的每一列，<strong>如果该列 0 的数目多于 1 的数目，就翻转该列，其他的列则保持不变。</strong></li></ul></li></ol><p><strong>对于实际编码的时候：我们无需要修改原来的矩阵</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201207/110943111.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此做法不必修改原来的矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">matrixScore</span><span class="params">(<span class="keyword">int</span>[][] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.length;</span><br><span class="line">        <span class="keyword">int</span> n = A[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 直接统计第一列的贡献（假设第一列全为1的结果）</span></span><br><span class="line">        <span class="keyword">int</span> ret = m * (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 统计从第二列开始 每一列的贡献</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> nOnes = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i][<span class="number">0</span>] == <span class="number">1</span>)&#123;           <span class="comment">// 说明这一行没有进行过行翻转</span></span><br><span class="line">                    nOnes += A[i][j];       <span class="comment">// 直接统计本列1的个数</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;                      <span class="comment">// 说明这一行开头是0,需要行翻转</span></span><br><span class="line">                    nOnes += (<span class="number">1</span> - A[i][j]); <span class="comment">// 如果这一行进行了翻转,则该元素的实际取值就是 1 - A[i][j]</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> k = Math.max(nOnes, m - nOnes);     <span class="comment">// k 是列翻转后1的数量 nOnes是1的数量 m - nOnes是0的数量</span></span><br><span class="line">            ret += k * (<span class="number">1</span> &lt;&lt; (n - j - <span class="number">1</span>));          <span class="comment">// 本列对于结果的贡献</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度 ： <code>O(mn)</code></strong></li><li><strong>空间复杂度：  <code>O(1)</code></strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-861-翻转矩阵后的得分&quot;&gt;&lt;a href=&quot;#Leetcode-861-翻转矩阵后的得分&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-861-翻转矩阵后的得分&quot;&gt;&lt;/a&gt;Leetcode-861-&lt;a href=&quot;https://leetcode-cn.com/problems/score-after-flipping-matrix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;翻转矩阵后的得分&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：贪心算法&quot;&gt;&lt;a href=&quot;#思路：贪心算法&quot; class=&quot;headerlink&quot; title=&quot;思路：贪心算法&quot;&gt;&lt;/a&gt;思路：贪心算法&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;有一个二维矩阵 A 其中每个元素的值为 0 或 1 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;移动是指选择任一行或列&lt;/strong&gt;，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;返回尽可能高的分数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;39&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;转换为 [[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0b1111&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;0b1001&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;0b1111&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;39&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="贪心算法" scheme="http://zhuuu.work/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-204-计数质数</title>
    <link href="http://zhuuu.work/2020/12/03/Leetcode/Leetcode-204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/"/>
    <id>http://zhuuu.work/2020/12/03/Leetcode/Leetcode-204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/</id>
    <published>2020-12-03T00:52:53.000Z</published>
    <updated>2020-12-03T01:44:43.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-204-计数质数"><a href="#Leetcode-204-计数质数" class="headerlink" title="Leetcode-204-计数质数"></a>Leetcode-204-<a href="https://leetcode-cn.com/problems/count-primes/" target="_blank" rel="noopener">计数质数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>统计所有小于非负整数 <em><code>n</code></em> 的质数的数量。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：n &#x3D; 10</span><br><span class="line">输出：4</span><br><span class="line">解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 0</span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt;&#x3D; n &lt;&#x3D; 5 * 106</span><br></pre></td></tr></table></figure><h2 id="方法一：枚举"><a href="#方法一：枚举" class="headerlink" title="方法一：枚举"></a>方法一：枚举</h2><ul><li><p>很直观的思路是我们枚举每个数判断其是不是质数。</p></li><li><p>考虑质数的定义：在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。</p></li><li><p>因此对于每个数 x，我们可以从小到大枚举<code>[2,x-1]</code>中的每个数 y，判断 y 是否为 x 的因数。但这样判断一个数是否为质数的时间复杂度最差情况下会到 <code>O(n)</code>，无法通过所有测试数据。</p></li></ul><p><strong>注意：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201203/091156606.png" alt="mark"></p><p>举例子 ： </p><ul><li><code>x = 6 y = 2 x/y =3</code></li><li><code>min(y,x/y)= 2</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化数据</span></span><br><span class="line">        String line;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((line = in.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> n = Integer.parseInt(line);</span><br><span class="line">            <span class="keyword">int</span> ret = <span class="keyword">new</span> Solution().countPrimes(n);</span><br><span class="line">            String out = String.valueOf(ret);</span><br><span class="line">            System.out.println(out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;++i)&#123;</span><br><span class="line">            ans += isPrime(i)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(sqrt(n))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i*i &lt;= x;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x % i == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201203/091257182.png" alt="mark"></p><a id="more"></a><h2 id="方法二-：-埃氏筛"><a href="#方法二-：-埃氏筛" class="headerlink" title="方法二 ： 埃氏筛"></a>方法二 ： 埃氏筛</h2><ul><li>枚举没有考虑到数与数的关联性，因此难以再继续优化时间复杂度。接下来我们介绍一个常见的算法，该算法由希腊数学家厄拉多塞（<code>Eratosthenes</code>）提出，称为厄拉多塞筛法，简称埃氏筛。</li></ul><p><strong>注意：</strong></p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201203/091731007.png" alt="mark" style="zoom:150%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 初始化质数数组</span></span><br><span class="line">        <span class="keyword">int</span>[] isPrime = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(isPrime,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 进行统计</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime[i] == <span class="number">1</span>)&#123;   <span class="comment">// 如果遇到的这个数是质数的话,开始判断,否则不会进循环</span></span><br><span class="line">                ans += <span class="number">1</span>;           <span class="comment">// 遍历数组,如果是质数的话,那么给结果加1</span></span><br><span class="line">                <span class="keyword">if</span>((<span class="keyword">long</span>)i*i &lt; n)&#123;  <span class="comment">// 如果i是质数 那么i*i就是合数 起始位置：需要标记为0</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = i*i;j &lt; n;j += i)&#123;  <span class="comment">// 同时,从i*i 位置开始标记,</span></span><br><span class="line">                        isPrime[j] = <span class="number">0</span>;             <span class="comment">// 标记i*i + i也同时为i的倍数，只要是i的倍数,那么就一定不是质数</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201203/094440295.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-204-计数质数&quot;&gt;&lt;a href=&quot;#Leetcode-204-计数质数&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-204-计数质数&quot;&gt;&lt;/a&gt;Leetcode-204-&lt;a href=&quot;https://leetcode-cn.com/problems/count-primes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;计数质数&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;统计所有小于非负整数 &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt; 的质数的数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：n &amp;#x3D; 10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：n &amp;#x3D; 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：n &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0 &amp;lt;&amp;#x3D; n &amp;lt;&amp;#x3D; 5 * 106&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;h2 id=&quot;方法一：枚举&quot;&gt;&lt;a href=&quot;#方法一：枚举&quot; class=&quot;headerlink&quot; title=&quot;方法一：枚举&quot;&gt;&lt;/a&gt;方法一：枚举&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;很直观的思路是我们枚举每个数判断其是不是质数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考虑质数的定义：在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;因此对于每个数 x，我们可以从小到大枚举&lt;code&gt;[2,x-1]&lt;/code&gt;中的每个数 y，判断 y 是否为 x 的因数。但这样判断一个数是否为质数的时间复杂度最差情况下会到 &lt;code&gt;O(n)&lt;/code&gt;，无法通过所有测试数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201203/091156606.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;举例子 ： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x = 6 y = 2 x/y =3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;min(y,x/y)= 2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainClass&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        BufferedReader in = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BufferedReader(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; InputStreamReader(System.in));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 初始化数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String line;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; ((line = in.readLine()) != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n = Integer.parseInt(line);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ret = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Solution().countPrimes(n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            String out = String.valueOf(ret);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(out);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;countPrimes&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ans = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// O(n)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;i &amp;lt; n;++i)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ans += isPrime(i)?&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// O(sqrt(n))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isPrime&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;i*i &amp;lt;= x;++i)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(x % i == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201203/091257182.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-134-加油站</title>
    <link href="http://zhuuu.work/2020/11/18/Leetcode/Leetcode-134-%E5%8A%A0%E6%B2%B9%E7%AB%99/"/>
    <id>http://zhuuu.work/2020/11/18/Leetcode/Leetcode-134-%E5%8A%A0%E6%B2%B9%E7%AB%99/</id>
    <published>2020-11-18T09:22:53.000Z</published>
    <updated>2020-11-18T04:56:06.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-134-加油站"><a href="#Leetcode-134-加油站" class="headerlink" title="Leetcode-134-加油站"></a>Leetcode-134-<a href="https://leetcode-cn.com/problems/gas-station/" target="_blank" rel="noopener">加油站</a></h1><h2 id="思路：一次遍历"><a href="#思路：一次遍历" class="headerlink" title="思路：一次遍历"></a>思路：一次遍历</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p>说明: </p><ul><li>如果题目有解，该答案即为唯一答案。</li><li>输入数组均为非空数组，且长度相同。</li><li>输入数组中的元素均为非负数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">gas  &#x3D; [1,2,3,4,5]</span><br><span class="line">cost &#x3D; [3,4,5,1,2]</span><br><span class="line"></span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 + 5 &#x3D; 8 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 8 - 2 + 1 &#x3D; 7 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 7 - 3 + 2 &#x3D; 6 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 6 - 4 + 3 &#x3D; 5 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">gas  &#x3D; [2,3,4]</span><br><span class="line">cost &#x3D; [3,4,3]</span><br><span class="line"></span><br><span class="line">输出: -1</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 4 - 3 + 2 &#x3D; 3 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 3 - 3 + 3 &#x3D; 3 升汽油</span><br><span class="line">你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法-：一次遍历"><a href="#方法-：一次遍历" class="headerlink" title="方法 ：一次遍历"></a>方法 ：一次遍历</h2><ul><li><p>最容易想到的解法是：从头到尾遍历每个加油站，并检查以该加油站为起点，最终能否行驶一周。我们可以通过减小被检查的加油站数目，来降低总的时间复杂度。</p></li><li><p>假设我们此前发现，从加油站 xx 出发，每经过一个加油站就加一次油，第一个无法到达的加油站是 y（不妨设 x&lt;y）。这就说明：</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201118/124732560.png" alt="mark"></p><ul><li>现在，考虑任意一个位于 x,y之间的加油站 z<em>，我们现在考察从该加油站出发，能否到达加油站 y</em></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201118/124851837.png" alt="mark"></p><p><strong>这也就是说明，从x,y 之间任何一个加油站出发,都无法到达加油站y(说明起点只能有一个,这个加油站不行的话，中间任何一个点作为起点都不可以，起点只能从下一次加油站 x + 1开始检查，故最后只遍历了一遍数组)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = gas.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从头到尾遍历每个加油站，并且检查以该加油站为起点，能否行驶一周</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            <span class="keyword">int</span> sumOfGas  = <span class="number">0</span>; <span class="comment">// 总共加的油</span></span><br><span class="line">            <span class="keyword">int</span> SumOfCost = <span class="number">0</span>; <span class="comment">// 总共消费的油</span></span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;     <span class="comment">// 记录能走过几个站点</span></span><br><span class="line">            <span class="keyword">while</span>(count &lt; n)&#123;  <span class="comment">// 退出循环的条件是走过所有的站点</span></span><br><span class="line">                <span class="keyword">int</span> j = (i + count) % n; <span class="comment">// 加油站是环形的</span></span><br><span class="line">                sumOfGas += gas[j];</span><br><span class="line">                SumOfCost += cost[j];</span><br><span class="line">                <span class="keyword">if</span>(SumOfCost &gt; sumOfGas)&#123; <span class="comment">// 如果这个站点发现油不够了</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count++; <span class="comment">// 这个站点满足情况</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(count == n)&#123;  <span class="comment">// 如果能环绕一圈</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 不行的话 从下一个站点开始 检查</span></span><br><span class="line">                i = i + count + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所有加油站作为起点都不满足</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(N)，其中 N为数组的长度。我们对数组进行了单次遍历。</li><li>空间复杂度：O(1)。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-134-加油站&quot;&gt;&lt;a href=&quot;#Leetcode-134-加油站&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-134-加油站&quot;&gt;&lt;/a&gt;Leetcode-134-&lt;a href=&quot;https://leetcode-cn.com/problems/gas-station/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;加油站&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：一次遍历&quot;&gt;&lt;a href=&quot;#思路：一次遍历&quot; class=&quot;headerlink&quot; title=&quot;思路：一次遍历&quot;&gt;&lt;/a&gt;思路：一次遍历&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。&lt;/p&gt;
&lt;p&gt;你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。&lt;/p&gt;
&lt;p&gt;如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。&lt;/p&gt;
&lt;p&gt;说明: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果题目有解，该答案即为唯一答案。&lt;/li&gt;
&lt;li&gt;输入数组均为非空数组，且长度相同。&lt;/li&gt;
&lt;li&gt;输入数组中的元素均为非负数。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;gas  &amp;#x3D; [1,2,3,4,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cost &amp;#x3D; [3,4,5,1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 &amp;#x3D; 0 + 4 &amp;#x3D; 4 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;开往 4 号加油站，此时油箱有 4 - 1 + 5 &amp;#x3D; 8 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;开往 0 号加油站，此时油箱有 8 - 2 + 1 &amp;#x3D; 7 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;开往 1 号加油站，此时油箱有 7 - 3 + 2 &amp;#x3D; 6 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;开往 2 号加油站，此时油箱有 6 - 4 + 3 &amp;#x3D; 5 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因此，3 可为起始索引。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;gas  &amp;#x3D; [2,3,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cost &amp;#x3D; [3,4,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: -1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 &amp;#x3D; 0 + 4 &amp;#x3D; 4 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;开往 0 号加油站，此时油箱有 4 - 3 + 2 &amp;#x3D; 3 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;开往 1 号加油站，此时油箱有 3 - 3 + 3 &amp;#x3D; 3 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因此，无论怎样，你都不可能绕环路行驶一周。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1030-距离顺序排列矩阵单元格</title>
    <link href="http://zhuuu.work/2020/11/17/Leetcode/Leetcode-1030-%E8%B7%9D%E7%A6%BB%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97%E7%9F%A9%E9%98%B5%E5%8D%95%E5%85%83%E6%A0%BC/"/>
    <id>http://zhuuu.work/2020/11/17/Leetcode/Leetcode-1030-%E8%B7%9D%E7%A6%BB%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97%E7%9F%A9%E9%98%B5%E5%8D%95%E5%85%83%E6%A0%BC/</id>
    <published>2020-11-17T07:52:53.000Z</published>
    <updated>2020-11-17T03:41:20.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-1030-距离顺序排列矩阵单元格"><a href="#Leetcode-1030-距离顺序排列矩阵单元格" class="headerlink" title="Leetcode-1030-距离顺序排列矩阵单元格"></a>Leetcode-1030-<a href="https://leetcode-cn.com/problems/matrix-cells-in-distance-order/" target="_blank" rel="noopener">距离顺序排列矩阵单元格</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>给出 R 行 C 列的矩阵，其中的单元格的整数坐标为<code>(r, c)</code>，满足 <code>0 &lt;= r &lt; R</code>且<code>0 &lt;= c &lt; C。</code></p><p>另外，我们在该矩阵中给出了一个坐标为<code>(r0, c0)</code> 的单元格。</p><p>返回矩阵中的所有单元格的坐标，并按到 <code>(r0, c0)</code> 的距离从最小到最大的顺序排，其中，两单元格<code>(r1, c1) 和 (r2, c2)</code> 之间的距离是曼哈顿距离，<code>|r1 - r2| + |c1 - c2|</code>。（你可以按任何满足此条件的顺序返回答案。）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：R &#x3D; 1, C &#x3D; 2, r0 &#x3D; 0, c0 &#x3D; 0</span><br><span class="line">输出：[[0,0],[0,1]]</span><br><span class="line">解释：从 (r0, c0) 到其他单元格的距离为：[0,1]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：R &#x3D; 2, C &#x3D; 2, r0 &#x3D; 0, c0 &#x3D; 1</span><br><span class="line">输出：[[0,1],[0,0],[1,1],[1,0]]</span><br><span class="line">解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2]</span><br><span class="line">[[0,1],[1,1],[0,0],[1,0]] 也会被视作正确答案。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：R &#x3D; 2, C &#x3D; 3, r0 &#x3D; 1, c0 &#x3D; 2</span><br><span class="line">输出：[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]</span><br><span class="line">解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2,2,3]</span><br><span class="line">其他满足题目要求的答案也会被视为正确，例如 [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法一-：-暴力排序"><a href="#方法一-：-暴力排序" class="headerlink" title="方法一 ： 暴力排序"></a>方法一 ： 暴力排序</h2><ul><li>最容易想到的方法是首先存储矩阵内所有的点，然后将其按照哈曼顿距离直接排序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] allCellsDistOrder(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] ret = <span class="keyword">new</span> <span class="keyword">int</span>[R * C][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">                ret[i * C + j] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(ret, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (Math.abs(a[<span class="number">0</span>] - r0) + Math.abs(a[<span class="number">1</span>] - c0)) - (Math.abs(b[<span class="number">0</span>] - r0) + Math.abs(b[<span class="number">1</span>] - c0));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201117/113741576.png" alt="mark"></p><h2 id="方法二-：桶排序"><a href="#方法二-：桶排序" class="headerlink" title="方法二 ：桶排序"></a>方法二 ：桶排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用桶排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] allCellsDistOrder(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) &#123;</span><br><span class="line">        <span class="comment">// 计算需要几个桶 并把创建相应数量的桶</span></span><br><span class="line">        <span class="keyword">int</span> maxDist = Math.max(r0,R - <span class="number">1</span> - r0) + Math.max(c0, C- <span class="number">1</span> - c0);</span><br><span class="line">        List&lt;List&lt;<span class="keyword">int</span>[]&gt;&gt; bucket = <span class="keyword">new</span> ArrayList&lt;List&lt;<span class="keyword">int</span>[]&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxDist;i++)&#123;</span><br><span class="line">            bucket.add(<span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算出哈曼顿距离 并结果加入到相应的桶里面(时间复杂度 O(RC))</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; R;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; C;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> d = dist(i,j,r0,c0);</span><br><span class="line">                bucket.get(d).add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建结果集，并把Arraylist&lt;List&lt;int[]&gt; 转换成int[][]</span></span><br><span class="line">        <span class="keyword">int</span>[][] ret = <span class="keyword">new</span> <span class="keyword">int</span>[R*C][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历每个桶,把桶中的元素加入到结果集中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= maxDist;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] it:bucket.get(i))&#123;</span><br><span class="line">                ret[idx++] = it;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算哈曼顿距离（排序方法）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> r1,<span class="keyword">int</span> c1,<span class="keyword">int</span> r2,<span class="keyword">int</span> c2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(r1 - r2) + Math.abs(c1 - c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201117/114113486.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-1030-距离顺序排列矩阵单元格&quot;&gt;&lt;a href=&quot;#Leetcode-1030-距离顺序排列矩阵单元格&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-1030-距离顺序排列矩阵单元格&quot;&gt;&lt;/a&gt;Leetcode-1030-&lt;a href=&quot;https://leetcode-cn.com/problems/matrix-cells-in-distance-order/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;距离顺序排列矩阵单元格&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;给出 R 行 C 列的矩阵，其中的单元格的整数坐标为&lt;code&gt;(r, c)&lt;/code&gt;，满足 &lt;code&gt;0 &amp;lt;= r &amp;lt; R&lt;/code&gt;且&lt;code&gt;0 &amp;lt;= c &amp;lt; C。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;另外，我们在该矩阵中给出了一个坐标为&lt;code&gt;(r0, c0)&lt;/code&gt; 的单元格。&lt;/p&gt;
&lt;p&gt;返回矩阵中的所有单元格的坐标，并按到 &lt;code&gt;(r0, c0)&lt;/code&gt; 的距离从最小到最大的顺序排，其中，两单元格&lt;code&gt;(r1, c1) 和 (r2, c2)&lt;/code&gt; 之间的距离是曼哈顿距离，&lt;code&gt;|r1 - r2| + |c1 - c2|&lt;/code&gt;。（你可以按任何满足此条件的顺序返回答案。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：R &amp;#x3D; 1, C &amp;#x3D; 2, r0 &amp;#x3D; 0, c0 &amp;#x3D; 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[[0,0],[0,1]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：从 (r0, c0) 到其他单元格的距离为：[0,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：R &amp;#x3D; 2, C &amp;#x3D; 2, r0 &amp;#x3D; 0, c0 &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[[0,1],[0,0],[1,1],[1,0]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[0,1],[1,1],[0,0],[1,0]] 也会被视作正确答案。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：R &amp;#x3D; 2, C &amp;#x3D; 3, r0 &amp;#x3D; 1, c0 &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2,2,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;其他满足题目要求的答案也会被视为正确，例如 [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="桶排序" scheme="http://zhuuu.work/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="BFS" scheme="http://zhuuu.work/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-402-移除K个数</title>
    <link href="http://zhuuu.work/2020/11/15/Leetcode/Leetcode-402-%E7%A7%BB%E9%99%A4K%E4%B8%AA%E6%95%B0/"/>
    <id>http://zhuuu.work/2020/11/15/Leetcode/Leetcode-402-%E7%A7%BB%E9%99%A4K%E4%B8%AA%E6%95%B0/</id>
    <published>2020-11-15T07:52:53.000Z</published>
    <updated>2020-11-15T01:32:21.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-409-移掉K位数字"><a href="#Leecode-409-移掉K位数字" class="headerlink" title="Leecode-409-移掉K位数字"></a>Leecode-409-<a href="https://leetcode-cn.com/problems/remove-k-digits/" target="_blank" rel="noopener">移掉K位数字</a></h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h2><ul><li>给定一个以字符串表示的非负整数 <em>num*，移除这个数中的 *k</em> 位数字，使得剩下的数字最小。</li></ul><p><strong>注意:</strong></p><ul><li><em>num</em> 的长度小于 10002 且 ≥ <em>k。</em></li><li><em>num</em> 不会包含任何前导零。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1 :</span><br><span class="line"></span><br><span class="line">输入: num &#x3D; &quot;1432219&quot;, k &#x3D; 3</span><br><span class="line">输出: &quot;1219&quot;</span><br><span class="line">解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。</span><br><span class="line"></span><br><span class="line">示例 2 :</span><br><span class="line"></span><br><span class="line">输入: num &#x3D; &quot;10200&quot;, k &#x3D; 1</span><br><span class="line">输出: &quot;200&quot;</span><br><span class="line">解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</span><br><span class="line"></span><br><span class="line">示例 3 :</span><br><span class="line"></span><br><span class="line">输入: num &#x3D; &quot;10&quot;, k &#x3D; 2</span><br><span class="line">输出: &quot;0&quot;</span><br><span class="line">解释: 从原数字移除所有的数字，剩余为空就是0。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法-：-贪心算法"><a href="#方法-：-贪心算法" class="headerlink" title="方法 ： 贪心算法"></a><strong>方法 ： 贪心算法</strong></h2><p><strong>官方很好的题解 ：</strong> <a href="https://leetcode-cn.com/problems/remove-k-digits/solution/yi-diao-kwei-shu-zi-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-k-digits/solution/yi-diao-kwei-shu-zi-by-leetcode-solution/</a></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201115/093033535.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeKdigits</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Character&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次丢弃一次，k 减去 1。当 k 减到 0 ，我们可以提前终止遍历。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> digit : num.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">while</span>(stack.size() &gt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span> &amp;&amp; stack.peekLast() &gt; digit)&#123;</span><br><span class="line">                stack.removeLast();</span><br><span class="line">                k -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.addLast(digit);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 而当遍历完成，如果 k 仍然大于 0。</span></span><br><span class="line">        <span class="comment">// 不妨假设最终还剩下 x 个需要丢弃，那么我们需要选择删除末尾 x 个元素。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">            stack.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder ret = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// 处理删除后的前导0，直接跳过即可</span></span><br><span class="line">        <span class="keyword">boolean</span> leadingZero = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> digit:stack)&#123;</span><br><span class="line">            <span class="keyword">if</span>(leadingZero &amp;&amp; digit == <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            leadingZero = <span class="keyword">false</span>;</span><br><span class="line">            ret.append(digit);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终数字序列为空的话,返回0</span></span><br><span class="line">        <span class="keyword">if</span>(ret.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度 ： O(n)，其中 n 为字符串的长度。尽管存在嵌套循环，但内部循环最多运行 k次。</strong>由于<code>0&lt;k≤n</code>，主循环的时间复杂度被限制在 <code>2n</code>以内。对于主循环之外的逻辑，它们的时间复杂度是 O(n)，因此总时间复杂度为 O(n)。</li><li><strong>空间复杂度 ： O(n) 栈所需要的空间大小</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-409-移掉K位数字&quot;&gt;&lt;a href=&quot;#Leecode-409-移掉K位数字&quot; class=&quot;headerlink&quot; title=&quot;Leecode-409-移掉K位数字&quot;&gt;&lt;/a&gt;Leecode-409-&lt;a href=&quot;https://leetcode-cn.com/problems/remove-k-digits/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;移掉K位数字&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;给定一个以字符串表示的非负整数 &lt;em&gt;num*，移除这个数中的 *k&lt;/em&gt; 位数字，使得剩下的数字最小。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;num&lt;/em&gt; 的长度小于 10002 且 ≥ &lt;em&gt;k。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;num&lt;/em&gt; 不会包含任何前导零。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1 :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: num &amp;#x3D; &amp;quot;1432219&amp;quot;, k &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;1219&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2 :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: num &amp;#x3D; &amp;quot;10200&amp;quot;, k &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;200&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3 :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: num &amp;#x3D; &amp;quot;10&amp;quot;, k &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;0&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 从原数字移除所有的数字，剩余为空就是0。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="贪心算法" scheme="http://zhuuu.work/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1122-数组的相对排序</title>
    <link href="http://zhuuu.work/2020/11/14/Leetcode/Leetcode-1122-%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhuuu.work/2020/11/14/Leetcode/Leetcode-1122-%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/</id>
    <published>2020-11-14T07:52:53.000Z</published>
    <updated>2020-11-14T01:22:40.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-1122-数组的相对排序https-leetcode-cn-com-problems-maximum-nesting-depth-of-two-valid-parentheses-strings"><a href="#Leecode-1122-数组的相对排序https-leetcode-cn-com-problems-maximum-nesting-depth-of-two-valid-parentheses-strings" class="headerlink" title="Leecode-1122-数组的相对排序https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/)"></a>Leecode-1122-<a href="https://leetcode-cn.com/problems/relative-sort-array/" target="_blank" rel="noopener">数组的相对排序</a><a href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/</a>)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给你两个数组，arr1 和 arr2，</span><br><span class="line"></span><br><span class="line">arr2 中的元素各不相同</span><br><span class="line">arr2 中的每个元素都出现在 arr1 中</span><br><span class="line">对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：arr1 &#x3D; [2,3,1,3,2,4,6,7,9,2,19], arr2 &#x3D; [2,1,4,3,9,6]</span><br><span class="line">输出：[2,2,2,1,4,3,3,9,6,7,19]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">arr1.length, arr2.length &lt;&#x3D; 1000</span><br><span class="line">0 &lt;&#x3D; arr1[i], arr2[i] &lt;&#x3D; 1000</span><br><span class="line">arr2 中的元素 arr2[i] 各不相同</span><br><span class="line">arr2 中的每个元素 arr2[i] 都出现在 arr1 中</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法-：-计数排序"><a href="#方法-：-计数排序" class="headerlink" title="方法 ： 计数排序"></a>方法 ： 计数排序</h2><ul><li>注意到本题中元素的范围为 [0, 1000][0,1000]，这个范围不是很大，我们也可以考虑不基于比较的排序，例如「计数排序」。</li></ul><p><strong>具体算法</strong></p><ol><li><p>使用长度为1001【下标0 - 1000】 的数组<code>frequency</code> 记录每一个元素在<code>arr1</code> 中出现的次数 </p></li><li><p>随后遍历数组<code>arr2</code>,当遍历到元素x的时候。将<code>frequency[x]</code> 放入到结果集中，并将<code>frequency[x]</code>清0</p></li><li><p>此时还剩下没有在<code>arr2</code> 中出现过的元素，因此我们还需要对整个数组<code>frequency</code> 进行一次遍历。当遍历到x时，如果<code>frequency[x]!=0</code> ，说明这个元素没有在arr2中出现，那么将这个元素添加到答案的最后。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] relativeSortArray(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2) &#123;</span><br><span class="line">        <span class="comment">// 本题中元素的范围是[0,1000] 这个范围不是很大，可以不考虑比较排序，例如【计数排序】</span></span><br><span class="line">        <span class="comment">// 对空间的优化，使用比数组arr1中最大值upper 使用长度upper + 1;</span></span><br><span class="line">        <span class="keyword">int</span> upper = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:arr1)&#123;</span><br><span class="line">            upper = Math.max(upper,x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录每个数出现的次数</span></span><br><span class="line">        <span class="keyword">int</span>[] frequency = <span class="keyword">new</span> <span class="keyword">int</span>[upper + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:arr1)&#123;</span><br><span class="line">            ++frequency[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组arr2，当遍历到元素x的时候</span></span><br><span class="line">        <span class="comment">// 将frequency[x] 放入到结果集中，并将frequency[x]清0</span></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[arr1.length];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:arr2)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; frequency[x];i++)&#123;</span><br><span class="line">                ans[idx++] = x;</span><br><span class="line">            &#125;</span><br><span class="line">            frequency[x] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将frequency[x]中剩余的数字放入到结果集中</span></span><br><span class="line">        <span class="comment">// 按照frequency中的升序放入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>;x &lt;= upper;++x)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; frequency[x];++i)&#123;</span><br><span class="line">                ans[idx++] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(<code>m + n + upper</code>)</li><li>空间复杂度 :   O(<code>upper</code>),即为<code>frequency</code>数组使用的空间</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-1122-数组的相对排序https-leetcode-cn-com-problems-maximum-nesting-depth-of-two-valid-parentheses-strings&quot;&gt;&lt;a href=&quot;#Leecode-1122-数组的相对排序https-leetcode-cn-com-problems-maximum-nesting-depth-of-two-valid-parentheses-strings&quot; class=&quot;headerlink&quot; title=&quot;Leecode-1122-数组的相对排序https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/)&quot;&gt;&lt;/a&gt;Leecode-1122-&lt;a href=&quot;https://leetcode-cn.com/problems/relative-sort-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数组的相对排序&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/&lt;/a&gt;)&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给你两个数组，arr1 和 arr2，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr2 中的元素各不相同&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr2 中的每个元素都出现在 arr1 中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：arr1 &amp;#x3D; [2,3,1,3,2,4,6,7,9,2,19], arr2 &amp;#x3D; [2,1,4,3,9,6]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[2,2,2,1,4,3,3,9,6,7,19]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr1.length, arr2.length &amp;lt;&amp;#x3D; 1000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0 &amp;lt;&amp;#x3D; arr1[i], arr2[i] &amp;lt;&amp;#x3D; 1000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr2 中的元素 arr2[i] 各不相同&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr2 中的每个元素 arr2[i] 都出现在 arr1 中&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="计数排序" scheme="http://zhuuu.work/tags/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-模板方法模式</title>
    <link href="http://zhuuu.work/2020/11/13/GoF23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zhuuu.work/2020/11/13/GoF23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-11-13T07:02:24.000Z</published>
    <updated>2020-11-19T11:12:26.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式-模板方法模式"><a href="#设计模式-模板方法模式" class="headerlink" title="设计模式-模板方法模式"></a>设计模式-模板方法模式</h1><h2 id="模板方法模式（Template-Method）"><a href="#模板方法模式（Template-Method）" class="headerlink" title="模板方法模式（Template Method）"></a>模板方法模式（Template Method）</h2><ul><li>动机：对于一项任务，常常有<strong>稳定的整体操作结构</strong>，但各个子步骤却又很多改变的需求，或者需要子步骤的晚期实现（<strong>延迟到子类去实现</strong>）。</li><li><strong><code>Template Method</code>使得子类可以复用一个算法的结构</strong>（<code>Override</code> 重写）该算法的某些特定步骤。</li><li><strong>不要调用我，让我来调用你，实现晚绑定机制</strong>，<strong>这也就是控制反转的思想。</strong></li><li><strong>声明成 <code>protected</code> ,因为具体步骤在流程中才有意义。</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200615/161657528.png" alt="mark"></p><ul><li><strong>AbstractClass : 稳定的骨架（里面有具体的方法和需要被重写的方法）</strong></li><li><strong>ContreteClass : 具体的重写方法</strong></li></ul><p><strong>模板方法模式定义</strong>（特别的常用）：</p><ul><li><strong>定义一个操作中的算法的骨架（稳定） ,而将一些步骤（变化）延迟到子类中。</strong></li><li><strong>Template Method 使得子类可以不改变（复用）一个算法的结构即可（Override 重写）该算法某些特定的步骤</strong></li></ul><a id="more"></a><ul><li>具体实现（举例）</li></ul><p>冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200615/162632540.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 骨架流程</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepareRecipe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        boilWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourIncoup();</span><br><span class="line">        addCondiments();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待重写的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待重写的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pourIncoup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"倒进杯子"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">boilWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"倒水"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"倒咖啡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"加入咖啡粉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tea</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"倒茶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"加入茶叶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractClass coffee = <span class="keyword">new</span> Coffee();</span><br><span class="line">        coffee.prepareRecipe();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"========"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        AbstractClass tea = <span class="keyword">new</span> Tea();</span><br><span class="line">        tea.prepareRecipe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果显示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">倒水</span><br><span class="line">倒咖啡</span><br><span class="line">倒进杯子</span><br><span class="line">加入咖啡粉</span><br><span class="line">========</span><br><span class="line">倒水</span><br><span class="line">倒茶</span><br><span class="line">倒进杯子</span><br><span class="line">加入茶叶</span><br></pre></td></tr></table></figure><p><strong>JDK中实现：</strong></p><ul><li><code>java.util.Collections#sort()</code></li><li><code>java.io.InputStream#skip()</code></li><li><code>java.io.InputStream#read()</code></li><li><code>java.util.AbstractList#indexOf()</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;设计模式-模板方法模式&quot;&gt;&lt;a href=&quot;#设计模式-模板方法模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式-模板方法模式&quot;&gt;&lt;/a&gt;设计模式-模板方法模式&lt;/h1&gt;&lt;h2 id=&quot;模板方法模式（Template-Method）&quot;&gt;&lt;a href=&quot;#模板方法模式（Template-Method）&quot; class=&quot;headerlink&quot; title=&quot;模板方法模式（Template Method）&quot;&gt;&lt;/a&gt;模板方法模式（Template Method）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;动机：对于一项任务，常常有&lt;strong&gt;稳定的整体操作结构&lt;/strong&gt;，但各个子步骤却又很多改变的需求，或者需要子步骤的晚期实现（&lt;strong&gt;延迟到子类去实现&lt;/strong&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Template Method&lt;/code&gt;使得子类可以复用一个算法的结构&lt;/strong&gt;（&lt;code&gt;Override&lt;/code&gt; 重写）该算法的某些特定步骤。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要调用我，让我来调用你，实现晚绑定机制&lt;/strong&gt;，&lt;strong&gt;这也就是控制反转的思想。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;声明成 &lt;code&gt;protected&lt;/code&gt; ,因为具体步骤在流程中才有意义。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200615/161657528.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;AbstractClass : 稳定的骨架（里面有具体的方法和需要被重写的方法）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ContreteClass : 具体的重写方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;模板方法模式定义&lt;/strong&gt;（特别的常用）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义一个操作中的算法的骨架（稳定） ,而将一些步骤（变化）延迟到子类中。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Template Method 使得子类可以不改变（复用）一个算法的结构即可（Override 重写）该算法某些特定的步骤&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="设计模式" scheme="http://zhuuu.work/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-观察者模式</title>
    <link href="http://zhuuu.work/2020/11/13/GoF23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zhuuu.work/2020/11/13/GoF23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-11-13T07:02:24.000Z</published>
    <updated>2020-11-16T09:50:42.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式-观察者模式"><a href="#设计模式-观察者模式" class="headerlink" title="设计模式-观察者模式"></a>设计模式-观察者模式</h1><h4 id="观察者模式（Obersver）"><a href="#观察者模式（Obersver）" class="headerlink" title="观察者模式（Obersver）"></a>观察者模式（Obersver）</h4><ul><li><strong>观察者模式是使用频率非常高的模式了，它定义了对象间一种一对多的关系，使得每当一个对象改变状态，则所有依赖它的对象都会收到通知，并且自动更新。</strong></li><li><strong>例如：<code>Java</code>中的监听器<code>Listener</code>用的就是观察者模式。</strong></li></ul><p><strong>UML类图：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200624/094333516.png" alt="mark"></p><ul><li><strong><code>Subject:</code> 具有注册和移除观察者，并且通知观察者的功能，主体是通过某种数据结构（可能是列表）来维护一张观察者列表实现这些操作的。</strong></li><li><strong>观察者（<code>Observer</code>）的注册功能需要调用主体的<code>registerObserver()</code>方法。</strong></li></ul><a id="more"></a><p><strong>实现：</strong></p><ul><li>开发<strong>技术周报</strong>，每周会更新一些内容，但是不知道具体的更新时间，又想第一时间阅读更新内容。</li><li>难道要一直按住<code>F5</code>等它更新么？那估计<code>F5</code>烂了可能都没有更新。其实我们只需要简单的订阅一下就好，当有新的内容更新的时候，会发邮件到你订阅的邮箱中。</li></ul><p>上述例子中：</p><ul><li>订阅者就是观察者，技术周报就是被观察者</li></ul><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"><span class="keyword">import</span> java.util.Observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者：程序员</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coder</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Coder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"收到的更新内容为"</span> + o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 被观察者：主体（开发周报）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weekly</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一对多的通知</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加一个观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除一个观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        observers.forEach(observer -&gt; observer.update(<span class="string">"数据更新了"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK中自带的观察者模式的类</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200624/103921192.png" alt="mark"></p><ul><li><strong>在<code>java.util</code> 包中内置了<code>Observer</code> 和 <code>observable</code>类,同时<code>Observable</code>类实现了注册和反注册等方法，使用起来方便很多。可见观察者模式是非常重要的。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Vector&lt;java.util.Observer&gt; obs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Observable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obs = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (!obs.contains(o)) &#123;</span><br><span class="line">            obs.addElement(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反注册</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        obs.removeElement(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反注册所有观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obs.removeAllElements();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知更新</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        notifyObservers(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知更新</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        Object[] arrLocal;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!changed)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            arrLocal = obs.toArray();</span><br><span class="line">            clearChanged();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arrLocal.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">            ((Observer)arrLocal[i]).update(<span class="keyword">this</span>, arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        changed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clearChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        changed = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">hasChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> changed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">countObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obs.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>Observer</code>接口则是比较简单的代码</strong>，<code>update()</code>的参数中除了可以传递数据意外，还提供了被观察者的引用对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is called whenever the observed object is changed. An</span></span><br><span class="line"><span class="comment">     * application calls an &lt;tt&gt;Observable&lt;/tt&gt; object's</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;notifyObservers&lt;/code&gt; method to have all the object's</span></span><br><span class="line"><span class="comment">     * observers notified of the change.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   o     the observable object.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   arg   an argument passed to the &lt;code&gt;notifyObservers&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     *                 method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK中的实现：</strong></p><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Observer.html" target="_blank" rel="noopener">java.util.Observer</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/EventListener.html" target="_blank" rel="noopener">java.util.EventListener</a></li><li><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionBindingListener.html" target="_blank" rel="noopener">javax.servlet.http.HttpSessionBindingListener</a></li><li><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;设计模式-观察者模式&quot;&gt;&lt;a href=&quot;#设计模式-观察者模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式-观察者模式&quot;&gt;&lt;/a&gt;设计模式-观察者模式&lt;/h1&gt;&lt;h4 id=&quot;观察者模式（Obersver）&quot;&gt;&lt;a href=&quot;#观察者模式（Obersver）&quot; class=&quot;headerlink&quot; title=&quot;观察者模式（Obersver）&quot;&gt;&lt;/a&gt;观察者模式（Obersver）&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;观察者模式是使用频率非常高的模式了，它定义了对象间一种一对多的关系，使得每当一个对象改变状态，则所有依赖它的对象都会收到通知，并且自动更新。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;例如：&lt;code&gt;Java&lt;/code&gt;中的监听器&lt;code&gt;Listener&lt;/code&gt;用的就是观察者模式。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;UML类图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200624/094333516.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Subject:&lt;/code&gt; 具有注册和移除观察者，并且通知观察者的功能，主体是通过某种数据结构（可能是列表）来维护一张观察者列表实现这些操作的。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;观察者（&lt;code&gt;Observer&lt;/code&gt;）的注册功能需要调用主体的&lt;code&gt;registerObserver()&lt;/code&gt;方法。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="设计模式" scheme="http://zhuuu.work/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-031-下一个排列</title>
    <link href="http://zhuuu.work/2020/11/10/Leetcode/Leetcode-031-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <id>http://zhuuu.work/2020/11/10/Leetcode/Leetcode-031-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</id>
    <published>2020-11-10T02:52:53.000Z</published>
    <updated>2020-11-10T01:20:54.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-031-下一个排列"><a href="#Leecode-031-下一个排列" class="headerlink" title="Leecode-031-下一个排列"></a>Leecode-031-<a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">下一个排列</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>实现获取<strong>下一个排列的函数</strong>，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p></li><li><p>如果<strong>不存在下一个更大的排列</strong>，则将<strong>数字重新排列成最小的排列（即升序排列）。</strong></p></li><li><p>必须<strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地</a></strong>修改，只允许使用额外常数空间。</p></li></ul><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br><code>1,2,3</code> → <code>1,3,2</code><br><code>3,2,1</code> → <code>1,2,3</code><br><code>1,1,5</code> → <code>1,5,1</code></p><a id="more"></a><h2 id="字典序"><a href="#字典序" class="headerlink" title="字典序"></a>字典序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">本题要求我们实现一个算法，将给定数字序列重新排列成字典序中下一个更大的排列。</span><br><span class="line"></span><br><span class="line">以数字序列 [1,2,3][1,2,3] 为例，其排列按照字典序依次为：</span><br><span class="line">[1,2,3]\\ [1,3,2]\\ [2,1,3]\\ [2,3,1]\\ [3,1,2]\\ [3,2,1]</span><br><span class="line"></span><br><span class="line">这样，排列 [2,3,1] 的下一个排列即为 [3,1,2]。特别的，最大的排列 [3,2,1] 的下一个排列为最小的排列 [1,2,3]。</span><br></pre></td></tr></table></figure><h2 id="方法：两边扫描"><a href="#方法：两边扫描" class="headerlink" title="方法：两边扫描"></a>方法：两边扫描</h2><p>注意到下一个排列总是比当前排列要大，除非该排列已经是最大的排列。我们希望找到一种方法，<strong>能够找到一个大于当前序列的新序列，且变大的幅度尽可能小</strong>。具体地：</p><ol><li>我们需要将一个<strong>左边的「较小数」与一个右边的「较大数」交换</strong>，以能够让当前排列变大，从而得到下一个排列。</li><li>同时我们要让这个「<strong>较小数」尽量靠右，而「较大数」尽可能小</strong>。</li><li><strong>当交换完成后，「较大数」右边的数需要按照升序重新排列</strong>。这样可以在保证新排列大于原来排列的情况下，使变大的幅</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以排列 [4,5,2,6,3,1] 为例：</span><br><span class="line"></span><br><span class="line">我们能找到的符合条件的一对「较小数」与「较大数」的组合为 2 与 3，满足「较小数」尽量靠右，而「较大数」尽可能小。</span><br><span class="line"></span><br><span class="line">当我们完成交换后排列变为 [4,5,3,6,2,1]，此时我们可以重排「较小数」右边的序列，序列变为 [4,5,3,1,2,6]。</span><br></pre></td></tr></table></figure><p><strong>具体地，我们这样描述该算法，对于长度为 n的排列 a：</strong></p><ol><li><p>首先从后向前查找第一个顺序对 <code>(i,i+1)</code>，满足 <code>a[i] &lt; a[i+1]</code>。这样「较小数」即为 <code>a[i]</code>。此时 <code>[i+1,n)</code>必然是下降序列。</p></li><li><p>如果找到了顺序对，那么在区间<code>[i+1,n)</code>中从后向前查找第一个元素 <code>j</code> 满足 <code>a[i] &lt; a[j]a[i]&lt;a[j]</code>。这样「较大数」即为 <code>a[j]</code>。</p></li><li><p>交换<code>a[i] 与 a[j]</code>，此时可以证明区间<code>[i+1,n)</code>必为降序。我们可以直接使用双指针反转区间 <code>[i+1,n)</code>使其变为升序，而无需对该区间进行排序。</p></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201110/090035559.gif" alt="mark"></p><p><strong>注意</strong></p><p><strong>如果在步骤 1 找不到顺序对，说明当前序列已经是一个降序序列，即最大的序列，我们直接跳过步骤 2 执行步骤 3，即可得到最小的升序序列。</strong></p><p><strong>该方法支持序列中存在重复元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = nums.length - <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从后向前扫描 找到较小数</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>])&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时(i + 1,n] 一定是下降序列</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)&#123; <span class="comment">// 如果这个条件不满足，说明当前序列已经是一个降序序列，即最大的序列 ，所以直接进行翻转reverser即可</span></span><br><span class="line">            <span class="comment">// 从[i + 1,n)从后往前查找</span></span><br><span class="line">            <span class="comment">// 找到丢一个元素j 满足 a[i] &lt; a[j] </span></span><br><span class="line">            <span class="comment">// 较大数即为 a[j]</span></span><br><span class="line">            <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j])&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 交换a[i] 和 a[j]</span></span><br><span class="line">            swap(nums,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时[i + 1,n) 一定是降序序列</span></span><br><span class="line">        reverse(nums,i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i]  = nums[j];</span><br><span class="line">        nums[j]  = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用双指针翻转区间[i + 1,n)</span></span><br><span class="line">    <span class="comment">// 使得该区间变成升序序列，而无需对区间进行排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left  = start;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            swap(nums,left,right);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：O(N)，其中 N为给定序列的长度。我们至多只需要扫描两次序列，以及进行一次反转操作。</li><li><strong>空间复杂度</strong>：O(1)，只需要常数的空间存放若干变量。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-031-下一个排列&quot;&gt;&lt;a href=&quot;#Leecode-031-下一个排列&quot; class=&quot;headerlink&quot; title=&quot;Leecode-031-下一个排列&quot;&gt;&lt;/a&gt;Leecode-031-&lt;a href=&quot;https://leetcode-cn.com/problems/next-permutation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;下一个排列&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;实现获取&lt;strong&gt;下一个排列的函数&lt;/strong&gt;，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果&lt;strong&gt;不存在下一个更大的排列&lt;/strong&gt;，则将&lt;strong&gt;数字重新排列成最小的排列（即升序排列）。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;必须&lt;strong&gt;&lt;a href=&quot;https://baike.baidu.com/item/原地算法&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原地&lt;/a&gt;&lt;/strong&gt;修改，只允许使用额外常数空间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是一些例子，输入位于左侧列，其相应输出位于右侧列。&lt;br&gt;&lt;code&gt;1,2,3&lt;/code&gt; → &lt;code&gt;1,3,2&lt;/code&gt;&lt;br&gt;&lt;code&gt;3,2,1&lt;/code&gt; → &lt;code&gt;1,2,3&lt;/code&gt;&lt;br&gt;&lt;code&gt;1,1,5&lt;/code&gt; → &lt;code&gt;1,5,1&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Netty-13-TCP粘包和拆包</title>
    <link href="http://zhuuu.work/2020/11/08/Netty/Netty-13-TCP%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/"/>
    <id>http://zhuuu.work/2020/11/08/Netty/Netty-13-TCP%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/</id>
    <published>2020-11-08T02:05:24.000Z</published>
    <updated>2021-05-16T03:16:56.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-13-TCP粘包和拆包"><a href="#Netty-13-TCP粘包和拆包" class="headerlink" title="Netty-13-TCP粘包和拆包"></a>Netty-13-TCP粘包和拆包</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>TCP是面向连接的，面向流的，提供高可靠性服务。</li><li>收发两端（<strong>客户端和服务器端）</strong>都要有一一成对的socket，因此，发送端为了将多个发给接收端的包，更有效的发给对方，<strong>使用了优化方法（Nagle算法</strong>），将多次<strong>间隔较小且数据量小</strong>的数据，合并成一个大的数据块，然后进行封包。</li><li>这样做虽然提高了效率，但是<strong>接收端就难于分辨出完整的数据包</strong>了，因为<strong>面向流的通信是无消息保护边界</strong>的</li></ul><p><strong>通常的解决方案</strong></p><ol><li><p><strong>发送端</strong>每发送一次消息，就需要在消息的内容之前<strong>携带消息的长度</strong></p></li><li><p>这样，<strong>接收方</strong>每次先接受消息的长度，再<strong>根据长度去读取消息剩余的元素</strong></p></li><li><p>如果 <code>socket</code> 中还有没有读取的内容，也只能放在下一次读取事件中读取</p></li></ol><a id="more"></a><h2 id="1-拆包、粘包的图解"><a href="#1-拆包、粘包的图解" class="headerlink" title="1. 拆包、粘包的图解"></a>1. 拆包、粘包的图解</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201109/091157126.png" alt="mark"></p><p>假设客户端同时发送了两个数据包D1和D2给服务端，由于服务端一次读取到字节数是不确定的，固可能存在以下四种情况：</p><ol><li><p>服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包</p></li><li><p>服务端一次接受到了两个数据包，D1和D2粘合在一起，<strong>称之为TCP粘包</strong></p></li><li><p>服务端分两次读取到了数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这<strong>称之为TCP拆包</strong></p></li><li><p>服务端分两次读取到了数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余部分内容D1_2和完整的D2包。</p></li></ol><h2 id="2-TCP-拆包、粘包"><a href="#2-TCP-拆包、粘包" class="headerlink" title="2. TCP  拆包、粘包"></a>2. TCP  拆包、粘包</h2><p> 本实例主要演示出现拆包和粘包的场景。</p><p><strong>客户端：</strong></p><p> 我们将使用循环连续发送10个<code>String</code>类型的字符串。这里相当于发送了10次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//使用客户端发送10条数据，hello，server</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        String msg = <span class="string">"server"</span> + i + <span class="string">"  "</span>;</span><br><span class="line">        System.out.println(<span class="string">"发送消息 "</span> + msg);</span><br><span class="line">        ByteBuf byteBuf = Unpooled.copiedBuffer(msg, CharsetUtil.UTF_8);</span><br><span class="line">        ctx.writeAndFlush(byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>服务端：</strong></p><p> 我们接受客户端发过来的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[msg.readableBytes()];</span><br><span class="line">    msg.readBytes(bytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将buffer转成字符串</span></span><br><span class="line">    String message = <span class="keyword">new</span> String(bytes, CharsetUtil.UTF_8);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"服务器接收到数据 "</span> + message);</span><br><span class="line">    System.out.println(<span class="string">"服务器接收到消息量 = "</span> + (++<span class="keyword">this</span>.count));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器回送数据到客户端，回送一个随机Id</span></span><br><span class="line">    ByteBuf response = Unpooled.copiedBuffer(UUID.randomUUID().toString() + <span class="string">"--"</span>, CharsetUtil.UTF_8);</span><br><span class="line">    ctx.writeAndFlush(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端输出结果如下：</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201109/091543240.png" alt="mark"></p><ul><li>可以看到，服务端直接一次就把我们客户端10次发送的内容读取完成了。</li><li>这里也印证了我们开篇所说的，当<strong>数据量小且发送间隔短</strong>，如果我们客户端每次发送的都是不同的结果，这种情况下我们就不知道客户端返回了多少次结果以及每次结果究竟是什么。这就是我们本篇需要解决的问题。</li></ul><h2 id="3-TCP-问题解决方案"><a href="#3-TCP-问题解决方案" class="headerlink" title="3. TCP 问题解决方案"></a>3. TCP 问题解决方案</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201109/091255970.png" alt="mark"></p><ul><li><strong>在数据包的前面加上一个固定字节数的数据长度</strong>，如加上一个 <code>int</code> (固定四个字节）类型的数据内容长度</li><li>就算客户端同时发送两个数据包到服务端，当服务端接收时，也可以先读取四个字节的长度，然后根据长度获取相应消息的内容，这样就不会出现多读取或者少读取的情况了。</li></ul><h3 id="3-1-解决方案代码演示"><a href="#3-1-解决方案代码演示" class="headerlink" title="3.1 解决方案代码演示"></a>3.1 解决方案代码演示</h3><ul><li><p><strong>使用自定义协议 + 编解码器 来解决</strong></p></li><li><p>关键就是要解决 <strong>服务器端每次读取数据长度的问题</strong></p></li><li><p>这个问题解决，就不会出现服务器多读或少读数据的问题，从而避免的TCP 粘包、拆包 。</p></li></ul><ol><li><strong>自定义协议(重要)</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义协议</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len; <span class="comment">//关键</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLen</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLen</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.len = len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getContent()&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(<span class="keyword">byte</span>[] content)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>客户端引导器</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">MyClientInitializer</span>())</span>; <span class="comment">// 自定义初始化类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">"localhost"</span>, <span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync(); <span class="comment">// 监听关闭端口事件</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭连接</span></span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>客户端pipeline</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加入多个handler</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyMessageEncoder()); <span class="comment">// 加入编码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyMessageDecoder()); <span class="comment">// 加入解码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyClientHandler());  <span class="comment">// 加入自定义处理器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>客户端Handler(重要)</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 记录发送了几条消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 客户端发送5条数据 "今天天气冷，吃火锅" 编号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            String msg = <span class="string">"今天天气冷，吃火锅"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 封装数据对象</span></span><br><span class="line">            <span class="keyword">byte</span>[] content = msg.getBytes(Charset.forName(<span class="string">"utf-8"</span>));     <span class="comment">// 数据内容转换成字节数组</span></span><br><span class="line">            <span class="keyword">int</span> length = msg.getBytes(Charset.forName(<span class="string">"utf-8"</span>)).length;  <span class="comment">// 数据长度</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 封装成自定义数据包对象</span></span><br><span class="line">            Message message = <span class="keyword">new</span> Message();</span><br><span class="line">            message.setLen(length);</span><br><span class="line">            message.setContent(content);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送</span></span><br><span class="line">            ctx.writeAndFlush(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, Message message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>服务端引导器</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">MyServerInitializer</span>())</span>;</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>服务端pipeline</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加入自定义处理器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyMessageDecoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyMessageEncoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li><strong>服务端handler(重要)</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 统计接收的次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, Message message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收到数据进行处理</span></span><br><span class="line">        <span class="keyword">int</span> len = message.getLen();</span><br><span class="line">        <span class="keyword">byte</span>[] content = message.getContent();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"服务器接收到信息如下"</span>);</span><br><span class="line">        System.out.println(<span class="string">"长度="</span> + len);</span><br><span class="line">        System.out.println(<span class="string">"内容="</span> + <span class="keyword">new</span> String(content, Charset.forName(<span class="string">"utf-8"</span>)));</span><br><span class="line">        System.out.println(<span class="string">"服务器接收到消息包数量="</span> + (++<span class="keyword">this</span>.count));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回复客户端消息</span></span><br><span class="line">        String response = UUID.randomUUID().toString();</span><br><span class="line">        <span class="keyword">int</span> resLen = response.getBytes(<span class="string">"utf-8"</span>).length;</span><br><span class="line">        <span class="keyword">byte</span>[] rescontent = response.getBytes(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把回复的消息封装成一个message对象</span></span><br><span class="line">        Message message1 = <span class="keyword">new</span> Message();</span><br><span class="line">        message1.setContent(rescontent);</span><br><span class="line">        message1.setLen(resLen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送给客户端</span></span><br><span class="line">        channelHandlerContext.writeAndFlush(message1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li><strong>自定义协议编码器</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.MessageToByteEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, Message message, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyMessageEncoder encode 方法被调用"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将编码数据写入ByteBuf中</span></span><br><span class="line">        byteBuf.writeInt(message.getLen());</span><br><span class="line">        byteBuf.writeBytes(message.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="9"><li><strong>自定义协议解码器</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ReplayingDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyMessageDecoder decode 被调用"</span>);</span><br><span class="line">        <span class="comment">//需要将得到二进制字节码-&gt; MessageProtocol 数据包(对象)</span></span><br><span class="line">        <span class="keyword">int</span> length = in.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] content = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.readBytes(content);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//封装成 MessageProtocol 对象，放入 out， 传递下一个handler业务处理</span></span><br><span class="line">        Message messageProtocol = <span class="keyword">new</span> Message();</span><br><span class="line">        messageProtocol.setLen(length);</span><br><span class="line">        messageProtocol.setContent(content);</span><br><span class="line"></span><br><span class="line">        out.add(messageProtocol);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 本文档整理自 尚硅谷韩顺平Netty 相关课程。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-13-TCP粘包和拆包&quot;&gt;&lt;a href=&quot;#Netty-13-TCP粘包和拆包&quot; class=&quot;headerlink&quot; title=&quot;Netty-13-TCP粘包和拆包&quot;&gt;&lt;/a&gt;Netty-13-TCP粘包和拆包&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;TCP是面向连接的，面向流的，提供高可靠性服务。&lt;/li&gt;
&lt;li&gt;收发两端（&lt;strong&gt;客户端和服务器端）&lt;/strong&gt;都要有一一成对的socket，因此，发送端为了将多个发给接收端的包，更有效的发给对方，&lt;strong&gt;使用了优化方法（Nagle算法&lt;/strong&gt;），将多次&lt;strong&gt;间隔较小且数据量小&lt;/strong&gt;的数据，合并成一个大的数据块，然后进行封包。&lt;/li&gt;
&lt;li&gt;这样做虽然提高了效率，但是&lt;strong&gt;接收端就难于分辨出完整的数据包&lt;/strong&gt;了，因为&lt;strong&gt;面向流的通信是无消息保护边界&lt;/strong&gt;的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;通常的解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;发送端&lt;/strong&gt;每发送一次消息，就需要在消息的内容之前&lt;strong&gt;携带消息的长度&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这样，&lt;strong&gt;接收方&lt;/strong&gt;每次先接受消息的长度，再&lt;strong&gt;根据长度去读取消息剩余的元素&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果 &lt;code&gt;socket&lt;/code&gt; 中还有没有读取的内容，也只能放在下一次读取事件中读取&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="TCP" scheme="http://zhuuu.work/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-127-单词接龙</title>
    <link href="http://zhuuu.work/2020/11/05/Leetcode/Leetcode-127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/"/>
    <id>http://zhuuu.work/2020/11/05/Leetcode/Leetcode-127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/</id>
    <published>2020-11-05T07:22:53.000Z</published>
    <updated>2020-11-05T06:06:39.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leecode-127-单词接龙"><a href="#Leecode-127-单词接龙" class="headerlink" title="Leecode-127-单词接龙"></a>Leecode-127-<a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener">单词接龙</a></h1><h2 id="思路：BFS-双向BFS"><a href="#思路：BFS-双向BFS" class="headerlink" title="思路：BFS/双向BFS"></a>思路：BFS/双向BFS</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：</span><br><span class="line"></span><br><span class="line">每次转换只能改变一个字母。</span><br><span class="line">转换过程中的中间单词必须是字典中的单词。</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">如果不存在这样的转换序列，返回 0。</span><br><span class="line">所有单词具有相同的长度。</span><br><span class="line">所有单词只由小写字母组成。</span><br><span class="line">字典中不存在重复的单词。</span><br><span class="line">你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">beginWord &#x3D; &quot;hit&quot;,</span><br><span class="line">endWord &#x3D; &quot;cog&quot;,</span><br><span class="line">wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">输出: 5</span><br><span class="line"></span><br><span class="line">解释: 一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class="line">     返回它的长度 5。</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">beginWord &#x3D; &quot;hit&quot;</span><br><span class="line">endWord &#x3D; &quot;cog&quot;</span><br><span class="line">wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">解释: endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul><li>无向图中两个顶点之间的最短路径的长度，可以通过广度优先遍历得到；</li><li>为什么 BFS 得到的路径最短？<strong>可以把起点和终点所在的路径拉直来看，两点之间线段最短</strong>；</li><li>已知目标顶点的情况下，可以<strong>分别从起点和目标顶点（终点）执行广度优先遍历</strong>，直到遍历的部分有交集，这是<strong>双向广度优先遍历的思想。</strong></li></ul><p><strong>分析题意：</strong></p><p>「转换」意即：两个单词对应位置只有一个字符不同，例如 “hit” 与 “hot”，这种转换是可以逆向的，因此，根据题目给出的单词列表，可以<strong>构建出一个无向（无权）图</strong>；</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201105/140134859.png" alt="mark"></p><ul><li>如果一开始就构建图，每一个单词都需要和除它以外的另外的单词进行比较，<strong>复杂度是 O(N O(NwordLen)</strong>，这里 N 是单词列表的长度；</li><li>为此，我们在遍历的一开始，把所有单词放入一个哈希表中，然后在遍历的过程中构件图，每一次得到在单词列表里可以转换的单词，<strong>复杂度是O(26×wordLen)，借助哈希表</strong>，找到邻居与 N 无关；</li><li>使用BFS ： 所需要的辅助数据结构是<ul><li>队列</li><li><code>visited</code> 集合<ul><li>说明：可以直接在 <code>wordSet</code> (由 <code>wordList</code> 放进集合中得到)里做删除</li><li>但更好的做法是新开一个哈希表，遍历过的字符串放进哈希表里。</li><li>这种做法具有普遍意义。绝大多数在线测评系统和应用场景都不会在意空间开销。</li></ul></li></ul></li></ul><h2 id="方法一-：-广度优先遍历"><a href="#方法一-：-广度优先遍历" class="headerlink" title="方法一 ： 广度优先遍历"></a>方法一 ： 广度优先遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第 1 步：先将 wordList 放到哈希表里，便于判断某个单词是否在 wordList 里</span></span><br><span class="line">        Set&lt;String&gt; wordSet = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">        <span class="keyword">if</span> (wordSet.size() == <span class="number">0</span> || !wordSet.contains(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        wordSet.remove(beginWord);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二步 ： 图的广度优先遍历,必须使用队列和表示访问过的visited 访问过数据的哈希表</span></span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(beginWord);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        visited.add(beginWord);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三步： 开始进行广度优先遍历，包含起点，因此起点的初始化步数为1</span></span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curSize = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; curSize;i++)&#123;</span><br><span class="line">                <span class="comment">// 依次遍历当前队列中的单词</span></span><br><span class="line">                String currWord = queue.poll();</span><br><span class="line">                <span class="comment">// 如果currWord 能够修改依次字符便和 endWord 相同，那么立即返回step + 1即可</span></span><br><span class="line">                <span class="keyword">if</span>(changeWordEveryOneLetter(currWord,endWord,queue,visited,wordSet))&#123;</span><br><span class="line">                    <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找不到的话返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">changeWordEveryOneLetter</span><span class="params">(String currentWord, String endWord,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             Queue&lt;String&gt; queue, Set&lt;String&gt; visited, Set&lt;String&gt; wordSet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] charArray = currentWord.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; endWord.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 先保存，然后恢复</span></span><br><span class="line">            <span class="keyword">char</span> originChar = charArray[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> k = <span class="string">'a'</span>; k &lt;= <span class="string">'z'</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k == originChar) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                charArray[i] = k;</span><br><span class="line">                String nextWord = String.valueOf(charArray);</span><br><span class="line">                <span class="keyword">if</span> (wordSet.contains(nextWord)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nextWord.equals(endWord)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(nextWord)) &#123;</span><br><span class="line">                        queue.add(nextWord);</span><br><span class="line">                        <span class="comment">// 注意：添加到队列以后，必须马上标记为已经访问</span></span><br><span class="line">                        visited.add(nextWord);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 恢复</span></span><br><span class="line">            charArray[i] = originChar;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二：-双向广度优先遍历"><a href="#方法二：-双向广度优先遍历" class="headerlink" title="方法二： 双向广度优先遍历"></a>方法二： 双向广度优先遍历</h2><p><strong>参考题解 ：</strong> <a href="https://leetcode-cn.com/problems/word-ladder/solution/yan-du-you-xian-bian-li-shuang-xiang-yan-du-you-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-ladder/solution/yan-du-you-xian-bian-li-shuang-xiang-yan-du-you-2/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leecode-127-单词接龙&quot;&gt;&lt;a href=&quot;#Leecode-127-单词接龙&quot; class=&quot;headerlink&quot; title=&quot;Leecode-127-单词接龙&quot;&gt;&lt;/a&gt;Leecode-127-&lt;a href=&quot;https://leetcode-cn.com/problems/word-ladder/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;单词接龙&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：BFS-双向BFS&quot;&gt;&lt;a href=&quot;#思路：BFS-双向BFS&quot; class=&quot;headerlink&quot; title=&quot;思路：BFS/双向BFS&quot;&gt;&lt;/a&gt;思路：BFS/双向BFS&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;每次转换只能改变一个字母。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;转换过程中的中间单词必须是字典中的单词。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;说明:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果不存在这样的转换序列，返回 0。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;所有单词具有相同的长度。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;所有单词只由小写字母组成。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;字典中不存在重复的单词。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;你可以假设 beginWord 和 endWord 是非空的，且二者不相同。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;beginWord &amp;#x3D; &amp;quot;hit&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;endWord &amp;#x3D; &amp;quot;cog&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wordList &amp;#x3D; [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;,&amp;quot;cog&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 一个最短转换序列是 &amp;quot;hit&amp;quot; -&amp;gt; &amp;quot;hot&amp;quot; -&amp;gt; &amp;quot;dot&amp;quot; -&amp;gt; &amp;quot;dog&amp;quot; -&amp;gt; &amp;quot;cog&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     返回它的长度 5。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;beginWord &amp;#x3D; &amp;quot;hit&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;endWord &amp;#x3D; &amp;quot;cog&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wordList &amp;#x3D; [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: endWord &amp;quot;cog&amp;quot; 不在字典中，所以无法进行转换。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="双向BFS" scheme="http://zhuuu.work/tags/%E5%8F%8C%E5%90%91BFS/"/>
    
  </entry>
  
  <entry>
    <title>Netty-12-handler调用机制</title>
    <link href="http://zhuuu.work/2020/11/05/Netty/Netty-12-handler%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/"/>
    <id>http://zhuuu.work/2020/11/05/Netty/Netty-12-handler%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/</id>
    <published>2020-11-05T05:05:24.000Z</published>
    <updated>2021-05-16T03:16:51.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-12-handler调用机制"><a href="#Netty-12-handler调用机制" class="headerlink" title="Netty-12-handler调用机制"></a>Netty-12-handler调用机制</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>netty的组件设计：Netty的主要组件有<code>Channel、EventLoop、ChannelFuture、ChannelHandler、ChannelPipe</code>等</li><li>我们先来复习一下<code>ChannelHandler</code>和<code>ChannelPipeline</code>的关系。示例图如下：我们可以将<code>pipeline</code>理解为一个双向链表，<code>ChannelHandlerContext</code>看作链表中的一个节点，<code>ChannelHandler</code>则为每个节点中保存的一个属性对象。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/123220946.png" alt="mark"></p><a id="more"></a><ul><li><strong><code>ChannelHandler</code>充当了处理入站和出站数据的应用程序逻辑的容器。</strong><ul><li>例如，实现<code>ChannelInboundHandler</code>接口（或<code>ChannelInboundHandlerAdapter</code>），你就可以接收入站事件和数据，这些数据会被业务逻辑处理。</li><li>当<strong>要给客户端发送响应</strong>时，也可以从<code>ChannelInboundHandler</code>冲刷数据。业务逻辑通常写在一个或者多个<code>ChannelInboundHandler</code>中。</li></ul></li><li><strong><code>ChannelPipeline</code>提供了<code>ChannelHandler</code>链的容器。</strong><ul><li>如果事件的运动方向是从<strong>客户端到服务端的，那么我们称这些事件为出站的，即客户端发送给服务端的数据会通过<code>pipeline</code>中的一系列<code>ChannelOutboundHandler</code>,被这些<code>Handler</code>处理</strong></li><li>反之则称为入站的</li></ul></li></ul><p><strong>下面，来看看我们常用的<code>Handler</code>的关系图：<code>Inbound</code>处理入站，<code>Outbound</code>处理出站</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201106/160524576.png" alt="mark"></p><p>一般来说，在我们接收数据时将数据解码后，就进行业务的相关处理，所以上图的<strong>入站的常用类更多(服务端到客户端)</strong>。<strong>在数据出站时（客户端到服务端）</strong>，一般我们只需要将数据编码后直接发出。</p><h2 id="1-Handler-链式调用"><a href="#1-Handler-链式调用" class="headerlink" title="1. Handler 链式调用"></a>1. Handler 链式调用</h2><ul><li><p><code>Pipeline</code>中的<code>Handler</code>可以当作一个双向链表。</p></li><li><p>但是<code>Handler</code>却又存在着入站和出站之分。那么<code>Netty</code>是如何将两种类型的<code>Handler</code>保存在一个链表中，却又能够入站的时候调用<code>InboundHandler</code>，出栈的时候调用<code>OutBoundHandler</code>呢</p></li><li><p>看下图，黄色的表示入站，以及入站的<code>Handler</code>，绿色的表示出站，以及出站的<code>Handler</code>。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201106/162411613.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> LongToByteEncoder()); <span class="comment">//out</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> ByteToLongDecoder()); <span class="comment">//in</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> OutBoundHandler()); <span class="comment">//out</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> InBoundHandler()); <span class="comment">//in</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>请求处理流程</strong></p><ul><li>当一个请求来了的时候，首先会将请求发给<code>pipeline</code>中位于链表首部的<code>Handler</code>。</li><li>首先由队列第一个handler 进行处理，如果接受类型不匹配，那么跳过，直接转发给下一个handler 进行处理</li><li>如果需要返回数据，我们就调用<code>writeAndFlush</code>方法，这个方法可不简单，当他一被调用，就会触发出站请求，然后就由当前所在的<code>handler</code> 节点往回调用</li></ul><p><strong>通过上面的描述，我们可以总结添加<code>Handler</code>的以下节点总结：</strong></p><ul><li><strong>调用<code>InboundHandler</code>的顺序和添加的顺序是一致的。</strong></li><li><strong>调用<code>OutboundHandler</code>的顺序和添加它的顺序是相反的。</strong></li><li><strong>链表的末尾不能有 <code>OutHandler</code>，因为如果最后是 <code>OutHandler</code>的话，当他前面的 <code>Inhandler</code> 处理完数据返回消息调用<code>writeAndflush</code> 方法后，它就直接在前面进行反向调用了。那么就无法调用到这个 <code>OutHandler</code></strong></li><li><strong>所以，平常会把 <code>OutHandler</code>写在前面，<code>InHandler</code> 一般放在链表的末尾</strong></li><li><strong><code>InHandler</code> 一旦进行了 <code>writeAndFlush</code> ，那么只有这个<code>Inhandler</code> 之前添加的 <code>Outhandler</code> 才能正确的处理数据</strong></li></ul><h2 id="2-Handler-编解码器"><a href="#2-Handler-编解码器" class="headerlink" title="2. Handler 编解码器"></a>2. Handler 编解码器</h2><ul><li><p>当<code>Netty</code>发送或者接受一个消息的时候，就将会发生一次数据转换。入站消息会被解码：从字节转换为另一种格式（比如<code>java</code>对象）；如果是出站消息，它会被编码成字节。</p></li><li><p>Netty提供一系列<strong>实用的编解码器</strong>，他们都实现了<code>ChannelInboundHadnler</code>或者<code>ChannelOutboundHandler</code>接口。在这些类中，<code>channelRead</code>方法已经被重写了</p></li><li><p><strong>以入站为例</strong>，对于每个从入站<code>Channel</code>读取的消息，这个方法会被调用。随后，它将调用由解码器所提供的<code>decode()</code>方法进行解码，并将已经解码的字节转发给<code>ChannelPipeline</code>中的下一个<code>ChannelInboundHandler</code>。</p></li></ul><h3 id="2-1-解码器-ByteToMessageDecoder"><a href="#2-1-解码器-ByteToMessageDecoder" class="headerlink" title="2.1 解码器-ByteToMessageDecoder"></a>2.1 解码器-ByteToMessageDecoder</h3><ul><li>由于<strong>不可能知道远程节点是否会一次性发送一个完整的信息，tcp有可能出现粘包拆包的问题，这个类会对入站数据进行缓冲，直到它准备好被处理。</strong></li></ul><p><strong>下面是段示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToIntegerDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (in.readableBytes() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">            out.add(in.readInt());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个例子中</strong></p><ol><li>每次入站从<code>ByteBuf</code>中读取4字节，将其解码为一个<code>int</code>，</li><li>然后将它添加到下一个<code>List</code>中。当没有更多元素可以被添加到该<code>List</code>中时，它的内容将会被发送给下一个<code>ChannelInboundHandler</code>。</li><li><code>int</code>在被添加到<code>List</code>中时，会被自动装箱为<code>Integer</code>。</li></ol><p>在调用<code>readInt()</code>方法前必须验证所输入的<code>ByteBuf</code>是否具有足够的数据</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201106/163527996.png" alt="mark"></p><h3 id="2-2-解码器-ReplayingDecoder"><a href="#2-2-解码器-ReplayingDecoder" class="headerlink" title="2.2 解码器 - ReplayingDecoder"></a>2.2 <strong>解码器 - ReplayingDecoder</strong></h3><ul><li><code>public abstract class ReplayingDecoder&lt;S&gt; extends ByteToMessageDecoder{ }</code></li><li><code>ReplayingDecoder</code>扩展了<code>ByteToMessageDecoder</code>类，使用这个类，我们不必调用<code>readableBytes()</code>方法。参数S指定了用户状态管理的类型，<strong>其中Void代表不需要状态管理</strong></li><li>下面是代码示例：这段代码起到了上面<code>ByteToMessageDecoder</code>一样的作用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteToLongDecoder2</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.add(in.readLong());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>ReplayingDecoder</code>使用方便，但它也有一些局限性：<ul><li><strong>并不是所有的 <code>ByteBuf</code> 操作都被支持</strong>，如果调用了一个不被支持的方法，将会抛出一个 <code>UnsupportedOperationException</code>。</li><li><code>ReplayingDecoder</code> 在某些情况下可能稍慢于 <code>ByteToMessageDecoder</code>，例如网络缓慢并且消息格式复杂时，消息会被拆成了多个碎片，速度变慢</li></ul></li></ul><p><strong>其他的解码器</strong></p><ul><li><code>LineBasedFrameDecoder</code>：这个类在Netty内部也有使用，它使用行尾控制字符（\n或者\r\n）作为分隔符来解析数据。</li><li><code>DelimiterBasedFrameDecoder</code>：使用自定义的特殊字符作为消息的分隔符。</li><li><code>HttpObjectDecoder</code>：一个HTTP数据的解码器</li><li><code>LengthFieldBasedFrameDecoder</code>：通过指定长度来标识整包消息，这样就可以自动的处理黏包和半包消息。</li></ul><h2 id="3-简单实例"><a href="#3-简单实例" class="headerlink" title="3. 简单实例"></a>3. 简单实例</h2><p><strong>实例要求：</strong></p><ul><li>使用自定义的编码器和解码器来说明Netty的<code>handler</code> 调用机制</li><li>客户端发送<code>long</code> -&gt; 服务器</li><li>服务端发送<code>long</code>-&gt; 客户端</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201106/172833866.png" alt="mark"></p><p>注意 ：  这里只展示，<code>Handler</code>相应的代码和添加<code>Handler</code>的关键代码。</p><ol><li><strong>Decoder</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteToLongDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * decode 方法会根据接收到的数据，被调用多次，知道确定没有新的元素被添加到list，或者是ByteBuf 没有更多的可读字节为止</span></span><br><span class="line"><span class="comment">     * 如果 list out不为空，就会将list的内容传递给下一个 Handler 进行处理，该处理器的方法也会被调用多次。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 入栈的 ByteBuf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out list集合，将解码后的数据传给下一个Handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//因为long为8个字节，所以需要8个字节才能读取成一个long类型的数据</span></span><br><span class="line">        System.out.println(<span class="string">"ByteToLongDecoder：入栈数据被解码"</span>);</span><br><span class="line">        <span class="keyword">if</span> (in.readableBytes() &gt;= <span class="number">8</span>)&#123;</span><br><span class="line">            out.add(in.readLong());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>Encoder</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongToByteEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Long msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"LongToByteEncoder: 出栈数据，msg = "</span> + msg);</span><br><span class="line">        out.writeLong(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>服务器端添加Handler</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> LongToByteEncoder()); <span class="comment">//编码器，出站</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> ByteToLongDecoder()); <span class="comment">//解码器，入站</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> ServerInBoundHandler()); <span class="comment">//业务处理，入站</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>客户端添加Handler</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> LongToByteEncoder()); <span class="comment">//编码器，出站</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> ByteToLongDecoder()); <span class="comment">//解码器，入站</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> ClientInBoundHandler()); <span class="comment">//业务处理，入站。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>这里当客户端和服务端接收消息的时候<ul><li>首先会调用入站的解码器，然后进行业务的处理</li><li>然后在调用出站的解码解码器再返回消息</li></ul></li><li>后面可以在业务处理类中，增加发送消息的代码，此处省略。</li></ul><h2 id="4-Netty整合-log4j"><a href="#4-Netty整合-log4j" class="headerlink" title="4. Netty整合 log4j"></a>4. Netty整合 log4j</h2><ol><li><strong>添加依赖</strong></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.7.25&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.7.25&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.7.25&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>添加配置文件</strong></li></ol><p>在<code>resource</code>目录下新建<code>log4j.properties</code>即可</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">log5j.rootLogger</span>=<span class="string">DEBUG, stdout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">[%p] %C&#123;1&#125; - %m%n</span></span><br></pre></td></tr></table></figure><blockquote><p> 本文档整理自 尚硅谷韩顺平Netty 相关课程。</p></blockquote><p><strong>参考博客 ：</strong> <a href="https://dongzl.github.io/netty-handbook/#/README" target="_blank" rel="noopener">https://dongzl.github.io/netty-handbook/#/README</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-12-handler调用机制&quot;&gt;&lt;a href=&quot;#Netty-12-handler调用机制&quot; class=&quot;headerlink&quot; title=&quot;Netty-12-handler调用机制&quot;&gt;&lt;/a&gt;Netty-12-handler调用机制&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;netty的组件设计：Netty的主要组件有&lt;code&gt;Channel、EventLoop、ChannelFuture、ChannelHandler、ChannelPipe&lt;/code&gt;等&lt;/li&gt;
&lt;li&gt;我们先来复习一下&lt;code&gt;ChannelHandler&lt;/code&gt;和&lt;code&gt;ChannelPipeline&lt;/code&gt;的关系。示例图如下：我们可以将&lt;code&gt;pipeline&lt;/code&gt;理解为一个双向链表，&lt;code&gt;ChannelHandlerContext&lt;/code&gt;看作链表中的一个节点，&lt;code&gt;ChannelHandler&lt;/code&gt;则为每个节点中保存的一个属性对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/123220946.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="handler" scheme="http://zhuuu.work/tags/handler/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-057-插入区间</title>
    <link href="http://zhuuu.work/2020/11/04/Leetcode/Leetcode-057-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/"/>
    <id>http://zhuuu.work/2020/11/04/Leetcode/Leetcode-057-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/</id>
    <published>2020-11-04T03:52:53.000Z</published>
    <updated>2020-11-04T06:06:05.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-057-插入区间"><a href="#Leetcode-057-插入区间" class="headerlink" title="Leetcode-057-插入区间"></a>Leetcode-057-<a href="https://leetcode-cn.com/problems/insert-interval/" target="_blank" rel="noopener">插入区间</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个<em>无重叠的 ，</em>按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：intervals &#x3D; [[1,3],[6,9]], newInterval &#x3D; [2,5]</span><br><span class="line">输出：[[1,5],[6,9]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：intervals &#x3D; [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval &#x3D; [4,8]</span><br><span class="line">输出：[[1,2],[3,10],[12,16]]</span><br><span class="line">解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-：模拟"><a href="#思路-：模拟" class="headerlink" title="思路 ：模拟"></a><strong>思路 ：模拟</strong></h2><ol><li><strong>是否有交集的探讨</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201104/135246852.png" alt="mark"></p><ol start="2"><li><strong>思路与算法</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201104/135519588.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201104/135533962.png" alt="mark"></p><ul><li><p>这样做的正确性在于，给定的区间<strong>集合中任意两个区间都是没有交集</strong>的，因此所有需要合并的区间，就是所有与区间 S 重叠的区间。</p></li><li><p>并且，在给定的区间集合已经按照左端点排序的前提下，所有与区间 S 重叠的区间在数组 <strong>intervals</strong> 中下标范围是连续的，因此我们<strong>可以对所有的区间进行一次遍历</strong>，就可以找到这个连续的下标范围。</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201104/135816063.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = newInterval[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> right = newInterval[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">boolean</span> placed = <span class="keyword">false</span>; <span class="comment">// 保证新插入的集合只被插入一次</span></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; ansList = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">0</span>] &gt; right) &#123;</span><br><span class="line">                <span class="comment">// 在插入区间的右侧且无交集</span></span><br><span class="line">                <span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">                    ansList.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left, right&#125;);</span><br><span class="line">                    placed = <span class="keyword">true</span>;                    </span><br><span class="line">                &#125;</span><br><span class="line">                ansList.add(interval);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interval[<span class="number">1</span>] &lt; left) &#123;</span><br><span class="line">                <span class="comment">// 在插入区间的左侧且无交集</span></span><br><span class="line">                ansList.add(interval);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 与插入区间有交集，计算它们的并集（扩大区间）</span></span><br><span class="line">                left = Math.min(left, interval[<span class="number">0</span>]);</span><br><span class="line">                right = Math.max(right, interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果走完发现 ： 新插入的集合还未加入到结果集中</span></span><br><span class="line">        <span class="comment">// 说明新插入的集合在 所有区间的最后</span></span><br><span class="line">        <span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">            ansList.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left, right&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将ArrayList转化成 int[ansList.size()][2]</span></span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[ansList.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ansList.size(); ++i) &#123;</span><br><span class="line">            ans[i] = ansList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)，其中 n 是数组 intervals 的长度，即给定的区间个数。</li><li>空间复杂度:   O(1) 除了存储返回答案的空间以外，我们只需要额外的常数空间即可。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-057-插入区间&quot;&gt;&lt;a href=&quot;#Leetcode-057-插入区间&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-057-插入区间&quot;&gt;&lt;/a&gt;Leetcode-057-&lt;a href=&quot;https://leetcode-cn.com/problems/insert-interval/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;插入区间&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给出一个&lt;em&gt;无重叠的 ，&lt;/em&gt;按照区间起始端点排序的区间列表。&lt;/p&gt;
&lt;p&gt;在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：intervals &amp;#x3D; [[1,3],[6,9]], newInterval &amp;#x3D; [2,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[[1,5],[6,9]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：intervals &amp;#x3D; [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval &amp;#x3D; [4,8]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[[1,2],[3,10],[12,16]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-24-IO核心子系统</title>
    <link href="http://zhuuu.work/2020/11/03/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-24-IO%E6%A0%B8%E5%BF%83%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <id>http://zhuuu.work/2020/11/03/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-24-IO%E6%A0%B8%E5%BF%83%E5%AD%90%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-11-03T03:00:53.000Z</published>
    <updated>2021-05-16T03:37:14.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-24-IO核心子系统"><a href="#操作系统-24-IO核心子系统" class="headerlink" title="操作系统-24-IO核心子系统"></a>操作系统-24-IO核心子系统</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/111350794.png" alt="mark"></p><p><strong>IO 核心子系统</strong></p><ul><li>设备独立性软件</li><li>设备驱动程序</li><li>中断处理程序</li></ul><h2 id="1-假脱机技术-SPOOLing"><a href="#1-假脱机技术-SPOOLing" class="headerlink" title="1. 假脱机技术(SPOOLing)"></a>1. 假脱机技术(SPOOLing)</h2><ul><li>在<strong>用户层软件</strong>实现，但是408大纲将其归入I/O核心子系统</li></ul><h3 id="1-1-什么是脱机技术？"><a href="#1-1-什么是脱机技术？" class="headerlink" title="1.1 什么是脱机技术？"></a>1.1 什么是脱机技术？</h3><p><strong>这里温习一下手工操作阶段：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/111631459.png" alt="mark"></p><p>因为手工阶段的速度慢问题，引入了脱机技术</p><a id="more"></a><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/111700059.png" alt="mark"></p><h3 id="1-2-假脱机技术"><a href="#1-2-假脱机技术" class="headerlink" title="1.2 假脱机技术"></a>1.2 假脱机技术</h3><ul><li>在脱机技术的基础上人们发明了更好的假脱机技术</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/111730874.png" alt="mark"></p><p><strong>输入井和输出井</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/111923725.png" alt="mark"></p><p><strong>输入进程和输出进程</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/111948908.png" alt="mark"></p><p><strong>输入和输出缓冲区</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112015684.png" alt="mark"></p><h3 id="1-3-共享打印机"><a href="#1-3-共享打印机" class="headerlink" title="1.3 共享打印机"></a>1.3 共享打印机</h3><p><strong>先了解一下独占和共享设备，以此引出假脱机技术如何实现对独占设备的共享：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112058454.png" alt="mark"></p><ul><li><strong>共享打印机原理</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112156732.png" alt="mark"></p><p>打印请求完成后，请求表从打印队列删除，执行后续队列的打印任务</p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112316764.png" alt="mark"></p><h2 id="2-IO-设备的分配和回收"><a href="#2-IO-设备的分配和回收" class="headerlink" title="2. IO 设备的分配和回收"></a>2. IO 设备的分配和回收</h2><p><strong>设备分配时应该考虑的因素</strong></p><ul><li><strong>设备的固有属性</strong><br>独占设备、共享设备、虚拟设备(SPOOLing技术将独占设备改造成虚拟的共享设备)</li><li><strong>设备分配算法</strong><br>先来先服务、优先级高者优先、短任务优先等等</li><li><strong>设备分配的安全性</strong><br><strong>安全分配方式</strong>：串行使用设备，为进程分配一个设备后将进程阻塞，I/O完成再唤醒。不会产生死锁<br><strong>不安全分配方式</strong>：进程请求I/O，操作系统负责分配设备，进程可以继续执行或者请求新的I/O，直到某个I/O无法满足才阻塞进程。可能产生死锁</li></ul><p><strong>静态分配和动态分配</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112601713.png" alt="mark"></p><h3 id="2-1-设备分配数据结构"><a href="#2-1-设备分配数据结构" class="headerlink" title="2.1 设备分配数据结构"></a>2.1 设备分配数据结构</h3><p><strong>设备、控制器、通道之间的关系：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112633304.png" alt="mark"></p><p><strong>设备控制表-DCT</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112655363.png" alt="mark"></p><p><strong>控制器控制表-COCT</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112713381.png" alt="mark"></p><p><strong>通道控制表-CHCT</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112740089.png" alt="mark"></p><p><strong>系统设备表-SDT</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112751658.png" alt="mark"></p><h3 id="2-2-设备分配的步骤"><a href="#2-2-设备分配的步骤" class="headerlink" title="2.2 设备分配的步骤"></a>2.2 设备分配的步骤</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112815959.png" alt="mark"></p><h3 id="2-3-设备分配改进步骤"><a href="#2-3-设备分配改进步骤" class="headerlink" title="2.3 设备分配改进步骤"></a>2.3 设备分配改进步骤</h3><ul><li><strong>缺点</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112905248.png" alt="mark"></p><ul><li><strong>改进方法 ： 逻辑设备名</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/112948310.png" alt="mark"></p><ul><li><strong>逻辑设备表</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113006948.png" alt="mark"></p><h2 id="3-缓冲区管理"><a href="#3-缓冲区管理" class="headerlink" title="3. 缓冲区管理"></a>3. 缓冲区管理</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113120359.png" alt="mark"></p><h3 id="3-1-缓冲区的作用"><a href="#3-1-缓冲区的作用" class="headerlink" title="3.1 缓冲区的作用"></a>3.1 缓冲区的作用</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113306353.png" alt="mark"></p><h3 id="3-2-单缓冲"><a href="#3-2-单缓冲" class="headerlink" title="3.2 单缓冲"></a><strong>3.2 单缓冲</strong></h3><p><strong>单缓冲的原则</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113336039.png" alt="mark"></p><ol><li><strong>T &gt; C</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113423300.png" alt="mark"></p><ol start="2"><li><strong>T &lt; C</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113434600.png" alt="mark"></p><h3 id="3-3-双缓冲"><a href="#3-3-双缓冲" class="headerlink" title="3.3 双缓冲"></a>3.3 双缓冲</h3><ol><li><strong>T  &gt; C+ M</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113506440.png" alt="mark"></p><ol start="2"><li><strong>T &lt; C + M</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113540130.png" alt="mark"></p><h3 id="3-4-循环缓冲"><a href="#3-4-循环缓冲" class="headerlink" title="3.4 循环缓冲"></a>3.4 循环缓冲</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113606985.png" alt="mark"></p><h3 id="3-5-缓冲池"><a href="#3-5-缓冲池" class="headerlink" title="3.5 缓冲池"></a>3.5 缓冲池</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/113853966.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考笔记 ：</strong> <a href="https://blog.csdn.net/weixin_43914604/article/details/104415990" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43914604/article/details/104415990</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-24-IO核心子系统&quot;&gt;&lt;a href=&quot;#操作系统-24-IO核心子系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统-24-IO核心子系统&quot;&gt;&lt;/a&gt;操作系统-24-IO核心子系统&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/111350794.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IO 核心子系统&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设备独立性软件&lt;/li&gt;
&lt;li&gt;设备驱动程序&lt;/li&gt;
&lt;li&gt;中断处理程序&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-假脱机技术-SPOOLing&quot;&gt;&lt;a href=&quot;#1-假脱机技术-SPOOLing&quot; class=&quot;headerlink&quot; title=&quot;1. 假脱机技术(SPOOLing)&quot;&gt;&lt;/a&gt;1. 假脱机技术(SPOOLing)&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在&lt;strong&gt;用户层软件&lt;/strong&gt;实现，但是408大纲将其归入I/O核心子系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-1-什么是脱机技术？&quot;&gt;&lt;a href=&quot;#1-1-什么是脱机技术？&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是脱机技术？&quot;&gt;&lt;/a&gt;1.1 什么是脱机技术？&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;这里温习一下手工操作阶段：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/111631459.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;因为手工阶段的速度慢问题，引入了脱机技术&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-941-有效的山脉数组</title>
    <link href="http://zhuuu.work/2020/11/03/Leetcode/Leetcode-941-%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84/"/>
    <id>http://zhuuu.work/2020/11/03/Leetcode/Leetcode-941-%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84/</id>
    <published>2020-11-02T23:52:53.000Z</published>
    <updated>2020-11-03T00:50:59.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-941-有效的山脉数组"><a href="#Leetcode-941-有效的山脉数组" class="headerlink" title="Leetcode-941-有效的山脉数组"></a>Leetcode-941-<a href="https://leetcode-cn.com/problems/valid-mountain-array/" target="_blank" rel="noopener">有效的山脉数组</a></h1><h2 id="思路：线性扫描"><a href="#思路：线性扫描" class="headerlink" title="思路：线性扫描"></a>思路：线性扫描</h2><p><strong>题目描述</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。</span><br><span class="line"></span><br><span class="line">让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：</span><br><span class="line"></span><br><span class="line">A.length &gt;&#x3D; 3</span><br><span class="line">在 0 &lt; i &lt; A.length - 1 条件下，存在 i 使得：</span><br><span class="line">A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</span><br><span class="line">A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201103/084745146.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：[2,1]</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：[3,5,5]</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：[0,3,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>思路：线性扫描</strong></p><ul><li>按照题目模拟即可，我们从数组最左侧开始向右扫描</li><li>直到找到第一个不满足<em>A</em>[<em>i</em>]&lt;<em>A</em>[<em>i</em>+1]  的下标 i ,那么 i 就是这个数组的最高点下标</li><li>如果 i = 0 或者不存在这样的 i (即整个数组单调递增)，那么就返回false</li><li>否则 从 i 开始继续向右扫描，判断接下来的下标 j 是否都满足 <em>A</em>[<em>j</em>]&gt;<em>A</em>[<em>j</em>+1] ，若都满足返回true ,不满足返回false.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validMountainArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查最高点左半部分</span></span><br><span class="line">        <span class="keyword">while</span>(i + <span class="number">1</span> &lt; n &amp;&amp; A[i] &lt; A[i + <span class="number">1</span>])&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最高点不能是数组的第一个位置或者最后一个位置</span></span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> || i == n - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查最高点后半部分</span></span><br><span class="line">        <span class="keyword">while</span>(i + <span class="number">1</span> &lt; n &amp;&amp; A[i] &gt; A[i + <span class="number">1</span>])&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否正确走到了数组最后</span></span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span> == i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n) 扫描一遍数组所需要的时间</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-941-有效的山脉数组&quot;&gt;&lt;a href=&quot;#Leetcode-941-有效的山脉数组&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-941-有效的山脉数组&quot;&gt;&lt;/a&gt;Leetcode-941-&lt;a href=&quot;https://leetcode-cn.com/problems/valid-mountain-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;有效的山脉数组&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：线性扫描&quot;&gt;&lt;a href=&quot;#思路：线性扫描&quot; class=&quot;headerlink&quot; title=&quot;思路：线性扫描&quot;&gt;&lt;/a&gt;思路：线性扫描&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A.length &amp;gt;&amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在 0 &amp;lt; i &amp;lt; A.length - 1 条件下，存在 i 使得：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A[0] &amp;lt; A[1] &amp;lt; ... A[i-1] &amp;lt; A[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A[i] &amp;gt; A[i+1] &amp;gt; ... &amp;gt; A[A.length - 1]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201103/084745146.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[2,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[3,5,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：[0,3,2,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Netty-10-WebSocket</title>
    <link href="http://zhuuu.work/2020/11/02/Netty/Netty-10-WebSocket/"/>
    <id>http://zhuuu.work/2020/11/02/Netty/Netty-10-WebSocket/</id>
    <published>2020-11-02T05:05:24.000Z</published>
    <updated>2021-05-16T03:16:41.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-10-WebSocket"><a href="#Netty-10-WebSocket" class="headerlink" title="Netty-10-WebSocket"></a>Netty-10-WebSocket</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>实例要求</strong></p><ul><li>Http 协议是无状态的，浏览器和服务器之间的请求只响应一次，下一次会重新创建连接</li><li>要求  ： 实现基于webSocket 的长连接全双工的交互</li><li>改变Http 协议多次请求的约束，实现长连接，服务器可以发送消息给浏览器</li><li>客户端浏览器和服务器端会相互感知，比如服务器关闭了，浏览器会感知，同样浏览器关闭了，服务器会感知</li></ul><a id="more"></a><h2 id="1-启动器代码"><a href="#1-启动器代码" class="headerlink" title="1. 启动器代码"></a>1. 启动器代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">    NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">            .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">handler</span>(<span class="title">new</span> <span class="title">LoggingHandler</span>(<span class="title">LogLevel</span>.<span class="title">INFO</span>))</span></span><br><span class="line"><span class="class">            .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                    <span class="comment">//因为是基于Http协议，所以要使用Http的编码和解码器</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">                    <span class="comment">//是以块方式写，添加ChunkedWriter处理器</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ChunkedWriteHandler());</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    * 1、http数据在传输过程中是分裂的,HttpObjectAggregator就可以将多个段聚合</span></span><br><span class="line"><span class="comment">                    * 2、这就是为什么，当浏览器发送大量数据时，就会发出多次http请求</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">8192</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    * 1、对于websocket，它的数据是以帧的形式传递的</span></span><br><span class="line"><span class="comment">                    * 2、可以看到 WebsocketFrame 下面有六个子类</span></span><br><span class="line"><span class="comment">                    * 3、浏览器请求时：ws://localhost:7000/hello 表示请求的uri</span></span><br><span class="line"><span class="comment">                    * 4、WebSocketServerProtocolHandler 核心功能是将 http 协议升级为 ws 协议，保持长连接</span></span><br><span class="line"><span class="comment">                    * 5、从Http协议升级到Websocket协议，是通过StatusCode 101（Switching Protocols）来切换的。</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> WebSocketServerProtocolHandler(<span class="string">"/hello"</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//自定义Handler，处理业务逻辑</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> MyTextWebSocketFrameHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        ChannelFuture sync = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">        sync.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        bossGroup.shutdownGracefully();</span><br><span class="line">        workerGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-案例总结"><a href="#2-案例总结" class="headerlink" title="2 . 案例总结"></a>2 . 案例总结</h2><ol><li><strong>创建启动类</strong></li></ol><ul><li>首先初始化两个NioEventLoopGroup。其中BossGroup一般设置线程为1</li><li>初始化一个ServerBootStrap类。并调用它设置很多参数。<ul><li><code>group()</code>：服务端设置两个Group，客户端设置一个Group</li><li><code>channel()</code>：服务端传入<code>NioServerSocketChannel</code>，客户端传入<code>NioSocketChannel</code></li><li><code>option()</code>：服务端给BossGroup设置<code>SO_BACKLOG</code>任务队列大小</li><li><code>childOption()</code>：服务端给WorkerGroup设置连接<code>SO_KEEPALIVE</code>保持连接状态</li><li><code>handler()</code>：服务端给BossGroup设置Handler，客户端设置Handler</li><li><code>childHandler()</code>：服务端给WorkerGroup设置Handler。</li></ul></li><li>通过BootStrap去绑定端口，监听关闭事件。设置为异步拿到ChannelFuture对象</li></ul><ol start="2"><li><strong>Handler 处理逻辑</strong></li></ol><ul><li><code>SimpleChannelInboundHandler</code><ul><li>可以继承它来处理很多通信。经过上面几个案例推敲，一般写自己的Handler继承它就可以了</li></ul></li><li><code>ChannelInboundHandlerAdapter</code><ul><li>这个是上一个的父类，我们在心跳检测的时候通过继承它的<code>userEventTriggered</code>去判断连接状态</li><li>其实通过上面那个<code>simple</code>也可以继承这个<code>trigger</code></li></ul></li><li><code>IdleStateHandler</code><ul><li>在心跳检测时我们要通过这个Handler去触发上面的<code>trigger</code></li></ul></li><li><code>HttpServerCodec</code><ul><li>提供好的用于Http编码解码，一般用于Http请求</li></ul></li><li><code>ChunkedWriteHandler</code><ul><li>提供好的Handler，以块方式写，添加ChunkedWriter处理器</li><li>我搜了一下，它一般用于发送大文件。这个东西使我们在Websocket的时候用的。</li></ul></li><li><code>HttpObjectAggregator</code><ul><li>它会将http数据聚合在一起发送</li></ul></li><li><code>WebSocketServerProtocolHandler</code><ul><li>传入ws路径，将Http协议升级成为ws协议</li></ul></li></ul><ol start="3"><li><strong>netty 中通信数据实体</strong></li></ol><ul><li><code>TextWebSocketFrame</code><ul><li>这是我们在websocket连接的时候用的，它表示一个文本帧，是websocket进行通信的数据形式</li></ul></li><li><code>HttpObject</code><ul><li>这是我们在建立Http连接的时候用到的，可以将它转换成一个<code>HttpRequest</code></li></ul></li></ul><ol start="4"><li><strong>Handler 常用方法</strong></li></ol><table><thead><tr><th>方法名</th><th>介绍</th></tr></thead><tbody><tr><td><code>channelRead0(ChannelHandlerContext channelHandlerContext, T t)</code></td><td>读取数据，并进行消息转发</td></tr><tr><td><code>handlerAdded(ChannelHandlerContext ctx)</code></td><td>连接建立，一旦建立连接，就第一个被执行</td></tr><tr><td><code>channelActive(ChannelHandlerContext ctx)</code></td><td>表示 channel 处于活动状态，提示 xxx 上线</td></tr><tr><td><code>channelInactive(ChannelHandlerContext ctx)</code></td><td>表示 channel 处于不活动状态，提示 xxx 离线</td></tr><tr><td><code>handlerRemoved(ChannelHandlerContext ctx)</code></td><td>表示 channel 断开连接，将xx客户离开信息推送给当前在线客户</td></tr><tr><td><code>exceptionCaught(ChannelHandlerContext ctx, Throwable cause)</code></td><td>出现错误如何进行处理</td></tr><tr><td><code>userEventTriggered(ChannelHandlerContext ctx, Object evt)</code></td><td>事件触发器，通过判断evt的类型去判断发生了什么事件，再通过里面的属性判断事件发生的类型。我们在<code>IdleStateHandler</code>后面加上一个触发器，可以检测心跳。</td></tr></tbody></table><blockquote><p> 本文档整理自 尚硅谷韩顺平Netty 相关课程。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-10-WebSocket&quot;&gt;&lt;a href=&quot;#Netty-10-WebSocket&quot; class=&quot;headerlink&quot; title=&quot;Netty-10-WebSocket&quot;&gt;&lt;/a&gt;Netty-10-WebSocket&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;实例要求&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Http 协议是无状态的，浏览器和服务器之间的请求只响应一次，下一次会重新创建连接&lt;/li&gt;
&lt;li&gt;要求  ： 实现基于webSocket 的长连接全双工的交互&lt;/li&gt;
&lt;li&gt;改变Http 协议多次请求的约束，实现长连接，服务器可以发送消息给浏览器&lt;/li&gt;
&lt;li&gt;客户端浏览器和服务器端会相互感知，比如服务器关闭了，浏览器会感知，同样浏览器关闭了，服务器会感知&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
      <category term="WebSocket" scheme="http://zhuuu.work/tags/WebSocket/"/>
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="NIO" scheme="http://zhuuu.work/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Netty-11-ProtoBuf</title>
    <link href="http://zhuuu.work/2020/11/02/Netty/Netty-11-ProtoBuf/"/>
    <id>http://zhuuu.work/2020/11/02/Netty/Netty-11-ProtoBuf/</id>
    <published>2020-11-02T05:05:24.000Z</published>
    <updated>2021-05-16T03:16:46.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-11-ProtoBuf"><a href="#Netty-11-ProtoBuf" class="headerlink" title="Netty-11-ProtoBuf"></a>Netty-11-ProtoBuf</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>编写网络应用程序时，因为<strong>数据在网络中传输的都是二进制字节码数据</strong>，在发送数据的时候就需要编码，接收数据时候就需要解码</li><li><strong>codec(编解码器)的组成部分有两个</strong><ul><li><code>decoder</code>(解码器) ： 负责把字节码数据转换成业务逻辑</li><li><code>encoder</code>(编码器) ： 负责把业务数据转换成字节码数据</li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201104/084813142.png" alt="mark"></p><a id="more"></a><h2 id="1-Netty-提供的编解码机制"><a href="#1-Netty-提供的编解码机制" class="headerlink" title="1. Netty 提供的编解码机制"></a>1. Netty 提供的编解码机制</h2><ul><li>Netty 本身的编解码器的机制和问题分析（为什么要引入<code>protobuf</code> ?）</li><li><code>Netty</code> 自身提供了一些 <code>codec</code>(编解码器)<ul><li><code>Netty</code> 提供的编码器 <code>StringEncoder</code>，对字符串数据进行编码 <code>ObjectEncoder</code>，对Java对象进行编码…</li><li><code>Netty</code> 提供的解码器 <code>StringDecoder</code>,对字符串数据进行解码 <code>ObjectDecoder</code>，对 <code>Java</code> 对象进行解码…</li></ul></li><li><strong><code>Netty</code> 本身自带的 <code>ObjectDecoder</code> 和 <code>ObjectEncoder</code> 可以用来实现 <code>POJO</code> 对象或各种业务对象的编码和解码，底层使用的仍是Java序列化技术,而Java序列化技术本身效率就不高，</strong>存在如下问题<ul><li>无法跨语言</li><li>序列化后的体积太大，是二进制编码的5倍多</li><li>序列化性能太低</li></ul></li></ul><p><strong>于是引出了新的解决方案（Google Protobuf）</strong></p><h2 id="2-ProtoBuf-简介"><a href="#2-ProtoBuf-简介" class="headerlink" title="2. ProtoBuf 简介"></a>2. ProtoBuf 简介</h2><p><strong>1. Google ProtoBuf 参考文档</strong>：</p><ul><li><a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/proto</a> <strong>语言指南</strong></li></ul><p><strong>2. 简介概述</strong></p><ul><li>首先，<strong>ProtoBuf 是用来将对象进行序列化的</strong>，相类似的技术还有<code>Json</code> 序列化等等，它是一种高效的结构化数据存储格式，</li><li>可以用于结构化数据串行化（序列化）。它很适合做数据存储或者<strong>RPC(远程工程调用)数据交换格式</strong> （目前很多公司 <code>http + json || tcp + protobuf</code>）</li><li><strong>ProtoBuf 是以 message的方式来管理数据的</strong></li></ul><p><strong>3. 优点：</strong></p><ul><li><strong>支持跨平台跨语言</strong> 【即客户端可以使用不同的语言编写】<ul><li>支持目前绝大多数语言，例如 C++、C#、Java、python 等</li></ul></li><li><strong>使用 protobuf 编译器能自动生成代码</strong></li><li><code>protobuf</code> 是将 类的定义使用<code>.proto</code> 文件进行描述<ul><li>说明，在<code>idea</code> 中编写 <code>.proto</code> 文件时，会自动提示是否下载 <code>.proto</code> 编写插件，可以让语法高亮</li><li><strong>然后通过 <code>proto.exe</code> 编译器根据 <code>.proto</code> 自动的生成java 文件</strong></li></ul></li></ul><p><strong>使用示意图 ：</strong> </p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201104/085943886.png" alt="mark"></p><h2 id="3-Proto-文件格式"><a href="#3-Proto-文件格式" class="headerlink" title="3. Proto 文件格式"></a>3. Proto 文件格式</h2><ul><li><strong>首先我们需要在<code>.proto</code>文件中定义好实体及他们的属性，再进行编译成<code>java</code>对象为我们所用。下面将介绍<code>proto</code>文件的写法。</strong></li></ul><ol><li><strong>文件头</strong></li></ol><ul><li>像写<code>java</code>需要写<code>package</code>包名一样，<code>.proto</code>文件也要写一些文件的全局属性，主要用于将<code>.proto</code>文件编译成<code>Java</code>文件。</li></ul><table><thead><tr><th><code>实例</code></th><th><code>介绍</code></th></tr></thead><tbody><tr><td><code>syntax=&quot;proto3&quot;;</code></td><td>声明使用到的protobuf的版本</td></tr><tr><td><code>optimize_for=SPEED;</code></td><td>表示</td></tr><tr><td><code>java_package=&quot;com.mical.netty.pojo&quot;;</code></td><td>表示生成Java对象所在包名</td></tr><tr><td><code>java_outer_classname=&quot;MyWorker&quot;;</code></td><td>表示生成的Java对象的外部类名</td></tr></tbody></table><ul><li>我们一般将这些代码写在<code>proto</code>文件的开头，以表明生成<code>Java</code>对象的相关文件属性。</li></ul><ol start="2"><li><strong>定义类和属性</strong></li></ol><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>; <span class="comment">//版本</span></span><br><span class="line"><span class="keyword">option</span> optimize_for = SPEED; <span class="comment">//加快解析</span></span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">"MyDataInfo"</span>; <span class="comment">//生成的外部类名，同时也是文件名</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Student</span> </span>&#123; <span class="comment">//会在StudentPojo 外部类生成一个内部类Student，他是真正发送的pojo对象</span></span><br><span class="line">    <span class="built_in">int32</span> id = <span class="number">1</span>; <span class="comment">//Student类中有一个属性名字为ID，类型为int32（protobuf类型），1表示序号，不是值</span></span><br><span class="line">    <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DateType</span> </span>&#123;</span><br><span class="line">    StudentType = <span class="number">0</span>; <span class="comment">//在proto3中，要求enum的编号从0开始</span></span><br><span class="line">    WorkerType = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如上图所示，我们在文件中不但声明了<code>protobuf</code>的版本，还声明了生成java对象的类名。当生成java对象后，<code>MyDataInfo</code>将是对象的类名，同时，它使用<code>message</code>声明了<code>Student</code>这个内部类，使用<code>enum</code>声明了<code>DataType</code>这个内部枚举类。就像下面这个样子</p></li><li><p><code>messag</code>：声明类。</p></li><li><p><code>enum</code>：声明枚举类。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDataInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> DataType &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后需要注意的是，protobuf中的变量类型和其他语言的声明有所不同。下面是<strong>类型的对照表</strong>。</p><table><thead><tr><th>.proto类型</th><th>java类型</th><th>C++类型</th><th>备注</th></tr></thead><tbody><tr><td><strong>double</strong></td><td><strong>double</strong></td><td><strong>double</strong></td><td></td></tr><tr><td><strong>float</strong></td><td><strong>float</strong></td><td><strong>float</strong></td><td></td></tr><tr><td><strong>int32</strong></td><td><strong>int</strong></td><td><strong>int32</strong></td><td><strong>使用可变长编码方式。编码负数时不够高效——如果你的字段可能含有负数，那么请使用sint32。</strong></td></tr><tr><td><strong>int64</strong></td><td><strong>long</strong></td><td><strong>int64</strong></td><td><strong>使用可变长编码方式。编码负数时不够高效——如果你的字段可能含有负数，那么请使用sint64。</strong></td></tr><tr><td>unit32</td><td>int[1]</td><td>unit32</td><td>总是4个字节。如果数值总是比总是比228大的话，这个类型会比uint32高效。</td></tr><tr><td>unit64</td><td>long[1]</td><td>unit64</td><td>总是8个字节。如果数值总是比总是比256大的话，这个类型会比uint64高效。</td></tr><tr><td>sint32</td><td>int</td><td>int32</td><td>使用可变长编码方式。有符号的整型值。编码时比通常的int32高效。</td></tr><tr><td>sint64</td><td>long</td><td>int64</td><td>使用可变长编码方式。有符号的整型值。编码时比通常的int64高效。</td></tr><tr><td>fixed32</td><td>int[1]</td><td>unit32</td><td></td></tr><tr><td>fixed64</td><td>long[1]</td><td>unit64</td><td>总是8个字节。如果数值总是比总是比256大的话，这个类型会比uint64高效。</td></tr><tr><td>sfixed32</td><td>int</td><td>int32</td><td>总是4个字节。</td></tr><tr><td>sfixed64</td><td>long</td><td>int64</td><td>总是8个字节。</td></tr><tr><td><strong>bool</strong></td><td><strong>boolean</strong></td><td><strong>bool</strong></td><td></td></tr><tr><td><strong>string</strong></td><td><strong>String</strong></td><td><strong>string</strong></td><td><strong>一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本。</strong></td></tr><tr><td>bytes</td><td>ByteString</td><td>string</td><td>可能包含任意顺序的字节数据</td></tr></tbody></table><ul><li>类型关注之后,我们看到代码中<code>string name = 2</code>，它并不是给name这个变量赋值，而是给它标号。每个类都需要给其中的变量标号，且需要注意的是类的标号是从1开始的，枚举的标号是从0开始的。</li></ul><ol start="3"><li><strong>复杂对象</strong></li></ol><ul><li>当我们<strong>需要统一发送对象和接受对象时，就需要使用一个对象将其他所有对象进行包装</strong>，再获取里面的某一类对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>; <span class="comment">//版本</span></span><br><span class="line">option optimize_for = SPEED; <span class="comment">//加快解析</span></span><br><span class="line">option java_outer_classname = <span class="string">"MyDataInfo"</span>; <span class="comment">//生成的外部类名，同时也是文件名</span></span><br><span class="line"></span><br><span class="line">message MyMessage &#123;</span><br><span class="line">    <span class="comment">//定义一个枚举类型</span></span><br><span class="line">    <span class="keyword">enum</span> DateType &#123;</span><br><span class="line">        StudentType = <span class="number">0</span>; <span class="comment">//在proto3中，要求enum的编号从0开始</span></span><br><span class="line">        WorkerType = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用data_type来标识传的是哪一个枚举类型</span></span><br><span class="line">    DateType data_type = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标识每次枚举类型最多只能出现其中的一个类型，节省空间</span></span><br><span class="line">    oneof dataBody &#123;</span><br><span class="line">        Student stuent = <span class="number">2</span>;</span><br><span class="line">        Worker worker = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Student &#123; <span class="comment">//会在StudentPojo 外部类生成一个内部类Student，他是真正发送的pojo对象</span></span><br><span class="line">    int32 id = <span class="number">1</span>; <span class="comment">//Student类中有一个属性名字为ID，类型为int32（protobuf类型），1表示序号，不是值</span></span><br><span class="line">    string name = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">message Worker &#123;</span><br><span class="line">    string name = <span class="number">1</span>;</span><br><span class="line">    int32 age = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里面我们定义了<code>MyMessage</code>、<code>Student</code>、<code>Worker</code>三个对象</li><li><code>MyMessage</code>里面持有了一个枚举类<code>DataType</code>和，<code>Student</code>、<code>Worker</code>这两个类对象中的其中一个。</li><li>这样设计的目的是什么呢？当我们在发送对象时，设置<code>MyMessage</code>里面的对象的同时就可以给枚举赋值，这样当我们接收对象时，就可以根据枚举判断我们接受到哪个实例类了。</li></ul><h2 id="4-Netty-ProtoBuf编解码器"><a href="#4-Netty-ProtoBuf编解码器" class="headerlink" title="4. Netty ProtoBuf编解码器"></a>4. Netty ProtoBuf编解码器</h2><h3 id="4-1-发送端"><a href="#4-1-发送端" class="headerlink" title="4.1 发送端"></a>4.1 发送端</h3><ol><li>需要给发送端的<code>pipeline</code>添加编码器：<code>ProtobufEncoder</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.group(group)</span><br><span class="line">    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> ProtobufEncoder());</span><br><span class="line">            pipeline.addLast(<span class="keyword">new</span> ProtoClientHandler());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>在发送时，如何<strong>构造一个具体对象</strong>呢？以上面复杂对象为例，我们主要构造的是<code>MyMessage</code>对象，设置里面的枚举属性，和对应的对象。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyDataInfo.MyMessage build = MyDataInfo.MyMessage.</span><br><span class="line">    newBuilder().</span><br><span class="line">    setDataType(MyDataInfo.MyMessage.DateType.StudentType)</span><br><span class="line">    .setStuent(MyDataInfo.Student</span><br><span class="line">                        .newBuilder()</span><br><span class="line">               .setId(<span class="number">5</span>)</span><br><span class="line">               .setName(<span class="string">"王五"</span>)</span><br><span class="line">               .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h3 id="4-2-接收端"><a href="#4-2-接收端" class="headerlink" title="4.2 接收端"></a>4.2 接收端</h3><ol><li>需要在接收端添加解码器：<code>ProtobufDecoder</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">LoggingHandler</span>())</span></span><br><span class="line"><span class="class">    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 128)</span></span><br><span class="line"><span class="class">    .<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            <span class="comment">//需要指定对哪种对象进行解码</span></span><br><span class="line">            pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> ProtobufDecoder(MyDataInfo.MyMessage.getDefaultInstance()));</span><br><span class="line">            pipeline.addLast(<span class="keyword">new</span> ProtoServerHandler());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li>在接收对象时，我们就可以根据枚举变量去获取实例对象了。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MyDataInfo.MyMessage message = (MyDataInfo.MyMessage) msg;</span><br><span class="line">MyDataInfo.MyMessage.DateType dataType = message.getDataType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (dataType) &#123;</span><br><span class="line">    <span class="keyword">case</span> StudentType:</span><br><span class="line">        MyDataInfo.Student student = message.getStuent();</span><br><span class="line">        System.out.println(<span class="string">"学生Id = "</span> + student.getId() + student.getName());</span><br><span class="line">    <span class="keyword">case</span> WorkerType:</span><br><span class="line">        MyDataInfo.Worker worker = message.getWorker();</span><br><span class="line">        System.out.println(<span class="string">"工人：name = "</span> + worker.getName() + worker.getAge());</span><br><span class="line">    <span class="keyword">case</span> UNRECOGNIZED:</span><br><span class="line">        System.out.println(<span class="string">"输入的类型不正确"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 本文档整理自 尚硅谷韩顺平Netty 相关课程。</p></blockquote><p><strong>参考博客 ：</strong> <a href="https://dongzl.github.io/netty-handbook/#/README" target="_blank" rel="noopener">https://dongzl.github.io/netty-handbook/#/README</a></p><p><strong>idea 使用 protobuf 问题 ：</strong> <a href="https://www.cnblogs.com/liugh/p/7505533.html" target="_blank" rel="noopener">https://www.cnblogs.com/liugh/p/7505533.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-11-ProtoBuf&quot;&gt;&lt;a href=&quot;#Netty-11-ProtoBuf&quot; class=&quot;headerlink&quot; title=&quot;Netty-11-ProtoBuf&quot;&gt;&lt;/a&gt;Netty-11-ProtoBuf&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;编写网络应用程序时，因为&lt;strong&gt;数据在网络中传输的都是二进制字节码数据&lt;/strong&gt;，在发送数据的时候就需要编码，接收数据时候就需要解码&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;codec(编解码器)的组成部分有两个&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;decoder&lt;/code&gt;(解码器) ： 负责把字节码数据转换成业务逻辑&lt;/li&gt;
&lt;li&gt;&lt;code&gt;encoder&lt;/code&gt;(编码器) ： 负责把业务数据转换成字节码数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201104/084813142.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="ProtoBuf" scheme="http://zhuuu.work/tags/ProtoBuf/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-059-螺旋矩阵II</title>
    <link href="http://zhuuu.work/2020/11/02/Leetcode/Leetcode-059-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/"/>
    <id>http://zhuuu.work/2020/11/02/Leetcode/Leetcode-059-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/</id>
    <published>2020-11-02T03:52:53.000Z</published>
    <updated>2020-11-05T06:15:36.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-059-螺旋矩阵-II"><a href="#Leetcode-059-螺旋矩阵-II" class="headerlink" title="Leetcode-059-螺旋矩阵 II"></a>Leetcode-059-<a href="https://leetcode-cn.com/problems/spiral-matrix-ii/" target="_blank" rel="noopener">螺旋矩阵 II</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个正整数 <em>n</em>，生成一个包含 1 到 <em>n</em> 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 8, 9, 4 ],</span><br><span class="line"> [ 7, 6, 5 ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-：模拟"><a href="#思路-：模拟" class="headerlink" title="思路 ：模拟"></a><strong>思路 ：模拟</strong></h2><ul><li>定义当前左右上下边界 <code>l,r,t,b</code>，初始值 <code>num = 1</code>，迭代终止值 <code>tar = n * n</code>；</li><li>当 <code>num &lt;= tar</code> 时，始终按照 <code>从左到右</code> <code>从上到下</code> <code>从右到左</code> <code>从下到上</code> 填入顺序循环，每次填入后：<ul><li>执行 <code>num += 1</code>：得到下一个需要填入的数字；</li><li>更新边界：例如从左到右填完后，上边界<code>t += 1</code>，相当于上边界向内缩 1。</li></ul></li><li><strong>使用<code>num &lt;= tar</code>而不是<code>l &lt; r || t &lt; b</code>作为迭代条件，是为了解决当<code>n</code>为奇数时，矩阵中心数字无法在迭代过程中被填充的问题。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  矩阵初始化 边界初始化</span></span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = matrix.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 起始数字和终止数字</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> target = n * n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环打印</span></span><br><span class="line">        <span class="keyword">while</span> (num &lt;= target)&#123;</span><br><span class="line">            <span class="comment">// 从左到右</span></span><br><span class="line">            <span class="comment">// 打印数字</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r ; i++) &#123;</span><br><span class="line">                matrix[t][i] = num;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 边界收缩</span></span><br><span class="line">            t++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从上到下</span></span><br><span class="line">            <span class="comment">// 打印数字</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt;= b ; i++) &#123;</span><br><span class="line">                matrix[i][r] = num;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 边界收缩</span></span><br><span class="line">            r--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从右到左</span></span><br><span class="line">            <span class="comment">// 打印数字</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt;= l ; i--) &#123;</span><br><span class="line">                matrix[b][i] = num;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 边界收缩</span></span><br><span class="line">            b--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从下到上</span></span><br><span class="line">            <span class="comment">// 打印数字</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &gt;= t ; i--) &#123;</span><br><span class="line">                matrix[i][l] = num;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 边界收缩</span></span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n^2) 矩阵元素的个数</li><li>空间复杂度:   O(1) 除了存储返回答案的空间以外，我们只需要额外的常数空间即可。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-059-螺旋矩阵-II&quot;&gt;&lt;a href=&quot;#Leetcode-059-螺旋矩阵-II&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-059-螺旋矩阵 II&quot;&gt;&lt;/a&gt;Leetcode-059-&lt;a href=&quot;https://leetcode-cn.com/problems/spiral-matrix-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;螺旋矩阵 II&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个正整数 &lt;em&gt;n&lt;/em&gt;，生成一个包含 1 到 &lt;em&gt;n&lt;/em&gt; 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [ 1, 2, 3 ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [ 8, 9, 4 ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [ 7, 6, 5 ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Netty-09-心跳检测机制</title>
    <link href="http://zhuuu.work/2020/11/02/Netty/Netty-09-%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6/"/>
    <id>http://zhuuu.work/2020/11/02/Netty/Netty-09-%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6/</id>
    <published>2020-11-02T02:05:24.000Z</published>
    <updated>2021-05-16T03:16:35.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-09-心跳检测机制"><a href="#Netty-09-心跳检测机制" class="headerlink" title="Netty-09-心跳检测机制"></a>Netty-09-心跳检测机制</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>实例要求</strong></p><ul><li>编写一个 Netty心跳检测机制案例, 当服务器超过3秒没有读时，就提示读空闲</li><li>当服务器超过5秒没有写操作时，就提示写空闲</li><li>实现当服务器超过7秒没有读或者写操作时，就提示读写空闲</li></ul><a id="more"></a><h2 id="1-服务端代码"><a href="#1-服务端代码" class="headerlink" title="1. 服务端代码"></a>1. 服务端代码</h2><h3 id="1-1-启动类"><a href="#1-1-启动类" class="headerlink" title="1.1 启动类"></a>1.1 启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">LoggingHandler</span>(<span class="title">LogLevel</span>.<span class="title">INFO</span>)) // 为<span class="title">bossGroup</span>请求日志处理<span class="title">handler</span></span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 加入一个netty提供的IdleStateHandler</span></span><br><span class="line">                            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                             * 1. IdleStateHandler 是netty提供的检测空闲状态的处理器</span></span><br><span class="line"><span class="comment">                             * 2. long readerIdleTime 表示多长事件没有读，就会发送一个心跳检测包检测是否还是连接状态</span></span><br><span class="line"><span class="comment">                             * 3、long writerIdleTime：表示多长时间没有写，就会发送一个心跳检测包检测是否还是连接的状态</span></span><br><span class="line"><span class="comment">                             * 4、long allIdleTime：表示多长时间没有读写，就会发送一个心跳检测包检测是否还是连接的状态</span></span><br><span class="line"><span class="comment">                             * 5、当 IdleStateEvent 触发后，就会传递给管道的下一个 Handler，通过调用（触发）下一个Handler的 userEventTriggered，在该方法区处理这个事件。</span></span><br><span class="line"><span class="comment">                             *</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line"></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 加入一个对空闲检测进一步处理的Handler(自定义)</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">//启动服务器，设置为同步模式。</span></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-Handler"><a href="#1-2-Handler" class="headerlink" title="1.2 Handler"></a>1.2 Handler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateEvent;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.EventExecutorGroup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evt 事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent)&#123;</span><br><span class="line">            <span class="comment">// 将evt向下转型成IdleStateEvent</span></span><br><span class="line">            IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断空闲事件类型</span></span><br><span class="line">            String eventType = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">switch</span> (event.state())&#123;</span><br><span class="line">                <span class="keyword">case</span> READER_IDLE:</span><br><span class="line">                    eventType = <span class="string">"读空闲"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WRITER_IDLE:</span><br><span class="line">                    eventType = <span class="string">"写空闲"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ALL_IDLE:</span><br><span class="line">                    eventType = <span class="string">"读写空闲"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ctx.channel().remoteAddress() +<span class="string">"---超时时间--"</span> + eventType);</span><br><span class="line">            System.out.println(<span class="string">"服务器做相应处理....."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-客户端代码"><a href="#2-客户端代码" class="headerlink" title="2. 客户端代码"></a>2. 客户端代码</h2><h3 id="2-1-客户端代码"><a href="#2-1-客户端代码" class="headerlink" title="2.1 客户端代码"></a>2.1 客户端代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        NioEventLoopGroup eventExecutors = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                    .group(eventExecutors)</span><br><span class="line">                    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//加入Handler</span></span><br><span class="line">                            pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> GroupChatClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// connect 事件</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(host, port).sync();</span><br><span class="line">            <span class="comment">// 得到channel,打印本地地址</span></span><br><span class="line">            Channel channel = channelFuture.channel();</span><br><span class="line">            System.out.println(<span class="string">"--------"</span> + channel.localAddress() + <span class="string">"---------"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 客户端需要输入信息</span></span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNextLine())&#123;</span><br><span class="line">                String msg = scanner.nextLine();</span><br><span class="line">                <span class="comment">// 通过channel 发送到服务器端</span></span><br><span class="line">                channel.writeAndFlush(msg + <span class="string">"\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            eventExecutors.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GroupChatClient(<span class="string">"127.0.0.1"</span>,<span class="number">7000</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-Handler"><a href="#2-2-Handler" class="headerlink" title="2.2  Handler"></a>2.2  Handler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(msg.trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-09-心跳检测机制&quot;&gt;&lt;a href=&quot;#Netty-09-心跳检测机制&quot; class=&quot;headerlink&quot; title=&quot;Netty-09-心跳检测机制&quot;&gt;&lt;/a&gt;Netty-09-心跳检测机制&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;实例要求&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编写一个 Netty心跳检测机制案例, 当服务器超过3秒没有读时，就提示读空闲&lt;/li&gt;
&lt;li&gt;当服务器超过5秒没有写操作时，就提示写空闲&lt;/li&gt;
&lt;li&gt;实现当服务器超过7秒没有读或者写操作时，就提示读写空闲&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="NIO" scheme="http://zhuuu.work/tags/NIO/"/>
    
      <category term="心跳包" scheme="http://zhuuu.work/tags/%E5%BF%83%E8%B7%B3%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-23-IO管理</title>
    <link href="http://zhuuu.work/2020/11/01/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-23-IO%E7%AE%A1%E7%90%86/"/>
    <id>http://zhuuu.work/2020/11/01/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-23-IO%E7%AE%A1%E7%90%86/</id>
    <published>2020-11-01T03:00:53.000Z</published>
    <updated>2021-05-16T03:37:05.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-23-IO管理"><a href="#操作系统-23-IO管理" class="headerlink" title="操作系统-23-IO管理"></a>操作系统-23-IO管理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>首先了解一下什么是IO 设备</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/112638277.png" alt="mark"></p><a id="more"></a><h2 id="1-IO-控制器"><a href="#1-IO-控制器" class="headerlink" title="1. IO 控制器"></a>1. IO 控制器</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/112847048.png" alt="mark"></p><ol><li><strong>机械部件</strong></li></ol><ul><li>执行具体的I/O操作，比如鼠标键盘的按钮，显示器的屏幕，移动硬盘的磁臂</li></ul><ol start="2"><li><strong>电子部件</strong></li></ol><ul><li><strong>CPU和机械部件的中介</strong>，通常是插入主板的电路板</li><li><strong>又叫I/O控制器，设备控制器</strong></li></ul><ol start="3"><li><strong>IO 控制器的组成</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/113021745.png" alt="mark"></p><ol start="4"><li><strong>IO 控制器两种寄存器编址方式</strong></li></ol><ul><li>内存映像</li><li>独立编址</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/113207976.png" alt="mark"></p><h2 id="2-IO-控制方式"><a href="#2-IO-控制方式" class="headerlink" title="2. IO 控制方式"></a>2. IO 控制方式</h2><ul><li><strong>有以下四种IO 控制方式</strong><ul><li><strong>程序直接控制</strong></li><li><strong>中断驱动方式</strong></li><li><strong>直接存储器存取DMA 方式</strong></li><li><strong>通道控制方式</strong></li></ul></li></ul><h3 id="2-1-程序直接控制"><a href="#2-1-程序直接控制" class="headerlink" title="2.1 程序直接控制"></a>2.1 程序直接控制</h3><ul><li>流程图如下</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/151737147.png" alt="mark"></p><h3 id="2-2-中断驱动方式"><a href="#2-2-中断驱动方式" class="headerlink" title="2.2 中断驱动方式"></a>2.2 中断驱动方式</h3><ul><li>流程图如下</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/152102370.png" alt="mark"></p><h3 id="2-3-DMA-方式"><a href="#2-3-DMA-方式" class="headerlink" title="2.3 DMA 方式"></a><strong>2.3 DMA 方式</strong></h3><ol><li><strong>DMA 控制器图</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/152156189.png" alt="mark"></p><ol start="2"><li><strong>流程图如下</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/152438653.png" alt="mark"></p><h3 id="2-4-通道处理方式"><a href="#2-4-通道处理方式" class="headerlink" title="2.4 通道处理方式"></a>2.4 通道处理方式</h3><ol><li><strong>通道的概念</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/152751952.png" alt="mark"></p><ol start="2"><li><strong>流程图</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/153050863.png" alt="mark"></p><h3 id="2-5-小结对比"><a href="#2-5-小结对比" class="headerlink" title="2.5 小结对比"></a>2.5 小结对比</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/153109627.png" alt="mark"></p><h2 id="3-IO-软件层次"><a href="#3-IO-软件层次" class="headerlink" title="3. IO 软件层次"></a>3. IO 软件层次</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/105845878.png" alt="mark"></p><h3 id="3-1-用户层软件"><a href="#3-1-用户层软件" class="headerlink" title="3.1 用户层软件"></a>3.1 用户层软件</h3><ul><li>向下提供系统调用</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/105904327.png" alt="mark"></p><h3 id="3-2-设备独立性软件"><a href="#3-2-设备独立性软件" class="headerlink" title="3.2 设备独立性软件"></a>3.2 设备独立性软件</h3><p><strong>功能</strong></p><ul><li>提供调用接口(read/write系统调用) </li><li>设备保护 </li><li>差错处理 </li><li><strong>设备分配与回收</strong> </li><li><strong>数据缓冲区管理</strong> </li><li><strong>建立逻辑设备名到物理设备名的映射关系</strong> </li><li>根据设备类型调用相应的驱动程序</li></ul><p><strong>逻辑设备表 LUT</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/110032068.png" alt="mark"></p><h3 id="3-3-设备驱动程序"><a href="#3-3-设备驱动程序" class="headerlink" title="3.3 设备驱动程序"></a>3.3 设备驱动程序</h3><ul><li>设置设备的寄存器</li><li>检测设备状态</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/110122761.png" alt="mark"></p><h3 id="3-4-中断处理程序"><a href="#3-4-中断处理程序" class="headerlink" title="3.4 中断处理程序"></a>3.4 中断处理程序</h3><ul><li><strong>一次IO 请求的流程</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/110157329.png" alt="mark"></p><ul><li><strong>中断处理逻辑</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201102/110412976.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考笔记 ：</strong> <a href="https://blog.csdn.net/weixin_43914604/article/details/104415990" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43914604/article/details/104415990</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-23-IO管理&quot;&gt;&lt;a href=&quot;#操作系统-23-IO管理&quot; class=&quot;headerlink&quot; title=&quot;操作系统-23-IO管理&quot;&gt;&lt;/a&gt;操作系统-23-IO管理&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;首先了解一下什么是IO 设备&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/112638277.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-22-磁盘调度算法</title>
    <link href="http://zhuuu.work/2020/11/01/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-22-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <id>http://zhuuu.work/2020/11/01/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-22-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</id>
    <published>2020-11-01T02:00:53.000Z</published>
    <updated>2021-05-16T03:37:10.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-22-磁盘调度算法"><a href="#操作系统-22-磁盘调度算法" class="headerlink" title="操作系统-22-磁盘调度算法"></a>操作系统-22-磁盘调度算法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111815980.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg" alt="mark"></p><a id="more"></a><h2 id="1-一次读磁盘所需要的时间"><a href="#1-一次读磁盘所需要的时间" class="headerlink" title="1. 一次读磁盘所需要的时间"></a>1. 一次读磁盘所需要的时间</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111926789.png" alt="mark"></p><h2 id="2-磁盘调度算法"><a href="#2-磁盘调度算法" class="headerlink" title="2. 磁盘调度算法"></a>2. 磁盘调度算法</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg" alt="mark"></p><p>磁盘调度算法的目的很简单，就是为了提高磁盘的访问性能，一般是通过优化磁盘的访问请求顺序来做到的。</p><p>寻道的时间是磁盘访问最耗时的部分，如果请求顺序优化的得当，必然可以节省一些不必要的寻道时间，从而提高磁盘的访问性能。</p><h3 id="2-1-先来先服务"><a href="#2-1-先来先服务" class="headerlink" title="2.1 先来先服务"></a>2.1 先来先服务</h3><ul><li><p>先来先服务（<em>First-Come，First-Served，FCFS</em>），顾名思义，先到来的请求，先被服务。</p></li><li><p>那按照这个序列的话：</p><p><code>98，183，37，122，14，124，65，67</code></p><p>那么，磁盘的写入顺序是从左到右，如下图：</p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/144809106.png" alt="mark"></p><ul><li>先来先服务算法总共移动了 <code>640</code> 个磁道的距离，这么一看这种算法，比较简单粗暴，但是如果大量进程竞争使用磁盘，请求访问的磁道可能会很分散，那先来先服务算法在性能上就会显得很差，因为寻道时间过长。</li></ul><h3 id="2-2-最短寻道时间优先"><a href="#2-2-最短寻道时间优先" class="headerlink" title="2.2 最短寻道时间优先"></a>2.2 最短寻道时间优先</h3><ul><li>最短寻道时间优先（<em>Shortest Seek First，SSF</em>）算法的工作方式是，优先选择从当前磁头位置所需寻道时间最短的请求，还是以这个序列为例子：</li></ul><p><code>98，183，37，122，14，124，65，67</code></p><ul><li>那么，那么根据距离磁头（ 53 位置）最近的请求的算法，具体的请求则会是下列从左到右的顺序：</li></ul><p><code>65，67，37，14，98，122，124，183</code></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/144946962.png" alt="mark"></p><ul><li>磁头移动的总距离是 <code>236</code> 磁道，相比先来先服务性能提高了不少。<ul><li>但这个算法可能存在某些请求的<strong>饥饿</strong>，因为本次例子我们是静态的序列，看不出问题，</li><li>假设是一个动态的请求，如果后续来的请求都是小于 183 磁道的，那么 183 磁道可能永远不会被响应，于是就产生了饥饿现象，这里<strong>产生饥饿的原因是磁头在一小块区域来回移动</strong>。</li></ul></li></ul><h3 id="2-3-扫描算法"><a href="#2-3-扫描算法" class="headerlink" title="2.3 扫描算法"></a>2.3 扫描算法</h3><ul><li>最短寻道时间优先算法会产生饥饿的原因在于：磁头有可能再一个小区域内来回得移动。</li><li>为了防止这个问题，可以规定：<strong>磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后的磁道，才调换方向，这就是扫描（Scan）算法</strong>。</li><li>这种算法也叫做<strong>电梯算法</strong>，比如电梯保持按一个方向移动，直到在那个方向上没有请求为止，然后改变方向。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">还是以这个序列为例子，磁头的初始位置是 53：</span><br><span class="line"></span><br><span class="line">98，183，37，122，14，124，65，67</span><br><span class="line"></span><br><span class="line">那么，假设扫描调度算先朝磁道号减少的方向移动，具体请求则会是下列从左到右的顺序：</span><br><span class="line"></span><br><span class="line">37，14，0，65，67，98，122，124，183</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/145111421.png" alt="mark"></p><ul><li>磁头先响应左边的请求，直到到达最左端（ 0 磁道）后，才开始反向移动，响应右边的请求。</li><li>扫描调度算法性能较好，不会产生饥饿现象，但是存在这样的问题<ul><li><strong>中间部分的磁道会比较占便宜</strong>，中间部分相比其他部分<strong>响应的频率会比较多</strong>，也就是说每个磁道的响应频率存在差异。</li></ul></li></ul><h3 id="2-4-循环扫描算法"><a href="#2-4-循环扫描算法" class="headerlink" title="2.4 循环扫描算法"></a>2.4 循环扫描算法</h3><ul><li>扫描算法使得每个磁道响应的频率存在差异，那么<strong>要优化这个问题的话，可以总是按相同的方向进行扫描，使得每个磁道的响应频率基本一致。</strong></li></ul><ul><li>循环扫描（<em>Circular Scan, CSCAN</em> ）规定：只有磁头朝某个特定方向移动时，才处理磁道访问请求，而<strong>返回时直接快速移动至最靠边缘的磁道，也就是复位磁头</strong>，这个过程是很快的，并且<strong>返回中途不处理任何请求</strong>，该算法的特点，就是<strong>磁道只响应一个方向上的请求</strong>。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">还是以这个序列为例子，磁头的初始位置是 53：</span><br><span class="line"></span><br><span class="line">98，183，37，122，14，124，65，67</span><br><span class="line"></span><br><span class="line">那么，假设循环扫描调度算先朝磁道增加的方向移动，具体请求会是下列从左到右的顺序：</span><br><span class="line"></span><br><span class="line">65，67，98，122，124，183，199，0，14，37</span><br></pre></td></tr></table></figure><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/145234782.png" alt="mark"></p><ul><li>磁头先响应了右边的请求，直到碰到了最右端的磁道 199，就立即回到磁盘的开始处（磁道 0），但这个返回的途中是不响应任何请求的，直到到达最开始的磁道后，才继续顺序响应右边的请求。</li><li>循环扫描算法相比于扫描算法，对于<strong>各个位置磁道响应频率相对比较平均。</strong></li></ul><h3 id="2-5-LOOK-与-C-LOOK算法"><a href="#2-5-LOOK-与-C-LOOK算法" class="headerlink" title="2.5 LOOK 与 C-LOOK算法"></a>2.5 LOOK 与 C-LOOK算法</h3><ul><li>我们前面说到的扫描算法和循环扫描算法，都是磁头移动到磁盘「最始端或最末端」才开始调换方向。</li><li>那这其实是可以优化的，优化的思路就是<strong>磁头在移动到「最远的请求」位置，然后立即反向移动。</strong></li><li>那<strong>针对 SCAN 算法的优化则叫 LOOK 算法</strong>，它的工作方式，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，<strong>反向移动的途中会响应请求</strong>。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/145437467.png" alt="mark"></p><ul><li>而针 <strong>C-SCAN 算法的优化则叫 C-LOOK</strong>，它的工作方式，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，<strong>反向移动的途中不会响应请求</strong>。</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/145453441.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-22-磁盘调度算法&quot;&gt;&lt;a href=&quot;#操作系统-22-磁盘调度算法&quot; class=&quot;headerlink&quot; title=&quot;操作系统-22-磁盘调度算法&quot;&gt;&lt;/a&gt;操作系统-22-磁盘调度算法&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111815980.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/114232317.jpg&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="磁盘管理" scheme="http://zhuuu.work/tags/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>网络-WebSocket理解</title>
    <link href="http://zhuuu.work/2020/11/01/NetworkCoding/%E7%BD%91%E7%BB%9C-WebSocket%E7%90%86%E8%A7%A3/"/>
    <id>http://zhuuu.work/2020/11/01/NetworkCoding/%E7%BD%91%E7%BB%9C-WebSocket%E7%90%86%E8%A7%A3/</id>
    <published>2020-11-01T01:02:24.000Z</published>
    <updated>2021-05-15T01:14:12.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络-WebSocket理解"><a href="#网络-WebSocket理解" class="headerlink" title="网络-WebSocket理解"></a>网络-WebSocket理解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><strong>WebSocket是HTML5出的东西（协议），也就是说HTTP协议没有变化，或者说没关系，但HTTP是不支持持久连接的（长连接，循环连接的不算）</strong></li><li>首先HTTP有<code>1.1</code>和<code>1.0</code>之说，也就是所谓的<code>keep-alive</code>，把多个HTTP请求合并为一个，但是<strong><code>Websocket</code>其实是一个新协议，跟HTTP协议基本没有关系</strong>，只是为了兼容现有浏览器的握手规范而已，也就是说它是HTTP协议上的一种补充可以通过这样一张图理解</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/093305644.png" alt="mark"></p><p>有交集，但是并不是全部。</p><ul><li>另外Html5是指的一系列新的API，或者说新规范，新技术。Http协议本身只有1.0和1.1，而且跟Html本身没有直接关系。</li><li>通俗来说，你可以用HTTP<strong>协议</strong>传输非Html<strong>数据</strong>，就是这样=。=</li><li>再简单来说，<strong>层级不一样</strong>。</li></ul><a id="more"></a><h2 id="1-WebSocket概念"><a href="#1-WebSocket概念" class="headerlink" title="1. WebSocket概念"></a>1. WebSocket概念</h2><ul><li>首先，Websocket是一个<strong>持久化</strong>的协议，相对于HTTP这种<strong>非持久</strong>的协议来说。</li></ul><p>简单的举个例子吧，用目前应用比较广泛的PHP生命周期来解释。</p><ol><li>HTTP的生命周期通过Request来界定，也就是一个Request 一个Response，那么<strong>在</strong>HTTP1.0<strong>中</strong>，这次HTTP请求就结束了。</li><li>在HTTP1.1中进行了改进，使得有一个keep-alive，也就是说，在一个HTTP连接中，可以发送多个Request，接收多个Response。</li><li>但是请记住 Request = Response ， <strong>在HTTP中永远是这样，也就是说一个request只能有一个response</strong>。而且这个response也是<strong>被动</strong>的，不能主动发起。</li></ol><p><strong>HTTP 和 WebSocket 的关系</strong></p><ul><li><p>首先Websocket是基于HTTP协议的，或者说<strong>借用</strong>了HTTP的协议来完成一部分握手。</p></li><li><p>在握手阶段是一样的</p></li><li><p>然后我们来看个典型的WebSocket 握手</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http://example.com</span><br></pre></td></tr></table></figure><p>熟悉HTTP的童鞋可能发现了，这段类似HTTP协议的握手请求中，多了几个东西。<br>我会顺便讲解下作用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure><p>这个就是Websocket的核心了，告诉Apache、Nginx等服务器：<strong>注意啦，窝发起的是Websocket协议，快点帮我找到对应的助理处理~不是那个老土的HTTP。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li><p>首先，Sec-WebSocket-Key 是一个Base64 encode的值，这个是浏览器随机生成的，告诉服务器：<strong>泥煤，不要忽悠窝，我要验证尼是不是真的是Websocket助理。</strong></p></li><li><p>然后，Sec_WebSocket-Protocol 是一个用户定义的字符串，用来区分同URL下，不同的服务所需要的协议。简单理解：<strong>今晚我要服务A，别搞错啦~</strong></p></li><li><p>最后，Sec-WebSocket-Version 是告诉服务器所使用的Websocket Draft（协议版本），在最初的时候，Websocket协议还在 Draft 阶段，各种奇奇怪怪的协议都有，而且还有很多期奇奇怪怪不同的东西，什么Firefox和Chrome用的不是一个版本之类的，当初Websocket协议太多可是一个大难题。。不过现在还好，已经定下来啦<del>大家都使用的一个东西</del> 脱水：<strong>服务员，我要的是13岁的噢→_→</strong></p></li></ol><ul><li>然后服务器会返回下列东西，表示已经接受到请求， 成功建立Websocket啦！</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure><p>这里开始就是HTTP最后负责的区域了，告诉客户，我已经成功切换协议啦~</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure><p>依然是固定的，告诉客户端即将升级的是Websocket协议，而不是mozillasocket，lurnarsocket或者shitsocket。</p><p>然后，Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key。服务器：<strong>好啦好啦，知道啦，给你看我的ID CARD来证明行了吧。。</strong><br>后面的，Sec-WebSocket-Protocol 则是表示最终使用的协议。</p><p><strong>至此，HTTP已经完成它所有工作了，接下来就是完全按照Websocket协议进行了。</strong></p><h2 id="2-WebSocket的作用"><a href="#2-WebSocket的作用" class="headerlink" title="2. WebSocket的作用"></a>2. WebSocket的作用</h2><p>在讲Websocket之前，我就<strong>顺带着讲下 long poll 和 ajax轮询 的原理</strong>。</p><ol><li><strong>首先是 ajax轮询 ，ajax轮询 的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">场景再现：</span><br><span class="line">客户端：啦啦啦，有没有新信息(Request)</span><br><span class="line">服务端：没有（Response）</span><br><span class="line">客户端：啦啦啦，有没有新信息(Request)</span><br><span class="line">服务端：没有。。（Response）</span><br><span class="line">客户端：啦啦啦，有没有新信息(Request)</span><br><span class="line">服务端：你好烦啊，没有啊。。（Response）</span><br><span class="line">客户端：啦啦啦，有没有新消息（Request）</span><br><span class="line">服务端：好啦好啦，有啦给你。（Response）</span><br><span class="line">客户端：啦啦啦，有没有新消息（Request）</span><br><span class="line">服务端：。。。。。没。。。。没。。。没有（Response） ---- loop</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>long poll</strong></li></ol><ul><li>long poll 其实原理跟 ajax轮询 差不多，都是采用轮询的方式，</li><li>不过采取的是<strong>阻塞模型</strong>（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。</li><li>直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request）</span><br><span class="line">服务端：额。。 等待到有消息的时候。。来 给你（Response）</span><br><span class="line">客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request） -loop</span><br></pre></td></tr></table></figure><p><strong>注意 ： 上面的共性</strong></p><ul><li><p>从上面可以看出其实这两种方式，都是在不断地建立HTTP连接，然后等待服务端处理</p></li><li><p>可以体现HTTP协议的另外一个特点，<strong>被动性</strong>。</p><ul><li>何为被动性呢，其实就是，<strong>服务端不能主动联系客户端，只能有客户端发起。</strong></li></ul></li><li><p>缺点：</p><ul><li>很容易看出来，不管怎么样，上面这两种都是非常消耗资源的。</li><li><strong>ajax轮询 需要服务器有很快的处理速度和资源。（速度）</strong></li><li><strong>long poll 需要有很高的并发，也就是说同时接待客户的能力。（场地大小）</strong></li></ul></li></ul><p><strong>所以ajax轮询 和long poll 都有可能发生这种情况。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">客户端：啦啦啦啦，有新信息么？</span><br><span class="line">服务端：月线正忙，请稍后再试（503 Server Unavailable）</span><br><span class="line">客户端：。。。。好吧，啦啦啦，有新信息么？</span><br><span class="line">服务端：月线正忙，请稍后再试（503 Server Unavailable）</span><br></pre></td></tr></table></figure><ul><li>通过上面这个例子，我们可以看出，这两种方式都不是最好的方式，需要很多资源。</li><li>HTTP还是一个<strong>无状态协议</strong>。<ul><li>通俗的说就是，服务器因为每天要接待太多客户了，是个<strong>健忘鬼</strong>，你一挂电话，他就把你的东西全忘光了，把你的东西全丢掉了。你第二次还得再告诉服务器一遍。</li></ul></li></ul><h3 id="2-1-WebSocket-的诞生"><a href="#2-1-WebSocket-的诞生" class="headerlink" title="2.1 WebSocket 的诞生"></a>2.1 WebSocket 的诞生</h3><ul><li>所以在这种情况下出现了，Websocket出现了。</li><li>他解决了HTTP的这几个难题。<ul><li>首先，<strong>被动性</strong>，当服务器完成协议升级后（HTTP-&gt;Websocket），服务端就可以主动推送信息给客户端啦。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">所以上面的情景可以做如下修改。</span><br><span class="line">客户端：啦啦啦，我要建立Websocket协议，需要的服务：chat，Websocket协议版本：17（HTTP Request）</span><br><span class="line">服务端：ok，确认，已升级为Websocket协议（HTTP Protocols Switched）</span><br><span class="line">客户端：麻烦你有信息的时候推送给我噢。。</span><br><span class="line">服务端：ok，有的时候会告诉你的。</span><br><span class="line">服务端：balabalabalabala服务端：balabalabalabala</span><br><span class="line">服务端：哈哈哈哈哈啊哈哈哈哈服务端：笑死我了哈哈哈哈哈哈哈</span><br></pre></td></tr></table></figure><ul><li><p>只需要经过<strong>一次HTTP请求</strong>，就可以做到源源不断的信息传送了。（在程序设计中，这种设计叫做<strong>回调</strong>，即：你有信息了再来通知我，而不是我傻乎乎的每次跑来问你）</p></li><li><p>那么为什么他会<strong>解决服务器上消耗资源</strong>的问题呢？</p><ul><li>其实我们所用的程序是要经过两层代理的，即<strong>HTTP协议在Nginx等服务器的解析下</strong>，然后再传送给相应的<strong>Handler（PHP等）</strong>来处理。</li><li>简单地说，我们有一个非常快速的接<strong>线员（Nginx）</strong>，他负责把问题转交给相应的<strong>客服（Handler）</strong>。</li><li>本身<strong>接线员基本上速度是足够的</strong>，但是每次都卡在<strong>客服（Handler）</strong>了，老有<strong>客服</strong>处理速度太慢。，导致客服不够。</li><li>Websocket就解决了这样一个难题，建立后，可以直接跟接线员建立持<strong>久连接</strong>，有信息的时候客服想办法通知接线员，然后<strong>接线员</strong>在统一转交给客户。</li></ul></li></ul><ul><li><p>同时，在传统的方式上，要不断的建立，关闭HTTP协议</p><ul><li>由于HTTP是非状态性的，每次都要<strong>重新传输identity info（鉴别信息）</strong>，来告诉服务端你是谁。</li><li>虽然接线员很快速，但是每次都要听这么一堆，效率也会有所下降的，同时还得不断把这些信息转交给客服，不但浪费客服的<strong>处理时间</strong>，而且还会在网路传输中消耗<strong>过多的流量/时间。</strong></li><li>但是Websocket只需要<strong>一次HTTP握手，所以说整个通讯过程是建立在一次连接/状态中</strong>，</li><li>也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议，还要查看identity info的信息。</li></ul></li><li><p>同时由<strong>客户主动询问</strong>，转换为<strong>服务器（推送）有信息的时候就发送（当然客户端还是等主动发送信息过来的。。）</strong></p><ul><li>没有信息的时候就交给接线员（Nginx），不需要占用本身速度就慢的<strong>客服（Handler）</strong>了</li></ul></li></ul><p><strong>PS  :</strong></p><p><strong>至于怎么在不支持Websocket的客户端上使用Websocket。。答案是：不能</strong></p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.  总结"></a>3.  总结</h2><ul><li>可以把 WebSocket 看成是 HTTP 协议为了支持长连接所打的一个大补丁，它和 HTTP 有一些共性，是为了解决 HTTP 本身无法解决的某些问题而做出的一个改良设计。</li><li>在以前 HTTP 协议中所谓的 keep-alive connection 是指在一次 TCP 连接中完成多个 HTTP 请求，但是对每个请求仍然要单独发 header；所谓的 polling 是指从客户端（一般就是浏览器）不断主动的向服务器发 HTTP 请求查询是否有新数据。</li><li>这两种模式有一个共同的缺点，<strong>就是除了真正的数据部分外，服务器和客户端还要大量交换 HTTP header</strong>，信息交换效率很低。<strong>它们建立的“长连接”都是伪.长连接</strong>，只不过好处是不需要对现有的 HTTP server 和浏览器架构做修改就能实现。</li></ul><p><strong>WebSocket 解决的第一个问题是，通过第一个 HTTP request 建立了 TCP 连接之后，之后的交换数据都不需要再发 HTTP request了</strong></p><ul><li>使得这个长连接变成了一个<strong>真.长连接</strong></li><li>但是不需要发送 HTTP header就能交换数据显然和原有的 HTTP 协议是有区别的，所以它需要对服务器和客户端都进行升级才能实现。</li><li>在此基础上 WebSocket 还是一个双通道的连接，在同一个 TCP 连接上既可以发也可以收信息。</li><li>另外外还有 multiplexing 功能，几个不同的 URI 可以复用同一个 WebSocket 连接。这些都是原来的 HTTP 不能做到的。</li></ul><p><strong>另外说一点技术细节，因为看到有人提问 WebSocket 可能进入某种半死不活的状态。这实际上也是原有网络世界的一些缺陷性设计</strong></p><ul><li>上面所说的 WebSocket 真.长连接虽然解决了服务器和客户端两边的问题，但坑爹的是网络应用除了服务器和客户端之外，另一个巨大的存在是中间的网络链路。</li><li>一个 HTTP/WebSocket 连接往往要经过无数的路由，防火墙。你以为你的数据是在一个“连接”中发送的，实际上它要跨越千山万水，经过无数次转发，过滤，才能最终抵达终点。在这过程中，中间节点的处理方法很可能会让你意想不到。</li><li>比如说，这些坑爹的中间节点可能会认为一份连接在一段时间内没有数据发送就等于失效，它们会自作主张的切断这些连接。</li><li>在这种情况下，不论服务器还是客户端都不会收到任何提示，它们只会一厢情愿的以为彼此间的红线还在，徒劳地一边又一边地发送抵达不了彼岸的信息。而计算机网络协议栈的实现中又会有一层套一层的缓存，除非填满这些缓存，你的程序根本不会发现任何错误</li></ul><p><strong>这样，本来一个美好的 WebSocket 长连接，就可能在毫不知情的情况下进入了半死不活状态。</strong></p><p><strong>而解决方案，WebSocket 的设计者们也早已想过。就是让服务器和客户端能够发送 Ping/Pong Frame</strong>（<a href="https://link.zhihu.com/?target=https%3A//tools.ietf.org/html/rfc6455%23section-5.5.2">RFC 6455 - The WebSocket Protocol</a>）。<strong>（心跳包）</strong></p><p><strong>这种 Frame 是一种特殊的数据包，它只包含一些元数据而不需要真正的 Data Payload，可以在不影响 Application 的情况下维持住中间网络的连接状态。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;网络-WebSocket理解&quot;&gt;&lt;a href=&quot;#网络-WebSocket理解&quot; class=&quot;headerlink&quot; title=&quot;网络-WebSocket理解&quot;&gt;&lt;/a&gt;网络-WebSocket理解&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;WebSocket是HTML5出的东西（协议），也就是说HTTP协议没有变化，或者说没关系，但HTTP是不支持持久连接的（长连接，循环连接的不算）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;首先HTTP有&lt;code&gt;1.1&lt;/code&gt;和&lt;code&gt;1.0&lt;/code&gt;之说，也就是所谓的&lt;code&gt;keep-alive&lt;/code&gt;，把多个HTTP请求合并为一个，但是&lt;strong&gt;&lt;code&gt;Websocket&lt;/code&gt;其实是一个新协议，跟HTTP协议基本没有关系&lt;/strong&gt;，只是为了兼容现有浏览器的握手规范而已，也就是说它是HTTP协议上的一种补充可以通过这样一张图理解&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/093305644.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;有交集，但是并不是全部。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;另外Html5是指的一系列新的API，或者说新规范，新技术。Http协议本身只有1.0和1.1，而且跟Html本身没有直接关系。&lt;/li&gt;
&lt;li&gt;通俗来说，你可以用HTTP&lt;strong&gt;协议&lt;/strong&gt;传输非Html&lt;strong&gt;数据&lt;/strong&gt;，就是这样=。=&lt;/li&gt;
&lt;li&gt;再简单来说，&lt;strong&gt;层级不一样&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="WebSocket" scheme="http://zhuuu.work/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-21-磁盘管理</title>
    <link href="http://zhuuu.work/2020/10/31/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-21-%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    <id>http://zhuuu.work/2020/10/31/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-21-%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-10-31T02:00:53.000Z</published>
    <updated>2021-05-16T03:37:00.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-21-磁盘管理"><a href="#操作系统-21-磁盘管理" class="headerlink" title="操作系统-21-磁盘管理"></a>操作系统-21-磁盘管理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111136067.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/144348215.png" alt="mark"></p><a id="more"></a><h2 id="1-磁盘的结构"><a href="#1-磁盘的结构" class="headerlink" title="1. 磁盘的结构"></a>1. 磁盘的结构</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111241257.png" alt="mark"></p><ol><li><strong>如何在磁盘中读写数据？</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111310259.png" alt="mark"></p><ol start="2"><li><strong>柱面盘面扇区号 = 磁盘地址</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111349961.png" alt="mark"></p><ol start="3"><li><strong>磁盘的分类</strong></li></ol><ul><li>按盘面分类</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111429132.png" alt="mark"></p><ul><li>按磁头分类</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111434376.png" alt="mark"></p><h2 id="2-磁盘管理"><a href="#2-磁盘管理" class="headerlink" title="2. 磁盘管理"></a>2. 磁盘管理</h2><h3 id="2-1-磁盘初始化"><a href="#2-1-磁盘初始化" class="headerlink" title="2.1 磁盘初始化"></a>2.1 磁盘初始化</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111623596.png" alt="mark"></p><h3 id="2-2-引导块"><a href="#2-2-引导块" class="headerlink" title="2.2 引导块"></a>2.2 引导块</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111648466.png" alt="mark"></p><h3 id="2-3-坏道管理（坏块）"><a href="#2-3-坏道管理（坏块）" class="headerlink" title="2.3 坏道管理（坏块）"></a>2.3 坏道管理（坏块）</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111715011.png" alt="mark"></p><h2 id="3-减少磁盘延迟"><a href="#3-减少磁盘延迟" class="headerlink" title="3. 减少磁盘延迟"></a>3. 减少磁盘延迟</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/153257581.png" alt="mark"></p><p><strong>需要减少磁盘延迟的原因 ： 无法连续的读取数据</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/153315306.png" alt="mark"></p><h3 id="3-1-交替编号"><a href="#3-1-交替编号" class="headerlink" title="3.1 交替编号"></a>3.1 交替编号</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/153406299.png" alt="mark"></p><h3 id="3-2-磁盘地址结构的设计"><a href="#3-2-磁盘地址结构的设计" class="headerlink" title="3.2 磁盘地址结构的设计"></a>3.2 磁盘地址结构的设计</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/153423711.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/153509150.png" alt="mark"></p><h3 id="3-3-错位命名"><a href="#3-3-错位命名" class="headerlink" title="3.3 错位命名"></a>3.3 错位命名</h3><ul><li>不使用错位命名</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/154002106.png" alt="mark"></p><ul><li>使用错位命名</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/154100860.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-21-磁盘管理&quot;&gt;&lt;a href=&quot;#操作系统-21-磁盘管理&quot; class=&quot;headerlink&quot; title=&quot;操作系统-21-磁盘管理&quot;&gt;&lt;/a&gt;操作系统-21-磁盘管理&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201101/111136067.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20200926/144348215.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="磁盘管理" scheme="http://zhuuu.work/tags/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-381-O(1) 时间插入、删除和获取随机元素 - 允许重复</title>
    <link href="http://zhuuu.work/2020/10/31/Leetcode/Leetcode-381-O(1)%20%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0%20-%20%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D/"/>
    <id>http://zhuuu.work/2020/10/31/Leetcode/Leetcode-381-O(1)%20%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0%20-%20%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D/</id>
    <published>2020-10-31T00:52:53.000Z</published>
    <updated>2020-10-31T02:06:35.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-381-O-1-时间插入、删除和获取随机元素-允许重复"><a href="#Leetcode-381-O-1-时间插入、删除和获取随机元素-允许重复" class="headerlink" title="Leetcode-381-O(1) 时间插入、删除和获取随机元素 - 允许重复"></a>Leetcode-381-<a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed/" target="_blank" rel="noopener">O(1) 时间插入、删除和获取随机元素 - 允许重复</a></h1><h2 id="思路：哈希表"><a href="#思路：哈希表" class="headerlink" title="思路：哈希表"></a>思路：哈希表</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>设计一个支持在平均 时间复杂度 O(1) 下， 执行以下操作的数据结构。</p><p>注意: 允许出现重复元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert(val)：向集合中插入元素 val。</span><br><span class="line">remove(val)：当 val 存在时，从集合中移除一个 val。</span><br><span class="line">getRandom：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 初始化一个空的集合。</span><br><span class="line">RandomizedCollection collection &#x3D; new RandomizedCollection();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向集合中插入 1 。返回 true 表示集合不包含 1 。</span><br><span class="line">collection.insert(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。</span><br><span class="line">collection.insert(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。</span><br><span class="line">collection.insert(2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; getRandom 应当有 2&#x2F;3 的概率返回 1 ，1&#x2F;3 的概率返回 2 。</span><br><span class="line">collection.getRandom();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。</span><br><span class="line">collection.remove(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; getRandom 应有相同概率返回 1 和 2 。</span><br><span class="line">collection.getRandom();</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法-哈希表"><a href="#方法-哈希表" class="headerlink" title="方法 : 哈希表"></a>方法 : 哈希表</h2><ul><li><strong>对于get() 方法</strong><ul><li>为了使得 <strong>O(1) 时间内能够随机获取一个元素</strong>，我们将<strong>每个数值（可以重复）存储在一个列表nums 中</strong>。</li><li>这样，获取随机元素时，只需要随机生成一个列表中的索引，就能够得到一个随机元素。</li></ul></li></ul><ul><li><strong>对于 remove() 方法</strong><ul><li>这样做的问题在于：<strong>列表中的随机删除并不是 O(1) 的。</strong></li><li>然而我们可以发现，<strong>列表中元素的顺序是无关紧要的</strong>，只要它们正确地存在于列表中即可。</li><li><strong>因此，在删除元素时，我们可以将被删的元素与列表中最后一个元素交换位置，随后便可以在 O(1)时间内，从列表中去除该元素。</strong></li><li>这需要我们<strong>额外维护数值在列表中每一次出现的下标集合</strong>。对于数值 val 而言，记其下标集合为 S<strong>i</strong>dx。</li></ul></li></ul><p><strong>具体删除操作</strong></p><ul><li><strong>在删除时，我们找出 val出现的其中一个下标 i</strong></li><li><strong>并将 <code>nums[i]</code> 和<code>nums[nums.length - 1]</code> 交换。</strong></li><li><strong>随后，将 i 从 Sval 中删除，并将<code>Snums[nums.length - 1]</code> 中原有的 <code>nums[nums.length - 1]</code> 替换成 i 。</strong></li><li><strong>由于每个操作都是O(1)的 那么平均时间复杂度也是 O（1）</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedCollection</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer,Set&lt;Integer&gt;&gt; idx; <span class="comment">// Map 用于维护数值在列表中每次出现的下标集合       Set 用于作为下标集合</span></span><br><span class="line">    List&lt;Integer&gt; nums; <span class="comment">// 用于随机获取元素 get() 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedCollection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        idx  = <span class="keyword">new</span> HashMap&lt;Integer,Set&lt;Integer&gt;&gt;();</span><br><span class="line">        nums = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 插入操作</span></span><br><span class="line">        nums.add(val); <span class="comment">// 加入到列表中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录出现的下标集合</span></span><br><span class="line">        <span class="comment">// key 是 出现的数字</span></span><br><span class="line">        <span class="comment">// val 是 出现数字所对应的下标</span></span><br><span class="line">        <span class="comment">// 比如插入[1,1,1,2,2,2]</span></span><br><span class="line">        <span class="comment">// 对应idx 即为 [1,[0,1,2]] [2,[3,4,5]]</span></span><br><span class="line">        Set&lt;Integer&gt; set = idx.getOrDefault(val,<span class="keyword">new</span> HashSet&lt;Integer&gt;()); </span><br><span class="line">        set.add(nums.size() - <span class="number">1</span>); </span><br><span class="line">        idx.put(val,set); <span class="comment">// set记录每个数字每一次出现的下标</span></span><br><span class="line">        <span class="keyword">return</span> set.size() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes a value from the collection. Returns true if the collection contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 删除操作</span></span><br><span class="line">        <span class="keyword">if</span>(!idx.containsKey(val))&#123; <span class="comment">// 如果根本没有这个数字的话，直接返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在删除时 找到val出现的其中一个下标i</span></span><br><span class="line">        <span class="comment">// 并将其和 最后一个元素进行交换</span></span><br><span class="line">        Iterator&lt;Integer&gt; it = idx.get(val).iterator();</span><br><span class="line">        <span class="keyword">int</span> i = it.next();</span><br><span class="line">        <span class="keyword">int</span> lastNum = nums.get(nums.size() - <span class="number">1</span>);</span><br><span class="line">        nums.set(i,lastNum);</span><br><span class="line"></span><br><span class="line">        idx.get(val).remove(i);</span><br><span class="line">        idx.get(lastNum).remove(nums.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &lt; nums.size() - <span class="number">1</span>)&#123;</span><br><span class="line">            idx.get(lastNum).add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(idx.get(val).size() == <span class="number">0</span>)&#123;</span><br><span class="line">            idx.remove(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the collection. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.get((<span class="keyword">int</span>) (Math.random() * nums.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedCollection object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RandomizedCollection obj = new RandomizedCollection();</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.insert(val);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.remove(val);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 O(1)</li><li>空间复杂度 O(n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-381-O-1-时间插入、删除和获取随机元素-允许重复&quot;&gt;&lt;a href=&quot;#Leetcode-381-O-1-时间插入、删除和获取随机元素-允许重复&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-381-O(1) 时间插入、删除和获取随机元素 - 允许重复&quot;&gt;&lt;/a&gt;Leetcode-381-&lt;a href=&quot;https://leetcode-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;O(1) 时间插入、删除和获取随机元素 - 允许重复&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;思路：哈希表&quot;&gt;&lt;a href=&quot;#思路：哈希表&quot; class=&quot;headerlink&quot; title=&quot;思路：哈希表&quot;&gt;&lt;/a&gt;思路：哈希表&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;设计一个支持在平均 时间复杂度 O(1) 下， 执行以下操作的数据结构。&lt;/p&gt;
&lt;p&gt;注意: 允许出现重复元素。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;insert(val)：向集合中插入元素 val。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remove(val)：当 val 存在时，从集合中移除一个 val。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getRandom：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; 初始化一个空的集合。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RandomizedCollection collection &amp;#x3D; new RandomizedCollection();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; 向集合中插入 1 。返回 true 表示集合不包含 1 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;collection.insert(1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;collection.insert(1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;collection.insert(2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; getRandom 应当有 2&amp;#x2F;3 的概率返回 1 ，1&amp;#x2F;3 的概率返回 2 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;collection.getRandom();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;collection.remove(1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; getRandom 应有相同概率返回 1 和 2 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;collection.getRandom();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
      <category term="哈希表" scheme="http://zhuuu.work/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-463-岛屿的周长</title>
    <link href="http://zhuuu.work/2020/10/30/Leetcode/Leetcode-463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/"/>
    <id>http://zhuuu.work/2020/10/30/Leetcode/Leetcode-463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/</id>
    <published>2020-10-30T08:35:53.000Z</published>
    <updated>2020-10-30T07:50:13.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-463-岛屿的周长"><a href="#Leetcode-463-岛屿的周长" class="headerlink" title="Leetcode-463-岛屿的周长"></a>Leetcode-463-<a href="https://leetcode-cn.com/problems/island-perimeter/" target="_blank" rel="noopener">岛屿的周长</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。</p><p>网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p><p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。<strong>计算这个岛屿的周长。</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/154731661.png" alt="mark"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 :</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[[0,1,0,0],</span><br><span class="line"> [1,1,1,0],</span><br><span class="line"> [0,1,0,0],</span><br><span class="line"> [1,1,0,0]]</span><br><span class="line"></span><br><span class="line">输出: 16</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路-迭代"><a href="#思路-迭代" class="headerlink" title="思路:  迭代"></a>思路:  迭代</h2><ul><li>对于一个陆地格子的每条边，它被算作岛屿的周长当且仅当这条边为网格的边界或者相邻的另一个格子为水域。</li><li>因此，我们可以遍历每个陆地格子，看其四个方向是否为边界或者水域，如果是，将这条边的贡献（即 1）加入答案<em>ans</em> 中即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dx = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dy = &#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.length; <span class="comment">// 行</span></span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].length; <span class="comment">// 列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个陆地格子，看其四个方向是否是边界或者水域</span></span><br><span class="line">        <span class="comment">// 如果是边界 或者 是水域 那么将这条边的贡献加1到ans中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)&#123;</span><br><span class="line">                <span class="comment">// 遍历每一个陆地格子</span></span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">// 遍历每个格子四条边4条边</span></span><br><span class="line">                    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">4</span>;k++)&#123;</span><br><span class="line">                        <span class="keyword">int</span> tx = i + dx[k];</span><br><span class="line">                        <span class="keyword">int</span> ty = j + dy[k];</span><br><span class="line">                        <span class="keyword">if</span>(tx &lt; <span class="number">0</span> || tx &gt;= n || ty &lt; <span class="number">0</span> || ty &gt;= m || grid[tx][ty] == <span class="number">0</span>)&#123;</span><br><span class="line">                            count += <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 计算完一个格子之后</span></span><br><span class="line">                    ans += count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：O(nm)，其中 n 为网格的高度，m 为网格的宽度。我们需要遍历每个格子，每个格子要看其周围 4 个格子是否为岛屿，因此总时间复杂度为 O(nm)。</li><li><strong>空间复杂度</strong>：<em>O</em>(1)。只需要常数空间存放若干变量。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-463-岛屿的周长&quot;&gt;&lt;a href=&quot;#Leetcode-463-岛屿的周长&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-463-岛屿的周长&quot;&gt;&lt;/a&gt;Leetcode-463-&lt;a href=&quot;https://leetcode-cn.com/problems/island-perimeter/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;岛屿的周长&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。&lt;/p&gt;
&lt;p&gt;网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。&lt;/p&gt;
&lt;p&gt;岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。&lt;strong&gt;计算这个岛屿的周长。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/154731661.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[0,1,0,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [1,1,1,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [0,1,0,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [1,1,0,0]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-20-文件的存储空间管理</title>
    <link href="http://zhuuu.work/2020/10/30/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-20-%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    <id>http://zhuuu.work/2020/10/30/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-20-%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/</id>
    <published>2020-10-30T02:00:53.000Z</published>
    <updated>2021-05-16T03:36:56.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-20-文件的存储空间管理"><a href="#操作系统-20-文件的存储空间管理" class="headerlink" title="操作系统-20-文件的存储空间管理"></a>操作系统-20-文件的存储空间管理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>操作系统对磁盘进行管理</strong></p><ul><li>对<strong>非空闲磁盘</strong>的管理（文件的分配方式）</li><li>对<strong>空闲磁盘</strong>的管理（文件的存储空间）</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/100452907.png" alt="mark"></p><a id="more"></a><h2 id="文件的存储空间管理"><a href="#文件的存储空间管理" class="headerlink" title="文件的存储空间管理"></a>文件的存储空间管理</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/100830136.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/100846144.png" alt="mark"></p><p><strong>接下来将一一介绍这些知识点</strong></p><h2 id="1-存储空间的划分和初始化"><a href="#1-存储空间的划分和初始化" class="headerlink" title="1. 存储空间的划分和初始化"></a>1. 存储空间的划分和初始化</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/162611539.png" alt="mark"></p><h2 id="2-文件空闲分配空间分配算法"><a href="#2-文件空闲分配空间分配算法" class="headerlink" title="2. 文件空闲分配空间分配算法"></a>2. 文件空闲分配空间分配算法</h2><ul><li><strong>文件存储设备管理实质上是对空闲块的组织和管理</strong></li></ul><h3 id="2-1-空闲表法"><a href="#2-1-空闲表法" class="headerlink" title="2.1 空闲表法"></a>2.1 空闲表法</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/162811554.png" alt="mark"></p><h3 id="2-2-空闲链表法"><a href="#2-2-空闲链表法" class="headerlink" title="2.2 空闲链表法"></a>2.2 空闲链表法</h3><p><strong>空闲链表法是将磁盘上的所有空闲空间以盘块位单位拉成一条链</strong></p><h4 id="2-2-1-空闲盘块链"><a href="#2-2-1-空闲盘块链" class="headerlink" title="2.2.1 空闲盘块链"></a>2.2.1 空闲盘块链</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/162946825.png" alt="mark"></p><h4 id="2-2-2-空闲盘区链"><a href="#2-2-2-空闲盘区链" class="headerlink" title="2.2.2 空闲盘区链"></a>2.2.2 空闲盘区链</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/163024433.png" alt="mark"></p><h3 id="2-3-位示图法"><a href="#2-3-位示图法" class="headerlink" title="2.3 位示图法"></a>2.3 位示图法</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/163116309.png" alt="mark"></p><p><strong>如何进行分配和回收？</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/163235928.png" alt="mark"></p><h3 id="2-4-成组链接法"><a href="#2-4-成组链接法" class="headerlink" title="2.4 成组链接法"></a>2.4 成组链接法</h3><ul><li><strong>Unix 采用成组链接法对磁盘空闲块进行管理</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/163702699.png" alt="mark"></p><h4 id="2-4-1-超级块"><a href="#2-4-1-超级块" class="headerlink" title="2.4.1 超级块"></a>2.4.1 超级块</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/163822214.png" alt="mark"></p><h4 id="2-4-2-分配策略"><a href="#2-4-2-分配策略" class="headerlink" title="2.4.2 分配策略"></a>2.4.2 分配策略</h4><ul><li><strong>需要1个空闲磁盘块</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/164120779.png" alt="mark"></p><ul><li><strong>需要分配100个空心块</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/164209348.png" alt="mark"></p><h4 id="2-4-3-回收策略"><a href="#2-4-3-回收策略" class="headerlink" title="2.4.3 回收策略"></a>2.4.3 回收策略</h4><ul><li><strong>回收区域未满</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/164258244.png" alt="mark"></p><ul><li><strong>回收区域已满</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201031/164404090.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-20-文件的存储空间管理&quot;&gt;&lt;a href=&quot;#操作系统-20-文件的存储空间管理&quot; class=&quot;headerlink&quot; title=&quot;操作系统-20-文件的存储空间管理&quot;&gt;&lt;/a&gt;操作系统-20-文件的存储空间管理&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;操作系统对磁盘进行管理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对&lt;strong&gt;非空闲磁盘&lt;/strong&gt;的管理（文件的分配方式）&lt;/li&gt;
&lt;li&gt;对&lt;strong&gt;空闲磁盘&lt;/strong&gt;的管理（文件的存储空间）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/100452907.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="文件管理" scheme="http://zhuuu.work/tags/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-19-文件的物理结构</title>
    <link href="http://zhuuu.work/2020/10/30/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-19-%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84/"/>
    <id>http://zhuuu.work/2020/10/30/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-19-%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84/</id>
    <published>2020-10-30T00:00:53.000Z</published>
    <updated>2021-05-16T03:36:51.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-19-文件的物理结构"><a href="#操作系统-19-文件的物理结构" class="headerlink" title="操作系统-19-文件的物理结构"></a>操作系统-19-文件的物理结构</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/085837475.png" alt="mark"></p><a id="more"></a><h2 id="1-文件块，磁盘块"><a href="#1-文件块，磁盘块" class="headerlink" title="1. 文件块，磁盘块"></a>1. 文件块，磁盘块</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/090314126.png" alt="mark"></p><h2 id="2-文件的实现（文件的分配方式）"><a href="#2-文件的实现（文件的分配方式）" class="headerlink" title="2. 文件的实现（文件的分配方式）"></a>2. 文件的实现（文件的分配方式）</h2><h3 id="2-1-连续分配方式"><a href="#2-1-连续分配方式" class="headerlink" title="2.1 连续分配方式"></a>2.1 连续分配方式</h3><ul><li><strong>优点</strong>：支持随机访问；顺序访问时速度最快（移动磁头所需的时间短） </li><li><strong>缺点</strong>：不方便文件扩展，每次扩展都得迁移到一段连续的空间，代价大；存储空间利用率低，产生磁盘碎片</li></ul><h3 id="2-2-链接分配方式"><a href="#2-2-链接分配方式" class="headerlink" title="2.2 链接分配方式"></a>2.2 链接分配方式</h3><p>链接分配采用离散分配的方式，消除了外部碎片</p><ul><li><strong>链接分配又分为</strong><ul><li><strong>显式链接</strong></li><li><strong>隐式链接</strong></li></ul></li></ul><h4 id="2-2-1-隐式链接"><a href="#2-2-1-隐式链接" class="headerlink" title="2.2.1 隐式链接"></a>2.2.1 隐式链接</h4><ul><li>不支持随机访问，查找效率低</li><li>方便拓展，磁盘利用率高</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/091949038.png" alt="mark"></p><h4 id="2-2-2-显示链接"><a href="#2-2-2-显示链接" class="headerlink" title="2.2.2 显示链接"></a>2.2.2 显示链接</h4><ul><li>逻辑块号转物理块号不需要访问磁盘，因此支持随机访问；扩展方便且不会有磁盘碎片</li><li>缺点是FAT要占用一定的存储空间</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/092112596.png" alt="mark"></p><h4 id="2-2-3-链式分配小结"><a href="#2-2-3-链式分配小结" class="headerlink" title="2.2.3 链式分配小结"></a>2.2.3 链式分配小结</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/092156870.png" alt="mark"></p><h3 id="2-3-索引分配"><a href="#2-3-索引分配" class="headerlink" title="2.3 索引分配"></a>2.3 索引分配</h3><ul><li>每一个文件建立一张索引表，其中记录文件的逻辑块对应的物理块。</li><li>存放索引表的磁盘块叫<strong>索引块</strong>，存放文件数据的磁盘块叫<strong>数据块</strong>。</li></ul><p><strong>索引分配支持直接访问，且没有外部碎片的问题。</strong></p><p><strong>但是每个文件都必须有一个索引块，因此索引块要尽可能的小。</strong></p><p>有如下几种方案减少索引块所占的空间：</p><ol><li><strong>链接方案</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/092725382.png" alt="mark"></p><ol start="2"><li><strong>多层索引</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/092811877.png" alt="mark"></p><ol start="3"><li><strong>混合索引</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/092832505.png" alt="mark"></p><p><strong>索引分配小结</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/092853080.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-19-文件的物理结构&quot;&gt;&lt;a href=&quot;#操作系统-19-文件的物理结构&quot; class=&quot;headerlink&quot; title=&quot;操作系统-19-文件的物理结构&quot;&gt;&lt;/a&gt;操作系统-19-文件的物理结构&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/085837475.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="文件管理" scheme="http://zhuuu.work/tags/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-129-求根到叶子节点数字之和</title>
    <link href="http://zhuuu.work/2020/10/29/Leetcode/Leetcode-129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"/>
    <id>http://zhuuu.work/2020/10/29/Leetcode/Leetcode-129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</id>
    <published>2020-10-29T07:22:53.000Z</published>
    <updated>2020-10-29T00:49:17.202Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-129-求根到叶子节点数字之和"><a href="#Leetcode-129-求根到叶子节点数字之和" class="headerlink" title="Leetcode-129-求根到叶子节点数字之和"></a><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">Leetcode-129-求根到叶子节点数字之和</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。</p><p>例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。</p><p>计算从根到叶子节点生成的所有数字之和。</p><p>说明: 叶子节点是指没有子节点的节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line">输出: 25</span><br><span class="line">解释:</span><br><span class="line">从根到叶子节点路径 1-&gt;2 代表数字 12.</span><br><span class="line">从根到叶子节点路径 1-&gt;3 代表数字 13.</span><br><span class="line">因此，数字总和 &#x3D; 12 + 13 &#x3D; 25.</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;sum-root-to-leaf-numbers</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br><span class="line"></span><br><span class="line">输入: [4,9,0,5,1]</span><br><span class="line">    4</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9   0</span><br><span class="line"> &#x2F; \</span><br><span class="line">5   1</span><br><span class="line">输出: 1026</span><br><span class="line">解释:</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.</span><br><span class="line">从根到叶子节点路径 4-&gt;0 代表数字 40.</span><br><span class="line">因此，数字总和 &#x3D; 495 + 491 + 40 &#x3D; 1026.</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;sum-root-to-leaf-numbers</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方法-：-DFS"><a href="#方法-：-DFS" class="headerlink" title="方法 ： DFS"></a>方法 ： DFS</h2><ul><li>深度优先搜索是很直观的做法。从根节点开始，遍历每个节点，如果遇到叶子节点，则将叶子节点对应的数字加到数字之和</li><li>如果<strong>当前节点不是叶子节点，则计算其子节点对应的数字，然后对子节点递归遍历。</strong></li><li>如果<strong>当前节点是叶子节点，直接返回sum即可</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201029/084301292.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root,<span class="keyword">int</span> prevSum)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1. 递归结束的条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 对叶子节点或者不是叶子节点的处理</span></span><br><span class="line">        <span class="keyword">int</span> sum = prevSum*<span class="number">10</span> + root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123; <span class="comment">//如果是叶子节点</span></span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(root.left,sum) + dfs(root.right,sum); <span class="comment">// 如果是根节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>： <em>O</em>(<em>n</em>)，其中<em>n</em> 是二叉树的节点个数。对每个节点访问一次。</li><li><strong>空间复杂度</strong>： <em>O</em>(<em>n</em>)，其中n 是二叉树节点的个数。空间复杂度主要取决于递归调用的栈空间，递归栈的深度等于二叉树的高度。（最坏情况下，空间复杂度为<em>O</em>(<em>n</em>)）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Leetcode-129-求根到叶子节点数字之和&quot;&gt;&lt;a href=&quot;#Leetcode-129-求根到叶子节点数字之和&quot; class=&quot;headerlink&quot; title=&quot;Leetcode-129-求根到叶子节点数字之和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/valid-palindrome/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode-129-求根到叶子节点数字之和&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。&lt;/p&gt;
&lt;p&gt;例如，从根到叶子节点路径 1-&amp;gt;2-&amp;gt;3 代表数字 123。&lt;/p&gt;
&lt;p&gt;计算从根到叶子节点生成的所有数字之和。&lt;/p&gt;
&lt;p&gt;说明: 叶子节点是指没有子节点的节点。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,2,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2   3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从根到叶子节点路径 1-&amp;gt;2 代表数字 12.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从根到叶子节点路径 1-&amp;gt;3 代表数字 13.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因此，数字总和 &amp;#x3D; 12 + 13 &amp;#x3D; 25.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;来源：力扣（LeetCode）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;链接：https:&amp;#x2F;&amp;#x2F;leetcode-cn.com&amp;#x2F;problems&amp;#x2F;sum-root-to-leaf-numbers&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [4,9,0,5,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  9   0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#x2F; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5   1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 1026&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从根到叶子节点路径 4-&amp;gt;9-&amp;gt;5 代表数字 495.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从根到叶子节点路径 4-&amp;gt;9-&amp;gt;1 代表数字 491.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从根到叶子节点路径 4-&amp;gt;0 代表数字 40.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因此，数字总和 &amp;#x3D; 495 + 491 + 40 &amp;#x3D; 1026.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;来源：力扣（LeetCode）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;链接：https:&amp;#x2F;&amp;#x2F;leetcode-cn.com&amp;#x2F;problems&amp;#x2F;sum-root-to-leaf-numbers&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://zhuuu.work/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Netty-06-核心组件</title>
    <link href="http://zhuuu.work/2020/10/28/Netty/Netty-06-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    <id>http://zhuuu.work/2020/10/28/Netty/Netty-06-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</id>
    <published>2020-10-28T10:05:24.000Z</published>
    <updated>2021-05-16T03:16:20.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-06-核心组件"><a href="#Netty-06-核心组件" class="headerlink" title="Netty-06-核心组件"></a>Netty-06-核心组件</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><strong>本文注重讲解Netty的核心组成</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/085701217.png" alt="mark"></p><h2 id="1-Bootstrap、ServerBootstrap"><a href="#1-Bootstrap、ServerBootstrap" class="headerlink" title="1. Bootstrap、ServerBootstrap"></a>1. Bootstrap、ServerBootstrap</h2><ul><li><code>Bootstrap</code> 意思是引导，一个 <code>Netty</code> 应用通常由一个 <code>Bootstrap</code> 开始，主要作用是配置整个 <code>Netty</code> 程序，串联各个组件，<code>Netty</code> 中 <code>Bootstrap</code> 类是客户端程序的启动引导类，<code>ServerBootstrap</code> 是服务端启动引导类</li></ul><p><strong>常见方法：</strong></p><table><thead><tr><th>方法名称</th><th>方法介绍</th></tr></thead><tbody><tr><td><code>public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)</code></td><td>该方法用于服务器端，用来设置两个EventLoop</td></tr><tr><td><code>public B group(EventLoopGroup group)</code></td><td>该方法用于客户端，用来设置一个EventLoop</td></tr><tr><td><code>public B channel(Class&lt;? extends C&gt; channelClass)</code></td><td>该方法用来设置一个服务器端的通道实现</td></tr><tr><td><code>public &lt;T&gt; B option(ChannelOption&lt;T&gt; option, T value)</code></td><td>用来给 ServerChannel 添加配置</td></tr><tr><td><code>public &lt;T&gt; ServerBootstrap childOption(ChannelOption&lt;T&gt; childOption, T value)</code></td><td>用来给接收到的通道添加配置</td></tr><tr><td><code>public ServerBootstrap childHandler(ChannelHandler childHandler)</code></td><td>该方法用来设置业务处理类（自定义的 handler）</td></tr><tr><td><code>public ChannelFuture bind(int inetPort)</code></td><td>该方法用于服务器端，用来设置占用的端口号</td></tr><tr><td><code>public ChannelFuture connect(String inetHost, int inetPort)</code></td><td>该方法用于客户端，用来连接服务器</td></tr></tbody></table><a id="more"></a><h2 id="2-Future、ChannelFuture"><a href="#2-Future、ChannelFuture" class="headerlink" title="2. Future、ChannelFuture"></a>2. Future、ChannelFuture</h2><ul><li><code>Netty</code> 中所有的 <code>IO</code> 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 <code>Future</code> 和 <code>ChannelFuture</code>，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件</li></ul><p><strong>常见的方法有</strong></p><table><thead><tr><th>方法名</th><th>方法介绍</th></tr></thead><tbody><tr><td><code>Channel channel()</code></td><td>返回当前正在进行 IO 操作的通道</td></tr><tr><td><code>ChannelFuture sync()</code></td><td>等待异步操作执行完毕，相当于将阻塞在当前。</td></tr></tbody></table><h2 id="3-Channel"><a href="#3-Channel" class="headerlink" title="3. Channel"></a>3. Channel</h2><ul><li><p><code>Netty</code> 网络通信的组件，能够用于执行网络 <code>I/O</code> 操作。</p></li><li><p>通过<code>Channel</code> 可获得当前网络连接的通道的状态</p></li><li><p>通过<code>Channel</code> 可获得 网络连接的配置参数 （例如接收缓冲区大小）</p></li><li><p><code>Channel</code> 提供异步的网络 <code>I/O</code> 操作(如建立连接，读写，绑定端口)，<strong>异步调用意味着任何 <code>I/O</code> 调用都将立即返回，并且不保证在调用结束时所请求的 <code>I/O</code> 操作已完成</strong></p></li><li><p><strong>调用立即返回一个 <code>ChannelFuture</code> 实例，通过注册监听器到 <code>ChannelFuture</code> 上，可以 <code>I/O</code> 操作成功、失败或取消时回调通知调用方</strong></p></li><li><p><strong>不同协议、不同的阻塞类型的连接都有不同的 <code>Channel</code> 类型与之对应</strong></p></li></ul><p><strong>常用的 <code>Channel</code> 类型</strong></p><table><thead><tr><th>名称</th><th>介绍</th></tr></thead><tbody><tr><td><code>NioSocketChannel</code></td><td>异步的客户端 TCP Socket 连接。</td></tr><tr><td><code>NioServerSocketChannel</code></td><td>异步的服务器端 TCP Socket 连接</td></tr><tr><td><code>NioDatagramChannel</code></td><td>异步的 UDP 连接。</td></tr><tr><td><code>NioSctpChannel</code></td><td>异步的客户端 Sctp 连接。</td></tr><tr><td><code>NioSctpServerChannel</code></td><td>异步的 Sctp 服务器端连接，这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO。</td></tr></tbody></table><h2 id="4-Seletor"><a href="#4-Seletor" class="headerlink" title="4. Seletor"></a>4. Seletor</h2><ul><li><p><strong><code>Netty</code> 基于 <code>Selector</code> 对象实现 <code>I/O</code> 多路复用，通过 <code>Selector</code> 一个线程可以监听多个连接的 <code>Channel</code> 事件。</strong></p></li><li><p>当向一个 <code>Selector</code> 中注册 <code>Channel</code> 后，<code>Selector</code> 内部的机制就可以自动不断地查询(<code>Select</code>) 这些注册的 <code>Channel</code> 是否有已就绪的 <code>I/O</code> 事件（例如可读，可写，网络连接完成等），这样程序就可以<strong>很简单地使用一个线程高效地管理多个 <code>Channel</code></strong></p></li><li><p>同时，<code>Netty</code>中对<code>selector</code>中的<code>selectedKey</code>集合进行了替换，它替换成了一个它自己实现的一个<code>set</code>集合，这样效率更高。</p></li></ul><h2 id="5-ChannelHandler"><a href="#5-ChannelHandler" class="headerlink" title="5. ChannelHandler"></a>5. ChannelHandler</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/123220946.png" alt="mark"></p><ul><li><strong><code>ChannelHandler</code> 是一个接口，处理 <code>I/O</code> 事件或拦截 <code>I/O</code> 操作，并将其转发到其 <code>ChannelPipeline</code>(业务处理链)中的下一个处理程序。</strong></li><li><strong><code>ChannelHandler</code> 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类</strong></li><li>我们经常需要<strong>自定义一个<code>Handler</code> 类去继承<code>ChannelInboundHandlerAdapter</code> ，然后通过相应方法实现业务逻辑，来看看有哪些方法需要重写</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201028/224217480.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelInboundHandlerAdapter</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">ChannelInboundHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通道注册事件</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelRegistered();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通道取消注册事件</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelUnregistered();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通道就绪事件</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#fireChannelInactive()&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelInboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelInactive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通道读取数据事件</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelRead(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通道数据读取完毕事件</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelReadComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#fireUserEventTriggered(Object)&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelInboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireUserEventTriggered(evt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#fireChannelWritabilityChanged()&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelInboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelWritabilityChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通道发生异常事件</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireExceptionCaught(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>再来回顾一下类图</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201028/224217480.png" alt="mark"></p><ul><li><code>ChannelInboundHandler</code> 用于处理入站 I/O 事件。</li><li><code>ChannelOutboundHandler</code> 用于处理出站 I/O 操作。</li></ul><p><strong>适配器</strong></p><ul><li><code>ChannelInboundHandlerAdapter</code> 用于处理入站 I/O 事件。</li><li><code>ChannelOutboundHandlerAdapter</code> 用于处理出站 I/O 操作。</li><li><code>ChannelDuplexHandler</code> 用于处理入站和出站事件。</li></ul><h2 id="7-Pipeline-和-ChannelPipeline"><a href="#7-Pipeline-和-ChannelPipeline" class="headerlink" title="7. Pipeline 和 ChannelPipeline"></a>7. Pipeline 和 ChannelPipeline</h2><ul><li><code>ChannelPipeline</code> 是一个 <code>Handler</code> 的集合，它负责处理和拦截 <code>inbound</code> 或者 <code>outbound</code> 的事件和操作，相当于一个贯穿 <code>Netty</code> 的链。(也可以这样理解：<code>ChannelPipeline</code> 是 保存 <code>ChannelHandler</code> 的 <code>List</code>，用于处理或拦截 <code>Channel</code> 的入站事件和出站操作)</li><li><code>ChannelPipeline</code> 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 <code>Channel</code> 中各个的 <code>ChannelHandler</code> 如何相互交互</li><li>在 <code>Netty</code> 中每个 <code>Channel</code> 都有且仅有一个 <code>ChannelPipeline</code> 与之对应，它们的组成关系如下</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201022/123220946.png" alt="mark"></p><p><strong>组成关系</strong></p><ul><li>一个 <code>Channel</code> 包含了一个 <code>ChannelPipeline</code>，而 <code>ChannelPipeline</code> 中又维护了一个由 <code>ChannelHandlerContext</code> 组成的<strong>双向链表</strong>，并且每个 <code>ChannelHandlerContext</code> 中又关联着一个 <code>ChannelHandler</code></li><li><strong>入站事件和出站事件在一个双向链表中</strong>，入站事件会从链表 <code>head</code> 往后传递到最后一个入站的 <code>handler</code>，出站事件会从链表 <code>tail</code> 往前传递到最前一个出站的 <code>handler</code>，两种类型的 <code>handler</code> 互不干扰</li></ul><p><strong>常用方法：</strong></p><table><thead><tr><th>方法名</th><th>介绍</th></tr></thead><tbody><tr><td><code>ChannelPipeline addFirst(ChannelHandler... handlers)</code></td><td>把一个业务处理类（handler）添加到链中的第一个位置</td></tr><tr><td>ChannelPipeline addLast(ChannelHandler… handlers)</td><td>把一个业务处理类（handler）添加到链中的最后一个位置</td></tr></tbody></table><h2 id="8-ChannelOption"><a href="#8-ChannelOption" class="headerlink" title="8. ChannelOption"></a>8. ChannelOption</h2><ul><li><code>Netty</code> 在创建 <code>Channel</code> 实例后,一般都需要设置 <code>ChannelOption</code> 参数。</li></ul><p><strong>ChannelOption 参数如下</strong></p><p><code>ChannelOption.SO_BACKLOG</code></p><ul><li><strong>对应 TCP/IP 协议 listen 函数中的 backlog 参数，用来初始化服务器可连接队列大小。</strong></li><li>服务端处理客户端连接请求是顺序处理的，所以同一时间只能处理一个客户端连接。多个客户端来的时候，<strong>服务端将不能处理的客户端连接请求放在队列中等待处理，backlog 参数指定了队列的大小。</strong></li></ul><p><code>ChannelOption.SO_KEEPALIVE</code></p><ul><li><strong>一直保持TCP连接活动的状态</strong></li></ul><h2 id="9-EventLoopGroup-和-NioEventLoopGroup"><a href="#9-EventLoopGroup-和-NioEventLoopGroup" class="headerlink" title="9. EventLoopGroup 和 NioEventLoopGroup"></a>9. EventLoopGroup 和 NioEventLoopGroup</h2><ul><li><code>EventLoopGroup</code> 是一组 <code>EventLoop</code> 的抽象，Netty为了更好的利用多核CPU资源，一般会有多个<code>EventLoop</code> 同时工作，每个<code>EventLoop</code>维护着一个Selector 实例</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201029/092123789.png" alt="mark"></p><ul><li><code>EventLoopGroup</code> 提供 next 接口，可以从组里面按照一定规则获取其中一个 <code>EventLoop</code>来处理任务。<ul><li>在 Netty 服务器端编程中，我们一般都需要提供两个 <code>EventLoopGroup</code>，例如：<code>BossEventLoopGroup</code> 和<code>WorkerEventLoopGroup</code>。</li></ul></li><li>通常一个服务端口即一个<code>ServerSocketChannel</code> 对应一个 <code>Selector</code> 和 一个<code>EventLoop</code> 线程。<ul><li>BossEventLoop 负责接收客户端的连接并将 SocketChannel 交给 WorkerEventLoopGroup 来进行 IO 处理</li></ul></li><li>BossEventLoopGroup 通常是一个单线程的 EventLoop，EventLoop 维护者一个注册了ServerSocketChannel 的Selector 实例BossEventLoop 不断轮询 Selector 将连接事件分离出来<ul><li>通常是 OP_ACCEPT 事件，然后将接收到的 SocketChannel 交给 WorkerEventLoopGroup</li><li>WorkerEventLoopGroup 会由 next 选择其中一个EventLoop 来讲这个SocketChannel 注册到其维护的Selector 并对和后续的IO事件进行处理</li></ul></li></ul><p><strong>常用方法：</strong></p><table><thead><tr><th>方法名</th><th>介绍</th></tr></thead><tbody><tr><td><code>public NioEventLoopGroup()</code></td><td>构造方法</td></tr><tr><td><code>public Future&lt;?&gt; shutdownGracefully()</code></td><td>断开连接，关闭线程</td></tr></tbody></table><h2 id="10-ByteBuf"><a href="#10-ByteBuf" class="headerlink" title="10. ByteBuf"></a>10. ByteBuf</h2><ul><li><strong>Netty 提供一个专门用来操作缓冲区(即Netty的数据容器)的工具类</strong></li></ul><p><strong>常用方法</strong></p><table><thead><tr><th>方法名</th><th>介绍</th></tr></thead><tbody><tr><td><code>public static ByteBuf copiedBuffer(CharSequence string, Charset charset)</code></td><td>通过给定的数据和字符编码返回一个 ByteBuf 对象（类似于 NIO 中的 ByteBuffer 但有区别）</td></tr></tbody></table><ul><li><strong>使用举例</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个ByteBuf</span></span><br><span class="line"><span class="comment">//1、创建对象，该对象包含一个数组，是一个byte[10]</span></span><br><span class="line"><span class="comment">//2、在netty的buffer中，写入数据后再读取数据不需要使用 flip 进行反转</span></span><br><span class="line"><span class="comment">// 底层维护了 readerIndex 和 writeIndex</span></span><br><span class="line"><span class="comment">//往buffer中写的范围为 [writeIndex, capacity)</span></span><br><span class="line"><span class="comment">//往buffer中可读的范围为 [readerIndex, writeIndex)。使用 buf.readByte() 会往后移动 readerIndex 指针，使用 buf.getByte(i) 通过索引获取就不会移动该指针</span></span><br><span class="line">ByteBuf byteBuf = Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    byteBuf.writeByte(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取该buf的大小</span></span><br><span class="line"><span class="keyword">int</span> capacity = byteBuf.capacity();</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; byteBuf.capacity(); i++) &#123;</span><br><span class="line">    System.out.println(byteBuf.getByte(i));</span><br><span class="line">    System.out.println(byteBuf.readByte());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">byte</span>[] content = byteBuf.array();</span><br><span class="line"><span class="comment">//将content转成字符串</span></span><br><span class="line">String c = <span class="keyword">new</span> String(content, StandardCharsets.UTF_8);</span><br><span class="line"><span class="comment">//数组偏移量</span></span><br><span class="line"><span class="keyword">int</span> offset = byteBuf.arrayOffset();</span><br><span class="line"><span class="comment">//获取读取偏移量</span></span><br><span class="line"><span class="keyword">int</span> readerIndex = byteBuf.readerIndex();</span><br><span class="line"><span class="comment">//获取写偏移量</span></span><br><span class="line"><span class="keyword">int</span> writerIndex = byteBuf.writerIndex();</span><br><span class="line"><span class="comment">//获取容量</span></span><br><span class="line"><span class="keyword">int</span> capacity = byteBuf.capacity();</span><br><span class="line"><span class="comment">//获取可读取的字节数</span></span><br><span class="line"><span class="keyword">int</span> readableBytes = byteBuf.readableBytes();</span><br><span class="line"><span class="comment">//通过索引获取某个位置的字节</span></span><br><span class="line"><span class="keyword">byte</span> aByte = byteBuf.getByte(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//获取Buf中某个范围的字符序列</span></span><br><span class="line">CharSequence charSequence = byteBuf.getCharSequence(<span class="number">0</span>, <span class="number">4</span>, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-06-核心组件&quot;&gt;&lt;a href=&quot;#Netty-06-核心组件&quot; class=&quot;headerlink&quot; title=&quot;Netty-06-核心组件&quot;&gt;&lt;/a&gt;Netty-06-核心组件&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;本文注重讲解Netty的核心组成&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/085701217.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-Bootstrap、ServerBootstrap&quot;&gt;&lt;a href=&quot;#1-Bootstrap、ServerBootstrap&quot; class=&quot;headerlink&quot; title=&quot;1. Bootstrap、ServerBootstrap&quot;&gt;&lt;/a&gt;1. Bootstrap、ServerBootstrap&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Bootstrap&lt;/code&gt; 意思是引导，一个 &lt;code&gt;Netty&lt;/code&gt; 应用通常由一个 &lt;code&gt;Bootstrap&lt;/code&gt; 开始，主要作用是配置整个 &lt;code&gt;Netty&lt;/code&gt; 程序，串联各个组件，&lt;code&gt;Netty&lt;/code&gt; 中 &lt;code&gt;Bootstrap&lt;/code&gt; 类是客户端程序的启动引导类，&lt;code&gt;ServerBootstrap&lt;/code&gt; 是服务端启动引导类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;常见方法：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法名称&lt;/th&gt;
&lt;th&gt;方法介绍&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;该方法用于服务器端，用来设置两个EventLoop&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;public B group(EventLoopGroup group)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;该方法用于客户端，用来设置一个EventLoop&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;public B channel(Class&amp;lt;? extends C&amp;gt; channelClass)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;该方法用来设置一个服务器端的通道实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;public &amp;lt;T&amp;gt; B option(ChannelOption&amp;lt;T&amp;gt; option, T value)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用来给 ServerChannel 添加配置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;public &amp;lt;T&amp;gt; ServerBootstrap childOption(ChannelOption&amp;lt;T&amp;gt; childOption, T value)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用来给接收到的通道添加配置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;public ServerBootstrap childHandler(ChannelHandler childHandler)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;该方法用来设置业务处理类（自定义的 handler）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;public ChannelFuture bind(int inetPort)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;该方法用于服务器端，用来设置占用的端口号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;public ChannelFuture connect(String inetHost, int inetPort)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;该方法用于客户端，用来连接服务器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="NIO" scheme="http://zhuuu.work/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Netty-07-群聊系统实现</title>
    <link href="http://zhuuu.work/2020/10/28/Netty/Netty-07-%E7%BE%A4%E8%81%8A%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/"/>
    <id>http://zhuuu.work/2020/10/28/Netty/Netty-07-%E7%BE%A4%E8%81%8A%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-10-28T10:05:24.000Z</published>
    <updated>2021-05-16T03:16:25.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-07-群聊系统实现"><a href="#Netty-07-群聊系统实现" class="headerlink" title="Netty-07-群聊系统实现"></a>Netty-07-群聊系统实现</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>实例要求</strong></p><ul><li>编写一个Netty 群聊系统，实现客户端和服务端之间的数据简单通信（非阻塞）</li><li>实现多人群聊</li><li>服务器端： 可以检测用户上线，离线，并实现消息的转发</li><li>客户端：通过channel 可以无阻塞发送消息给其他用户，同时可以接受其他用户发送来的消息（由）服务器转发得到</li><li>目的 ： 进一步理解Netty 非阻塞网络编程机制</li></ul><a id="more"></a><h2 id="1-服务端代码"><a href="#1-服务端代码" class="headerlink" title="1. 服务端代码"></a>1. 服务端代码</h2><h3 id="1-1-启动类"><a href="#1-1-启动类" class="headerlink" title="1.1 启动类"></a>1.1 启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编写run 方法，处理客户端请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="comment">// 创建两个线程组</span></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>,128)</span></span><br><span class="line"><span class="class">                    .<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>,<span class="title">true</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="string">"decoder"</span>,<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            pipeline.addLast(<span class="string">"encoder"</span>,<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> GroupChatHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"----- netty 服务端启动 -----"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 绑定端口</span></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(port).sync();</span><br><span class="line">            <span class="comment">// 监听关闭事件</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主方法启动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        GroupChatServer groupChatServer = <span class="keyword">new</span> GroupChatServer(<span class="number">7000</span>);</span><br><span class="line">        groupChatServer.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-Handler"><a href="#1-2-Handler" class="headerlink" title="1.2 Handler"></a>1.2 Handler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.ChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.DefaultChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.GlobalEventExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个channel组，管理所有的channel</span></span><br><span class="line">    <span class="comment">// GlobalEventExecutor.INSTANCE 是全局事件执行器，是一个单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ChannelGroup channelGroup = <span class="keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此方法表示连接建立，一旦建立连接就第一个被执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        <span class="comment">// 该方法会将channelGroup 中所有的channel 遍历，并发送消息而不需要我们自己去遍历</span></span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">"[客户端]"</span> + channel.remoteAddress() + sdf.format(<span class="keyword">new</span> Date()) + <span class="string">"加入了聊天"</span>);</span><br><span class="line">        <span class="comment">// 将当前的Channel 加入到 channelGroup</span></span><br><span class="line">        channelGroup.add(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示channel 处于活动状态，提示XXX已经上线</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">" "</span> + sdf.format(<span class="keyword">new</span> Date()) + <span class="string">"上线了~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示channel 断开连接，将xx客户端离开信息推送给当前在线用户</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">" "</span> + sdf.format(<span class="keyword">new</span> Date()) + <span class="string">"离线了~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// channel 关闭后会自动remove掉</span></span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">"[客户端]"</span> + channel.remoteAddress() +<span class="string">" "</span>+ sdf.format(<span class="keyword">new</span> Date()) + <span class="string">"离开了\n"</span>);</span><br><span class="line">        System.out.println(<span class="string">"当前channelGroup大小 ："</span> + channelGroup.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据进行消息的转发</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前的channel</span></span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历channelGroup 根据不同的情况回显不同的消息</span></span><br><span class="line">        channelGroup.forEach(item -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (item != channel)&#123;</span><br><span class="line">                item.writeAndFlush(<span class="string">"[客户]"</span> + channel.remoteAddress() + <span class="string">"发送了消息："</span> + msg + <span class="string">"\n"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                item.writeAndFlush(<span class="string">"[自己]发送了消息："</span> + msg + <span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-客户端代码"><a href="#2-客户端代码" class="headerlink" title="2. 客户端代码"></a>2. 客户端代码</h2><h3 id="2-1-客户端代码"><a href="#2-1-客户端代码" class="headerlink" title="2.1 客户端代码"></a>2.1 客户端代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        NioEventLoopGroup eventExecutors = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                    .group(eventExecutors)</span><br><span class="line">                    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//加入Handler</span></span><br><span class="line">                            pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> GroupChatClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// connect 事件</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(host, port).sync();</span><br><span class="line">            <span class="comment">// 得到channel,打印本地地址</span></span><br><span class="line">            Channel channel = channelFuture.channel();</span><br><span class="line">            System.out.println(<span class="string">"--------"</span> + channel.localAddress() + <span class="string">"---------"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 客户端需要输入信息</span></span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNextLine())&#123;</span><br><span class="line">                String msg = scanner.nextLine();</span><br><span class="line">                <span class="comment">// 通过channel 发送到服务器端</span></span><br><span class="line">                channel.writeAndFlush(msg + <span class="string">"\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            eventExecutors.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GroupChatClient(<span class="string">"127.0.0.1"</span>,<span class="number">7000</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-Handler"><a href="#2-2-Handler" class="headerlink" title="2.2  Handler"></a>2.2  Handler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(msg.trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-07-群聊系统实现&quot;&gt;&lt;a href=&quot;#Netty-07-群聊系统实现&quot; class=&quot;headerlink&quot; title=&quot;Netty-07-群聊系统实现&quot;&gt;&lt;/a&gt;Netty-07-群聊系统实现&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;实例要求&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编写一个Netty 群聊系统，实现客户端和服务端之间的数据简单通信（非阻塞）&lt;/li&gt;
&lt;li&gt;实现多人群聊&lt;/li&gt;
&lt;li&gt;服务器端： 可以检测用户上线，离线，并实现消息的转发&lt;/li&gt;
&lt;li&gt;客户端：通过channel 可以无阻塞发送消息给其他用户，同时可以接受其他用户发送来的消息（由）服务器转发得到&lt;/li&gt;
&lt;li&gt;目的 ： 进一步理解Netty 非阻塞网络编程机制&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="NIO" scheme="http://zhuuu.work/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-18-文件基础</title>
    <link href="http://zhuuu.work/2020/10/24/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-18-%E6%96%87%E4%BB%B6%E5%9F%BA%E7%A1%80/"/>
    <id>http://zhuuu.work/2020/10/24/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-18-%E6%96%87%E4%BB%B6%E5%9F%BA%E7%A1%80/</id>
    <published>2020-10-24T02:00:53.000Z</published>
    <updated>2021-05-16T03:36:45.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统-18-文件基础"><a href="#操作系统-18-文件基础" class="headerlink" title="操作系统-18-文件基础"></a>操作系统-18-文件基础</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/092059126.png" alt="mark"></p><a id="more"></a><h2 id="1-文件的属性"><a href="#1-文件的属性" class="headerlink" title="1. 文件的属性"></a>1. 文件的属性</h2><ul><li><strong>文件名</strong><br>主要是给用户看，同一个目录下不允许重名文件</li><li><strong>标识符</strong><br>一个系统内各文件标识符唯一，对用户毫无可读性，给操作系统看的</li><li><strong>类型</strong><br>文件扩展名</li><li><strong>位置</strong><br>文件存放路径，给用户看的，在外存中的地址用户是看不到的</li><li><strong>大小</strong></li><li><strong>创建时间</strong></li><li><strong>上次修改/访问时间</strong></li><li><strong>所有者信息</strong></li><li><strong>保护信息</strong></li></ul><h2 id="2-文件的逻辑结构"><a href="#2-文件的逻辑结构" class="headerlink" title="2. 文件的逻辑结构"></a>2. 文件的逻辑结构</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/092304381.png" alt="mark"></p><h3 id="2-1-无结构文件"><a href="#2-1-无结构文件" class="headerlink" title="2.1 无结构文件"></a>2.1 无结构文件</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/092424194.png" alt="mark"></p><h3 id="2-2-有结构文件"><a href="#2-2-有结构文件" class="headerlink" title="2.2 有结构文件"></a>2.2 有结构文件</h3><ul><li><p>又叫做 记录式 文件，<strong>比如数据库表，由一组相似的记录组成</strong></p></li><li><p>记录是一组相关的数据线的集合，<strong>每条记录有一个数据项可作为关键字</strong></p></li><li><p>根据记录的长度是否相等，可以分为</p><ul><li><strong>定长记录</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/092629157.png" alt="mark"></p><ul><li><strong>可变长记录</strong></li></ul></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/092639472.png" alt="mark">****</p><p><strong>有结构文件的逻辑结构</strong></p><h4 id="2-2-1-顺序文件"><a href="#2-2-1-顺序文件" class="headerlink" title="2.2.1 顺序文件"></a>2.2.1 顺序文件</h4><ul><li><p><strong>链式存储</strong><br>逻辑上相邻的记录，<strong>在物理上离散存储</strong>。<br>​无论是定长/可变长记录，都无法实现随机存取，只能从链头开始遍历</p></li><li><p><strong>顺序存储</strong></p><p>逻辑上相邻的记录，在物理上也相邻。<br>没有说明的情况下，顺序文件指采用顺序存储的顺序文件</p><ul><li><p><strong>可变长记录</strong><br>无法实现随机存取</p></li><li><p><strong>定长记录</strong><br>可以实现随机存储。如果采用串结构(记录顺序与关键字无关)，无法快速找到某个关键字对应的记录，如果采用顺序结构(记录按关键字排序的)，可以使用折半查找快速找到记录</p></li></ul></li></ul><h4 id="2-2-2-索引文件"><a href="#2-2-2-索引文件" class="headerlink" title="2.2.2 索引文件"></a>2.2.2 索引文件</h4><ul><li><strong>索引表本身是定长记录的顺序文件</strong>，</li><li>索引表项包含索引号，长度，指针，<strong>真正的记录可以在物理上离散存储</strong>。</li><li><strong>索引号可以是关键字</strong>，这样就能折半查找加快检索速度，用于对信息处理及时性要求高的场合，解决了顺序文件增删不便的问题 可以用不同的数据项建立多个索引表</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/092917082.png" alt="mark"></p><h4 id="2-2-3-索引顺序文件"><a href="#2-2-3-索引顺序文件" class="headerlink" title="2.2.3 索引顺序文件"></a>2.2.3 索引顺序文件</h4><ul><li><strong>将记录分组，每一个组对应一个索引表项</strong> </li><li><strong>检索记录时先检索索引表，找到分组，再顺序查找分组</strong> </li><li>记录过多时，可以建立多级索引表 记录N的表，平均查找次数是N/2</li></ul><ol><li><strong>索引文件的缺点</strong></li></ol><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/093155169.png" alt="mark"></p><p><strong>索引顺序文件的效率分析：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/093318355.png" alt="mark"></p><ul><li><strong>多级索引顺序文件</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/093407395.png" alt="mark"></p><h2 id="3-文件的目录结构"><a href="#3-文件的目录结构" class="headerlink" title="3. 文件的目录结构"></a>3. 文件的目录结构</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/093521886.png" alt="mark"></p><h3 id="3-1-文件控制块"><a href="#3-1-文件控制块" class="headerlink" title="3.1 文件控制块"></a>3.1 文件控制块</h3><ul><li><strong>一个FCB 对应一个文件，一个FCB就是一个目录项</strong>，</li><li><strong>FCB的有序集合叫“文件目录”</strong> </li><li>FCB包含了文件的基本信息，存取控制信息，使用信息等等，最重要的是文件名、文件存放的物理地址 对目录的操作:搜索、创建文件、删除文件、显示文件、修改文件</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/093627660.png" alt="mark"></p><ul><li><strong>对目录的操作分类</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/093700128.png" alt="mark"></p><h3 id="3-2-目录结构"><a href="#3-2-目录结构" class="headerlink" title="3.2 目录结构"></a>3.2 目录结构</h3><h4 id="3-2-1-单级目录结构"><a href="#3-2-1-单级目录结构" class="headerlink" title="3.2.1 单级目录结构"></a>3.2.1 单级目录结构</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/093735243.png" alt="mark"></p><h4 id="3-2-2-两级目录结构"><a href="#3-2-2-两级目录结构" class="headerlink" title="3.2.2 两级目录结构"></a>3.2.2 两级目录结构</h4><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/093830141.png" alt="mark"></p><h4 id="3-2-3-多级目录结构-树形目录结构"><a href="#3-2-3-多级目录结构-树形目录结构" class="headerlink" title="3.2.3 多级目录结构(树形目录结构)"></a>3.2.3 多级目录结构(树形目录结构)</h4><ul><li><p>共享不方便</p></li><li><p>从根目录出发的路径叫做<strong>绝对路径</strong></p></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/094017394.png" alt="mark"></p><ul><li>从当前目录出发的路径叫做<strong>相对路径</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/094026527.png" alt="mark"></p><h4 id="3-2-4-无环图目录结构"><a href="#3-2-4-无环图目录结构" class="headerlink" title="3.2.4 无环图目录结构"></a>3.2.4 无环图目录结构</h4><ul><li>树形目录结构能够便于实现文件分类，但是不利于文件共享</li><li><strong>为此在树形目录结构的基础上增加一些指向同一节点的有向边</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/094101496.png" alt="mark"></p><h3 id="3-3-索引节点"><a href="#3-3-索引节点" class="headerlink" title="3.3 索引节点"></a>3.3 索引节点</h3><ul><li><strong>FCB  的问题</strong></li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/094317250.png" alt="mark"></p><ul><li>存放在磁盘上的索引节点叫做<strong>磁盘索引节点</strong></li><li>当文件被打开的时候，磁盘索引节点复制到<strong>内存索引节点</strong>中</li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/094516179.png" alt="mark"></p><h2 id="4-文件的基本操作"><a href="#4-文件的基本操作" class="headerlink" title="4. 文件的基本操作"></a>4. 文件的基本操作</h2><ul><li><strong>创建文件(creat)</strong><ul><li>在外存中找到文件所需的<strong>空间</strong></li><li>根据<strong>文件路径找到对应的目录</strong>，创建文件对应的目录项</li></ul></li></ul><ul><li><strong>删除文件(delete)</strong><ul><li>根据文件路径找到对应的目录文件，找到文件名对应的目录项</li><li>回收文件占用的磁盘块</li><li>删除目录项</li></ul></li></ul><ul><li><strong>打开文件(open)</strong><ul><li>根据路径找到目录文件，找到文件名对应的目录项，检测用户的权限</li><li>将目录项复制到该进程在内存中的<strong>打开文件表</strong>中，返回<strong>表目编号</strong>(<strong>索引号/文件描述符FD</strong>)</li></ul></li></ul><ul><li><strong>关闭文件(close)</strong><ul><li>删除进程的打开文件表的对应项</li><li>回收分配给该文件的内存空间等资源</li><li>系统打开文件表的打开计数器count -= 1 (归零时删除该项)</li></ul></li></ul><ul><li><strong>读文件(read)</strong><ul><li>需要提供进程<strong>打开文件表中的索引号</strong>，读入的数据量，数据在内存中存放的位置</li><li>从读指针指向的外存位置读取指定大小的数据到指定的内存区域</li></ul></li></ul><ul><li><strong>写文件(write)</strong><ul><li>需要提供打开文件表中的索引号，写出的数据量，写回外存的数据位置(写指针指向)</li></ul></li></ul><h2 id="5-文件共享"><a href="#5-文件共享" class="headerlink" title="5. 文件共享"></a>5. 文件共享</h2><h3 id="5-1-基于索引节点的共享（硬链接）"><a href="#5-1-基于索引节点的共享（硬链接）" class="headerlink" title="5.1 基于索引节点的共享（硬链接）"></a>5.1 基于索引节点的共享（硬链接）</h3><ul><li>索引节点里面放了一个链接计数器 count </li></ul><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/094159031.png" alt="mark"></p><h3 id="5-2-基于符号链的共享（软链接）"><a href="#5-2-基于符号链的共享（软链接）" class="headerlink" title="5.2 基于符号链的共享（软链接）"></a>5.2 基于符号链的共享（软链接）</h3><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/094226319.png" alt="mark"></p><ul><li>系统会创建一个<strong>Link 类型的新文件</strong><ul><li><strong>新文件的路径名</strong>只被视为是符号链</li><li>在利用符号链实现文件共享时候<ul><li><strong>只有文件的拥有</strong>者才拥有指向其索引节点的指针</li><li><strong>共享该文件的其他用户</strong>只有该为文件的路径名</li></ul></li></ul></li></ul><h2 id="6-文件保护"><a href="#6-文件保护" class="headerlink" title="6. 文件保护"></a>6. 文件保护</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/094509107.png" alt="mark"></p><ol><li><strong>口令保护</strong></li><li><strong>加密保护</strong></li><li><strong>访问控制</strong></li></ol><h2 id="7-文件的系统层次结构"><a href="#7-文件的系统层次结构" class="headerlink" title="7. 文件的系统层次结构"></a>7. 文件的系统层次结构</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/094625764.png" alt="mark"></p><p><strong>举个例子：</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201030/094641719.png" alt="mark"></p><p><strong>参考书籍：《王道考研计算机操作系统》</strong></p><p><strong>参考博客</strong> ：<a href="https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh#o-1d01735b78f18c07f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统-18-文件基础&quot;&gt;&lt;a href=&quot;#操作系统-18-文件基础&quot; class=&quot;headerlink&quot; title=&quot;操作系统-18-文件基础&quot;&gt;&lt;/a&gt;操作系统-18-文件基础&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/092059126.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机基础理论" scheme="http://zhuuu.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
      <category term="操作系统" scheme="http://zhuuu.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="文件管理" scheme="http://zhuuu.work/tags/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Netty-05-异步模型</title>
    <link href="http://zhuuu.work/2020/10/24/Netty/Netty-05-%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B/"/>
    <id>http://zhuuu.work/2020/10/24/Netty/Netty-05-%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-10-24T00:05:24.000Z</published>
    <updated>2021-05-16T03:16:16.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-05-异步模型"><a href="#Netty-05-异步模型" class="headerlink" title="Netty-05-异步模型"></a>Netty-05-异步模型</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本文注重讲解Netty的<strong>异步模型</strong> 和 <strong>任务的队列</strong></li></ul><h2 id="1-任务队列"><a href="#1-任务队列" class="headerlink" title="1. 任务队列"></a>1. 任务队列</h2><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/085701217.png" alt="mark"></p><ul><li>任务队列由<code>NioEventLoop</code> 维护并且不断执行，当我们收到请求之后，在当前的 <code>channel</code> 中对应的 <code>pipeline</code>中的各个 <code>Hanlder</code>进行业务的处理和请求的过滤。</li><li>当某些业务需要消费大量事件的时候，我们可以将这些任务提交到由 <code>NioEventLoop</code> 维护的 <code>taskQueue</code> 或者 <code>ScheduleTaskQueue</code>中， 让当前的 NioEventLoop 线程在空闲的时候去执行这些任务。</li><li><strong>下面将介绍提交任务的三种方式:</strong></li></ul><a id="more"></a><h3 id="1-1-用户程序自定义的普通任务"><a href="#1-1-用户程序自定义的普通任务" class="headerlink" title="1.1 用户程序自定义的普通任务"></a>1.1 用户程序自定义的普通任务</h3><ul><li>该方式会将任务提交到<code>taskQueue</code>队列中。提交到该队列中的任务会按照提交顺序依次执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">channelHandlerContext.channel().eventLoop().execute(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="1-2-用户自定的定时任务"><a href="#1-2-用户自定的定时任务" class="headerlink" title="1.2 用户自定的定时任务"></a>1.2 用户自定的定时任务</h3><ul><li>该方式会将任务提交到<code>scheduleTaskQueue</code>定时任务队列中。该队列是底层是优先队列<code>PriorityQueue</code>实现的，固该队列中的任务会按照时间的先后顺序定时执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">channelHandlerContext.channel().eventLoop().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">60</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><h3 id="1-3-为其他的-EventLoop-线程对应的-Channel添加任务"><a href="#1-3-为其他的-EventLoop-线程对应的-Channel添加任务" class="headerlink" title="1.3 为其他的 EventLoop 线程对应的 Channel添加任务"></a>1.3 为其他的 EventLoop 线程对应的 Channel添加任务</h3><ul><li><strong>可以在<code>ChannelInitializer</code>中，将刚创建的各个<code>Channel</code>以及对应的标识加入到统一的集合中去</strong></li><li>然后可以根据表示获取 Channel 对应的 NioEventLoop,然后就可以调用<code>execute()</code>或者<code>schedule()</code>方法。</li></ul><h2 id="2-异步模型"><a href="#2-异步模型" class="headerlink" title="2. 异步模型"></a>2. 异步模型</h2><h3 id="2-1-异步的概念"><a href="#2-1-异步的概念" class="headerlink" title="2.1 异步的概念"></a>2.1 异步的概念</h3><ul><li>异步的概念和同步是相对的，当一个异步过程调用发出后，调用者不能立即的得到结果。实际处理这个调用的组件在完成后，<strong>通过状态，通知和回调来通知调用者</strong></li><li><code>Netty</code> 中的 <code>I/O</code> 操作是异步的，包括 <code>Bind</code>、<code>Write</code>、<code>Connect</code> 等操作会简单的返回一个 <code>ChannelFuture</code>。</li><li>调用者并不能立即获得结果，而是通过 <code>Future-Listener</code> 机制，用户可以方便的主动获取或者通过通知机构获取IO 的操作结果。</li></ul><p><strong>机制描述</strong></p><ul><li><code>Netty</code> 的异步模型是建立在 <code>future</code> 和 <code>callback</code> 的之上的。<code>callback</code> 就是回调。重点说 <code>Future</code>，它的核心思想是：假设一个方法 <code>fun</code>，计算过程可能非常耗时，等待 <code>fun</code>返回显然不合适。那么可以在调用 <code>fun</code> 的时候，立马返回一个 <code>Future</code>，后续可以通过 <code>Future</code>去监控方法 <code>fun</code> 的处理过程(即 ： <code>Future-Listener</code> 机制)</li></ul><p><strong>关于 Future 的说明</strong></p><ul><li>表示异步的执行结果, 可以通过它提供的方法来检测执行是否完成，比如检索计算等等.</li><li><code>ChannelFuture</code> 是一个接口 ： <code>public interface ChannelFuture extends Future&lt;Void&gt;</code>。我们可以添加监听器，当监听的事件发生时，就会通知到监听器</li></ul><p><strong>工作原理示意图</strong></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201028/215425984.png" alt="mark"></p><p><img src="http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201028/215442367.png" alt="mark"></p><ul><li>在使用 <code>Netty</code> 进行编程时，拦截操作和转换出入站数据只需要您提供 <code>callback</code> 或利用<code>future</code> 即可。这使得链式操作简单、高效, 并有利于编写可重用的、通用的代码。</li><li><code>Netty</code> 框架的目标就是让你的业务逻辑从网络基础应用编码中分离出来、解脱出来</li></ul><h3 id="2-2-Future-Listener-机制"><a href="#2-2-Future-Listener-机制" class="headerlink" title="2.2 Future-Listener 机制"></a>2.2 Future-Listener 机制</h3><ul><li>当 <code>Future</code> 对象刚刚创建时，处于非完成状态，调用者可以通过返回的 <code>ChannelFuture</code> 来获取操作执行的状态，注册监听函数来执行完成后的操作。</li></ul><p><strong>常用方法如下：</strong></p><table><thead><tr><th>方法名称</th><th>方法作用</th></tr></thead><tbody><tr><td>isDone()</td><td>判断当前操作是否完成</td></tr><tr><td>isSuccess()</td><td>判断已完成的当前操作是否成功</td></tr><tr><td>getCause()</td><td>获取已完成当前操作失败的原因</td></tr><tr><td>isCancelled()</td><td>判断已完成的当前操作是否被取消</td></tr><tr><td>addListener()</td><td>注册监听器，当前操作（Future）已完成，将会通知指定的监听器</td></tr></tbody></table><p><strong>举例说明</strong></p><ul><li>绑定端口操作时异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.bind(port).addListener(future -&gt; &#123;</span><br><span class="line">       <span class="keyword">if</span>(future.isSuccess()) &#123;</span><br><span class="line">           System.out.println(newDate() + <span class="string">": 端口["</span>+ port + <span class="string">"]绑定成功!"</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">           System.err.println(<span class="string">"端口["</span>+ port + <span class="string">"]绑定失败!"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><h3 id="2-3-HTTP-实战入门"><a href="#2-3-HTTP-实战入门" class="headerlink" title="2.3 HTTP 实战入门"></a>2.3 HTTP 实战入门</h3><p><strong>目标 ：  浏览器访问<code>Netty</code>服务器后，返回<code>HelloWorld</code></strong></p><ol><li><strong>启动器</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">TestServerInitializer</span>())</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 绑定端口号操作</span></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭线程池</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>自定义ChannelInitializer</strong></p><p><strong>用于给<code>Channel</code>对应的<code>pipeline</code>添加<code>handler</code></strong>。该<code>ChannelInitializer</code>中的代码在<code>SocketChannel</code>被创建时都会执行</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向管道加入处理器</span></span><br><span class="line">        <span class="comment">// 首先得到管道</span></span><br><span class="line">        ChannelPipeline pipeline = channel.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 加入一个netty提供的HttpServerCodec</span></span><br><span class="line">        <span class="comment">// netty自带的http编码解码器</span></span><br><span class="line">        pipeline.addLast(<span class="string">"MyHttpServerCodec"</span>,<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 增加自定义handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">"MyTestHttpServerHandler"</span>,<span class="keyword">new</span> TestHttpServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>自定义Handler</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHttpServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">HttpObject</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取客户端的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channelHandlerContext</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> httpObject 客户端和服务端互相通讯所使用的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, HttpObject httpObject)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 判断msg 是不是 HttpRequest请求</span></span><br><span class="line">        <span class="keyword">if</span>(httpObject <span class="keyword">instanceof</span> HttpRequest)&#123;</span><br><span class="line">            System.out.println(<span class="string">"msg 类型 = "</span> + httpObject.getClass());</span><br><span class="line">            System.out.println(<span class="string">"客户端地址："</span> + channelHandlerContext.channel().remoteAddress());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取http请求</span></span><br><span class="line">            HttpRequest request = (HttpRequest) httpObject;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从http请求中获取uri</span></span><br><span class="line">            URI uri = <span class="keyword">new</span> URI(request.uri());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 过滤http中的请求</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"/favicon.ico"</span>.equals(uri.getPath()))&#123;</span><br><span class="line">                System.out.println(<span class="string">"请求了 favicon.ico，不做响应"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回复信息给浏览器[http协议]</span></span><br><span class="line">            ByteBuf content = Unpooled.copiedBuffer(<span class="string">"helloWorld"</span>, CharsetUtil.UTF_8);</span><br><span class="line">            <span class="comment">// 构造一个http响应回复给浏览器</span></span><br><span class="line">            DefaultFullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_TYPE,<span class="string">"text/plain"</span>);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_LENGTH,content.readableBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将构建好的response返回给客户端</span></span><br><span class="line">            channelHandlerContext.writeAndFlush(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Netty-05-异步模型&quot;&gt;&lt;a href=&quot;#Netty-05-异步模型&quot; class=&quot;headerlink&quot; title=&quot;Netty-05-异步模型&quot;&gt;&lt;/a&gt;Netty-05-异步模型&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本文注重讲解Netty的&lt;strong&gt;异步模型&lt;/strong&gt; 和 &lt;strong&gt;任务的队列&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-任务队列&quot;&gt;&lt;a href=&quot;#1-任务队列&quot; class=&quot;headerlink&quot; title=&quot;1. 任务队列&quot;&gt;&lt;/a&gt;1. 任务队列&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/20201024/085701217.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任务队列由&lt;code&gt;NioEventLoop&lt;/code&gt; 维护并且不断执行，当我们收到请求之后，在当前的 &lt;code&gt;channel&lt;/code&gt; 中对应的 &lt;code&gt;pipeline&lt;/code&gt;中的各个 &lt;code&gt;Hanlder&lt;/code&gt;进行业务的处理和请求的过滤。&lt;/li&gt;
&lt;li&gt;当某些业务需要消费大量事件的时候，我们可以将这些任务提交到由 &lt;code&gt;NioEventLoop&lt;/code&gt; 维护的 &lt;code&gt;taskQueue&lt;/code&gt; 或者 &lt;code&gt;ScheduleTaskQueue&lt;/code&gt;中， 让当前的 NioEventLoop 线程在空闲的时候去执行这些任务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;下面将介绍提交任务的三种方式:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="IO" scheme="http://zhuuu.work/tags/IO/"/>
    
      <category term="Netty" scheme="http://zhuuu.work/tags/Netty/"/>
    
      <category term="NIO" scheme="http://zhuuu.work/tags/NIO/"/>
    
  </entry>
  
</feed>
