<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="Java Python" />
   
  <meta name="description" content="From Zero to Hero" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    kafka-01-简介 |  朱酱酱的学习博客
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>


  

  

<link rel="alternate" href="/atom.xml" title="朱酱酱的学习博客" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content">
      <section class="outer">
  <article id="post-kafka/kafka-01-简介" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  kafka-01-简介
</h1>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/10/13/kafka/kafka-01-%E7%AE%80%E4%BB%8B/" class="article-date">
  <time datetime="2021-10-13T09:02:24.000Z" itemprop="datePublished">2021-10-13</time>
</a>
      
      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">6k字</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">20分钟</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="kafka-01-简介"><a href="#kafka-01-简介" class="headerlink" title="kafka-01-简介"></a>kafka-01-简介</h1><h2 id="前言-why-learning"><a href="#前言-why-learning" class="headerlink" title="前言: why learning?"></a>前言: why learning?</h2><p><strong>官方文档</strong>：<a href="https://kafka.apache.org/" target="_blank" rel="noopener">https://kafka.apache.org/</a></p>
<p><strong>注意：</strong>⚠️：<strong>此篇废话较多</strong></p>
<ul>
<li>你可能会有这样的疑问，<strong>我为什么要学习 Kafka 呢</strong>？要回答这个问题，我们不妨从更大的视角来审视它，先聊聊我对这几年互联网技术发展的理解吧。</li>
<li>互联网蓬勃发展的这些年涌现出了很多令人眼花缭乱的新技术。当下互联网行业最火的技术当属 ABC 了，即所谓的 AI 人工智能、BigData 大数据和 Cloud 云计算云平台。我个人对区块链技术发展前景存疑，毕竟目前没有看到特别好的落地应用场景，也许在未来几年它会更令人刮目相看吧。</li>
<li>对于数据密集型应用来说，如何应对数据量激增、数据复杂度增加以及数据变化速率变快，是彰显大数据工程师、架构师功力的最有效表征。</li>
<li>Kafka 在帮助你应对这些问题方面能起到非常好的效果。就拿数据量激增来说，Kafka 能够有效隔离上下游业务，将上游突增的流量缓存起来，以平滑的方式传导到下游子系统中，避免了流量的不规则冲击。由此可见，如果你是一名大数据从业人员，熟练掌握 Kafka 是非常必要的一项技能。<ul>
<li>刚刚所举的例子仅仅是 Kafka 助力业务的一个场景罢了。事实上，Kafka 有着非常广阔的应用场景。不谦虚地说，目前 Apache Kafka 被认为是整个消息引擎领域的执牛耳者，仅凭这一点就值得我们好好学习一下它。</li>
<li>另外，从学习技术的角度而言，Kafka 也是很有亮点的。仅需要学习一套框架就能在实际业务系统中实现消息引擎应用、应用程序集成、分布式存储构建，甚至是流处理应用的开发与部署，听起来还是很超值的吧。</li>
</ul>
</li>
</ul>
<p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-11-17-030034.jpg" alt=""></p>
<a id="more"></a>



<h2 id="1-学习方式建议"><a href="#1-学习方式建议" class="headerlink" title="1. 学习方式建议"></a>1. 学习方式建议</h2><ul>
<li>总之 Kafka 是个利器，值得一试！既然知道了为什么要学 Kafka，那我们就要行动起来，把它学透，而学透 Kafka 有什么路径吗？<ul>
<li>如果你是一名软件开发工程师的话，掌握 Kafka 的第一步就是要根据你掌握的编程语言去寻找对应的 Kafka 客户端。当前 Kafka 最重要的两大客户端是 Java 客户端和 libkafka 客户端，它们更新和维护的速度很快，非常适合你持续花时间投入。</li>
<li>一旦确定了要使用的客户端，马上去官网上学习一下代码示例，如果能够正确编译和运行这些样例，你就能轻松地驾驭客户端了。<ul>
<li>下一步你可以尝试修改样例代码尝试去理解并使用其他的 <code>API</code>，之后观测你修改的结果。如果这些都没有难倒你，你可以自己编写一个小型项目来验证下学习成果，然后就是改善和提升客户端的可靠性和性能了。到了这一步，你可以熟读一遍 <code>Kafka</code> 官网文档，确保你理解了那些可能影响可靠性和性能的参数。</li>
<li>最后是学习 <code>Kafka</code> 的高级功能，比如流处理应用开发。流处理 API 不仅能够生产和消费消息，还能执行高级的流式处理操作，比如时间窗口聚合、流处理连接等。</li>
</ul>
</li>
<li>如果你是系统管理员或运维工程师，那么相应的学习目标应该是学习搭建及管理<code>Kafka</code>线上环境。如何根据实际业务需求评估、搭建生产线上环境将是你主要的学习目标。另外对生产环境的监控也是重中之重的工作，<code>Kafka</code>提供了超多的 <code>JMX</code>监控指标，你可以选择任意你熟知的框架进行监控。有了监控数据，作为系统运维管理员的你，势必要观测真实业务负载下的<code>Kafka</code> 集群表现。之后如何利用已有的监控指标来找出系统瓶颈，然后提升整个系统的吞吐量，这也是最能体现你工作价值的地方。</li>
</ul>
</li>
</ul>
<p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-11-17-030632.jpg" alt=""></p>
<h2 id="2-消息引擎"><a href="#2-消息引擎" class="headerlink" title="2. 消息引擎"></a>2. 消息引擎</h2><ul>
<li><p>毫无疑问，你现在对 <code>Apache Kafka</code> 一定充满了各种好奇，那么今天就允许我先来尝试回答下 Kafka 是什么这个问题。</p>
<ul>
<li>对了，先卖个关子，在下一期我还将继续回答这个问题，而且答案是不同的。那么，Kafka 是什么呢？用一句话概括一下：<strong>Apache Kafka 是一款开源的消息引擎系统</strong>。</li>
</ul>
</li>
<li><p>倘若“消息引擎系统”这个词对你来说有点陌生的话，那么“消息队列”“消息中间件”的提法想必你一定是有所耳闻的。不过说实话我更愿意使用消息引擎系统这个称谓，因为消息队列给出了一个很不明确的暗示，仿佛 Kafka 是利用队列的方式构建的；而消息中间件的提法有过度夸张“中间件”之嫌，让人搞不清楚这个中间件到底是做什么的。</p>
</li>
<li><p>根据维基百科的定义，消息引擎系统是一组规范。企业利用这组规范在不同系统之间传递语义准确的消息，实现松耦合的异步式数据传递。</p>
<ul>
<li>系统 A 发送消息给消息引擎系统，系统 B 从消息引擎系统中读取 A 发送的消息。</li>
<li>最基础的消息引擎就是做这点事的！不论是上面哪个版本，它们都提到了两个重要的事实：<ul>
<li>消息引擎传输的对象是消息；</li>
<li>如何传输消息属于消息引擎设计机制的一部分。</li>
</ul>
</li>
</ul>
</li>
<li><p>一个比较容易想到的是使用已有的一些成熟解决方案</p>
<ul>
<li>比如使用 CSV、XML 亦或是 JSON；</li>
<li>又或者你可能熟知国外大厂开源的一些序列化框架，比如 Google 的 Protocol Buffer 或 Facebook 的 Thrift。</li>
<li>这些都是很酷的办法。<strong>那么现在我告诉你 Kafka 的选择：它使用的是纯二进制的字节序列</strong>。当然消息还是结构化的，只是在使用之前都要将其转换成二进制的字节序列。</li>
</ul>
</li>
</ul>
<ul>
<li><p>消息设计出来之后还不够，消息引擎系统还要设定具体的传输协议，即我用什么方法把消息传输出去。常见的有两种方法：</p>
<ul>
<li><strong>点对点模型</strong>：也叫消息队列模型。如果拿上面那个“民间版”的定义来说，那么系统 A 发送的消息只能被系统 B 接收，其他任何系统都不能读取 A 发送的消息。日常生活的例子比如电话客服就属于这种模型：同一个客户呼入电话只能被一位客服人员处理，第二个客服人员不能为该客户服务。</li>
<li><strong>发布 / 订阅模型</strong>：与上面不同的是，它有一个主题（Topic）的概念，你可以理解成逻辑语义相近的消息容器。该模型也有发送方和接收方，只不过提法不同。<ul>
<li>发送方也称为发布者（Publisher），接收方称为订阅者（Subscriber）。和点对点模型不同的是，这个模型可能存在多个发布者向相同的主题发送消息，而订阅者也可能存在多个，它们都能接收到相同主题的消息。生活中的报纸订阅就是一种典型的发布 / 订阅模型。</li>
</ul>
</li>
<li><strong>比较酷的是 Kafka 同时支持这两种消息引擎模型</strong></li>
</ul>
</li>
<li><p>提到消息引擎系统，你可能会问 JMS 和它是什么关系。JMS 是<code>Java Message Service</code>，它也是支持上面这两种消息引擎模型的。严格来说它并非传输协议而仅仅是一组 API 罢了。不过可能是 JMS 太有名气以至于很多主流消息引擎系统都支持 JMS 规范</p>
<ul>
<li>比如 <code>ActiveMQ、RabbitMQ</code>、<code>IBM 的 WebSphere MQ 和 Apache Kafka</code>。当然 Kafka 并未完全遵照 JMS 规范，相反，它另辟蹊径，探索出了一条特有的道路。</li>
</ul>
</li>
<li><p>目前我们仅仅是了解了消息引擎系统是做什么的以及怎么做的，但还有个重要的问题是为什么要使用它。</p>
<ul>
<li>答案就是“<strong>削峰填谷</strong>”。这四个字简直比消息引擎本身还要有名气。</li>
<li>我翻了很多文献，最常见的就是这四个字。所谓的“削峰填谷”就是指缓冲上下游瞬时突发流量，使其更平滑。特别是对于那种发送能力很强的上游系统</li>
<li>如果没有消息引擎的保护，“脆弱”的下游系统可能会直接被压垮导致全链路服务“雪崩”。<ul>
<li>但是，一旦有了消息引擎，它能够有效地对抗上游的流量冲击，真正做到将上游的“峰”填满到“谷”中，避免了流量的震荡。消息引擎系统的另一大好处在于发送方和接收方的松耦合，这也在一定程度上简化了应用的开发，减少了系统间不必要的交互。</li>
</ul>
</li>
<li><strong>说了这么多，可能你对“削峰填谷”并没有太多直观的感受。</strong><ul>
<li>举个例子来说明一下 <code>Kafka</code>在这中间是怎么去“抗”峰值流量的吧。</li>
<li>订单的每门课程都有一个专门的订阅按钮，点击之后进入到付费页面。这个简单的流程中就可能包含多个子服务，比如点击订阅按钮会调用订单系统生成对应的订单，而处理该订单会依次调用下游的多个子系统服务 ，比如调用支付宝和微信支付的接口、查询你的登录信息、验证课程信息等。</li>
<li>显然上游的订单操作比较简单，它的 TPS 要远高于处理订单的下游服务，因此如果上下游系统直接对接，势必会出现下游服务无法及时处理上游订单从而造成订单堆积的情形。特别是当出现类似于秒杀这样的业务时，上游订单流量会瞬时增加，可能出现的结果就是直接压跨下游子系统服务。</li>
<li>解决此问题的一个常见做法是我们对上游系统进行限速，但这种做法对上游系统而言显然是不合理的，毕竟问题并不出现在它那里。所以更常见的办法是引入像 Kafka 这样的消息引擎系统来对抗这种上下游系统 TPS 的错配以及瞬时峰值流量。</li>
<li>还是这个例子，当引入了 Kafka 之后。<strong>上游订单服务</strong>不再直接与下游子服务进行交互。当新订单生成后它仅仅是向 <code>Kafka Broker</code>发送一条订单消息即可。</li>
<li>类似地，<strong>下游的各个子服务订阅 Kafka 中的对应主题</strong>，并实时从该主题的各自分区（Partition）中获取到订单消息进行处理，从而实现了上游订单服务与下游订单处理服务的解耦。<ul>
<li>这样当出现秒杀业务时，<strong>Kafka 能够将瞬时增加的订单流量全部以消息形式保存在对应的主题中，既不影响上游服务的 TPS，同时也给下游子服务留出了充足的时间去消费它们。这就是 Kafka 这类消息引擎系统的最大意义所在。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>如果你对 <code>Kafka Broker</code>、主题和分区等术语还不甚了解的话也不必担心，我会在专栏后面专门花时间介绍一下<code>Kafka</code>的常见概念和术语。</p>
</li>
</ul>
<h2 id="3-Kafka-的术语"><a href="#3-Kafka-的术语" class="headerlink" title="3. Kafka 的术语"></a>3. Kafka 的术语</h2><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-11-17-070118.png" alt=""></p>
<h3 id="3-1-生产者与消费者"><a href="#3-1-生产者与消费者" class="headerlink" title="3.1 生产者与消费者"></a>3.1 生产者与消费者</h3><ul>
<li>向主题发布消息的客户端应用程序称为生产者（<code>Producer</code>），生产者程序通常持续不断地向一个或多个主题发送消息，而订阅这些主题消息的客户端应用程序就被称为消费者（<code>Consumer</code>）。</li>
<li>和生产者类似，消费者也能够同时订阅多个主题的消息。我们把<strong>生产者和消费者统称为客户端（Clients）。</strong></li>
<li>你可以同时运行多个生产者和消费者实例，这些实例会不断地向 Kafka 集群中的多个主题生产和消费消息。</li>
</ul>
<h3 id="3-2-服务端"><a href="#3-2-服务端" class="headerlink" title="3.2 服务端"></a>3.2 服务端</h3><ul>
<li>有客户端自然也就有服务器端。<code>Kafka</code> 的服务器端由被称为 <code>Broker</code> 的服务进程构成，即一个 Kafka 集群由多个 <code>Broker</code>组成，<code>Broker</code>负责接收和处理客户端发送过来的请求，以及对消息进行持久化。</li>
<li>虽然多个 <code>Broker</code>进程能够运行在同一台机器上，但更常见的做法是将不同的 Broker 分散运行在不同的机器上，这样如果集群中某一台机器宕机，即使在它上面运行的所有 Broker 进程都挂掉了，其他机器上的 <code>Broker</code> 也依然能够对外提供服务。这其实就是 Kafka 提供高可用的手段之一。</li>
</ul>
<h3 id="3-3-备份机制"><a href="#3-3-备份机制" class="headerlink" title="3.3 备份机制"></a>3.3 备份机制</h3><ul>
<li><p>实现高可用的另一个手段就是备份机制（<code>Replication</code>）。</p>
</li>
<li><p>备份的思想很简单，就是把相同的数据拷贝到多台机器上，而这些相同的数据拷贝在 Kafka 中被称为副本（<code>Replica</code>）。</p>
</li>
<li><p>其实在整个分布式系统里好像都叫这个名字。副本的数量是可以配置的，这些副本保存着相同的数据，但却有不同的角色和作用。</p>
</li>
<li><p><code>Kafka</code> 定义了两类副本：领导者副本（<code>Leader Replica</code>）和追随者副本（<code>Follower Replica</code>）。</p>
<ul>
<li>前者对外提供服务，这里的对外指的是与客户端程序进行交互；而后者只是被动地追随领导者副本而已，不能与外界进行交互。</li>
<li>当然了，你可能知道在很多其他系统中追随者副本是可以对外提供服务的，比如 MySQL 的从库是可以处理读操作的，但是在 Kafka 中追随者副本不会对外提供服务。</li>
<li>对了，一个有意思的事情是现在已经不提倡使用 Master-Slave 来指代这种主从关系了，毕竟 Slave 有奴隶的意思，在美国这种严禁种族歧视的国度，这种表述有点政治不正确了，所以目前大部分的系统都改成 <code>Leader-Follower</code> 了。</li>
</ul>
</li>
<li><p>副本的工作机制也很简单：生产者总是向领导者副本写消息；而消费者总是从领导者副本读消息。至于追随者副本，它只做一件事：向领导者副本发送请求，请求领导者把最新生产的消息发给它，这样它能保持与领导者的同步。</p>
</li>
</ul>
<h3 id="3-4-伸缩性"><a href="#3-4-伸缩性" class="headerlink" title="3.4 伸缩性"></a>3.4 伸缩性</h3><ul>
<li><p>虽然有了副本机制可以保证数据的持久化或消息不丢失，但没有解决伸缩性的问题。伸缩性即所谓的 <code>Scalability</code>，是分布式系统中非常重要且必须要谨慎对待的问题。</p>
</li>
<li><p>什么是伸缩性呢？</p>
<ul>
<li>拿副本来说，虽然现在有了领导者副本和追随者副本，但倘若领导者副本积累了太多的数据以至于单台 Broker 机器都无法容纳了，此时应该怎么办呢？一个很自然的想法就是，能否把数据分割成多份保存在不同的 Broker 上？如果你就是这么想的，那么恭喜你，Kafka 就是这么设计的。</li>
</ul>
</li>
<li><p>这种机制就是所谓的分区（<code>Partitioning</code>）。如果你了解其他分布式系统，你可能听说过分片、分区域等提法，比如 <code>MongoDB</code> 和 <code>Elasticsearch</code>中的<code>Sharding、HBase 中的</code> <code>Region</code>，其实它们都是相同的原理，只是 <code>Partitioning</code> 是最标准的名称。</p>
</li>
</ul>
<h3 id="3-5-分区"><a href="#3-5-分区" class="headerlink" title="3.5 分区"></a>3.5 分区</h3><ul>
<li><p>Kafka 中的分区机制指的是将每个主题划分成多个分区（Partition），每个分区是一组有序的消息日志。</p>
</li>
<li><p>生产者生产的每条消息只会被发送到一个分区中，也就是说如果向一个双分区的主题发送一条消息，这条消息要么在分区 0 中，要么在分区 1 中。如你所见，Kafka 的分区编号是从 0 开始的，如果 Topic 有 100 个分区，那么它们的分区号就是从 0 到 99。</p>
</li>
<li><p>讲到这里，你可能有这样的疑问：刚才提到的副本如何与这里的分区联系在一起呢？实际上，副本是在分区这个层级定义的。每个分区下可以配置若干个副本，其中只能有 1 个领导者副本和 N-1 个追随者副本。</p>
</li>
<li><p>生产者向分区写入消息，每条消息在分区中的位置信息由一个叫位移（<code>Offset</code>）的数据来表征。分区位移总是从 0 开始，假设一个生产者向一个空分区写入了 10 条消息，那么这 10 条消息的位移依次是 <code>0、1、2、…、9</code>。</p>
</li>
</ul>
<h2 id="4-Kafka-三层消息架构"><a href="#4-Kafka-三层消息架构" class="headerlink" title="4. Kafka 三层消息架构"></a>4. Kafka 三层消息架构</h2><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-11-17-070118.png" alt=""></p>
<p>至此我们能够完整地串联起 Kafka 的三层消息架构：</p>
<ul>
<li>第一层是主题层，每个主题可以配置 <code>M</code> 个分区，而每个分区又可以配置<code>N</code>个副本。</li>
<li>第二层是分区层，每个分区的 N 个副本中只能有一个充当领导者角色，对外提供服务；其他 <code>N-1</code> 个副本是追随者副本，只是提供数据冗余之用。</li>
<li>第三层是消息层，分区中包含若干条消息，每条消息的位移从 0 开始，依次递增。</li>
<li><strong>最后，客户端程序只能与分区的领导者副本进行交互。</strong></li>
</ul>
<h2 id="5-持久化技术"><a href="#5-持久化技术" class="headerlink" title="5. 持久化技术"></a>5. 持久化技术</h2><ul>
<li>讲完了消息层次，现在来说说<code>Kafka Broker</code> 是如何持久化数据的。</li>
<li>总的来说，Kafka 使用消息日志（<code>Log</code>）来保存数据，一个日志就是磁盘上一个只能追加写（<code>Append-only</code>）消息的物理文件。<ul>
<li>因为只能追加写入，故避免了缓慢的随机<code>I/O</code> 操作，改为性能较好的顺序 I/O 写操作，这也是实现 Kafka 高吞吐量特性的一个重要手段。</li>
<li>不过如果你不停地向一个日志写入消息，最终也会耗尽所有的磁盘空间，因此 <code>Kafka</code> 必然要定期地删除消息以回收磁盘。</li>
<li>怎么删除呢？简单来说就是通过日志段（<code>Log Segment</code>）机制。<ul>
<li>在<code>Kafka</code> 底层，一个日志又近一步细分成多个日志段，消息被追加写到当前最新的日志段中，当写满了一个日志段后，<code>Kafka</code>会自动切分出一个新的日志段，并将老的日志段封存起来。</li>
<li><code>Kafka</code>在后台还有定时任务会定期地检查老的日志段是否能够被删除，从而实现回收磁盘空间的目的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-再说消费者"><a href="#6-再说消费者" class="headerlink" title="6. 再说消费者"></a>6. 再说消费者</h2><h3 id="6-1-消费者组"><a href="#6-1-消费者组" class="headerlink" title="6.1 消费者组"></a>6.1 消费者组</h3><ul>
<li>这里再重点说说消费者。在第一期中我提到过两种消息模型，即<ul>
<li>点对点模型（<code>Peer to Peer，P2P</code>）</li>
<li>发布订阅模型。<ul>
<li>这里面的点对点指的是同一条消息只能被下游的一个消费者消费，其他消费者则不能染指。</li>
<li>在 Kafka 中实现这种 P2P 模型的方法就是引入了消费者组（<code>Consumer Group</code>）。所谓的消费者组，指的是多个消费者实例共同组成一个组来消费一组主题。</li>
<li>这组主题中的每个分区都只会被组内的一个消费者实例消费，其他消费者实例不能消费它。</li>
<li>为什么要引入消费者组呢？主要是为了提升消费者端的吞吐量。多个消费者实例同时消费，加速整个消费端的吞吐量（TPS）。<ul>
<li>会在后面详细介绍消费者组机制，所以现在你只需要了解消费者组是做什么的即可。另外这里的消费者实例可以是运行消费者应用的进程，也可以是一个线程，它们都称为一个消费者实例（<code>Consumer Instance</code>）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-2-重平衡"><a href="#6-2-重平衡" class="headerlink" title="6.2 重平衡"></a>6.2 重平衡</h3><ul>
<li>消费者组里面的所有消费者实例不仅“瓜分”订阅主题的数据，而且更酷的是它们还能彼此协助。</li>
<li>假设组内某个实例挂掉了，Kafka 能够自动检测到，然后把这个 Failed 实例之前负责的分区转移给其他活着的消费者。</li>
<li>这个过程就是 Kafka 中大名鼎鼎的“重平衡”（<code>Rebalance</code>）。嗯，其实既是大名鼎鼎，也是臭名昭著，因为由重平衡引发的消费者问题比比皆是。事实上，目前很多重平衡的 Bug 社区都无力解决。</li>
</ul>
<h3 id="6-3-消费者位移"><a href="#6-3-消费者位移" class="headerlink" title="6.3 消费者位移"></a>6.3 消费者位移</h3><ul>
<li>每个消费者在消费消息的过程中必然需要有个字段记录它当前消费到了分区的哪个位置上，这个字段就是消费者位移（<code>Consumer Offset</code>）。</li>
<li>注意，这和上面所说的位移完全不是一个概念。<ul>
<li>上面的“位移”表征的是分区内的消息位置，它是不变的，即一旦消息被成功写入到一个分区上，它的位移值就是固定的了。</li>
<li>而消费者位移则不同，它可能是随时变化的，毕竟它是消费者消费进度的指示器嘛。</li>
<li>另外每个消费者有着自己的消费者位移，因此一定要区分这两类位移的区别。我个人把消息在分区中的位移称为分区位移，而把消费者端的位移称为消费者位移。</li>
</ul>
</li>
</ul>
<h2 id="7-术语小结"><a href="#7-术语小结" class="headerlink" title="7. 术语小结"></a>7. 术语小结</h2><p><img src="https://zhuuu-bucket.oss-cn-beijing.aliyuncs.com/img/2021-11-18-025036.jpg" alt=""></p>
<ul>
<li>消息：<code>Record</code>。Kafka 是消息引擎嘛，这里的消息就是指 Kafka 处理的主要对象。</li>
<li>主题：<code>Topic</code>。<strong>主题是承载消息的逻辑容器</strong>，在实际使用中多用来区分具体的业务。</li>
<li>分区：<code>Partition</code>。一个有序不变的消息序列。每个主题下可以有多个分区。</li>
<li>消息位移：<code>Offset</code>。表示分区中每条消息的位置信息，是一个单调递增且不变的值。</li>
<li>副本：<code>Replica</code>。Kafka 中同一条消息能够被拷贝到多个地方以提供数据冗余，这些地方就是所谓的副本。副本还分为领导者副本和追随者副本，各自有不同的角色划分。副本是在分区层级下的，即每个分区可配置多个副本实现高可用。</li>
<li>生产者：<code>Producer</code>。向主题发布新消息的应用程序。</li>
<li>消费者：<code>Consumer</code>。从主题订阅新消息的应用程序。</li>
<li>消费者位移：<code>Consumer Offset</code>。表征消费者消费进度，每个消费者都有自己的消费者位移。</li>
<li>消费者组：<code>Consumer Group</code>。多个消费者实例共同组成的一个组，同时消费多个分区以实现高吞吐。</li>
<li>重平衡：Rebalance。消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。Rebalance 是 Kafka 消费者端实现高可用的重要手段。</li>
</ul>
<p>参考博客系列 ：<a href="https://blog.csdn.net/u013256816/article/details/54743481" target="_blank" rel="noopener">https://blog.csdn.net/u013256816/article/details/54743481</a></p>

      
      <!-- reward -->
      
      <div id="reward-btn">
        打赏
      </div>
      
    </div>
      <!-- copyright -->
      
        <div class="declare">
          <ul class="post-copyright">
            <li>
              <i class="ri-copyright-line"></i>
              <strong>版权声明： </strong s>
              本博客所有文章除特别声明外，均采用 <a href="https://www.apache.org/licenses/LICENSE-2.0.html" rel="external nofollow"
                target="_blank">Apache License 2.0</a> 许可协议。转载请注明出处！
            </li>
          </ul>
        </div>
        
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://zhuuu.work/2021/10/13/kafka/kafka-01-%E7%AE%80%E4%BB%8B/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kafka/" rel="tag">kafka</a></li></ul>


    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2021/11/25/ES/ES-01-%E7%AE%80%E4%BB%8B/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            ES-01-简介
          
        </div>
      </a>
    
    
      <a href="/2021/08/23/MyBatis-Plus/MyBatisPlus-05-%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%99%A8/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">MyBatisPlus-05-代码自动生成器</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        notify: false,
        verify: '',
        app_id: '',
        app_key: '',
        path: window.location.pathname,
        avatar: 'mp',
        placeholder: '给我的文章加点评论吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.css">


<script src="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.js"></script>


<script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'db188ed8c86dc4b0dbf3',
    clientSecret: 'a58f92160e5a9efd726b7d533000a0737f3e3f3e',
    repo: 'Blog-comments',
    owner: 'Zhuuuuuuuu',
    admin: ['Zhuuuuuuuu'],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2019-2022
        Zhuuu
      </li>
      <li>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="朱酱酱的学习博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2020/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/">计算机基础理论</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/Leetcode/">Leetcode</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">JDK源码</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/JVM/">JVM</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/Mysql/">Mysql</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/Redis/">Redis</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/IO">IO/Netty</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/Spring/">SSM</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/SpringBoot/">SpringBoot</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/RabbitMQ/">中间件</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E8%AE%BE%E8%AE%A1%E8%80%85%E6%A8%A1%E5%BC%8F/">设计模式</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/Linux/">Linux</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://smartzhuuu.lofter.com/" target="_blank" rel="noopener">摄影</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<script src="/js/share.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['昨夜西风凋碧树。独上高楼，望尽天涯路','衣带渐宽终不悔，为伊消得人憔悴。','众里寻他千百度。蓦然回首，那人却在，灯火阑珊处。'],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>




<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer:'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    onClick: (e) => {
      $('.toc-link').removeClass('is-active-link');
      $(`a[href=${e.target.hash}]`).addClass('is-active-link');
      $(e.target.hash).scrollIntoView();
      return false;
    }
  });
</script>


<script>
  var ayerConfig = {
    mathjax: true
  }
</script>


<script src="/js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>



<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  </div>
</body>

</html>